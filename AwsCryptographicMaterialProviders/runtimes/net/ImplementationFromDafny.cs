// Dafny program the_program compiled into C#
// To recompile, you will need the libraries
//     System.Runtime.Numerics.dll System.Collections.Immutable.dll
// but the 'dotnet' tool in net6.0 should pick those up automatically.
// Optionally, you may want to include compiler switches like
//     /debug /nowarn:162,164,168,183,219,436,1717,1718

using System;
using System.Numerics;
using System.Collections;
[assembly: DafnyAssembly.DafnySourceAttribute(@"// dafny 4.1.0.0
// Command Line Options: -stdin -noVerify -vcsCores:2 -compileTarget:cs -spillTargetCode:3 -compile:0 -optimizeErasableDatatypeWrapper:0 -quantifierSyntax:3 -unicodeChar:0 -functionSyntax:3 -useRuntimeLib -out runtimes/net/ImplementationFromDafny -library:/Users/jocorell/crypto-tools/mpl/aws-cryptographic-material-providers-library-net/StandardLibrary/src/Index.dfy -library:/Users/jocorell/crypto-tools/mpl/aws-cryptographic-material-providers-library-net/AwsCryptographyPrimitives/src/Index.dfy -library:/Users/jocorell/crypto-tools/mpl/aws-cryptographic-material-providers-library-net/ComAmazonawsKms/src/Index.dfy -library:/Users/jocorell/crypto-tools/mpl/aws-cryptographic-material-providers-library-net/ComAmazonawsDynamodb/src/Index.dfy
// the_program






























































module {:extern ""software.amazon.cryptography.materialproviders.internaldafny""} MaterialProviders refines AbstractAwsCryptographyMaterialProvidersService {

  import Operations = AwsCryptographyMaterialProvidersOperations

  import Primitives = Aws.Cryptography.Primitives
  class MaterialProvidersClient ...  {
    predicate ValidState()
      ensures ValidState() ==> Operations.ValidInternalConfig?(config) && History !in Operations.ModifiesInternalConfig(config) && Modifies == Operations.ModifiesInternalConfig(config) + {History}
    {
      Operations.ValidInternalConfig?(config) &&
      Modifies == Operations.ModifiesInternalConfig(config) + {History}
    }

    constructor (config: Operations.InternalConfig)
      requires Operations.ValidInternalConfig?(config)
      ensures ValidState() && fresh(History) && this.config == config
      decreases config
    {
      this.config := config;
      History := new IAwsCryptographicMaterialProvidersClientCallHistory();
      Modifies := Operations.ModifiesInternalConfig(config) + {History};
    }

    const config: Operations.InternalConfig

    predicate CreateAwsKmsKeyringEnsuresPublicly(input: CreateAwsKmsKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsKeyring(input: CreateAwsKmsKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsKeyring == old(History.CreateAwsKmsKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies
    {
      output := Operations.CreateAwsKmsKeyring(config, input);
      History.CreateAwsKmsKeyring := History.CreateAwsKmsKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input: CreateAwsKmsDiscoveryKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsDiscoveryKeyring(input: CreateAwsKmsDiscoveryKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsDiscoveryKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsDiscoveryKeyring == old(History.CreateAwsKmsDiscoveryKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies
    {
      output := Operations.CreateAwsKmsDiscoveryKeyring(config, input);
      History.CreateAwsKmsDiscoveryKeyring := History.CreateAwsKmsDiscoveryKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsMultiKeyringEnsuresPublicly(input: CreateAwsKmsMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsMultiKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsMultiKeyring(input: CreateAwsKmsMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMultiKeyring == old(History.CreateAwsKmsMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    {
      output := Operations.CreateAwsKmsMultiKeyring(config, input);
      History.CreateAwsKmsMultiKeyring := History.CreateAwsKmsMultiKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input: CreateAwsKmsDiscoveryMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsDiscoveryMultiKeyring(input: CreateAwsKmsDiscoveryMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsDiscoveryMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsDiscoveryMultiKeyring == old(History.CreateAwsKmsDiscoveryMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    {
      output := Operations.CreateAwsKmsDiscoveryMultiKeyring(config, input);
      History.CreateAwsKmsDiscoveryMultiKeyring := History.CreateAwsKmsDiscoveryMultiKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsMrkKeyringEnsuresPublicly(input: CreateAwsKmsMrkKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsMrkKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsMrkKeyring(input: CreateAwsKmsMrkKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsMrkKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsMrkKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkKeyring == old(History.CreateAwsKmsMrkKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies
    {
      output := Operations.CreateAwsKmsMrkKeyring(config, input);
      History.CreateAwsKmsMrkKeyring := History.CreateAwsKmsMrkKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input: CreateAwsKmsMrkMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsMrkMultiKeyring(input: CreateAwsKmsMrkMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsMrkMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkMultiKeyring == old(History.CreateAwsKmsMrkMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    {
      output := Operations.CreateAwsKmsMrkMultiKeyring(config, input);
      History.CreateAwsKmsMrkMultiKeyring := History.CreateAwsKmsMrkMultiKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input: CreateAwsKmsMrkDiscoveryKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsMrkDiscoveryKeyring(input: CreateAwsKmsMrkDiscoveryKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsMrkDiscoveryKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkDiscoveryKeyring == old(History.CreateAwsKmsMrkDiscoveryKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies
    {
      output := Operations.CreateAwsKmsMrkDiscoveryKeyring(config, input);
      History.CreateAwsKmsMrkDiscoveryKeyring := History.CreateAwsKmsMrkDiscoveryKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input: CreateAwsKmsMrkDiscoveryMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsMrkDiscoveryMultiKeyring(input: CreateAwsKmsMrkDiscoveryMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsMrkDiscoveryMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkDiscoveryMultiKeyring == old(History.CreateAwsKmsMrkDiscoveryMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    {
      output := Operations.CreateAwsKmsMrkDiscoveryMultiKeyring(config, input);
      History.CreateAwsKmsMrkDiscoveryMultiKeyring := History.CreateAwsKmsMrkDiscoveryMultiKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input: CreateAwsKmsHierarchicalKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsHierarchicalKeyring(input: CreateAwsKmsHierarchicalKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.branchKeyIdSupplier.Some? ==> input.branchKeyIdSupplier.value.ValidState() && input.branchKeyIdSupplier.value.Modifies !! {History}) && input.keyStore.ValidState() && input.keyStore.Modifies !! {History}
      modifies Modifies - {History}, if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}, input.keyStore.Modifies, History`CreateAwsKmsHierarchicalKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - (if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}) - input.keyStore.Modifies))
      ensures CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsHierarchicalKeyring == old(History.CreateAwsKmsHierarchicalKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}, input.keyStore.Modifies
    {
      output := Operations.CreateAwsKmsHierarchicalKeyring(config, input);
      History.CreateAwsKmsHierarchicalKeyring := History.CreateAwsKmsHierarchicalKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateMultiKeyringEnsuresPublicly(input: CreateMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateMultiKeyringEnsuresPublicly(input, output)
    }

    method CreateMultiKeyring(input: CreateMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.generator.Some? ==> input.generator.value.ValidState() && input.generator.value.Modifies !! {History}) && forall i: IKeyring {:trigger i.Modifies} {:trigger i.ValidState()} {:trigger i in input.childKeyrings} | i in input.childKeyrings :: i.ValidState() && i.Modifies !! {History}
      modifies Modifies - {History}, if input.generator.Some? then input.generator.value.Modifies else {}, set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m, History`CreateMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - (if input.generator.Some? then input.generator.value.Modifies else {}) - set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m))
      ensures CreateMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateMultiKeyring == old(History.CreateMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.generator.Some? then input.generator.value.Modifies else {}, set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m
    {
      output := Operations.CreateMultiKeyring(config, input);
      History.CreateMultiKeyring := History.CreateMultiKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateRawAesKeyringEnsuresPublicly(input: CreateRawAesKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateRawAesKeyringEnsuresPublicly(input, output)
    }

    method CreateRawAesKeyring(input: CreateRawAesKeyringInput) returns (output: Result<IKeyring, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateRawAesKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateRawAesKeyringEnsuresPublicly(input, output)
      ensures History.CreateRawAesKeyring == old(History.CreateRawAesKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateRawAesKeyring(config, input);
      History.CreateRawAesKeyring := History.CreateRawAesKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateRawRsaKeyringEnsuresPublicly(input: CreateRawRsaKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateRawRsaKeyringEnsuresPublicly(input, output)
    }

    method CreateRawRsaKeyring(input: CreateRawRsaKeyringInput) returns (output: Result<IKeyring, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateRawRsaKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateRawRsaKeyringEnsuresPublicly(input, output)
      ensures History.CreateRawRsaKeyring == old(History.CreateRawRsaKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateRawRsaKeyring(config, input);
      History.CreateRawRsaKeyring := History.CreateRawRsaKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsRsaKeyringEnsuresPublicly(input: CreateAwsKmsRsaKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsRsaKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsRsaKeyring(input: CreateAwsKmsRsaKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.kmsClient.Some? ==> input.kmsClient.value.ValidState() && input.kmsClient.value.Modifies !! {History})
      modifies Modifies - {History}, if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}, History`CreateAwsKmsRsaKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}))
      ensures CreateAwsKmsRsaKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsRsaKeyring == old(History.CreateAwsKmsRsaKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}
    {
      output := Operations.CreateAwsKmsRsaKeyring(config, input);
      History.CreateAwsKmsRsaKeyring := History.CreateAwsKmsRsaKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input: CreateDefaultCryptographicMaterialsManagerInput, output: Result<ICryptographicMaterialsManager, Error>)
      decreases input, output
    {
      Operations.CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input, output)
    }

    method CreateDefaultCryptographicMaterialsManager(input: CreateDefaultCryptographicMaterialsManagerInput) returns (output: Result<ICryptographicMaterialsManager, Error>)
      requires ValidState() && input.keyring.ValidState() && input.keyring.Modifies !! {History}
      modifies Modifies - {History}, input.keyring.Modifies, History`CreateDefaultCryptographicMaterialsManager
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.keyring.Modifies))
      ensures CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input, output)
      ensures History.CreateDefaultCryptographicMaterialsManager == old(History.CreateDefaultCryptographicMaterialsManager) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.keyring.Modifies
    {
      output := Operations.CreateDefaultCryptographicMaterialsManager(config, input);
      History.CreateDefaultCryptographicMaterialsManager := History.CreateDefaultCryptographicMaterialsManager + [DafnyCallEvent(input, output)];
    }

    predicate CreateRequiredEncryptionContextCMMEnsuresPublicly(input: CreateRequiredEncryptionContextCMMInput, output: Result<ICryptographicMaterialsManager, Error>)
      decreases input, output
    {
      Operations.CreateRequiredEncryptionContextCMMEnsuresPublicly(input, output)
    }

    method CreateRequiredEncryptionContextCMM(input: CreateRequiredEncryptionContextCMMInput) returns (output: Result<ICryptographicMaterialsManager, Error>)
      requires ValidState() && (input.underlyingCMM.Some? ==> input.underlyingCMM.value.ValidState() && input.underlyingCMM.value.Modifies !! {History}) && (input.keyring.Some? ==> input.keyring.value.ValidState() && input.keyring.value.Modifies !! {History})
      modifies Modifies - {History}, if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}, History`CreateRequiredEncryptionContextCMM
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - (if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}) - if input.keyring.Some? then input.keyring.value.Modifies else {}))
      ensures CreateRequiredEncryptionContextCMMEnsuresPublicly(input, output)
      ensures History.CreateRequiredEncryptionContextCMM == old(History.CreateRequiredEncryptionContextCMM) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}
    {
      output := Operations.CreateRequiredEncryptionContextCMM(config, input);
      History.CreateRequiredEncryptionContextCMM := History.CreateRequiredEncryptionContextCMM + [DafnyCallEvent(input, output)];
    }

    predicate CreateCryptographicMaterialsCacheEnsuresPublicly(input: CreateCryptographicMaterialsCacheInput, output: Result<ICryptographicMaterialsCache, Error>)
      decreases input, output
    {
      Operations.CreateCryptographicMaterialsCacheEnsuresPublicly(input, output)
    }

    method CreateCryptographicMaterialsCache(input: CreateCryptographicMaterialsCacheInput) returns (output: Result<ICryptographicMaterialsCache, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateCryptographicMaterialsCache
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateCryptographicMaterialsCacheEnsuresPublicly(input, output)
      ensures History.CreateCryptographicMaterialsCache == old(History.CreateCryptographicMaterialsCache) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateCryptographicMaterialsCache(config, input);
      History.CreateCryptographicMaterialsCache := History.CreateCryptographicMaterialsCache + [DafnyCallEvent(input, output)];
    }

    predicate CreateDefaultClientSupplierEnsuresPublicly(input: CreateDefaultClientSupplierInput, output: Result<IClientSupplier, Error>)
      decreases input, output
    {
      Operations.CreateDefaultClientSupplierEnsuresPublicly(input, output)
    }

    method CreateDefaultClientSupplier(input: CreateDefaultClientSupplierInput) returns (output: Result<IClientSupplier, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateDefaultClientSupplier
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateDefaultClientSupplierEnsuresPublicly(input, output)
      ensures History.CreateDefaultClientSupplier == old(History.CreateDefaultClientSupplier) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateDefaultClientSupplier(config, input);
      History.CreateDefaultClientSupplier := History.CreateDefaultClientSupplier + [DafnyCallEvent(input, output)];
    }

    function method InitializeEncryptionMaterials(input: InitializeEncryptionMaterialsInput): (output: Result<EncryptionMaterials, Error>)
      decreases input
    {
      Operations.InitializeEncryptionMaterials(config, input)
    }

    function method InitializeDecryptionMaterials(input: InitializeDecryptionMaterialsInput): (output: Result<DecryptionMaterials, Error>)
      decreases input
    {
      Operations.InitializeDecryptionMaterials(config, input)
    }

    function method ValidEncryptionMaterialsTransition(input: ValidEncryptionMaterialsTransitionInput): (output: Result<(), Error>)
      decreases input
    {
      Operations.ValidEncryptionMaterialsTransition(config, input)
    }

    function method ValidDecryptionMaterialsTransition(input: ValidDecryptionMaterialsTransitionInput): (output: Result<(), Error>)
      decreases input
    {
      Operations.ValidDecryptionMaterialsTransition(config, input)
    }

    function method EncryptionMaterialsHasPlaintextDataKey(input: EncryptionMaterials): (output: Result<(), Error>)
      decreases input
    {
      Operations.EncryptionMaterialsHasPlaintextDataKey(config, input)
    }

    function method DecryptionMaterialsWithPlaintextDataKey(input: DecryptionMaterials): (output: Result<(), Error>)
      decreases input
    {
      Operations.DecryptionMaterialsWithPlaintextDataKey(config, input)
    }

    function method GetAlgorithmSuiteInfo(input: seq<uint8>): (output: Result<AlgorithmSuiteInfo, Error>)
      decreases input
    {
      Operations.GetAlgorithmSuiteInfo(config, input)
    }

    function method ValidAlgorithmSuiteInfo(input: AlgorithmSuiteInfo): (output: Result<(), Error>)
      decreases input
    {
      Operations.ValidAlgorithmSuiteInfo(config, input)
    }

    function method ValidateCommitmentPolicyOnEncrypt(input: ValidateCommitmentPolicyOnEncryptInput): (output: Result<(), Error>)
      decreases input
    {
      Operations.ValidateCommitmentPolicyOnEncrypt(config, input)
    }

    function method ValidateCommitmentPolicyOnDecrypt(input: ValidateCommitmentPolicyOnDecryptInput): (output: Result<(), Error>)
      decreases input
    {
      Operations.ValidateCommitmentPolicyOnDecrypt(config, input)
    }
  }

  function method DefaultMaterialProvidersConfig(): MaterialProvidersConfig
  {
    MaterialProvidersConfig
  }

  method MaterialProviders(config: MaterialProvidersConfig := DefaultMaterialProvidersConfig()) returns (res: Result<MaterialProvidersClient, Error>)
    ensures res.Success? ==> fresh(res.value) && fresh(res.value.Modifies) && fresh(res.value.History) && res.value.ValidState()
    decreases config
  {
    var maybeCrypto := Primitives.AtomicPrimitives();
    var crypto :- maybeCrypto.MapFailure((e: Error) => AwsCryptographyPrimitives(e));
    var client := new MaterialProvidersClient(Operations.Config(crypto := crypto));
    return Success(client);
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyMaterialProvidersTypes
}

module AwsCryptographyMaterialProvidersOperations refines AbstractAwsCryptographyMaterialProvidersOperations {

  import MultiKeyring

  import opened S = StrictMultiKeyring

  import opened D = DiscoveryMultiKeyring

  import opened MD = MrkAwareDiscoveryMultiKeyring

  import opened M = MrkAwareStrictMultiKeyring

  import AwsKmsKeyring

  import AwsKmsHierarchicalKeyring

  import AwsKmsMrkKeyring

  import AwsKmsDiscoveryKeyring

  import AwsKmsMrkDiscoveryKeyring

  import AwsKmsRsaKeyring

  import RawAESKeyring

  import RawRSAKeyring

  import opened C = DefaultCMM

  import LocalCMC

  import SynchronizedLocalCMC

  import StormTracker

  import StormTrackingCMC

  import Crypto = AwsCryptographyPrimitivesTypes

  import Primitives = Aws.Cryptography.Primitives

  import opened AwsKmsUtils

  import DefaultClientSupplier

  import Materials

  import Commitment

  import AlgorithmSuites

  import opened AwsArnParsing

  import Kms = Com.Amazonaws.Kms

  import Ddb = ComAmazonawsDynamodbTypes

  import RequiredEncryptionContextCMM
  datatype Config = Config(nameonly crypto: Primitives.AtomicPrimitivesClient)

  type InternalConfig = Config

  predicate ValidInternalConfig?(config: InternalConfig)
    decreases config
  {
    true &&
    config.crypto.ValidState()
  }

  function ModifiesInternalConfig(config: InternalConfig): set<object>
    decreases config
  {
    config.crypto.Modifies
  }

  predicate CreateAwsKmsKeyringEnsuresPublicly(input: CreateAwsKmsKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  method CreateAwsKmsKeyring(config: InternalConfig, input: CreateAwsKmsKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && input.kmsClient.ValidState()
    modifies ModifiesInternalConfig(config), input.kmsClient.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - input.kmsClient.Modifies))
    ensures CreateAwsKmsKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.kmsClient.Modifies
  {
    var _ /* _v0 */ :- ValidateKmsKeyId(input.kmsKeyId);
    var grantTokens :- GetValidGrantTokens(input.grantTokens);
    var keyring := new AwsKmsKeyring.AwsKmsKeyring(input.kmsClient, input.kmsKeyId, grantTokens);
    return Success(keyring);
  }

  predicate CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input: CreateAwsKmsDiscoveryKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  method CreateAwsKmsDiscoveryKeyring(config: InternalConfig, input: CreateAwsKmsDiscoveryKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && input.kmsClient.ValidState()
    modifies ModifiesInternalConfig(config), input.kmsClient.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - input.kmsClient.Modifies))
    ensures CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.kmsClient.Modifies
  {
    if input.discoveryFilter.Some? {
      var _ /* _v1 */ :- ValidateDiscoveryFilter(input.discoveryFilter.value);
    }
    var grantTokens :- GetValidGrantTokens(input.grantTokens);
    var keyring := new AwsKmsDiscoveryKeyring.AwsKmsDiscoveryKeyring(input.kmsClient, input.discoveryFilter, grantTokens);
    return Success(keyring);
  }

  predicate CreateAwsKmsMultiKeyringEnsuresPublicly(input: CreateAwsKmsMultiKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  method CreateAwsKmsMultiKeyring(config: InternalConfig, input: CreateAwsKmsMultiKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.clientSupplier.Some? ==> true && input.clientSupplier.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
    ensures CreateAwsKmsMultiKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
  {
    var grantTokens :- GetValidGrantTokens(input.grantTokens);
    if input.clientSupplier.Some? {
      output := StrictMultiKeyring(input.generator, input.kmsKeyIds, input.clientSupplier.value, Option.Some(grantTokens));
    } else {
      var clientSupplier :- CreateDefaultClientSupplier(config, Types.CreateDefaultClientSupplierInput());
      output := StrictMultiKeyring(input.generator, input.kmsKeyIds, clientSupplier, Option.Some(grantTokens));
    }
  }

  predicate CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input: CreateAwsKmsDiscoveryMultiKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  method CreateAwsKmsDiscoveryMultiKeyring(config: InternalConfig, input: CreateAwsKmsDiscoveryMultiKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.clientSupplier.Some? ==> true && input.clientSupplier.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
    ensures CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
  {
    var grantTokens :- GetValidGrantTokens(input.grantTokens);
    var clientSupplier: Types.IClientSupplier;
    if input.clientSupplier.None? {
      clientSupplier :- CreateDefaultClientSupplier(config, Types.CreateDefaultClientSupplierInput());
    } else {
      clientSupplier := input.clientSupplier.value;
    }
    output := DiscoveryMultiKeyring(input.regions, input.discoveryFilter, clientSupplier, Option.Some(grantTokens));
  }

  predicate CreateAwsKmsMrkKeyringEnsuresPublicly(input: CreateAwsKmsMrkKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  method CreateAwsKmsMrkKeyring(config: InternalConfig, input: CreateAwsKmsMrkKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && input.kmsClient.ValidState()
    modifies ModifiesInternalConfig(config), input.kmsClient.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - input.kmsClient.Modifies))
    ensures CreateAwsKmsMrkKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.kmsClient.Modifies
  {
    var _ /* _v2 */ :- ValidateKmsKeyId(input.kmsKeyId);
    var grantTokens :- GetValidGrantTokens(input.grantTokens);
    var keyring := new AwsKmsMrkKeyring.AwsKmsMrkKeyring(input.kmsClient, input.kmsKeyId, grantTokens);
    return Success(keyring);
  }

  predicate CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input: CreateAwsKmsMrkMultiKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  method CreateAwsKmsMrkMultiKeyring(config: InternalConfig, input: CreateAwsKmsMrkMultiKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.clientSupplier.Some? ==> true && input.clientSupplier.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
    ensures CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
  {
    var grantTokens :- GetValidGrantTokens(input.grantTokens);
    var clientSupplier: Types.IClientSupplier;
    if input.clientSupplier.None? {
      clientSupplier :- CreateDefaultClientSupplier(config, Types.CreateDefaultClientSupplierInput());
    } else {
      clientSupplier := input.clientSupplier.value;
    }
    output := MrkAwareStrictMultiKeyring(input.generator, input.kmsKeyIds, clientSupplier, Option.Some(grantTokens));
  }

  predicate CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input: CreateAwsKmsMrkDiscoveryKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  method CreateAwsKmsMrkDiscoveryKeyring(config: InternalConfig, input: CreateAwsKmsMrkDiscoveryKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && input.kmsClient.ValidState()
    modifies ModifiesInternalConfig(config), input.kmsClient.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - input.kmsClient.Modifies))
    ensures CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.kmsClient.Modifies
  {
    if input.discoveryFilter.Some? {
      var _ /* _v3 */ :- ValidateDiscoveryFilter(input.discoveryFilter.value);
    }
    var regionMatch := Kms.RegionMatch(input.kmsClient, input.region);
    :- Need(regionMatch != Some(false), Types.AwsCryptographicMaterialProvidersException(message := ""Provided client and region do not match""));
    var grantTokens :- GetValidGrantTokens(input.grantTokens);
    var keyring := new AwsKmsMrkDiscoveryKeyring.AwsKmsMrkDiscoveryKeyring(input.kmsClient, input.region, input.discoveryFilter, grantTokens);
    return Success(keyring);
  }

  predicate CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input: CreateAwsKmsMrkDiscoveryMultiKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  method CreateAwsKmsMrkDiscoveryMultiKeyring(config: InternalConfig, input: CreateAwsKmsMrkDiscoveryMultiKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.clientSupplier.Some? ==> true && input.clientSupplier.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
    ensures CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
  {
    var grantTokens :- GetValidGrantTokens(input.grantTokens);
    var clientSupplier: Types.IClientSupplier;
    if input.clientSupplier.None? {
      clientSupplier :- CreateDefaultClientSupplier(config, Types.CreateDefaultClientSupplierInput());
    } else {
      clientSupplier := input.clientSupplier.value;
    }
    output := MrkAwareDiscoveryMultiKeyring(input.regions, input.discoveryFilter, clientSupplier, Option.Some(grantTokens));
  }

  predicate CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input: CreateAwsKmsHierarchicalKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  method CreateAwsKmsHierarchicalKeyring(config: InternalConfig, input: CreateAwsKmsHierarchicalKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.branchKeyIdSupplier.Some? ==> true && input.branchKeyIdSupplier.value.ValidState()) && input.keyStore.ValidState()
    modifies ModifiesInternalConfig(config), if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}, input.keyStore.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - (if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}) - input.keyStore.Modifies))
    ensures CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}, input.keyStore.Modifies
  {
    var maxCacheSize: int32;
    var cache := if input.cache.Some? then input.cache.value else Types.Default(Types.DefaultCache(entryCapacity := 1000));
    :- Need(input.branchKeyId.None? || input.branchKeyIdSupplier.None?, Types.AwsCryptographicMaterialProvidersException(message := ""Cannot initialize keyring with both a branchKeyId and BranchKeyIdSupplier.""));
    :- Need(input.branchKeyId.Some? || input.branchKeyIdSupplier.Some?, Types.AwsCryptographicMaterialProvidersException(message := ""Must initialize keyring with either branchKeyId or BranchKeyIdSupplier.""));
    var cmc :- CreateCryptographicMaterialsCache(config, CreateCryptographicMaterialsCacheInput(cache := cache));
    var keyring := new AwsKmsHierarchicalKeyring.AwsKmsHierarchicalKeyring(keyStore := input.keyStore, branchKeyId := input.branchKeyId, branchKeyIdSupplier := input.branchKeyIdSupplier, ttlSeconds := input.ttlSeconds, cmc := cmc, cryptoPrimitives := config.crypto);
    return Success(keyring);
  }

  predicate CreateMultiKeyringEnsuresPublicly(input: CreateMultiKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  method CreateMultiKeyring(config: InternalConfig, input: CreateMultiKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.generator.Some? ==> true && input.generator.value.ValidState()) && forall i: IKeyring {:trigger i.ValidState()} {:trigger i in input.childKeyrings} | i in input.childKeyrings :: i.ValidState()
    modifies ModifiesInternalConfig(config), if input.generator.Some? then input.generator.value.Modifies else {}, set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - (if input.generator.Some? then input.generator.value.Modifies else {}) - set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m))
    ensures CreateMultiKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.generator.Some? then input.generator.value.Modifies else {}, set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m
  {
    :- Need(input.generator.Some? || |input.childKeyrings| > 0, Types.AwsCryptographicMaterialProvidersException(message := ""Must include a generator keyring and/or at least one child keyring""));
    var keyring := new MultiKeyring.MultiKeyring(input.generator, input.childKeyrings);
    return Success(keyring);
  }

  predicate CreateRawAesKeyringEnsuresPublicly(input: CreateRawAesKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    input.keyNamespace == ""aws-kms"" ==>
      output.Failure?
  }

  method CreateRawAesKeyring(config: InternalConfig, input: CreateRawAesKeyringInput) returns (output: Result<IKeyring, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config)))
    ensures CreateRawAesKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    :- Need(input.keyNamespace != ""aws-kms"", Types.AwsCryptographicMaterialProvidersException(message := ""keyNamespace must not be `aws-kms`""));
    var wrappingAlg: Crypto.AES_GCM := match input.wrappingAlg case ALG_AES128_GCM_IV12_TAG16() => Crypto.AES_GCM(keyLength := 16, tagLength := 16, ivLength := 12) case ALG_AES192_GCM_IV12_TAG16() => Crypto.AES_GCM(keyLength := 24, tagLength := 16, ivLength := 12) case ALG_AES256_GCM_IV12_TAG16() => Crypto.AES_GCM(keyLength := 32, tagLength := 16, ivLength := 12);
    var namespaceAndName :- ParseKeyNamespaceAndName(input.keyNamespace, input.keyName);
    var (namespace, name) := namespaceAndName;
    :- Need(|input.wrappingKey| == 16 || |input.wrappingKey| == 24 || |input.wrappingKey| == 32, Types.AwsCryptographicMaterialProvidersException(message := ""Invalid wrapping key length""));
    :- Need(|input.wrappingKey| == wrappingAlg.keyLength as int, Types.AwsCryptographicMaterialProvidersException(message := ""Wrapping key length does not match specified wrapping algorithm""));
    var keyring := new RawAESKeyring.RawAESKeyring(namespace := namespace, name := name, key := input.wrappingKey, wrappingAlgorithm := wrappingAlg, cryptoPrimitives := config.crypto);
    return Success(keyring);
  }

  predicate CreateRawRsaKeyringEnsuresPublicly(input: CreateRawRsaKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    (input.keyNamespace == ""aws-kms"" ==>
      output.Failure?) &&
    (input.publicKey.None? &&
    input.privateKey.None? ==>
      output.Failure?)
  }

  method CreateRawRsaKeyring(config: InternalConfig, input: CreateRawRsaKeyringInput) returns (output: Result<IKeyring, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config)))
    ensures CreateRawRsaKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    :- Need(input.keyNamespace != ""aws-kms"", Types.AwsCryptographicMaterialProvidersException(message := ""keyNamespace must not be `aws-kms`""));
    :- Need(input.publicKey.Some? || input.privateKey.Some?, Types.AwsCryptographicMaterialProvidersException(message := ""A publicKey or a privateKey is required""));
    var padding: Crypto.RSAPaddingMode := match input.paddingScheme case PKCS1() => Crypto.RSAPaddingMode.PKCS1 case OAEP_SHA1_MGF1() => Crypto.RSAPaddingMode.OAEP_SHA1 case OAEP_SHA256_MGF1() => Crypto.RSAPaddingMode.OAEP_SHA256 case OAEP_SHA384_MGF1() => Crypto.RSAPaddingMode.OAEP_SHA384 case OAEP_SHA512_MGF1() => Crypto.RSAPaddingMode.OAEP_SHA512;
    var namespaceAndName :- ParseKeyNamespaceAndName(input.keyNamespace, input.keyName);
    var (namespace, name) := namespaceAndName;
    var keyring := new RawRSAKeyring.RawRSAKeyring(namespace := namespace, name := name, publicKey := input.publicKey, privateKey := input.privateKey, paddingScheme := padding, cryptoPrimitives := config.crypto);
    return Success(keyring);
  }

  predicate CreateAwsKmsRsaKeyringEnsuresPublicly(input: CreateAwsKmsRsaKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  method CreateAwsKmsRsaKeyring(config: InternalConfig, input: CreateAwsKmsRsaKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.kmsClient.Some? ==> true && input.kmsClient.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}))
    ensures CreateAwsKmsRsaKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}
  {
    :- Need(input.publicKey.Some? || input.kmsClient.Some?, Types.AwsCryptographicMaterialProvidersException(message := ""A publicKey or a kmsClient is required""));
    :- Need(input.encryptionAlgorithm.RSAES_OAEP_SHA_1? || input.encryptionAlgorithm.RSAES_OAEP_SHA_256?, Types.AwsCryptographicMaterialProvidersException(message := ""Unsupported EncryptionAlgorithmSpec""));
    :- Need(KMS.IsValid_KeyIdType(input.kmsKeyId) && ParseAwsKmsArn(input.kmsKeyId).Success?, Types.AwsCryptographicMaterialProvidersException(message := ""Kms Key ID must be a KMS Key ARN""));
    if input.publicKey.Some? {
      var lengthOutputRes := config.crypto.GetRSAKeyModulusLength(Crypto.GetRSAKeyModulusLengthInput(publicKey := input.publicKey.value));
      var lengthOutput :- lengthOutputRes.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
      :- Need(lengthOutput.length >= AwsKmsRsaKeyring.MIN_KMS_RSA_KEY_LEN, Types.AwsCryptographicMaterialProvidersException(message := ""Invalid public key length""));
    }
    var _ /* _v4 */ :- ValidateKmsKeyId(input.kmsKeyId);
    var grantTokens :- GetValidGrantTokens(input.grantTokens);
    var keyring := new AwsKmsRsaKeyring.AwsKmsRsaKeyring(publicKey := input.publicKey, awsKmsKey := input.kmsKeyId, paddingScheme := input.encryptionAlgorithm, client := input.kmsClient, cryptoPrimitives := config.crypto, grantTokens := grantTokens);
    return Success(keyring);
  }

  predicate CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input: CreateDefaultCryptographicMaterialsManagerInput, output: Result<ICryptographicMaterialsManager, Error>)
    decreases input, output
  {
    true
  }

  method CreateDefaultCryptographicMaterialsManager(config: InternalConfig, input: CreateDefaultCryptographicMaterialsManagerInput) returns (output: Result<ICryptographicMaterialsManager, Error>)
    requires ValidInternalConfig?(config) && input.keyring.ValidState()
    modifies ModifiesInternalConfig(config), input.keyring.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - input.keyring.Modifies))
    ensures CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.keyring.Modifies
  {
    var cmm := new DefaultCMM.OfKeyring(input.keyring, config.crypto);
    return Success(cmm);
  }

  function method CmpError(s: string): Error
    decreases s
  {
    Types.AwsCryptographicMaterialProvidersException(message := ""A publicKey or a kmsClient is required"")
  }

  predicate CreateRequiredEncryptionContextCMMEnsuresPublicly(input: CreateRequiredEncryptionContextCMMInput, output: Result<ICryptographicMaterialsManager, Error>)
    decreases input, output
  {
    true
  }

  method CreateRequiredEncryptionContextCMM(config: InternalConfig, input: CreateRequiredEncryptionContextCMMInput) returns (output: Result<ICryptographicMaterialsManager, Error>)
    requires ValidInternalConfig?(config) && (input.underlyingCMM.Some? ==> true && input.underlyingCMM.value.ValidState()) && (input.keyring.Some? ==> true && input.keyring.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - (if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}) - if input.keyring.Some? then input.keyring.value.Modifies else {}))
    ensures CreateRequiredEncryptionContextCMMEnsuresPublicly(input, output)
    ensures output.Success? ==> output.value.ValidState()
    decreases ModifiesInternalConfig(config), if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}
  {
    :- Need(input.underlyingCMM.Some? && input.keyring.None?, CmpError(""CreateRequiredEncryptionContextCMM currently only supports cmm.""));
    var keySet: set<UTF8.ValidUTF8Bytes> := set k: UTF8.ValidUTF8Bytes {:trigger k in input.requiredEncryptionContextKeys} | k in input.requiredEncryptionContextKeys;
    :- Need(0 < |keySet|, CmpError(""RequiredEncryptionContextCMM needs at least one requiredEncryptionContextKey.""));
    var cmm := new RequiredEncryptionContextCMM.RequiredEncryptionContextCMM(input.underlyingCMM.value, keySet);
    return Success(cmm);
  }

  predicate CreateCryptographicMaterialsCacheEnsuresPublicly(input: CreateCryptographicMaterialsCacheInput, output: Result<ICryptographicMaterialsCache, Error>)
    decreases input, output
  {
    true
  }

  method CreateCryptographicMaterialsCache(config: InternalConfig, input: CreateCryptographicMaterialsCacheInput) returns (output: Result<ICryptographicMaterialsCache, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config)))
    ensures CreateCryptographicMaterialsCacheEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    match input.cache {
      case {:split false} Default(c) =>
        var cache := StormTracker.DefaultStorm().(entryCapacity := c.entryCapacity);
        var cmc := new StormTracker.StormTracker(cache);
        var synCmc := new StormTrackingCMC.StormTrackingCMC(cmc);
        return Success(synCmc);
      case {:split false} No(_ /* _v5 */) =>
        var cmc := new LocalCMC.LocalCMC(0, 1);
        return Success(cmc);
      case {:split false} SingleThreaded(c) =>
        var cmc := new LocalCMC.LocalCMC(c.entryCapacity as nat, c.entryPruningTailSize.UnwrapOr(1) as nat);
        return Success(cmc);
      case {:split false} MultiThreaded(c) =>
        var cmc := new LocalCMC.LocalCMC(c.entryCapacity as nat, c.entryPruningTailSize.UnwrapOr(1) as nat);
        var synCmc := new SynchronizedLocalCMC.SynchronizedLocalCMC(cmc);
        return Success(synCmc);
      case {:split false} StormTracking(c) =>
        var cmc := new StormTracker.StormTracker(c);
        var synCmc := new StormTrackingCMC.StormTrackingCMC(cmc);
        return Success(synCmc);
    }
  }

  predicate CreateDefaultClientSupplierEnsuresPublicly(input: CreateDefaultClientSupplierInput, output: Result<IClientSupplier, Error>)
    decreases input, output
  {
    true
  }

  method CreateDefaultClientSupplier(config: InternalConfig, input: CreateDefaultClientSupplierInput) returns (output: Result<IClientSupplier, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config)))
    ensures CreateDefaultClientSupplierEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    var clientSupplier := new DefaultClientSupplier.DefaultClientSupplier();
    return Success(clientSupplier);
  }

  function method InitializeEncryptionMaterials(config: InternalConfig, input: InitializeEncryptionMaterialsInput): (output: Result<EncryptionMaterials, Error>)
    decreases config, input
  {
    Materials.InitializeEncryptionMaterials(input)
  }

  function method InitializeDecryptionMaterials(config: InternalConfig, input: InitializeDecryptionMaterialsInput): (output: Result<DecryptionMaterials, Error>)
    decreases config, input
  {
    Materials.InitializeDecryptionMaterials(input)
  }

  function method ValidEncryptionMaterialsTransition(config: InternalConfig, input: ValidEncryptionMaterialsTransitionInput): (output: Result<(), Error>)
    decreases config, input
  {
    Need(Materials.ValidEncryptionMaterialsTransition(input.start, input.stop), InvalidEncryptionMaterialsTransition(message := ""Invalid Encryption Materials Transition"")); Success(())
  }

  function method ValidDecryptionMaterialsTransition(config: InternalConfig, input: ValidDecryptionMaterialsTransitionInput): (output: Result<(), Error>)
    decreases config, input
  {
    Need(Materials.DecryptionMaterialsTransitionIsValid(input.start, input.stop), InvalidDecryptionMaterialsTransition(message := ""Invalid Decryption Materials Transition"")); Success(())
  }

  function method EncryptionMaterialsHasPlaintextDataKey(config: InternalConfig, input: EncryptionMaterials): (output: Result<(), Error>)
    decreases config, input
  {
    Need(Materials.EncryptionMaterialsHasPlaintextDataKey(input), InvalidDecryptionMaterials(message := ""Invalid Encryption Materials"")); Success(())
  }

  function method DecryptionMaterialsWithPlaintextDataKey(config: InternalConfig, input: DecryptionMaterials): (output: Result<(), Error>)
    decreases config, input
  {
    Need(Materials.DecryptionMaterialsWithPlaintextDataKey(input), InvalidDecryptionMaterials(message := ""Invalid Decryption Materials"")); Success(())
  }

  function method GetAlgorithmSuiteInfo(config: InternalConfig, input: seq<uint8>): (output: Result<AlgorithmSuiteInfo, Error>)
    decreases config, input
  {
    AlgorithmSuites.GetAlgorithmSuiteInfo(input)
  }

  function method ValidAlgorithmSuiteInfo(config: InternalConfig, input: AlgorithmSuiteInfo): (output: Result<(), Error>)
    decreases config, input
  {
    Need(AlgorithmSuites.AlgorithmSuite?(input), InvalidAlgorithmSuiteInfo(message := ""Invalid AlgorithmSuiteInfo"")); Success(())
  }

  function method ValidateCommitmentPolicyOnEncrypt(config: InternalConfig, input: ValidateCommitmentPolicyOnEncryptInput): (output: Result<(), Error>)
    decreases config, input
  {
    Commitment.ValidateCommitmentPolicyOnEncrypt(input.algorithm, input.commitmentPolicy); Success(())
  }

  function method ValidateCommitmentPolicyOnDecrypt(config: InternalConfig, input: ValidateCommitmentPolicyOnDecryptInput): (output: Result<(), Error>)
    decreases config, input
  {
    Commitment.ValidateCommitmentPolicyOnDecrypt(input.algorithm, input.commitmentPolicy); Success(())
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyMaterialProvidersTypes
}

module {:extern ""software.amazon.cryptography.materialproviders.internaldafny.types""} AwsCryptographyMaterialProvidersTypes {

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import AwsCryptographyKeyStoreTypes

  import AwsCryptographyPrimitivesTypes

  import ComAmazonawsDynamodbTypes

  import ComAmazonawsKmsTypes
  datatype DafnyCallEvent<I, O> = DafnyCallEvent(input: I, output: O)

  type AccountId = string

  type AccountIdList = seq<AccountId>

  datatype AesWrappingAlg = ALG_AES128_GCM_IV12_TAG16 | ALG_AES192_GCM_IV12_TAG16 | ALG_AES256_GCM_IV12_TAG16

  datatype AlgorithmSuiteId = ESDK(ESDK: ESDKAlgorithmSuiteId) | DBE(DBE: DBEAlgorithmSuiteId)

  datatype AlgorithmSuiteInfo = AlgorithmSuiteInfo(nameonly id: AlgorithmSuiteId, nameonly binaryId: seq<uint8>, nameonly messageVersion: int32, nameonly encrypt: Encrypt, nameonly kdf: DerivationAlgorithm, nameonly commitment: DerivationAlgorithm, nameonly signature: SignatureAlgorithm, nameonly symmetricSignature: SymmetricSignatureAlgorithm, nameonly edkWrapping: EdkWrappingAlgorithm)

  class IAwsCryptographicMaterialProvidersClientCallHistory {
    ghost constructor ()
    {
      CreateAwsKmsKeyring := [];
      CreateAwsKmsDiscoveryKeyring := [];
      CreateAwsKmsMultiKeyring := [];
      CreateAwsKmsDiscoveryMultiKeyring := [];
      CreateAwsKmsMrkKeyring := [];
      CreateAwsKmsMrkMultiKeyring := [];
      CreateAwsKmsMrkDiscoveryKeyring := [];
      CreateAwsKmsMrkDiscoveryMultiKeyring := [];
      CreateAwsKmsHierarchicalKeyring := [];
      CreateMultiKeyring := [];
      CreateRawAesKeyring := [];
      CreateRawRsaKeyring := [];
      CreateAwsKmsRsaKeyring := [];
      CreateDefaultCryptographicMaterialsManager := [];
      CreateRequiredEncryptionContextCMM := [];
      CreateCryptographicMaterialsCache := [];
      CreateDefaultClientSupplier := [];
      InitializeEncryptionMaterials := [];
      InitializeDecryptionMaterials := [];
      ValidEncryptionMaterialsTransition := [];
      ValidDecryptionMaterialsTransition := [];
      EncryptionMaterialsHasPlaintextDataKey := [];
      DecryptionMaterialsWithPlaintextDataKey := [];
      GetAlgorithmSuiteInfo := [];
      ValidAlgorithmSuiteInfo := [];
      ValidateCommitmentPolicyOnEncrypt := [];
      ValidateCommitmentPolicyOnDecrypt := [];
    }

    ghost var CreateAwsKmsKeyring: seq<DafnyCallEvent<CreateAwsKmsKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateAwsKmsDiscoveryKeyring: seq<DafnyCallEvent<CreateAwsKmsDiscoveryKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateAwsKmsMultiKeyring: seq<DafnyCallEvent<CreateAwsKmsMultiKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateAwsKmsDiscoveryMultiKeyring: seq<DafnyCallEvent<CreateAwsKmsDiscoveryMultiKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateAwsKmsMrkKeyring: seq<DafnyCallEvent<CreateAwsKmsMrkKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateAwsKmsMrkMultiKeyring: seq<DafnyCallEvent<CreateAwsKmsMrkMultiKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateAwsKmsMrkDiscoveryKeyring: seq<DafnyCallEvent<CreateAwsKmsMrkDiscoveryKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateAwsKmsMrkDiscoveryMultiKeyring: seq<DafnyCallEvent<CreateAwsKmsMrkDiscoveryMultiKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateAwsKmsHierarchicalKeyring: seq<DafnyCallEvent<CreateAwsKmsHierarchicalKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateMultiKeyring: seq<DafnyCallEvent<CreateMultiKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateRawAesKeyring: seq<DafnyCallEvent<CreateRawAesKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateRawRsaKeyring: seq<DafnyCallEvent<CreateRawRsaKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateAwsKmsRsaKeyring: seq<DafnyCallEvent<CreateAwsKmsRsaKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateDefaultCryptographicMaterialsManager: seq<DafnyCallEvent<CreateDefaultCryptographicMaterialsManagerInput, Result<ICryptographicMaterialsManager, Error>>>
    ghost var CreateRequiredEncryptionContextCMM: seq<DafnyCallEvent<CreateRequiredEncryptionContextCMMInput, Result<ICryptographicMaterialsManager, Error>>>
    ghost var CreateCryptographicMaterialsCache: seq<DafnyCallEvent<CreateCryptographicMaterialsCacheInput, Result<ICryptographicMaterialsCache, Error>>>
    ghost var CreateDefaultClientSupplier: seq<DafnyCallEvent<CreateDefaultClientSupplierInput, Result<IClientSupplier, Error>>>
    ghost var InitializeEncryptionMaterials: seq<DafnyCallEvent<InitializeEncryptionMaterialsInput, Result<EncryptionMaterials, Error>>>
    ghost var InitializeDecryptionMaterials: seq<DafnyCallEvent<InitializeDecryptionMaterialsInput, Result<DecryptionMaterials, Error>>>
    ghost var ValidEncryptionMaterialsTransition: seq<DafnyCallEvent<ValidEncryptionMaterialsTransitionInput, Result<(), Error>>>
    ghost var ValidDecryptionMaterialsTransition: seq<DafnyCallEvent<ValidDecryptionMaterialsTransitionInput, Result<(), Error>>>
    ghost var EncryptionMaterialsHasPlaintextDataKey: seq<DafnyCallEvent<EncryptionMaterials, Result<(), Error>>>
    ghost var DecryptionMaterialsWithPlaintextDataKey: seq<DafnyCallEvent<DecryptionMaterials, Result<(), Error>>>
    ghost var GetAlgorithmSuiteInfo: seq<DafnyCallEvent<seq<uint8>, Result<AlgorithmSuiteInfo, Error>>>
    ghost var ValidAlgorithmSuiteInfo: seq<DafnyCallEvent<AlgorithmSuiteInfo, Result<(), Error>>>
    ghost var ValidateCommitmentPolicyOnEncrypt: seq<DafnyCallEvent<ValidateCommitmentPolicyOnEncryptInput, Result<(), Error>>>
    ghost var ValidateCommitmentPolicyOnDecrypt: seq<DafnyCallEvent<ValidateCommitmentPolicyOnDecryptInput, Result<(), Error>>>
  }

  trait {:termination false} IAwsCryptographicMaterialProvidersClient {
    ghost const Modifies: set<object>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies

    ghost const History: IAwsCryptographicMaterialProvidersClientCallHistory

    predicate CreateAwsKmsKeyringEnsuresPublicly(input: CreateAwsKmsKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateAwsKmsKeyring(input: CreateAwsKmsKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsKeyring == old(History.CreateAwsKmsKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies

    predicate CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input: CreateAwsKmsDiscoveryKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateAwsKmsDiscoveryKeyring(input: CreateAwsKmsDiscoveryKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsDiscoveryKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsDiscoveryKeyring == old(History.CreateAwsKmsDiscoveryKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies

    predicate CreateAwsKmsMultiKeyringEnsuresPublicly(input: CreateAwsKmsMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateAwsKmsMultiKeyring(input: CreateAwsKmsMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMultiKeyring == old(History.CreateAwsKmsMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}

    predicate CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input: CreateAwsKmsDiscoveryMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateAwsKmsDiscoveryMultiKeyring(input: CreateAwsKmsDiscoveryMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsDiscoveryMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsDiscoveryMultiKeyring == old(History.CreateAwsKmsDiscoveryMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}

    predicate CreateAwsKmsMrkKeyringEnsuresPublicly(input: CreateAwsKmsMrkKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateAwsKmsMrkKeyring(input: CreateAwsKmsMrkKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsMrkKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsMrkKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkKeyring == old(History.CreateAwsKmsMrkKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies

    predicate CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input: CreateAwsKmsMrkMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateAwsKmsMrkMultiKeyring(input: CreateAwsKmsMrkMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsMrkMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkMultiKeyring == old(History.CreateAwsKmsMrkMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}

    predicate CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input: CreateAwsKmsMrkDiscoveryKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateAwsKmsMrkDiscoveryKeyring(input: CreateAwsKmsMrkDiscoveryKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsMrkDiscoveryKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkDiscoveryKeyring == old(History.CreateAwsKmsMrkDiscoveryKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies

    predicate CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input: CreateAwsKmsMrkDiscoveryMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateAwsKmsMrkDiscoveryMultiKeyring(input: CreateAwsKmsMrkDiscoveryMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsMrkDiscoveryMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkDiscoveryMultiKeyring == old(History.CreateAwsKmsMrkDiscoveryMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}

    predicate CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input: CreateAwsKmsHierarchicalKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateAwsKmsHierarchicalKeyring(input: CreateAwsKmsHierarchicalKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.branchKeyIdSupplier.Some? ==> input.branchKeyIdSupplier.value.ValidState() && input.branchKeyIdSupplier.value.Modifies !! {History}) && input.keyStore.ValidState() && input.keyStore.Modifies !! {History}
      modifies Modifies - {History}, if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}, input.keyStore.Modifies, History`CreateAwsKmsHierarchicalKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - (if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}) - input.keyStore.Modifies))
      ensures CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsHierarchicalKeyring == old(History.CreateAwsKmsHierarchicalKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}, input.keyStore.Modifies

    predicate CreateMultiKeyringEnsuresPublicly(input: CreateMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateMultiKeyring(input: CreateMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.generator.Some? ==> input.generator.value.ValidState() && input.generator.value.Modifies !! {History}) && forall i: IKeyring {:trigger i.Modifies} {:trigger i.ValidState()} {:trigger i in input.childKeyrings} | i in input.childKeyrings :: i.ValidState() && i.Modifies !! {History}
      modifies Modifies - {History}, if input.generator.Some? then input.generator.value.Modifies else {}, set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m, History`CreateMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - (if input.generator.Some? then input.generator.value.Modifies else {}) - set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m))
      ensures CreateMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateMultiKeyring == old(History.CreateMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.generator.Some? then input.generator.value.Modifies else {}, set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m

    predicate CreateRawAesKeyringEnsuresPublicly(input: CreateRawAesKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateRawAesKeyring(input: CreateRawAesKeyringInput) returns (output: Result<IKeyring, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateRawAesKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateRawAesKeyringEnsuresPublicly(input, output)
      ensures History.CreateRawAesKeyring == old(History.CreateRawAesKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate CreateRawRsaKeyringEnsuresPublicly(input: CreateRawRsaKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateRawRsaKeyring(input: CreateRawRsaKeyringInput) returns (output: Result<IKeyring, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateRawRsaKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateRawRsaKeyringEnsuresPublicly(input, output)
      ensures History.CreateRawRsaKeyring == old(History.CreateRawRsaKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate CreateAwsKmsRsaKeyringEnsuresPublicly(input: CreateAwsKmsRsaKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateAwsKmsRsaKeyring(input: CreateAwsKmsRsaKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.kmsClient.Some? ==> input.kmsClient.value.ValidState() && input.kmsClient.value.Modifies !! {History})
      modifies Modifies - {History}, if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}, History`CreateAwsKmsRsaKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}))
      ensures CreateAwsKmsRsaKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsRsaKeyring == old(History.CreateAwsKmsRsaKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}

    predicate CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input: CreateDefaultCryptographicMaterialsManagerInput, output: Result<ICryptographicMaterialsManager, Error>)
      decreases input, output

    method CreateDefaultCryptographicMaterialsManager(input: CreateDefaultCryptographicMaterialsManagerInput) returns (output: Result<ICryptographicMaterialsManager, Error>)
      requires ValidState() && input.keyring.ValidState() && input.keyring.Modifies !! {History}
      modifies Modifies - {History}, input.keyring.Modifies, History`CreateDefaultCryptographicMaterialsManager
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.keyring.Modifies))
      ensures CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input, output)
      ensures History.CreateDefaultCryptographicMaterialsManager == old(History.CreateDefaultCryptographicMaterialsManager) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.keyring.Modifies

    predicate CreateRequiredEncryptionContextCMMEnsuresPublicly(input: CreateRequiredEncryptionContextCMMInput, output: Result<ICryptographicMaterialsManager, Error>)
      decreases input, output

    method CreateRequiredEncryptionContextCMM(input: CreateRequiredEncryptionContextCMMInput) returns (output: Result<ICryptographicMaterialsManager, Error>)
      requires ValidState() && (input.underlyingCMM.Some? ==> input.underlyingCMM.value.ValidState() && input.underlyingCMM.value.Modifies !! {History}) && (input.keyring.Some? ==> input.keyring.value.ValidState() && input.keyring.value.Modifies !! {History})
      modifies Modifies - {History}, if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}, History`CreateRequiredEncryptionContextCMM
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - (if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}) - if input.keyring.Some? then input.keyring.value.Modifies else {}))
      ensures CreateRequiredEncryptionContextCMMEnsuresPublicly(input, output)
      ensures History.CreateRequiredEncryptionContextCMM == old(History.CreateRequiredEncryptionContextCMM) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}

    predicate CreateCryptographicMaterialsCacheEnsuresPublicly(input: CreateCryptographicMaterialsCacheInput, output: Result<ICryptographicMaterialsCache, Error>)
      decreases input, output

    method CreateCryptographicMaterialsCache(input: CreateCryptographicMaterialsCacheInput) returns (output: Result<ICryptographicMaterialsCache, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateCryptographicMaterialsCache
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateCryptographicMaterialsCacheEnsuresPublicly(input, output)
      ensures History.CreateCryptographicMaterialsCache == old(History.CreateCryptographicMaterialsCache) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate CreateDefaultClientSupplierEnsuresPublicly(input: CreateDefaultClientSupplierInput, output: Result<IClientSupplier, Error>)
      decreases input, output

    method CreateDefaultClientSupplier(input: CreateDefaultClientSupplierInput) returns (output: Result<IClientSupplier, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateDefaultClientSupplier
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateDefaultClientSupplierEnsuresPublicly(input, output)
      ensures History.CreateDefaultClientSupplier == old(History.CreateDefaultClientSupplier) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    function method InitializeEncryptionMaterials(input: InitializeEncryptionMaterialsInput): (output: Result<EncryptionMaterials, Error>)
      decreases input

    function method InitializeDecryptionMaterials(input: InitializeDecryptionMaterialsInput): (output: Result<DecryptionMaterials, Error>)
      decreases input

    function method ValidEncryptionMaterialsTransition(input: ValidEncryptionMaterialsTransitionInput): (output: Result<(), Error>)
      decreases input

    function method ValidDecryptionMaterialsTransition(input: ValidDecryptionMaterialsTransitionInput): (output: Result<(), Error>)
      decreases input

    function method EncryptionMaterialsHasPlaintextDataKey(input: EncryptionMaterials): (output: Result<(), Error>)
      decreases input

    function method DecryptionMaterialsWithPlaintextDataKey(input: DecryptionMaterials): (output: Result<(), Error>)
      decreases input

    function method GetAlgorithmSuiteInfo(input: seq<uint8>): (output: Result<AlgorithmSuiteInfo, Error>)
      decreases input

    function method ValidAlgorithmSuiteInfo(input: AlgorithmSuiteInfo): (output: Result<(), Error>)
      decreases input

    function method ValidateCommitmentPolicyOnEncrypt(input: ValidateCommitmentPolicyOnEncryptInput): (output: Result<(), Error>)
      decreases input

    function method ValidateCommitmentPolicyOnDecrypt(input: ValidateCommitmentPolicyOnDecryptInput): (output: Result<(), Error>)
      decreases input
  }

  class IBranchKeyIdSupplierCallHistory {
    ghost constructor ()
    {
      GetBranchKeyId := [];
    }

    ghost var GetBranchKeyId: seq<DafnyCallEvent<GetBranchKeyIdInput, Result<GetBranchKeyIdOutput, Error>>>
  }

  trait {:termination false} IBranchKeyIdSupplier {
    ghost const Modifies: set<object>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies

    ghost const History: IBranchKeyIdSupplierCallHistory

    predicate GetBranchKeyIdEnsuresPublicly(input: GetBranchKeyIdInput, output: Result<GetBranchKeyIdOutput, Error>)
      decreases input, output

    method GetBranchKeyId(input: GetBranchKeyIdInput) returns (output: Result<GetBranchKeyIdOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetBranchKeyId
      ensures true && ValidState()
      ensures GetBranchKeyIdEnsuresPublicly(input, output)
      ensures History.GetBranchKeyId == old(History.GetBranchKeyId) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := GetBranchKeyId'(input);
      History.GetBranchKeyId := History.GetBranchKeyId + [DafnyCallEvent(input, output)];
    }

    method GetBranchKeyId'(input: GetBranchKeyIdInput) returns (output: Result<GetBranchKeyIdOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures true && ValidState()
      ensures GetBranchKeyIdEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}
  }

  datatype CacheType = Default(Default: DefaultCache) | No(No: NoCache) | SingleThreaded(SingleThreaded: SingleThreadedCache) | MultiThreaded(MultiThreaded: MultiThreadedCache) | StormTracking(StormTracking: StormTrackingCache)

  class IClientSupplierCallHistory {
    ghost constructor ()
    {
      GetClient := [];
    }

    ghost var GetClient: seq<DafnyCallEvent<GetClientInput, Result<ComAmazonawsKmsTypes.IKMSClient, Error>>>
  }

  trait {:termination false} IClientSupplier {
    ghost const Modifies: set<object>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies

    ghost const History: IClientSupplierCallHistory

    predicate GetClientEnsuresPublicly(input: GetClientInput, output: Result<ComAmazonawsKmsTypes.IKMSClient, Error>)
      decreases input, output

    method GetClient(input: GetClientInput) returns (output: Result<ComAmazonawsKmsTypes.IKMSClient, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetClient
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures GetClientEnsuresPublicly(input, output)
      ensures History.GetClient == old(History.GetClient) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := GetClient'(input);
      History.GetClient := History.GetClient + [DafnyCallEvent(input, output)];
    }

    method GetClient'(input: GetClientInput) returns (output: Result<ComAmazonawsKmsTypes.IKMSClient, Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures GetClientEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}
  }

  datatype CommitmentPolicy = ESDK(ESDK: ESDKCommitmentPolicy) | DBE(DBE: DBECommitmentPolicy)

  type CountingNumber = x: int32
    | IsValid_CountingNumber(x)
    witness *

  datatype CreateAwsKmsDiscoveryKeyringInput = CreateAwsKmsDiscoveryKeyringInput(nameonly kmsClient: ComAmazonawsKmsTypes.IKMSClient, nameonly discoveryFilter: Option<DiscoveryFilter>, nameonly grantTokens: Option<GrantTokenList>)

  datatype CreateAwsKmsDiscoveryMultiKeyringInput = CreateAwsKmsDiscoveryMultiKeyringInput(nameonly regions: RegionList, nameonly discoveryFilter: Option<DiscoveryFilter>, nameonly clientSupplier: Option<IClientSupplier>, nameonly grantTokens: Option<GrantTokenList>)

  datatype CreateAwsKmsHierarchicalKeyringInput = CreateAwsKmsHierarchicalKeyringInput(nameonly branchKeyId: Option<string>, nameonly branchKeyIdSupplier: Option<IBranchKeyIdSupplier>, nameonly keyStore: AwsCryptographyKeyStoreTypes.IKeyStoreClient, nameonly ttlSeconds: PositiveLong, nameonly cache: Option<CacheType>)

  datatype CreateAwsKmsKeyringInput = CreateAwsKmsKeyringInput(nameonly kmsKeyId: KmsKeyId, nameonly kmsClient: ComAmazonawsKmsTypes.IKMSClient, nameonly grantTokens: Option<GrantTokenList>)

  datatype CreateAwsKmsMrkDiscoveryKeyringInput = CreateAwsKmsMrkDiscoveryKeyringInput(nameonly kmsClient: ComAmazonawsKmsTypes.IKMSClient, nameonly discoveryFilter: Option<DiscoveryFilter>, nameonly grantTokens: Option<GrantTokenList>, nameonly region: Region)

  datatype CreateAwsKmsMrkDiscoveryMultiKeyringInput = CreateAwsKmsMrkDiscoveryMultiKeyringInput(nameonly regions: RegionList, nameonly discoveryFilter: Option<DiscoveryFilter>, nameonly clientSupplier: Option<IClientSupplier>, nameonly grantTokens: Option<GrantTokenList>)

  datatype CreateAwsKmsMrkKeyringInput = CreateAwsKmsMrkKeyringInput(nameonly kmsKeyId: KmsKeyId, nameonly kmsClient: ComAmazonawsKmsTypes.IKMSClient, nameonly grantTokens: Option<GrantTokenList>)

  datatype CreateAwsKmsMrkMultiKeyringInput = CreateAwsKmsMrkMultiKeyringInput(nameonly generator: Option<KmsKeyId>, nameonly kmsKeyIds: Option<KmsKeyIdList>, nameonly clientSupplier: Option<IClientSupplier>, nameonly grantTokens: Option<GrantTokenList>)

  datatype CreateAwsKmsMultiKeyringInput = CreateAwsKmsMultiKeyringInput(nameonly generator: Option<KmsKeyId>, nameonly kmsKeyIds: Option<KmsKeyIdList>, nameonly clientSupplier: Option<IClientSupplier>, nameonly grantTokens: Option<GrantTokenList>)

  datatype CreateAwsKmsRsaKeyringInput = CreateAwsKmsRsaKeyringInput(nameonly publicKey: Option<Secret>, nameonly kmsKeyId: KmsKeyId, nameonly encryptionAlgorithm: ComAmazonawsKmsTypes.EncryptionAlgorithmSpec, nameonly kmsClient: Option<ComAmazonawsKmsTypes.IKMSClient>, nameonly grantTokens: Option<GrantTokenList>)

  datatype CreateCryptographicMaterialsCacheInput = CreateCryptographicMaterialsCacheInput(nameonly cache: CacheType)

  datatype CreateDefaultClientSupplierInput = CreateDefaultClientSupplierInput

  datatype CreateDefaultCryptographicMaterialsManagerInput = CreateDefaultCryptographicMaterialsManagerInput(nameonly keyring: IKeyring)

  datatype CreateMultiKeyringInput = CreateMultiKeyringInput(nameonly generator: Option<IKeyring>, nameonly childKeyrings: KeyringList)

  datatype CreateRawAesKeyringInput = CreateRawAesKeyringInput(nameonly keyNamespace: string, nameonly keyName: string, nameonly wrappingKey: seq<uint8>, nameonly wrappingAlg: AesWrappingAlg)

  datatype CreateRawRsaKeyringInput = CreateRawRsaKeyringInput(nameonly keyNamespace: string, nameonly keyName: string, nameonly paddingScheme: PaddingScheme, nameonly publicKey: Option<seq<uint8>>, nameonly privateKey: Option<seq<uint8>>)

  datatype CreateRequiredEncryptionContextCMMInput = CreateRequiredEncryptionContextCMMInput(nameonly underlyingCMM: Option<ICryptographicMaterialsManager>, nameonly keyring: Option<IKeyring>, nameonly requiredEncryptionContextKeys: EncryptionContextKeys)

  class ICryptographicMaterialsCacheCallHistory {
    ghost constructor ()
    {
      PutCacheEntry := [];
      UpdateUsageMetadata := [];
      GetCacheEntry := [];
      DeleteCacheEntry := [];
    }

    ghost var PutCacheEntry: seq<DafnyCallEvent<PutCacheEntryInput, Result<(), Error>>>
    ghost var UpdateUsageMetadata: seq<DafnyCallEvent<UpdateUsageMetadataInput, Result<(), Error>>>
    ghost var GetCacheEntry: seq<DafnyCallEvent<GetCacheEntryInput, Result<GetCacheEntryOutput, Error>>>
    ghost var DeleteCacheEntry: seq<DafnyCallEvent<DeleteCacheEntryInput, Result<(), Error>>>
  }

  trait {:termination false} ICryptographicMaterialsCache {
    ghost var Modifies: set<object>

    predicate ValidState()
      reads this`Modifies, Modifies - {History}
      ensures ValidState() ==> History in Modifies
      decreases Modifies - {History} + {this}

    ghost const History: ICryptographicMaterialsCacheCallHistory

    predicate PutCacheEntryEnsuresPublicly(input: PutCacheEntryInput, output: Result<(), Error>)
      decreases input, output

    method PutCacheEntry(input: PutCacheEntryInput) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`PutCacheEntry
      ensures true && ValidState()
      ensures PutCacheEntryEnsuresPublicly(input, output)
      ensures History.PutCacheEntry == old(History.PutCacheEntry) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := PutCacheEntry'(input);
      History.PutCacheEntry := History.PutCacheEntry + [DafnyCallEvent(input, output)];
    }

    method PutCacheEntry'(input: PutCacheEntryInput) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures true && ValidState()
      ensures PutCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}

    predicate UpdateUsageMetadataEnsuresPublicly(input: UpdateUsageMetadataInput, output: Result<(), Error>)
      decreases input, output

    method UpdateUsageMetadata(input: UpdateUsageMetadataInput) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`UpdateUsageMetadata
      ensures true && ValidState()
      ensures UpdateUsageMetadataEnsuresPublicly(input, output)
      ensures History.UpdateUsageMetadata == old(History.UpdateUsageMetadata) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := UpdateUsageMetadata'(input);
      History.UpdateUsageMetadata := History.UpdateUsageMetadata + [DafnyCallEvent(input, output)];
    }

    method UpdateUsageMetadata'(input: UpdateUsageMetadataInput) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures true && ValidState()
      ensures UpdateUsageMetadataEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}

    predicate GetCacheEntryEnsuresPublicly(input: GetCacheEntryInput, output: Result<GetCacheEntryOutput, Error>)
      decreases input, output

    method GetCacheEntry(input: GetCacheEntryInput) returns (output: Result<GetCacheEntryOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetCacheEntry
      ensures true && ValidState()
      ensures GetCacheEntryEnsuresPublicly(input, output)
      ensures History.GetCacheEntry == old(History.GetCacheEntry) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := GetCacheEntry'(input);
      History.GetCacheEntry := History.GetCacheEntry + [DafnyCallEvent(input, output)];
    }

    method GetCacheEntry'(input: GetCacheEntryInput) returns (output: Result<GetCacheEntryOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures true && ValidState()
      ensures GetCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}

    predicate DeleteCacheEntryEnsuresPublicly(input: DeleteCacheEntryInput, output: Result<(), Error>)
      decreases input, output

    method DeleteCacheEntry(input: DeleteCacheEntryInput) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DeleteCacheEntry
      ensures true && ValidState()
      ensures DeleteCacheEntryEnsuresPublicly(input, output)
      ensures History.DeleteCacheEntry == old(History.DeleteCacheEntry) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := DeleteCacheEntry'(input);
      History.DeleteCacheEntry := History.DeleteCacheEntry + [DafnyCallEvent(input, output)];
    }

    method DeleteCacheEntry'(input: DeleteCacheEntryInput) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures true && ValidState()
      ensures DeleteCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}
  }

  class ICryptographicMaterialsManagerCallHistory {
    ghost constructor ()
    {
      GetEncryptionMaterials := [];
      DecryptMaterials := [];
    }

    ghost var GetEncryptionMaterials: seq<DafnyCallEvent<GetEncryptionMaterialsInput, Result<GetEncryptionMaterialsOutput, Error>>>
    ghost var DecryptMaterials: seq<DafnyCallEvent<DecryptMaterialsInput, Result<DecryptMaterialsOutput, Error>>>
  }

  trait {:termination false} ICryptographicMaterialsManager {
    ghost const Modifies: set<object>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies

    ghost const History: ICryptographicMaterialsManagerCallHistory

    predicate GetEncryptionMaterialsEnsuresPublicly(input: GetEncryptionMaterialsInput, output: Result<GetEncryptionMaterialsOutput, Error>)
      decreases input, output

    method GetEncryptionMaterials(input: GetEncryptionMaterialsInput) returns (output: Result<GetEncryptionMaterialsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetEncryptionMaterials
      ensures true && ValidState()
      ensures GetEncryptionMaterialsEnsuresPublicly(input, output)
      ensures History.GetEncryptionMaterials == old(History.GetEncryptionMaterials) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := GetEncryptionMaterials'(input);
      History.GetEncryptionMaterials := History.GetEncryptionMaterials + [DafnyCallEvent(input, output)];
    }

    method GetEncryptionMaterials'(input: GetEncryptionMaterialsInput) returns (output: Result<GetEncryptionMaterialsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures true && ValidState()
      ensures GetEncryptionMaterialsEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}

    predicate DecryptMaterialsEnsuresPublicly(input: DecryptMaterialsInput, output: Result<DecryptMaterialsOutput, Error>)
      decreases input, output

    method DecryptMaterials(input: DecryptMaterialsInput) returns (output: Result<DecryptMaterialsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DecryptMaterials
      ensures true && ValidState()
      ensures DecryptMaterialsEnsuresPublicly(input, output)
      ensures History.DecryptMaterials == old(History.DecryptMaterials) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := DecryptMaterials'(input);
      History.DecryptMaterials := History.DecryptMaterials + [DafnyCallEvent(input, output)];
    }

    method DecryptMaterials'(input: DecryptMaterialsInput) returns (output: Result<DecryptMaterialsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures true && ValidState()
      ensures DecryptMaterialsEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}
  }

  datatype DBEAlgorithmSuiteId = ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_SYMSIG_HMAC_SHA384 | ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384_SYMSIG_HMAC_SHA384

  datatype DBECommitmentPolicy = REQUIRE_ENCRYPT_REQUIRE_DECRYPT

  type DdbTableArn = string

  datatype DecryptionMaterials = DecryptionMaterials(nameonly algorithmSuite: AlgorithmSuiteInfo, nameonly encryptionContext: EncryptionContext, nameonly requiredEncryptionContextKeys: EncryptionContextKeys, nameonly plaintextDataKey: Option<Secret>, nameonly verificationKey: Option<Secret>, nameonly symmetricSigningKey: Option<Secret>)

  datatype DecryptMaterialsInput = DecryptMaterialsInput(nameonly algorithmSuiteId: AlgorithmSuiteId, nameonly commitmentPolicy: CommitmentPolicy, nameonly encryptedDataKeys: EncryptedDataKeyList, nameonly encryptionContext: EncryptionContext, nameonly reproducedEncryptionContext: Option<EncryptionContext>)

  datatype DecryptMaterialsOutput = DecryptMaterialsOutput(nameonly decryptionMaterials: DecryptionMaterials)

  datatype DefaultCache = DefaultCache(nameonly entryCapacity: CountingNumber)

  datatype DeleteCacheEntryInput = DeleteCacheEntryInput(nameonly identifier: seq<uint8>)

  datatype DerivationAlgorithm = HKDF(HKDF: HKDF) | IDENTITY(IDENTITY: IDENTITY) | None(None: None)

  datatype DIRECT_KEY_WRAPPING = DIRECT_KEY_WRAPPING

  datatype DiscoveryFilter = DiscoveryFilter(nameonly accountIds: AccountIdList, nameonly partition: string)

  datatype ECDSA = ECDSA(nameonly curve: AwsCryptographyPrimitivesTypes.ECDSASignatureAlgorithm)

  datatype EdkWrappingAlgorithm = DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING: DIRECT_KEY_WRAPPING) | IntermediateKeyWrapping(IntermediateKeyWrapping: IntermediateKeyWrapping)

  datatype Encrypt = AES_GCM(AES_GCM: AwsCryptographyPrimitivesTypes.AES_GCM)

  datatype EncryptedDataKey = EncryptedDataKey(nameonly keyProviderId: Utf8Bytes, nameonly keyProviderInfo: seq<uint8>, nameonly ciphertext: seq<uint8>)

  type EncryptedDataKeyList = seq<EncryptedDataKey>

  type EncryptionContext = map<Utf8Bytes, Utf8Bytes>

  type EncryptionContextKeys = seq<Utf8Bytes>

  datatype EncryptionMaterials = EncryptionMaterials(nameonly algorithmSuite: AlgorithmSuiteInfo, nameonly encryptionContext: EncryptionContext, nameonly encryptedDataKeys: EncryptedDataKeyList, nameonly requiredEncryptionContextKeys: EncryptionContextKeys, nameonly plaintextDataKey: Option<Secret>, nameonly signingKey: Option<Secret>, nameonly symmetricSigningKeys: Option<SymmetricSigningKeyList>)

  datatype ESDKAlgorithmSuiteId = ALG_AES_128_GCM_IV12_TAG16_NO_KDF | ALG_AES_192_GCM_IV12_TAG16_NO_KDF | ALG_AES_256_GCM_IV12_TAG16_NO_KDF | ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256 | ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA256 | ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA256 | ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256 | ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384 | ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384 | ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY | ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384

  datatype ESDKCommitmentPolicy = FORBID_ENCRYPT_ALLOW_DECRYPT | REQUIRE_ENCRYPT_ALLOW_DECRYPT | REQUIRE_ENCRYPT_REQUIRE_DECRYPT

  datatype GetBranchKeyIdInput = GetBranchKeyIdInput(nameonly encryptionContext: EncryptionContext)

  datatype GetBranchKeyIdOutput = GetBranchKeyIdOutput(nameonly branchKeyId: string)

  datatype GetCacheEntryInput = GetCacheEntryInput(nameonly identifier: seq<uint8>, nameonly bytesUsed: Option<int64>)

  datatype GetCacheEntryOutput = GetCacheEntryOutput(nameonly materials: Materials, nameonly creationTime: PositiveLong, nameonly expiryTime: PositiveLong, nameonly messagesUsed: PositiveInteger, nameonly bytesUsed: PositiveInteger)

  datatype GetClientInput = GetClientInput(nameonly region: Region)

  datatype GetEncryptionMaterialsInput = GetEncryptionMaterialsInput(nameonly encryptionContext: EncryptionContext, nameonly commitmentPolicy: CommitmentPolicy, nameonly algorithmSuiteId: Option<AlgorithmSuiteId>, nameonly maxPlaintextLength: Option<int64>, nameonly requiredEncryptionContextKeys: Option<EncryptionContextKeys>)

  datatype GetEncryptionMaterialsOutput = GetEncryptionMaterialsOutput(nameonly encryptionMaterials: EncryptionMaterials)

  type GrantTokenList = seq<string>

  datatype HKDF = HKDF(nameonly hmac: AwsCryptographyPrimitivesTypes.DigestAlgorithm, nameonly saltLength: AwsCryptographyPrimitivesTypes.PositiveInteger, nameonly inputKeyLength: AwsCryptographyPrimitivesTypes.SymmetricKeyLength, nameonly outputKeyLength: AwsCryptographyPrimitivesTypes.SymmetricKeyLength)

  datatype IDENTITY = IDENTITY

  datatype InitializeDecryptionMaterialsInput = InitializeDecryptionMaterialsInput(nameonly algorithmSuiteId: AlgorithmSuiteId, nameonly encryptionContext: EncryptionContext, nameonly requiredEncryptionContextKeys: EncryptionContextKeys)

  datatype InitializeEncryptionMaterialsInput = InitializeEncryptionMaterialsInput(nameonly algorithmSuiteId: AlgorithmSuiteId, nameonly encryptionContext: EncryptionContext, nameonly requiredEncryptionContextKeys: EncryptionContextKeys, nameonly signingKey: Option<Secret>, nameonly verificationKey: Option<Secret>)

  datatype IntermediateKeyWrapping = IntermediateKeyWrapping(nameonly keyEncryptionKeyKdf: DerivationAlgorithm, nameonly macKeyKdf: DerivationAlgorithm, nameonly pdkEncryptAlgorithm: Encrypt)

  type KeyringList = seq<IKeyring>

  class IKeyringCallHistory {
    ghost constructor ()
    {
      OnEncrypt := [];
      OnDecrypt := [];
    }

    ghost var OnEncrypt: seq<DafnyCallEvent<OnEncryptInput, Result<OnEncryptOutput, Error>>>
    ghost var OnDecrypt: seq<DafnyCallEvent<OnDecryptInput, Result<OnDecryptOutput, Error>>>
  }

  trait {:termination false} IKeyring {
    ghost const Modifies: set<object>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies

    ghost const History: IKeyringCallHistory

    predicate OnEncryptEnsuresPublicly(input: OnEncryptInput, output: Result<OnEncryptOutput, Error>)
      decreases input, output

    method OnEncrypt(input: OnEncryptInput) returns (output: Result<OnEncryptOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`OnEncrypt
      ensures true && ValidState()
      ensures OnEncryptEnsuresPublicly(input, output)
      ensures History.OnEncrypt == old(History.OnEncrypt) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := OnEncrypt'(input);
      History.OnEncrypt := History.OnEncrypt + [DafnyCallEvent(input, output)];
    }

    method OnEncrypt'(input: OnEncryptInput) returns (output: Result<OnEncryptOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures true && ValidState()
      ensures OnEncryptEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}

    predicate OnDecryptEnsuresPublicly(input: OnDecryptInput, output: Result<OnDecryptOutput, Error>)
      decreases input, output

    method OnDecrypt(input: OnDecryptInput) returns (output: Result<OnDecryptOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`OnDecrypt
      ensures true && ValidState()
      ensures OnDecryptEnsuresPublicly(input, output)
      ensures History.OnDecrypt == old(History.OnDecrypt) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := OnDecrypt'(input);
      History.OnDecrypt := History.OnDecrypt + [DafnyCallEvent(input, output)];
    }

    method OnDecrypt'(input: OnDecryptInput) returns (output: Result<OnDecryptOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures true && ValidState()
      ensures OnDecryptEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}
  }

  type KmsKeyId = string

  type KmsKeyIdList = seq<KmsKeyId>

  datatype MaterialProvidersConfig = MaterialProvidersConfig

  datatype Materials = Encryption(Encryption: EncryptionMaterials) | Decryption(Decryption: DecryptionMaterials) | BranchKey(BranchKey: AwsCryptographyKeyStoreTypes.BranchKeyMaterials) | BeaconKey(BeaconKey: AwsCryptographyKeyStoreTypes.BeaconKeyMaterials)

  datatype MultiThreadedCache = MultiThreadedCache(nameonly entryCapacity: CountingNumber, nameonly entryPruningTailSize: Option<CountingNumber>)

  datatype NoCache = NoCache

  datatype None = None

  datatype OnDecryptInput = OnDecryptInput(nameonly materials: DecryptionMaterials, nameonly encryptedDataKeys: EncryptedDataKeyList)

  datatype OnDecryptOutput = OnDecryptOutput(nameonly materials: DecryptionMaterials)

  datatype OnEncryptInput = OnEncryptInput(nameonly materials: EncryptionMaterials)

  datatype OnEncryptOutput = OnEncryptOutput(nameonly materials: EncryptionMaterials)

  datatype PaddingScheme = PKCS1 | OAEP_SHA1_MGF1 | OAEP_SHA256_MGF1 | OAEP_SHA384_MGF1 | OAEP_SHA512_MGF1

  type PositiveInteger = x: int32
    | IsValid_PositiveInteger(x)
    witness *

  type PositiveLong = x: int64
    | IsValid_PositiveLong(x)
    witness *

  datatype PutCacheEntryInput = PutCacheEntryInput(nameonly identifier: seq<uint8>, nameonly materials: Materials, nameonly creationTime: PositiveLong, nameonly expiryTime: PositiveLong, nameonly messagesUsed: Option<PositiveInteger>, nameonly bytesUsed: Option<PositiveInteger>)

  type Region = string

  type RegionList = seq<Region>

  type Secret = seq<uint8>

  datatype SignatureAlgorithm = ECDSA(ECDSA: ECDSA) | None(None: None)

  datatype SingleThreadedCache = SingleThreadedCache(nameonly entryCapacity: CountingNumber, nameonly entryPruningTailSize: Option<CountingNumber>)

  datatype StormTrackingCache = StormTrackingCache(nameonly entryCapacity: CountingNumber, nameonly entryPruningTailSize: Option<CountingNumber>, nameonly gracePeriod: CountingNumber, nameonly graceInterval: CountingNumber, nameonly fanOut: CountingNumber, nameonly inFlightTTL: CountingNumber, nameonly sleepMilli: CountingNumber)

  datatype SymmetricSignatureAlgorithm = HMAC(HMAC: AwsCryptographyPrimitivesTypes.DigestAlgorithm) | None(None: None)

  type SymmetricSigningKeyList = seq<Secret>

  datatype UpdateUsageMetadataInput = UpdateUsageMetadataInput(nameonly identifier: seq<uint8>, nameonly bytesUsed: PositiveInteger)

  type Utf8Bytes = ValidUTF8Bytes

  datatype ValidateCommitmentPolicyOnDecryptInput = ValidateCommitmentPolicyOnDecryptInput(nameonly algorithm: AlgorithmSuiteId, nameonly commitmentPolicy: CommitmentPolicy)

  datatype ValidateCommitmentPolicyOnEncryptInput = ValidateCommitmentPolicyOnEncryptInput(nameonly algorithm: AlgorithmSuiteId, nameonly commitmentPolicy: CommitmentPolicy)

  datatype ValidDecryptionMaterialsTransitionInput = ValidDecryptionMaterialsTransitionInput(nameonly start: DecryptionMaterials, nameonly stop: DecryptionMaterials)

  datatype ValidEncryptionMaterialsTransitionInput = ValidEncryptionMaterialsTransitionInput(nameonly start: EncryptionMaterials, nameonly stop: EncryptionMaterials)

  datatype Error = AwsCryptographicMaterialProvidersException(nameonly message: string) | EntryAlreadyExists(nameonly message: string) | EntryDoesNotExist(nameonly message: string) | InvalidAlgorithmSuiteInfo(nameonly message: string) | InvalidAlgorithmSuiteInfoOnDecrypt(nameonly message: string) | InvalidAlgorithmSuiteInfoOnEncrypt(nameonly message: string) | InvalidDecryptionMaterials(nameonly message: string) | InvalidDecryptionMaterialsTransition(nameonly message: string) | InvalidEncryptionMaterials(nameonly message: string) | InvalidEncryptionMaterialsTransition(nameonly message: string) | AwsCryptographyKeyStore(AwsCryptographyKeyStore: AwsCryptographyKeyStoreTypes.Error) | AwsCryptographyPrimitives(AwsCryptographyPrimitives: AwsCryptographyPrimitivesTypes.Error) | ComAmazonawsDynamodb(ComAmazonawsDynamodb: ComAmazonawsDynamodbTypes.Error) | ComAmazonawsKms(ComAmazonawsKms: ComAmazonawsKmsTypes.Error) | CollectionOfErrors(list: seq<Error>, nameonly message: string) | Opaque(obj: object)

  type OpaqueError = e: Error
    | e.Opaque?
    witness *

  predicate method IsValid_CountingNumber(x: int32)
    decreases x
  {
    1 <= x
  }

  predicate method IsValid_PositiveInteger(x: int32)
    decreases x
  {
    0 <= x
  }

  predicate method IsValid_PositiveLong(x: int64)
    decreases x
  {
    0 <= x
  }
}

abstract module AbstractAwsCryptographyMaterialProvidersService {

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyMaterialProvidersTypes

  import Operations : AbstractAwsCryptographyMaterialProvidersOperations
  class MaterialProvidersClient extends IAwsCryptographicMaterialProvidersClient {
    constructor (config: Operations.InternalConfig)
      requires Operations.ValidInternalConfig?(config)
      ensures ValidState() && fresh(History) && this.config == config

    const config: Operations.InternalConfig

    predicate ValidState()
      ensures ValidState() ==> Operations.ValidInternalConfig?(config) && History !in Operations.ModifiesInternalConfig(config) && Modifies == Operations.ModifiesInternalConfig(config) + {History}

    predicate CreateAwsKmsKeyringEnsuresPublicly(input: CreateAwsKmsKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsKeyring(input: CreateAwsKmsKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsKeyring == old(History.CreateAwsKmsKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies
    {
      output := Operations.CreateAwsKmsKeyring(config, input);
      History.CreateAwsKmsKeyring := History.CreateAwsKmsKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input: CreateAwsKmsDiscoveryKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsDiscoveryKeyring(input: CreateAwsKmsDiscoveryKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsDiscoveryKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsDiscoveryKeyring == old(History.CreateAwsKmsDiscoveryKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies
    {
      output := Operations.CreateAwsKmsDiscoveryKeyring(config, input);
      History.CreateAwsKmsDiscoveryKeyring := History.CreateAwsKmsDiscoveryKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsMultiKeyringEnsuresPublicly(input: CreateAwsKmsMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsMultiKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsMultiKeyring(input: CreateAwsKmsMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMultiKeyring == old(History.CreateAwsKmsMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    {
      output := Operations.CreateAwsKmsMultiKeyring(config, input);
      History.CreateAwsKmsMultiKeyring := History.CreateAwsKmsMultiKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input: CreateAwsKmsDiscoveryMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsDiscoveryMultiKeyring(input: CreateAwsKmsDiscoveryMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsDiscoveryMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsDiscoveryMultiKeyring == old(History.CreateAwsKmsDiscoveryMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    {
      output := Operations.CreateAwsKmsDiscoveryMultiKeyring(config, input);
      History.CreateAwsKmsDiscoveryMultiKeyring := History.CreateAwsKmsDiscoveryMultiKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsMrkKeyringEnsuresPublicly(input: CreateAwsKmsMrkKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsMrkKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsMrkKeyring(input: CreateAwsKmsMrkKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsMrkKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsMrkKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkKeyring == old(History.CreateAwsKmsMrkKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies
    {
      output := Operations.CreateAwsKmsMrkKeyring(config, input);
      History.CreateAwsKmsMrkKeyring := History.CreateAwsKmsMrkKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input: CreateAwsKmsMrkMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsMrkMultiKeyring(input: CreateAwsKmsMrkMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsMrkMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkMultiKeyring == old(History.CreateAwsKmsMrkMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    {
      output := Operations.CreateAwsKmsMrkMultiKeyring(config, input);
      History.CreateAwsKmsMrkMultiKeyring := History.CreateAwsKmsMrkMultiKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input: CreateAwsKmsMrkDiscoveryKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsMrkDiscoveryKeyring(input: CreateAwsKmsMrkDiscoveryKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsMrkDiscoveryKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkDiscoveryKeyring == old(History.CreateAwsKmsMrkDiscoveryKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies
    {
      output := Operations.CreateAwsKmsMrkDiscoveryKeyring(config, input);
      History.CreateAwsKmsMrkDiscoveryKeyring := History.CreateAwsKmsMrkDiscoveryKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input: CreateAwsKmsMrkDiscoveryMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsMrkDiscoveryMultiKeyring(input: CreateAwsKmsMrkDiscoveryMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsMrkDiscoveryMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkDiscoveryMultiKeyring == old(History.CreateAwsKmsMrkDiscoveryMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    {
      output := Operations.CreateAwsKmsMrkDiscoveryMultiKeyring(config, input);
      History.CreateAwsKmsMrkDiscoveryMultiKeyring := History.CreateAwsKmsMrkDiscoveryMultiKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input: CreateAwsKmsHierarchicalKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsHierarchicalKeyring(input: CreateAwsKmsHierarchicalKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.branchKeyIdSupplier.Some? ==> input.branchKeyIdSupplier.value.ValidState() && input.branchKeyIdSupplier.value.Modifies !! {History}) && input.keyStore.ValidState() && input.keyStore.Modifies !! {History}
      modifies Modifies - {History}, if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}, input.keyStore.Modifies, History`CreateAwsKmsHierarchicalKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - (if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}) - input.keyStore.Modifies))
      ensures CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsHierarchicalKeyring == old(History.CreateAwsKmsHierarchicalKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}, input.keyStore.Modifies
    {
      output := Operations.CreateAwsKmsHierarchicalKeyring(config, input);
      History.CreateAwsKmsHierarchicalKeyring := History.CreateAwsKmsHierarchicalKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateMultiKeyringEnsuresPublicly(input: CreateMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateMultiKeyringEnsuresPublicly(input, output)
    }

    method CreateMultiKeyring(input: CreateMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.generator.Some? ==> input.generator.value.ValidState() && input.generator.value.Modifies !! {History}) && forall i: IKeyring {:trigger i.Modifies} {:trigger i.ValidState()} {:trigger i in input.childKeyrings} | i in input.childKeyrings :: i.ValidState() && i.Modifies !! {History}
      modifies Modifies - {History}, if input.generator.Some? then input.generator.value.Modifies else {}, set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m, History`CreateMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - (if input.generator.Some? then input.generator.value.Modifies else {}) - set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m))
      ensures CreateMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateMultiKeyring == old(History.CreateMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.generator.Some? then input.generator.value.Modifies else {}, set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m
    {
      output := Operations.CreateMultiKeyring(config, input);
      History.CreateMultiKeyring := History.CreateMultiKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateRawAesKeyringEnsuresPublicly(input: CreateRawAesKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateRawAesKeyringEnsuresPublicly(input, output)
    }

    method CreateRawAesKeyring(input: CreateRawAesKeyringInput) returns (output: Result<IKeyring, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateRawAesKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateRawAesKeyringEnsuresPublicly(input, output)
      ensures History.CreateRawAesKeyring == old(History.CreateRawAesKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateRawAesKeyring(config, input);
      History.CreateRawAesKeyring := History.CreateRawAesKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateRawRsaKeyringEnsuresPublicly(input: CreateRawRsaKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateRawRsaKeyringEnsuresPublicly(input, output)
    }

    method CreateRawRsaKeyring(input: CreateRawRsaKeyringInput) returns (output: Result<IKeyring, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateRawRsaKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateRawRsaKeyringEnsuresPublicly(input, output)
      ensures History.CreateRawRsaKeyring == old(History.CreateRawRsaKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateRawRsaKeyring(config, input);
      History.CreateRawRsaKeyring := History.CreateRawRsaKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsRsaKeyringEnsuresPublicly(input: CreateAwsKmsRsaKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsRsaKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsRsaKeyring(input: CreateAwsKmsRsaKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.kmsClient.Some? ==> input.kmsClient.value.ValidState() && input.kmsClient.value.Modifies !! {History})
      modifies Modifies - {History}, if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}, History`CreateAwsKmsRsaKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}))
      ensures CreateAwsKmsRsaKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsRsaKeyring == old(History.CreateAwsKmsRsaKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}
    {
      output := Operations.CreateAwsKmsRsaKeyring(config, input);
      History.CreateAwsKmsRsaKeyring := History.CreateAwsKmsRsaKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input: CreateDefaultCryptographicMaterialsManagerInput, output: Result<ICryptographicMaterialsManager, Error>)
      decreases input, output
    {
      Operations.CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input, output)
    }

    method CreateDefaultCryptographicMaterialsManager(input: CreateDefaultCryptographicMaterialsManagerInput) returns (output: Result<ICryptographicMaterialsManager, Error>)
      requires ValidState() && input.keyring.ValidState() && input.keyring.Modifies !! {History}
      modifies Modifies - {History}, input.keyring.Modifies, History`CreateDefaultCryptographicMaterialsManager
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.keyring.Modifies))
      ensures CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input, output)
      ensures History.CreateDefaultCryptographicMaterialsManager == old(History.CreateDefaultCryptographicMaterialsManager) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.keyring.Modifies
    {
      output := Operations.CreateDefaultCryptographicMaterialsManager(config, input);
      History.CreateDefaultCryptographicMaterialsManager := History.CreateDefaultCryptographicMaterialsManager + [DafnyCallEvent(input, output)];
    }

    predicate CreateRequiredEncryptionContextCMMEnsuresPublicly(input: CreateRequiredEncryptionContextCMMInput, output: Result<ICryptographicMaterialsManager, Error>)
      decreases input, output
    {
      Operations.CreateRequiredEncryptionContextCMMEnsuresPublicly(input, output)
    }

    method CreateRequiredEncryptionContextCMM(input: CreateRequiredEncryptionContextCMMInput) returns (output: Result<ICryptographicMaterialsManager, Error>)
      requires ValidState() && (input.underlyingCMM.Some? ==> input.underlyingCMM.value.ValidState() && input.underlyingCMM.value.Modifies !! {History}) && (input.keyring.Some? ==> input.keyring.value.ValidState() && input.keyring.value.Modifies !! {History})
      modifies Modifies - {History}, if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}, History`CreateRequiredEncryptionContextCMM
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - (if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}) - if input.keyring.Some? then input.keyring.value.Modifies else {}))
      ensures CreateRequiredEncryptionContextCMMEnsuresPublicly(input, output)
      ensures History.CreateRequiredEncryptionContextCMM == old(History.CreateRequiredEncryptionContextCMM) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}
    {
      output := Operations.CreateRequiredEncryptionContextCMM(config, input);
      History.CreateRequiredEncryptionContextCMM := History.CreateRequiredEncryptionContextCMM + [DafnyCallEvent(input, output)];
    }

    predicate CreateCryptographicMaterialsCacheEnsuresPublicly(input: CreateCryptographicMaterialsCacheInput, output: Result<ICryptographicMaterialsCache, Error>)
      decreases input, output
    {
      Operations.CreateCryptographicMaterialsCacheEnsuresPublicly(input, output)
    }

    method CreateCryptographicMaterialsCache(input: CreateCryptographicMaterialsCacheInput) returns (output: Result<ICryptographicMaterialsCache, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateCryptographicMaterialsCache
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateCryptographicMaterialsCacheEnsuresPublicly(input, output)
      ensures History.CreateCryptographicMaterialsCache == old(History.CreateCryptographicMaterialsCache) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateCryptographicMaterialsCache(config, input);
      History.CreateCryptographicMaterialsCache := History.CreateCryptographicMaterialsCache + [DafnyCallEvent(input, output)];
    }

    predicate CreateDefaultClientSupplierEnsuresPublicly(input: CreateDefaultClientSupplierInput, output: Result<IClientSupplier, Error>)
      decreases input, output
    {
      Operations.CreateDefaultClientSupplierEnsuresPublicly(input, output)
    }

    method CreateDefaultClientSupplier(input: CreateDefaultClientSupplierInput) returns (output: Result<IClientSupplier, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateDefaultClientSupplier
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateDefaultClientSupplierEnsuresPublicly(input, output)
      ensures History.CreateDefaultClientSupplier == old(History.CreateDefaultClientSupplier) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateDefaultClientSupplier(config, input);
      History.CreateDefaultClientSupplier := History.CreateDefaultClientSupplier + [DafnyCallEvent(input, output)];
    }

    function method InitializeEncryptionMaterials(input: InitializeEncryptionMaterialsInput): (output: Result<EncryptionMaterials, Error>)
      decreases input
    {
      Operations.InitializeEncryptionMaterials(config, input)
    }

    function method InitializeDecryptionMaterials(input: InitializeDecryptionMaterialsInput): (output: Result<DecryptionMaterials, Error>)
      decreases input
    {
      Operations.InitializeDecryptionMaterials(config, input)
    }

    function method ValidEncryptionMaterialsTransition(input: ValidEncryptionMaterialsTransitionInput): (output: Result<(), Error>)
      decreases input
    {
      Operations.ValidEncryptionMaterialsTransition(config, input)
    }

    function method ValidDecryptionMaterialsTransition(input: ValidDecryptionMaterialsTransitionInput): (output: Result<(), Error>)
      decreases input
    {
      Operations.ValidDecryptionMaterialsTransition(config, input)
    }

    function method EncryptionMaterialsHasPlaintextDataKey(input: EncryptionMaterials): (output: Result<(), Error>)
      decreases input
    {
      Operations.EncryptionMaterialsHasPlaintextDataKey(config, input)
    }

    function method DecryptionMaterialsWithPlaintextDataKey(input: DecryptionMaterials): (output: Result<(), Error>)
      decreases input
    {
      Operations.DecryptionMaterialsWithPlaintextDataKey(config, input)
    }

    function method GetAlgorithmSuiteInfo(input: seq<uint8>): (output: Result<AlgorithmSuiteInfo, Error>)
      decreases input
    {
      Operations.GetAlgorithmSuiteInfo(config, input)
    }

    function method ValidAlgorithmSuiteInfo(input: AlgorithmSuiteInfo): (output: Result<(), Error>)
      decreases input
    {
      Operations.ValidAlgorithmSuiteInfo(config, input)
    }

    function method ValidateCommitmentPolicyOnEncrypt(input: ValidateCommitmentPolicyOnEncryptInput): (output: Result<(), Error>)
      decreases input
    {
      Operations.ValidateCommitmentPolicyOnEncrypt(config, input)
    }

    function method ValidateCommitmentPolicyOnDecrypt(input: ValidateCommitmentPolicyOnDecryptInput): (output: Result<(), Error>)
      decreases input
    {
      Operations.ValidateCommitmentPolicyOnDecrypt(config, input)
    }
  }

  function method DefaultMaterialProvidersConfig(): MaterialProvidersConfig

  method MaterialProviders(config: MaterialProvidersConfig := DefaultMaterialProvidersConfig()) returns (res: Result<MaterialProvidersClient, Error>)
    ensures res.Success? ==> fresh(res.value) && fresh(res.value.Modifies) && fresh(res.value.History) && res.value.ValidState()
    decreases config
}

abstract module AbstractAwsCryptographyMaterialProvidersOperations {

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyMaterialProvidersTypes
  type InternalConfig

  predicate ValidInternalConfig?(config: InternalConfig)

  function ModifiesInternalConfig(config: InternalConfig): set<object>

  predicate CreateAwsKmsKeyringEnsuresPublicly(input: CreateAwsKmsKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateAwsKmsKeyring(config: InternalConfig, input: CreateAwsKmsKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && input.kmsClient.ValidState()
    modifies ModifiesInternalConfig(config), input.kmsClient.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - input.kmsClient.Modifies))
    ensures CreateAwsKmsKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.kmsClient.Modifies

  predicate CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input: CreateAwsKmsDiscoveryKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateAwsKmsDiscoveryKeyring(config: InternalConfig, input: CreateAwsKmsDiscoveryKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && input.kmsClient.ValidState()
    modifies ModifiesInternalConfig(config), input.kmsClient.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - input.kmsClient.Modifies))
    ensures CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.kmsClient.Modifies

  predicate CreateAwsKmsMultiKeyringEnsuresPublicly(input: CreateAwsKmsMultiKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateAwsKmsMultiKeyring(config: InternalConfig, input: CreateAwsKmsMultiKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.clientSupplier.Some? ==> true && input.clientSupplier.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
    ensures CreateAwsKmsMultiKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}

  predicate CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input: CreateAwsKmsDiscoveryMultiKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateAwsKmsDiscoveryMultiKeyring(config: InternalConfig, input: CreateAwsKmsDiscoveryMultiKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.clientSupplier.Some? ==> true && input.clientSupplier.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
    ensures CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}

  predicate CreateAwsKmsMrkKeyringEnsuresPublicly(input: CreateAwsKmsMrkKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateAwsKmsMrkKeyring(config: InternalConfig, input: CreateAwsKmsMrkKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && input.kmsClient.ValidState()
    modifies ModifiesInternalConfig(config), input.kmsClient.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - input.kmsClient.Modifies))
    ensures CreateAwsKmsMrkKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.kmsClient.Modifies

  predicate CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input: CreateAwsKmsMrkMultiKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateAwsKmsMrkMultiKeyring(config: InternalConfig, input: CreateAwsKmsMrkMultiKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.clientSupplier.Some? ==> true && input.clientSupplier.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
    ensures CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}

  predicate CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input: CreateAwsKmsMrkDiscoveryKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateAwsKmsMrkDiscoveryKeyring(config: InternalConfig, input: CreateAwsKmsMrkDiscoveryKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && input.kmsClient.ValidState()
    modifies ModifiesInternalConfig(config), input.kmsClient.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - input.kmsClient.Modifies))
    ensures CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.kmsClient.Modifies

  predicate CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input: CreateAwsKmsMrkDiscoveryMultiKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateAwsKmsMrkDiscoveryMultiKeyring(config: InternalConfig, input: CreateAwsKmsMrkDiscoveryMultiKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.clientSupplier.Some? ==> true && input.clientSupplier.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
    ensures CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}

  predicate CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input: CreateAwsKmsHierarchicalKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateAwsKmsHierarchicalKeyring(config: InternalConfig, input: CreateAwsKmsHierarchicalKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.branchKeyIdSupplier.Some? ==> true && input.branchKeyIdSupplier.value.ValidState()) && input.keyStore.ValidState()
    modifies ModifiesInternalConfig(config), if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}, input.keyStore.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - (if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}) - input.keyStore.Modifies))
    ensures CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}, input.keyStore.Modifies

  predicate CreateMultiKeyringEnsuresPublicly(input: CreateMultiKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateMultiKeyring(config: InternalConfig, input: CreateMultiKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.generator.Some? ==> true && input.generator.value.ValidState()) && forall i: IKeyring {:trigger i.ValidState()} {:trigger i in input.childKeyrings} | i in input.childKeyrings :: i.ValidState()
    modifies ModifiesInternalConfig(config), if input.generator.Some? then input.generator.value.Modifies else {}, set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - (if input.generator.Some? then input.generator.value.Modifies else {}) - set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m))
    ensures CreateMultiKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.generator.Some? then input.generator.value.Modifies else {}, set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m

  predicate CreateRawAesKeyringEnsuresPublicly(input: CreateRawAesKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateRawAesKeyring(config: InternalConfig, input: CreateRawAesKeyringInput) returns (output: Result<IKeyring, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config)))
    ensures CreateRawAesKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate CreateRawRsaKeyringEnsuresPublicly(input: CreateRawRsaKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateRawRsaKeyring(config: InternalConfig, input: CreateRawRsaKeyringInput) returns (output: Result<IKeyring, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config)))
    ensures CreateRawRsaKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate CreateAwsKmsRsaKeyringEnsuresPublicly(input: CreateAwsKmsRsaKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateAwsKmsRsaKeyring(config: InternalConfig, input: CreateAwsKmsRsaKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.kmsClient.Some? ==> true && input.kmsClient.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}))
    ensures CreateAwsKmsRsaKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}

  predicate CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input: CreateDefaultCryptographicMaterialsManagerInput, output: Result<ICryptographicMaterialsManager, Error>)
    decreases input, output

  method CreateDefaultCryptographicMaterialsManager(config: InternalConfig, input: CreateDefaultCryptographicMaterialsManagerInput) returns (output: Result<ICryptographicMaterialsManager, Error>)
    requires ValidInternalConfig?(config) && input.keyring.ValidState()
    modifies ModifiesInternalConfig(config), input.keyring.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - input.keyring.Modifies))
    ensures CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.keyring.Modifies

  predicate CreateRequiredEncryptionContextCMMEnsuresPublicly(input: CreateRequiredEncryptionContextCMMInput, output: Result<ICryptographicMaterialsManager, Error>)
    decreases input, output

  method CreateRequiredEncryptionContextCMM(config: InternalConfig, input: CreateRequiredEncryptionContextCMMInput) returns (output: Result<ICryptographicMaterialsManager, Error>)
    requires ValidInternalConfig?(config) && (input.underlyingCMM.Some? ==> true && input.underlyingCMM.value.ValidState()) && (input.keyring.Some? ==> true && input.keyring.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - (if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}) - if input.keyring.Some? then input.keyring.value.Modifies else {}))
    ensures CreateRequiredEncryptionContextCMMEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}

  predicate CreateCryptographicMaterialsCacheEnsuresPublicly(input: CreateCryptographicMaterialsCacheInput, output: Result<ICryptographicMaterialsCache, Error>)
    decreases input, output

  method CreateCryptographicMaterialsCache(config: InternalConfig, input: CreateCryptographicMaterialsCacheInput) returns (output: Result<ICryptographicMaterialsCache, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config)))
    ensures CreateCryptographicMaterialsCacheEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate CreateDefaultClientSupplierEnsuresPublicly(input: CreateDefaultClientSupplierInput, output: Result<IClientSupplier, Error>)
    decreases input, output

  method CreateDefaultClientSupplier(config: InternalConfig, input: CreateDefaultClientSupplierInput) returns (output: Result<IClientSupplier, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config)))
    ensures CreateDefaultClientSupplierEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  function method InitializeEncryptionMaterials(config: InternalConfig, input: InitializeEncryptionMaterialsInput): (output: Result<EncryptionMaterials, Error>)
    decreases input

  function method InitializeDecryptionMaterials(config: InternalConfig, input: InitializeDecryptionMaterialsInput): (output: Result<DecryptionMaterials, Error>)
    decreases input

  function method ValidEncryptionMaterialsTransition(config: InternalConfig, input: ValidEncryptionMaterialsTransitionInput): (output: Result<(), Error>)
    decreases input

  function method ValidDecryptionMaterialsTransition(config: InternalConfig, input: ValidDecryptionMaterialsTransitionInput): (output: Result<(), Error>)
    decreases input

  function method EncryptionMaterialsHasPlaintextDataKey(config: InternalConfig, input: EncryptionMaterials): (output: Result<(), Error>)
    decreases input

  function method DecryptionMaterialsWithPlaintextDataKey(config: InternalConfig, input: DecryptionMaterials): (output: Result<(), Error>)
    decreases input

  function method GetAlgorithmSuiteInfo(config: InternalConfig, input: seq<uint8>): (output: Result<AlgorithmSuiteInfo, Error>)
    decreases input

  function method ValidAlgorithmSuiteInfo(config: InternalConfig, input: AlgorithmSuiteInfo): (output: Result<(), Error>)
    decreases input

  function method ValidateCommitmentPolicyOnEncrypt(config: InternalConfig, input: ValidateCommitmentPolicyOnEncryptInput): (output: Result<(), Error>)
    decreases input

  function method ValidateCommitmentPolicyOnDecrypt(config: InternalConfig, input: ValidateCommitmentPolicyOnDecryptInput): (output: Result<(), Error>)
    decreases input
}

module {:extern ""software.amazon.cryptography.keystore.internaldafny""} KeyStore refines AbstractAwsCryptographyKeyStoreService {

  import opened AwsArnParsing

  import opened AwsKmsUtils

  import Operations = AwsCryptographyKeyStoreOperations

  import KMSOperations = Com.Amazonaws.Kms

  import DDBOperations = Com.Amazonaws.Dynamodb

  import KMS = ComAmazonawsKmsTypes

  import DDB = ComAmazonawsDynamodbTypes

  import UUID
  class KeyStoreClient ...  {
    predicate {:vcs_split_on_every_assert} {:rlimit 3000} ValidState()
      ensures ValidState() ==> Operations.ValidInternalConfig?(config) && History !in Operations.ModifiesInternalConfig(config) && Modifies == Operations.ModifiesInternalConfig(config) + {History}
    {
      Operations.ValidInternalConfig?(config) &&
      History !in Operations.ModifiesInternalConfig(config) &&
      Modifies == Operations.ModifiesInternalConfig(config) + {History}
    }

    constructor (config: Operations.InternalConfig)
      requires Operations.ValidInternalConfig?(config)
      ensures ValidState() && fresh(History) && this.config == config
      decreases config
    {
      this.config := config;
      History := new IKeyStoreClientCallHistory();
      Modifies := Operations.ModifiesInternalConfig(config) + {History};
    }

    const config: Operations.InternalConfig

    predicate GetKeyStoreInfoEnsuresPublicly(output: Result<GetKeyStoreInfoOutput, Error>)
      decreases output
    {
      Operations.GetKeyStoreInfoEnsuresPublicly(output)
    }

    method GetKeyStoreInfo() returns (output: Result<GetKeyStoreInfoOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetKeyStoreInfo
      ensures true && ValidState()
      ensures GetKeyStoreInfoEnsuresPublicly(output)
      ensures History.GetKeyStoreInfo == old(History.GetKeyStoreInfo) + [DafnyCallEvent((), output)]
      decreases Modifies - {History}
    {
      output := Operations.GetKeyStoreInfo(config);
      History.GetKeyStoreInfo := History.GetKeyStoreInfo + [DafnyCallEvent((), output)];
    }

    predicate CreateKeyStoreEnsuresPublicly(input: CreateKeyStoreInput, output: Result<CreateKeyStoreOutput, Error>)
      decreases input, output
    {
      Operations.CreateKeyStoreEnsuresPublicly(input, output)
    }

    method CreateKeyStore(input: CreateKeyStoreInput) returns (output: Result<CreateKeyStoreOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateKeyStore
      ensures true && ValidState()
      ensures CreateKeyStoreEnsuresPublicly(input, output)
      ensures History.CreateKeyStore == old(History.CreateKeyStore) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateKeyStore(config, input);
      History.CreateKeyStore := History.CreateKeyStore + [DafnyCallEvent(input, output)];
    }

    predicate CreateKeyEnsuresPublicly(input: CreateKeyInput, output: Result<CreateKeyOutput, Error>)
      decreases input, output
    {
      Operations.CreateKeyEnsuresPublicly(input, output)
    }

    method CreateKey(input: CreateKeyInput) returns (output: Result<CreateKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateKey
      ensures true && ValidState()
      ensures CreateKeyEnsuresPublicly(input, output)
      ensures History.CreateKey == old(History.CreateKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateKey(config, input);
      History.CreateKey := History.CreateKey + [DafnyCallEvent(input, output)];
    }

    predicate VersionKeyEnsuresPublicly(input: VersionKeyInput, output: Result<VersionKeyOutput, Error>)
      decreases input, output
    {
      Operations.VersionKeyEnsuresPublicly(input, output)
    }

    method VersionKey(input: VersionKeyInput) returns (output: Result<VersionKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`VersionKey
      ensures true && ValidState()
      ensures VersionKeyEnsuresPublicly(input, output)
      ensures History.VersionKey == old(History.VersionKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.VersionKey(config, input);
      History.VersionKey := History.VersionKey + [DafnyCallEvent(input, output)];
    }

    predicate GetActiveBranchKeyEnsuresPublicly(input: GetActiveBranchKeyInput, output: Result<GetActiveBranchKeyOutput, Error>)
      decreases input, output
    {
      Operations.GetActiveBranchKeyEnsuresPublicly(input, output)
    }

    method GetActiveBranchKey(input: GetActiveBranchKeyInput) returns (output: Result<GetActiveBranchKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetActiveBranchKey
      ensures true && ValidState()
      ensures GetActiveBranchKeyEnsuresPublicly(input, output)
      ensures History.GetActiveBranchKey == old(History.GetActiveBranchKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GetActiveBranchKey(config, input);
      History.GetActiveBranchKey := History.GetActiveBranchKey + [DafnyCallEvent(input, output)];
    }

    predicate GetBranchKeyVersionEnsuresPublicly(input: GetBranchKeyVersionInput, output: Result<GetBranchKeyVersionOutput, Error>)
      decreases input, output
    {
      Operations.GetBranchKeyVersionEnsuresPublicly(input, output)
    }

    method GetBranchKeyVersion(input: GetBranchKeyVersionInput) returns (output: Result<GetBranchKeyVersionOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetBranchKeyVersion
      ensures true && ValidState()
      ensures GetBranchKeyVersionEnsuresPublicly(input, output)
      ensures History.GetBranchKeyVersion == old(History.GetBranchKeyVersion) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GetBranchKeyVersion(config, input);
      History.GetBranchKeyVersion := History.GetBranchKeyVersion + [DafnyCallEvent(input, output)];
    }

    predicate GetBeaconKeyEnsuresPublicly(input: GetBeaconKeyInput, output: Result<GetBeaconKeyOutput, Error>)
      decreases input, output
    {
      Operations.GetBeaconKeyEnsuresPublicly(input, output)
    }

    method GetBeaconKey(input: GetBeaconKeyInput) returns (output: Result<GetBeaconKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetBeaconKey
      ensures true && ValidState()
      ensures GetBeaconKeyEnsuresPublicly(input, output)
      ensures History.GetBeaconKey == old(History.GetBeaconKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GetBeaconKey(config, input);
      History.GetBeaconKey := History.GetBeaconKey + [DafnyCallEvent(input, output)];
    }
  }

  function method DefaultKeyStoreConfig(): KeyStoreConfig
  {
    KeyStoreConfig(ddbTableName := ""None"", kmsConfiguration := KMSConfiguration.kmsKeyArn(""1234abcd-12ab-34cd-56ef-1234567890ab""), logicalKeyStoreName := ""None"", id := None, grantTokens := None, kmsClient := None, ddbClient := None)
  }

  method KeyStore(config: KeyStoreConfig := DefaultKeyStoreConfig()) returns (res: Result<KeyStoreClient, Error>)
    requires config.ddbClient.Some? ==> config.ddbClient.value.ValidState()
    requires config.kmsClient.Some? ==> config.kmsClient.value.ValidState()
    modifies if config.ddbClient.Some? then config.ddbClient.value.Modifies else {}, if config.kmsClient.Some? then config.kmsClient.value.Modifies else {}
    ensures res.Success? ==> fresh(res.value) && fresh(res.value.Modifies - (if config.ddbClient.Some? then config.ddbClient.value.Modifies else {}) - if config.kmsClient.Some? then config.kmsClient.value.Modifies else {}) && fresh(res.value.History) && res.value.ValidState()
    ensures config.ddbClient.Some? ==> config.ddbClient.value.ValidState()
    ensures config.kmsClient.Some? ==> config.kmsClient.value.ValidState()
    ensures res.Success? ==> KMS.IsValid_KeyIdType(res.value.config.kmsConfiguration.kmsKeyArn) && DDB.IsValid_TableName(config.ddbTableName) && GetValidGrantTokens(config.grantTokens).Success? && config.kmsClient.Some? ==> res.value.config.kmsClient == config.kmsClient.value && config.ddbClient.Some? ==> res.value.config.ddbClient == config.ddbClient.value && res.value.config.kmsClient.ValidState() && res.value.config.ddbClient.ValidState()
    ensures !DDB.IsValid_TableName(config.ddbTableName) && !KMS.IsValid_KeyIdType(config.kmsConfiguration.kmsKeyArn) && ParseAwsKmsArn(config.kmsConfiguration.kmsKeyArn).Failure? ==> res.Failure?
    decreases config
  {
    :- Need(KMS.IsValid_KeyIdType(config.kmsConfiguration.kmsKeyArn) && ParseAwsKmsArn(config.kmsConfiguration.kmsKeyArn).Success?, Types.KeyStoreException(message := ""Invalid AWS KMS Key Arn""));
    var grantTokens := GetValidGrantTokens(config.grantTokens);
    :- Need(true && grantTokens.Success?, Types.KeyStoreException(message := ""CreateKey received invalid grant tokens""));
    var keyStoreId;
    if config.id.Some? {
      keyStoreId := config.id.value;
    } else {
      var maybeUuid := UUID.GenerateUUID();
      var uuid :- maybeUuid.MapFailure((e: string) => Types.KeyStoreException(message := e));
      keyStoreId := uuid;
    }
    var kmsClient: KMS.IKMSClient;
    var ddbClient: DDB.IDynamoDBClient;
    var keyArn := ParseAwsKmsIdentifier(config.kmsConfiguration.kmsKeyArn);
    var kmsRegion := GetRegion(keyArn.value);
    if config.kmsClient.None? {
      var maybeKmsClient := KMSOperations.KMSClientForRegion(kmsRegion.value);
      kmsClient :- maybeKmsClient.MapFailure((e: Error) => Types.ComAmazonawsKms(ComAmazonawsKms := e));
    } else {
      kmsClient := config.kmsClient.value;
    }
    if config.ddbClient.None? {
      var maybeDdbClient := DDBOperations.DDBClientForRegion(kmsRegion.value);
      ddbClient :- maybeDdbClient.MapFailure((e: Error) => Types.ComAmazonawsDynamodb(ComAmazonawsDynamodb := e));
    } else {
      ddbClient := config.ddbClient.value;
      assume {:axiom} ddbClient.Modifies !! kmsClient.Modifies;
    }
    :- Need(DDB.IsValid_TableName(config.ddbTableName), Types.KeyStoreException(message := ""Invalid Amazon DynamoDB Table Name""));
    var client := new KeyStoreClient(Operations.Config(id := keyStoreId, ddbTableName := config.ddbTableName, logicalKeyStoreName := config.logicalKeyStoreName, kmsConfiguration := config.kmsConfiguration, grantTokens := grantTokens.value, kmsClient := kmsClient, ddbClient := ddbClient));
    return Success(client);
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyKeyStoreTypes
}

module {:extern ""software.amazon.cryptography.keystore.internaldafny.types""} AwsCryptographyKeyStoreTypes {

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import ComAmazonawsDynamodbTypes

  import ComAmazonawsKmsTypes
  datatype DafnyCallEvent<I, O> = DafnyCallEvent(input: I, output: O)

  datatype BeaconKeyMaterials = BeaconKeyMaterials(nameonly beaconKeyIdentifier: string, nameonly encryptionContext: EncryptionContext, nameonly beaconKey: Option<Secret>, nameonly hmacKeys: Option<HmacKeyMap>)

  datatype BranchKeyMaterials = BranchKeyMaterials(nameonly branchKeyIdentifier: string, nameonly branchKeyVersion: Utf8Bytes, nameonly encryptionContext: EncryptionContext, nameonly branchKey: Secret)

  datatype CreateKeyInput = CreateKeyInput(nameonly branchKeyIdentifier: Option<string>, nameonly encryptionContext: Option<EncryptionContext>)

  datatype CreateKeyOutput = CreateKeyOutput(nameonly branchKeyIdentifier: string)

  datatype CreateKeyStoreInput = CreateKeyStoreInput

  datatype CreateKeyStoreOutput = CreateKeyStoreOutput(nameonly tableArn: ComAmazonawsDynamodbTypes.TableArn)

  type EncryptionContext = map<Utf8Bytes, Utf8Bytes>

  datatype GetActiveBranchKeyInput = GetActiveBranchKeyInput(nameonly branchKeyIdentifier: string)

  datatype GetActiveBranchKeyOutput = GetActiveBranchKeyOutput(nameonly branchKeyMaterials: BranchKeyMaterials)

  datatype GetBeaconKeyInput = GetBeaconKeyInput(nameonly branchKeyIdentifier: string)

  datatype GetBeaconKeyOutput = GetBeaconKeyOutput(nameonly beaconKeyMaterials: BeaconKeyMaterials)

  datatype GetBranchKeyVersionInput = GetBranchKeyVersionInput(nameonly branchKeyIdentifier: string, nameonly branchKeyVersion: string)

  datatype GetBranchKeyVersionOutput = GetBranchKeyVersionOutput(nameonly branchKeyMaterials: BranchKeyMaterials)

  datatype GetKeyStoreInfoOutput = GetKeyStoreInfoOutput(nameonly keyStoreId: string, nameonly keyStoreName: ComAmazonawsDynamodbTypes.TableName, nameonly logicalKeyStoreName: string, nameonly grantTokens: GrantTokenList, nameonly kmsConfiguration: KMSConfiguration)

  type GrantTokenList = seq<string>

  type HmacKeyMap = map<string, Secret>

  class IKeyStoreClientCallHistory {
    ghost constructor ()
    {
      GetKeyStoreInfo := [];
      CreateKeyStore := [];
      CreateKey := [];
      VersionKey := [];
      GetActiveBranchKey := [];
      GetBranchKeyVersion := [];
      GetBeaconKey := [];
    }

    ghost var GetKeyStoreInfo: seq<DafnyCallEvent<(), Result<GetKeyStoreInfoOutput, Error>>>
    ghost var CreateKeyStore: seq<DafnyCallEvent<CreateKeyStoreInput, Result<CreateKeyStoreOutput, Error>>>
    ghost var CreateKey: seq<DafnyCallEvent<CreateKeyInput, Result<CreateKeyOutput, Error>>>
    ghost var VersionKey: seq<DafnyCallEvent<VersionKeyInput, Result<VersionKeyOutput, Error>>>
    ghost var GetActiveBranchKey: seq<DafnyCallEvent<GetActiveBranchKeyInput, Result<GetActiveBranchKeyOutput, Error>>>
    ghost var GetBranchKeyVersion: seq<DafnyCallEvent<GetBranchKeyVersionInput, Result<GetBranchKeyVersionOutput, Error>>>
    ghost var GetBeaconKey: seq<DafnyCallEvent<GetBeaconKeyInput, Result<GetBeaconKeyOutput, Error>>>
  }

  trait {:termination false} IKeyStoreClient {
    ghost const Modifies: set<object>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies

    ghost const History: IKeyStoreClientCallHistory

    predicate GetKeyStoreInfoEnsuresPublicly(output: Result<GetKeyStoreInfoOutput, Error>)
      decreases output

    method GetKeyStoreInfo() returns (output: Result<GetKeyStoreInfoOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetKeyStoreInfo
      ensures true && ValidState()
      ensures GetKeyStoreInfoEnsuresPublicly(output)
      ensures History.GetKeyStoreInfo == old(History.GetKeyStoreInfo) + [DafnyCallEvent((), output)]
      decreases Modifies - {History}

    predicate CreateKeyStoreEnsuresPublicly(input: CreateKeyStoreInput, output: Result<CreateKeyStoreOutput, Error>)
      decreases input, output

    method CreateKeyStore(input: CreateKeyStoreInput) returns (output: Result<CreateKeyStoreOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateKeyStore
      ensures true && ValidState()
      ensures CreateKeyStoreEnsuresPublicly(input, output)
      ensures History.CreateKeyStore == old(History.CreateKeyStore) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate CreateKeyEnsuresPublicly(input: CreateKeyInput, output: Result<CreateKeyOutput, Error>)
      decreases input, output

    method CreateKey(input: CreateKeyInput) returns (output: Result<CreateKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateKey
      ensures true && ValidState()
      ensures CreateKeyEnsuresPublicly(input, output)
      ensures History.CreateKey == old(History.CreateKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate VersionKeyEnsuresPublicly(input: VersionKeyInput, output: Result<VersionKeyOutput, Error>)
      decreases input, output

    method VersionKey(input: VersionKeyInput) returns (output: Result<VersionKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`VersionKey
      ensures true && ValidState()
      ensures VersionKeyEnsuresPublicly(input, output)
      ensures History.VersionKey == old(History.VersionKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GetActiveBranchKeyEnsuresPublicly(input: GetActiveBranchKeyInput, output: Result<GetActiveBranchKeyOutput, Error>)
      decreases input, output

    method GetActiveBranchKey(input: GetActiveBranchKeyInput) returns (output: Result<GetActiveBranchKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetActiveBranchKey
      ensures true && ValidState()
      ensures GetActiveBranchKeyEnsuresPublicly(input, output)
      ensures History.GetActiveBranchKey == old(History.GetActiveBranchKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GetBranchKeyVersionEnsuresPublicly(input: GetBranchKeyVersionInput, output: Result<GetBranchKeyVersionOutput, Error>)
      decreases input, output

    method GetBranchKeyVersion(input: GetBranchKeyVersionInput) returns (output: Result<GetBranchKeyVersionOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetBranchKeyVersion
      ensures true && ValidState()
      ensures GetBranchKeyVersionEnsuresPublicly(input, output)
      ensures History.GetBranchKeyVersion == old(History.GetBranchKeyVersion) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GetBeaconKeyEnsuresPublicly(input: GetBeaconKeyInput, output: Result<GetBeaconKeyOutput, Error>)
      decreases input, output

    method GetBeaconKey(input: GetBeaconKeyInput) returns (output: Result<GetBeaconKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetBeaconKey
      ensures true && ValidState()
      ensures GetBeaconKeyEnsuresPublicly(input, output)
      ensures History.GetBeaconKey == old(History.GetBeaconKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
  }

  datatype KeyStoreConfig = KeyStoreConfig(nameonly ddbTableName: ComAmazonawsDynamodbTypes.TableName, nameonly kmsConfiguration: KMSConfiguration, nameonly logicalKeyStoreName: string, nameonly id: Option<string>, nameonly grantTokens: Option<GrantTokenList>, nameonly ddbClient: Option<ComAmazonawsDynamodbTypes.IDynamoDBClient>, nameonly kmsClient: Option<ComAmazonawsKmsTypes.IKMSClient>)

  datatype KMSConfiguration = kmsKeyArn(kmsKeyArn: ComAmazonawsKmsTypes.KeyIdType)

  type Secret = seq<uint8>

  type Utf8Bytes = ValidUTF8Bytes

  datatype VersionKeyInput = VersionKeyInput(nameonly branchKeyIdentifier: string)

  datatype VersionKeyOutput = VersionKeyOutput

  datatype Error = KeyStoreException(nameonly message: string) | ComAmazonawsDynamodb(ComAmazonawsDynamodb: ComAmazonawsDynamodbTypes.Error) | ComAmazonawsKms(ComAmazonawsKms: ComAmazonawsKmsTypes.Error) | CollectionOfErrors(list: seq<Error>, nameonly message: string) | Opaque(obj: object)

  type OpaqueError = e: Error
    | e.Opaque?
    witness *
}

abstract module AbstractAwsCryptographyKeyStoreService {

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyKeyStoreTypes

  import Operations : AbstractAwsCryptographyKeyStoreOperations
  class KeyStoreClient extends IKeyStoreClient {
    constructor (config: Operations.InternalConfig)
      requires Operations.ValidInternalConfig?(config)
      ensures ValidState() && fresh(History) && this.config == config

    const config: Operations.InternalConfig

    predicate ValidState()
      ensures ValidState() ==> Operations.ValidInternalConfig?(config) && History !in Operations.ModifiesInternalConfig(config) && Modifies == Operations.ModifiesInternalConfig(config) + {History}

    predicate GetKeyStoreInfoEnsuresPublicly(output: Result<GetKeyStoreInfoOutput, Error>)
      decreases output
    {
      Operations.GetKeyStoreInfoEnsuresPublicly(output)
    }

    method GetKeyStoreInfo() returns (output: Result<GetKeyStoreInfoOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetKeyStoreInfo
      ensures true && ValidState()
      ensures GetKeyStoreInfoEnsuresPublicly(output)
      ensures History.GetKeyStoreInfo == old(History.GetKeyStoreInfo) + [DafnyCallEvent((), output)]
      decreases Modifies - {History}
    {
      output := Operations.GetKeyStoreInfo(config);
      History.GetKeyStoreInfo := History.GetKeyStoreInfo + [DafnyCallEvent((), output)];
    }

    predicate CreateKeyStoreEnsuresPublicly(input: CreateKeyStoreInput, output: Result<CreateKeyStoreOutput, Error>)
      decreases input, output
    {
      Operations.CreateKeyStoreEnsuresPublicly(input, output)
    }

    method CreateKeyStore(input: CreateKeyStoreInput) returns (output: Result<CreateKeyStoreOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateKeyStore
      ensures true && ValidState()
      ensures CreateKeyStoreEnsuresPublicly(input, output)
      ensures History.CreateKeyStore == old(History.CreateKeyStore) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateKeyStore(config, input);
      History.CreateKeyStore := History.CreateKeyStore + [DafnyCallEvent(input, output)];
    }

    predicate CreateKeyEnsuresPublicly(input: CreateKeyInput, output: Result<CreateKeyOutput, Error>)
      decreases input, output
    {
      Operations.CreateKeyEnsuresPublicly(input, output)
    }

    method CreateKey(input: CreateKeyInput) returns (output: Result<CreateKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateKey
      ensures true && ValidState()
      ensures CreateKeyEnsuresPublicly(input, output)
      ensures History.CreateKey == old(History.CreateKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateKey(config, input);
      History.CreateKey := History.CreateKey + [DafnyCallEvent(input, output)];
    }

    predicate VersionKeyEnsuresPublicly(input: VersionKeyInput, output: Result<VersionKeyOutput, Error>)
      decreases input, output
    {
      Operations.VersionKeyEnsuresPublicly(input, output)
    }

    method VersionKey(input: VersionKeyInput) returns (output: Result<VersionKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`VersionKey
      ensures true && ValidState()
      ensures VersionKeyEnsuresPublicly(input, output)
      ensures History.VersionKey == old(History.VersionKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.VersionKey(config, input);
      History.VersionKey := History.VersionKey + [DafnyCallEvent(input, output)];
    }

    predicate GetActiveBranchKeyEnsuresPublicly(input: GetActiveBranchKeyInput, output: Result<GetActiveBranchKeyOutput, Error>)
      decreases input, output
    {
      Operations.GetActiveBranchKeyEnsuresPublicly(input, output)
    }

    method GetActiveBranchKey(input: GetActiveBranchKeyInput) returns (output: Result<GetActiveBranchKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetActiveBranchKey
      ensures true && ValidState()
      ensures GetActiveBranchKeyEnsuresPublicly(input, output)
      ensures History.GetActiveBranchKey == old(History.GetActiveBranchKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GetActiveBranchKey(config, input);
      History.GetActiveBranchKey := History.GetActiveBranchKey + [DafnyCallEvent(input, output)];
    }

    predicate GetBranchKeyVersionEnsuresPublicly(input: GetBranchKeyVersionInput, output: Result<GetBranchKeyVersionOutput, Error>)
      decreases input, output
    {
      Operations.GetBranchKeyVersionEnsuresPublicly(input, output)
    }

    method GetBranchKeyVersion(input: GetBranchKeyVersionInput) returns (output: Result<GetBranchKeyVersionOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetBranchKeyVersion
      ensures true && ValidState()
      ensures GetBranchKeyVersionEnsuresPublicly(input, output)
      ensures History.GetBranchKeyVersion == old(History.GetBranchKeyVersion) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GetBranchKeyVersion(config, input);
      History.GetBranchKeyVersion := History.GetBranchKeyVersion + [DafnyCallEvent(input, output)];
    }

    predicate GetBeaconKeyEnsuresPublicly(input: GetBeaconKeyInput, output: Result<GetBeaconKeyOutput, Error>)
      decreases input, output
    {
      Operations.GetBeaconKeyEnsuresPublicly(input, output)
    }

    method GetBeaconKey(input: GetBeaconKeyInput) returns (output: Result<GetBeaconKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetBeaconKey
      ensures true && ValidState()
      ensures GetBeaconKeyEnsuresPublicly(input, output)
      ensures History.GetBeaconKey == old(History.GetBeaconKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GetBeaconKey(config, input);
      History.GetBeaconKey := History.GetBeaconKey + [DafnyCallEvent(input, output)];
    }
  }

  function method DefaultKeyStoreConfig(): KeyStoreConfig

  method KeyStore(config: KeyStoreConfig := DefaultKeyStoreConfig()) returns (res: Result<KeyStoreClient, Error>)
    requires config.ddbClient.Some? ==> config.ddbClient.value.ValidState()
    requires config.kmsClient.Some? ==> config.kmsClient.value.ValidState()
    modifies if config.ddbClient.Some? then config.ddbClient.value.Modifies else {}, if config.kmsClient.Some? then config.kmsClient.value.Modifies else {}
    ensures res.Success? ==> fresh(res.value) && fresh(res.value.Modifies - (if config.ddbClient.Some? then config.ddbClient.value.Modifies else {}) - if config.kmsClient.Some? then config.kmsClient.value.Modifies else {}) && fresh(res.value.History) && res.value.ValidState()
    ensures config.ddbClient.Some? ==> config.ddbClient.value.ValidState()
    ensures config.kmsClient.Some? ==> config.kmsClient.value.ValidState()
    decreases config
}

abstract module AbstractAwsCryptographyKeyStoreOperations {

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyKeyStoreTypes
  type InternalConfig

  predicate ValidInternalConfig?(config: InternalConfig)

  function ModifiesInternalConfig(config: InternalConfig): set<object>

  predicate GetKeyStoreInfoEnsuresPublicly(output: Result<GetKeyStoreInfoOutput, Error>)
    decreases output

  method GetKeyStoreInfo(config: InternalConfig) returns (output: Result<GetKeyStoreInfoOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetKeyStoreInfoEnsuresPublicly(output)
    decreases ModifiesInternalConfig(config)

  predicate CreateKeyStoreEnsuresPublicly(input: CreateKeyStoreInput, output: Result<CreateKeyStoreOutput, Error>)
    decreases input, output

  method CreateKeyStore(config: InternalConfig, input: CreateKeyStoreInput) returns (output: Result<CreateKeyStoreOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures CreateKeyStoreEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate CreateKeyEnsuresPublicly(input: CreateKeyInput, output: Result<CreateKeyOutput, Error>)
    decreases input, output

  method CreateKey(config: InternalConfig, input: CreateKeyInput) returns (output: Result<CreateKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures CreateKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate VersionKeyEnsuresPublicly(input: VersionKeyInput, output: Result<VersionKeyOutput, Error>)
    decreases input, output

  method VersionKey(config: InternalConfig, input: VersionKeyInput) returns (output: Result<VersionKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures VersionKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GetActiveBranchKeyEnsuresPublicly(input: GetActiveBranchKeyInput, output: Result<GetActiveBranchKeyOutput, Error>)
    decreases input, output

  method GetActiveBranchKey(config: InternalConfig, input: GetActiveBranchKeyInput) returns (output: Result<GetActiveBranchKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetActiveBranchKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GetBranchKeyVersionEnsuresPublicly(input: GetBranchKeyVersionInput, output: Result<GetBranchKeyVersionOutput, Error>)
    decreases input, output

  method GetBranchKeyVersion(config: InternalConfig, input: GetBranchKeyVersionInput) returns (output: Result<GetBranchKeyVersionOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetBranchKeyVersionEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GetBeaconKeyEnsuresPublicly(input: GetBeaconKeyInput, output: Result<GetBeaconKeyOutput, Error>)
    decreases input, output

  method GetBeaconKey(config: InternalConfig, input: GetBeaconKeyInput) returns (output: Result<GetBeaconKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetBeaconKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
}

module AwsCryptographyKeyStoreOperations refines AbstractAwsCryptographyKeyStoreOperations {

  import opened AwsArnParsing

  import opened AwsKmsUtils

  import KMS = ComAmazonawsKmsTypes

  import DDB = ComAmazonawsDynamodbTypes

  import MPL = AwsCryptographyMaterialProvidersTypes

  import CreateKeys

  import CreateKeyStoreTable

  import GetKeys

  import UUID

  import Time

  import Structure
  datatype Config = Config(nameonly id: string, nameonly ddbTableName: DDB.TableName, nameonly logicalKeyStoreName: string, nameonly kmsConfiguration: KMSConfiguration, nameonly grantTokens: KMS.GrantTokenList, nameonly kmsClient: ComAmazonawsKmsTypes.IKMSClient, nameonly ddbClient: ComAmazonawsDynamodbTypes.IDynamoDBClient)

  type InternalConfig = Config

  predicate ValidInternalConfig?(config: InternalConfig)
    decreases config
  {
    DDB.IsValid_TableName(config.ddbTableName) &&
    KMS.IsValid_KeyIdType(config.kmsConfiguration.kmsKeyArn) &&
    config.kmsClient.ValidState() &&
    config.ddbClient.ValidState() &&
    config.ddbClient.Modifies !! config.kmsClient.Modifies
  }

  function ModifiesInternalConfig(config: InternalConfig): set<object>
    decreases config
  {
    config.kmsClient.Modifies + config.ddbClient.Modifies
  }

  predicate GetKeyStoreInfoEnsuresPublicly(output: Result<GetKeyStoreInfoOutput, Error>)
    decreases output
  {
    true
  }

  method GetKeyStoreInfo(config: InternalConfig) returns (output: Result<GetKeyStoreInfoOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetKeyStoreInfoEnsuresPublicly(output)
    ensures output.Success? ==> output.value.keyStoreId == config.id && output.value.keyStoreName == config.ddbTableName && output.value.logicalKeyStoreName == config.logicalKeyStoreName && output.value.grantTokens == config.grantTokens && output.value.kmsConfiguration == config.kmsConfiguration
    decreases ModifiesInternalConfig(config)
  {
    output := Success(Types.GetKeyStoreInfoOutput(keyStoreId := config.id, keyStoreName := config.ddbTableName, logicalKeyStoreName := config.logicalKeyStoreName, grantTokens := config.grantTokens, kmsConfiguration := config.kmsConfiguration));
  }

  predicate CreateKeyStoreEnsuresPublicly(input: CreateKeyStoreInput, output: Result<CreateKeyStoreOutput, Error>)
    decreases input, output
  {
    true
  }

  method CreateKeyStore(config: InternalConfig, input: CreateKeyStoreInput) returns (output: Result<CreateKeyStoreOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures CreateKeyStoreEnsuresPublicly(input, output)
    ensures output.Success? ==> AwsArnParsing.ParseAmazonDynamodbTableName(output.value.tableArn).Success? && AwsArnParsing.ParseAmazonDynamodbTableName(output.value.tableArn).value == config.ddbTableName
    decreases ModifiesInternalConfig(config)
  {
    var ddbTableArn :- CreateKeyStoreTable.CreateKeyStoreTable(config.ddbTableName, config.ddbClient);
    var tableName := AwsArnParsing.ParseAmazonDynamodbTableName(ddbTableArn);
    :- Need(tableName.Success? && tableName.value == config.ddbTableName, Types.KeyStoreException(message := ""Configured DDB Table Name does not match parsed Table Name from DDB Table Arn.""));
    output := Success(Types.CreateKeyStoreOutput(tableArn := ddbTableArn));
  }

  predicate CreateKeyEnsuresPublicly(input: CreateKeyInput, output: Result<CreateKeyOutput, Error>)
    decreases input, output
  {
    true
  }

  method CreateKey(config: InternalConfig, input: CreateKeyInput) returns (output: Result<CreateKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures CreateKeyEnsuresPublicly(input, output)
    ensures input.branchKeyIdentifier.Some? && input.encryptionContext.None? ==> output.Failure?
    decreases ModifiesInternalConfig(config)
  {
    :- Need(input.branchKeyIdentifier.Some? ==> input.encryptionContext.Some? && 0 < |input.encryptionContext.value|, Types.KeyStoreException(message := ""Custom branch key id requires custom encryption context.""));
    var branchKeyIdentifier: string;
    if input.branchKeyIdentifier.None? {
      var maybeBranchKeyId := UUID.GenerateUUID();
      branchKeyIdentifier :- maybeBranchKeyId.MapFailure((e: string) => Types.KeyStoreException(message := e));
    } else {
      :- Need(0 < |input.branchKeyIdentifier.value|, Types.KeyStoreException(message := ""Custom branch key id can not be an empty string.""));
      branchKeyIdentifier := input.branchKeyIdentifier.value;
    }
    var timestamp :- Time.GetCurrentTimeStamp().MapFailure((e: string) => Types.KeyStoreException(message := e));
    var maybeBranchKeyVersion := UUID.GenerateUUID();
    var branchKeyVersion :- maybeBranchKeyVersion.MapFailure((e: string) => Types.KeyStoreException(message := e));
    var unwrapEncryptionContext := input.encryptionContext.UnwrapOr(map[]);
    var encodedEncryptionContext := set k: ValidUTF8Bytes {:trigger unwrapEncryptionContext[k]} {:trigger k in unwrapEncryptionContext} | k in unwrapEncryptionContext :: (UTF8.Decode(k), UTF8.Decode(unwrapEncryptionContext[k]), k);
    :- Need(forall i: (Result<string, string>, Result<string, string>, ValidUTF8Bytes) {:trigger i.2} {:trigger i.1} {:trigger i.0} {:trigger i in encodedEncryptionContext} | i in encodedEncryptionContext :: i.0.Success? && i.1.Success? && _default.IsValid_AttributeName(Structure.ENCRYPTION_CONTEXT_PREFIX + i.0.value) && var encoded: Result<ValidUTF8Bytes, string> := UTF8.Encode(i.0.value); encoded.Success? && i.2 == encoded.value, Types.KeyStoreException(message := ""Unable to encode string""));
    output := CreateKeys.CreateBranchAndBeaconKeys(branchKeyIdentifier, map i: (Result<string, string>, Result<string, string>, ValidUTF8Bytes) {:trigger i.1} {:trigger i.0} {:trigger i in encodedEncryptionContext} | i in encodedEncryptionContext :: i.0.value := i.1.value, timestamp, branchKeyVersion, config.ddbTableName, config.logicalKeyStoreName, config.kmsConfiguration, config.grantTokens, config.kmsClient, config.ddbClient);
  }

  predicate VersionKeyEnsuresPublicly(input: VersionKeyInput, output: Result<VersionKeyOutput, Error>)
    decreases input, output
  {
    true
  }

  method VersionKey(config: InternalConfig, input: VersionKeyInput) returns (output: Result<VersionKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures VersionKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    :- Need(0 < |input.branchKeyIdentifier|, Types.KeyStoreException(message := ""Empty string not supported for identifier.""));
    var timestamp :- Time.GetCurrentTimeStamp().MapFailure((e: string) => Types.KeyStoreException(message := e));
    var maybeBranchKeyVersion := UUID.GenerateUUID();
    var branchKeyVersion :- maybeBranchKeyVersion.MapFailure((e: string) => Types.KeyStoreException(message := e));
    output := CreateKeys.VersionActiveBranchKey(input, timestamp, branchKeyVersion, config.ddbTableName, config.logicalKeyStoreName, config.kmsConfiguration, config.grantTokens, config.kmsClient, config.ddbClient);
  }

  predicate GetActiveBranchKeyEnsuresPublicly(input: GetActiveBranchKeyInput, output: Result<GetActiveBranchKeyOutput, Error>)
    decreases input, output
  {
    true
  }

  method GetActiveBranchKey(config: InternalConfig, input: GetActiveBranchKeyInput) returns (output: Result<GetActiveBranchKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetActiveBranchKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := GetKeys.GetActiveKeyAndUnwrap(input, config.ddbTableName, config.logicalKeyStoreName, config.kmsConfiguration, config.grantTokens, config.kmsClient, config.ddbClient);
  }

  predicate GetBranchKeyVersionEnsuresPublicly(input: GetBranchKeyVersionInput, output: Result<GetBranchKeyVersionOutput, Error>)
    decreases input, output
  {
    true
  }

  method GetBranchKeyVersion(config: InternalConfig, input: GetBranchKeyVersionInput) returns (output: Result<GetBranchKeyVersionOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetBranchKeyVersionEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := GetKeys.GetBranchKeyVersion(input, config.ddbTableName, config.logicalKeyStoreName, config.kmsConfiguration, config.grantTokens, config.kmsClient, config.ddbClient);
  }

  predicate GetBeaconKeyEnsuresPublicly(input: GetBeaconKeyInput, output: Result<GetBeaconKeyOutput, Error>)
    decreases input, output
  {
    true
  }

  method GetBeaconKey(config: InternalConfig, input: GetBeaconKeyInput) returns (output: Result<GetBeaconKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetBeaconKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := GetKeys.GetBeaconKeyAndUnwrap(input, config.ddbTableName, config.logicalKeyStoreName, config.kmsConfiguration, config.grantTokens, config.kmsClient, config.ddbClient);
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyKeyStoreTypes
}

module AwsArnParsing {

  import opened StandardLibrary

  import opened Wrappers

  import opened Seq

  import opened UInt = StandardLibrary.UInt

  import Types = AwsCryptographyMaterialProvidersTypes

  import DDB = ComAmazonawsDynamodbTypes

  import UTF8
  datatype AwsResource = AwsResource(resourceType: string, value: string) {
    predicate method Valid()
      decreases this
    {
      true &&
      0 < |value|
    }

    function method ToString(): string
      decreases this
    {
      resourceType + ""/"" + value
    }
  }

  datatype AwsArn = AwsArn(arnLiteral: string, partition: string, service: string, region: string, account: string, resource: AwsResource) {
    predicate method Valid()
      decreases this
    {
      arnLiteral == ""arn"" &&
      0 < |partition| &&
      0 < |service| &&
      0 < |region| &&
      0 < |account| &&
      resource.Valid()
    }

    function method ToString(): string
      requires this.Valid()
      decreases this
    {
      ToArnString(None)
    }

    function method ToArnString(customRegion: Option<string>): string
      requires this.Valid()
      decreases if customRegion.None? then 1 else 0
    {
      match customRegion {
        case None() =>
          ToArnString(Some(region))
        case Some(customRegion) =>
          Join([arnLiteral, partition, service, customRegion, account, resource.ToString()], "":"")
      }
    }
  }

  type AwsKmsArn = a: AwsArn
    | ValidAwsKmsArn(a)
    witness *

  type AwsKmsResource = r: AwsResource
    | ValidAwsKmsResource(r)
    witness *

  datatype AwsKmsIdentifier = AwsKmsArnIdentifier(a: AwsKmsArn) | AwsKmsRawResourceIdentifier(r: AwsKmsResource) {
    function method ToString(): string
      decreases this
    {
      match this {
        case AwsKmsArnIdentifier(a: AwsKmsArn) =>
          a.ToString()
        case AwsKmsRawResourceIdentifier(r: AwsKmsResource) =>
          r.ToString()
      }
    }
  }

  type AmazonDynamodbTableArn = a: AwsArn
    | ValidAmazonDynamodbArn(a)
    witness *

  type AmazonDynamodbResource = r: AwsResource
    | ValidAmazonDynamodbResource(r)
    witness *

  datatype AmazonDynamodbTableName = AmazonDynamodbTableArn(a: AmazonDynamodbTableArn) {
    function method GetTableName(): string
      decreases this
    {
      match this {
        case AmazonDynamodbTableArn(a: AmazonDynamodbTableArn) =>
          a.resource.value
      }
    }
  }

  type AwsKmsIdentifierString = s: string
    | IsAwsKmsIdentifierString(s).Success?
    witness *

  const MAX_AWS_KMS_IDENTIFIER_LENGTH := 2048

  predicate method ValidAwsKmsResource(resource: AwsResource)
    decreases resource
  {
    resource.Valid() &&
    (resource.resourceType == ""key"" || resource.resourceType == ""alias"")
  }

  predicate method ValidAwsKmsArn(arn: AwsArn)
    decreases arn
  {
    arn.Valid() &&
    arn.service == ""kms"" &&
    ValidAwsKmsResource(arn.resource)
  }

  function method ParseAwsKmsRawResources(identifier: string): (result: Result<AwsKmsResource, string>)
    decreases identifier
  {
    var info: seq<seq<char>> := Split(identifier, '/');
    Need(info[0] != ""key"", ""Malformed raw key id: "" + identifier); if |info| == 1 then ParseAwsKmsResources(""key/"" + identifier) else ParseAwsKmsResources(identifier)
  }

  function method ParseAwsKmsResources(identifier: string): (result: Result<AwsKmsResource, string>)
    decreases identifier
  {
    var info: seq<seq<char>> := Split(identifier, '/');
    Need(|info| > 1, ""Malformed resource: "" + identifier); var resourceType: seq<char> := info[0]; var value: seq<char> := Join(info[1..], ""/""); var resource: AwsResource := AwsResource(resourceType, value); Need(ValidAwsKmsResource(resource), ""Malformed resource: "" + identifier); Success(resource)
  }

  predicate method ValidAmazonDynamodbResource(resource: AwsResource)
    decreases resource
  {
    resource.Valid() &&
    resource.resourceType == ""table""
  }

  predicate method ValidAmazonDynamodbArn(arn: AwsArn)
    decreases arn
  {
    arn.Valid() &&
    arn.service == ""dynamodb"" &&
    ValidAmazonDynamodbResource(arn.resource)
  }

  function method ParseAmazonDynamodbResources(identifier: string): (result: Result<AmazonDynamodbResource, string>)
    decreases identifier
  {
    var info: Option<(seq<char>, seq<char>)> := SplitOnce?(identifier, '/');
    Need(info.Some?, ""Malformed resource: "" + identifier); var resourceType: seq<char> := info.value.0; var value: seq<char> := info.value.1; Need(DDB.IsValid_TableName(value), ""Table Name invalid: "" + identifier); var resource: AwsResource := AwsResource(resourceType, value); Need(ValidAmazonDynamodbResource(resource), ""Malformed resource: "" + identifier); Success(resource)
  }

  lemma /*{:_induction identifier}*/ ParseAwsKmsResourcesCorrect(identifier: string)
    ensures ParseAwsKmsResources(identifier).Success? ==> ghost var info: seq<seq<char>> := Split(identifier, '/'); ghost var r: Result<AwsKmsResource, string> := ParseAwsKmsResources(identifier); |info| > 1 && Join([r.value.resourceType, r.value.value], ""/"") == identifier
    ensures ParseAwsKmsResources(identifier).Success? ==> ghost var resourceType: seq<char> := Split(identifier, '/')[0]; ""key"" == resourceType || ""alias"" == resourceType
    ensures ParseAwsKmsResources(identifier).Success? ==> ghost var info: seq<seq<char>> := Split(identifier, '/'); |Join(info[1..], ""/"")| > 0
    decreases identifier
  {
  }

  lemma ParseAmazonDynamodbResourcesCorrect(identifier: string)
    ensures ParseAmazonDynamodbResources(identifier).Success? ==> ghost var info: Option<(seq<char>, seq<char>)> := SplitOnce?(identifier, '/'); ghost var r: Result<AmazonDynamodbResource, string> := ParseAmazonDynamodbResources(identifier); info.Some? && Join([r.value.resourceType, r.value.value], ""/"") == identifier
    ensures ParseAmazonDynamodbResources(identifier).Success? ==> ghost var resourceType: seq<char> := SplitOnce?(identifier, '/').value.0; resourceType == ""table""
    ensures ParseAmazonDynamodbResources(identifier).Success? ==> ghost var info: Option<(seq<char>, seq<char>)> := SplitOnce?(identifier, '/'); DDB.IsValid_TableName(info.value.1)
    decreases identifier
  {
  }

  function method ParseAwsKmsArn(identifier: string): (result: Result<AwsKmsArn, string>)
    ensures result.Success? ==> ""arn"" <= identifier && |Split(identifier, ':')| == 6 && |Split(identifier, ':')[1]| > 0 && Split(identifier, ':')[2] == ""kms"" && |Split(identifier, ':')[3]| > 0 && |Split(identifier, ':')[4]| > 0
    decreases identifier
  {
    var components: seq<seq<char>> := Split(identifier, ':');
    Need(6 == |components|, ""Malformed arn: "" + identifier); var resource: AwsKmsResource :- ParseAwsKmsResources(components[5]); var arn: AwsArn := AwsArn(components[0], components[1], components[2], components[3], components[4], resource); Need(ValidAwsKmsArn(arn), ""Malformed Arn:"" + identifier); Success(arn)
  }

  function method ParseAmazonDynamodbTableArn(identifier: string): (result: Result<AmazonDynamodbTableArn, string>)
    ensures result.Success? ==> ""arn"" <= identifier && |Split(identifier, ':')| == 6 && |Split(identifier, ':')[1]| > 0 && Split(identifier, ':')[2] == ""dynamodb"" && |Split(identifier, ':')[3]| > 0 && |Split(identifier, ':')[4]| > 0
    decreases identifier
  {
    var components: seq<seq<char>> := Split(identifier, ':');
    Need(6 == |components|, ""Malformed arn: "" + identifier); var resource: AmazonDynamodbResource :- ParseAmazonDynamodbResources(components[5]); var arn: AwsArn := AwsArn(components[0], components[1], components[2], components[3], components[4], resource); Need(ValidAmazonDynamodbArn(arn), ""Malformed Arn:"" + identifier); Success(arn)
  }

  lemma /*{:_induction identifier}*/ ParseAwsKmsArnCorrect(identifier: string)
    ensures ParseAwsKmsArn(identifier).Success? ==> ""arn"" <= identifier
    ensures ParseAwsKmsArn(identifier).Success? ==> |Split(identifier, ':')| == 6
    ensures ParseAwsKmsArn(identifier).Success? ==> |Split(identifier, ':')[1]| > 0
    ensures ParseAwsKmsArn(identifier).Success? ==> Split(identifier, ':')[2] == ""kms""
    ensures ParseAwsKmsArn(identifier).Success? ==> |Split(identifier, ':')[3]| > 0
    ensures ParseAwsKmsArn(identifier).Success? ==> |Split(identifier, ':')[4]| > 0
    decreases identifier
  {
  }

  lemma /*{:_induction identifier}*/ ParseAmazonDynamodbTableArnCorrect(identifier: string)
    ensures ParseAmazonDynamodbTableArn(identifier).Success? ==> ""arn"" <= identifier
    ensures ParseAmazonDynamodbTableArn(identifier).Success? ==> |Split(identifier, ':')| == 6
    ensures ParseAmazonDynamodbTableArn(identifier).Success? ==> |Split(identifier, ':')[1]| > 0
    ensures ParseAmazonDynamodbTableArn(identifier).Success? ==> Split(identifier, ':')[2] == ""dynamodb""
    ensures ParseAmazonDynamodbTableArn(identifier).Success? ==> |Split(identifier, ':')[3]| > 0
    ensures ParseAmazonDynamodbTableArn(identifier).Success? ==> |Split(identifier, ':')[4]| > 0
    decreases identifier
  {
  }

  function method ParseAwsKmsIdentifier(identifier: string): (result: Result<AwsKmsIdentifier, string>)
    decreases identifier
  {
    if ""arn:"" <= identifier then
      var arn: AwsKmsArn :- ParseAwsKmsArn(identifier); Success(AwsKmsArnIdentifier(arn))
    else
      var r: AwsKmsResource :- ParseAwsKmsRawResources(identifier); Success(AwsKmsRawResourceIdentifier(r))
  }

  function method ParseAmazonDynamodbTableName(identifier: string): (result: Result<DDB.TableName, string>)
    decreases identifier
  {
    var arn: AmazonDynamodbTableArn :- ParseAmazonDynamodbTableArn(identifier); var tableArn: AmazonDynamodbTableName := AmazonDynamodbTableArn(arn); var tableName: string := tableArn.GetTableName(); Success(tableName)
  }

  predicate method IsMultiRegionAwsKmsArn(arn: AwsKmsArn)
    decreases arn
  {
    IsMultiRegionAwsKmsResource(arn.resource)
  }

  lemma IsMultiRegionAwsKmsArnCorrectness(arn: AwsKmsArn)
    ensures !IsMultiRegionAwsKmsArn(arn) <== arn.resource.resourceType == ""alias""
    ensures !IsMultiRegionAwsKmsArn(arn) <== arn.resource.resourceType == ""key"" && !(""mrk-"" <= arn.resource.value)
    ensures IsMultiRegionAwsKmsArn(arn) <== arn.resource.resourceType == ""key"" && ""mrk-"" <= arn.resource.value
    decreases arn
  {
  }

  predicate method IsMultiRegionAwsKmsIdentifier(identifier: AwsKmsIdentifier)
    decreases identifier
  {
    match identifier {
      case AwsKmsArnIdentifier(arn) =>
        IsMultiRegionAwsKmsArn(arn)
      case AwsKmsRawResourceIdentifier(r) =>
        IsMultiRegionAwsKmsResource(r)
    }
  }

  lemma IsMultiRegionAwsKmsIdentifierCorrect(s: string)
    ensures ""arn:"" <= s && ParseAwsKmsArn(s).Success? ==> ghost var arn: Result<AwsKmsArn, string> := ParseAwsKmsArn(s); ghost var arnIdentifier: AwsKmsIdentifier := AwsKmsArnIdentifier(arn.value); IsMultiRegionAwsKmsIdentifier(arnIdentifier) == IsMultiRegionAwsKmsArn(arn.value)
    ensures ""alias/"" <= s && ParseAwsKmsResources(s).Success? ==> ghost var resource: Result<AwsKmsResource, string> := ParseAwsKmsResources(s); ghost var resourceIdentifier: AwsKmsIdentifier := AwsKmsRawResourceIdentifier(resource.value); !IsMultiRegionAwsKmsIdentifier(resourceIdentifier)
    ensures ""mrk-"" <= s && ParseAwsKmsResources(s).Success? ==> ghost var resource: Result<AwsKmsResource, string> := ParseAwsKmsResources(s); ghost var resourceIdentifier: AwsKmsIdentifier := AwsKmsRawResourceIdentifier(resource.value); IsMultiRegionAwsKmsIdentifier(resourceIdentifier)
    ensures !(""arn:"" <= s) && !(""alias/"" <= s) && !(""mrk-"" <= s) && ParseAwsKmsIdentifier(s).Success? ==> ghost var resourceIdentifier: Result<AwsKmsIdentifier, string> := ParseAwsKmsIdentifier(s); !IsMultiRegionAwsKmsIdentifier(resourceIdentifier.value)
    decreases s
  {
  }

  predicate method IsMultiRegionAwsKmsResource(resource: AwsKmsResource)
    decreases resource
  {
    resource.resourceType == ""key"" &&
    ""mrk-"" <= resource.value
  }

  function method GetRegion(identifier: AwsKmsIdentifier): (res: Option<string>)
    decreases identifier
  {
    match identifier {
      case AwsKmsArnIdentifier(a) =>
        Some(a.region)
      case AwsKmsRawResourceIdentifier(_ /* _v0 */) =>
        None()
    }
  }

  function method IsAwsKmsIdentifierString(s: string): (res: Result<AwsKmsIdentifier, string>)
    decreases s
  {
    Need(UTF8.IsASCIIString(s), ""Not a valid ASCII string.""); Need(0 < |s| <= MAX_AWS_KMS_IDENTIFIER_LENGTH, ""Identifier exceeds maximum length.""); ParseAwsKmsIdentifier(s)
  }

  function method Error(s: string): Types.Error
    decreases s
  {
    Types.AwsCryptographicMaterialProvidersException(message := s)
  }

  function method ValidateDdbTableArn(tableArn: string): (res: Result<(), Types.Error>)
    ensures res.Success? ==> ParseAmazonDynamodbTableArn(tableArn).Success? && UTF8.IsASCIIString(tableArn) && DDB.IsValid_TableName(ParseAmazonDynamodbTableName(tableArn).value)
    decreases tableArn
  {
    var _ /* _v1 */: DDB.TableName :- ParseAmazonDynamodbTableName(tableArn).MapFailure(Error); Need(UTF8.IsASCIIString(tableArn), Types.AwsCryptographicMaterialProvidersException(message := ""Table Arn is not ASCII"")); Need(DDB.IsValid_TableName(ParseAmazonDynamodbTableName(tableArn).value), Types.AwsCryptographicMaterialProvidersException(message := ""Table Name is too long"")); Success(())
  }
}

module AwsKmsUtils {

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened Actions

  import opened A = AwsKmsMrkMatchForDecrypt

  import Types = AwsCryptographyMaterialProvidersTypes

  import KMS = Types.ComAmazonawsKmsTypes

  import AwsArnParsing

  import UTF8
  class OnDecryptMrkAwareEncryptedDataKeyFilter extends DeterministicActionWithResult<Types.EncryptedDataKey, bool, Types.Error> {
    const awsKmsKey: AwsArnParsing.AwsKmsIdentifier
    const providerId: UTF8.ValidUTF8Bytes

    function Modifies(): set<object>
    {
      {}
    }

    constructor (awsKmsKey: AwsArnParsing.AwsKmsIdentifier, providerId: UTF8.ValidUTF8Bytes)
      ensures this.awsKmsKey == awsKmsKey && this.providerId == providerId
      decreases awsKmsKey, providerId
    {
      this.awsKmsKey := awsKmsKey;
      this.providerId := providerId;
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<bool, Types.Error>)
      decreases edk, res
    {
      true &&
      (res.Success? &&
      res.value ==>
        edk.keyProviderId == providerId)
    }

    method Invoke(edk: Types.EncryptedDataKey) returns (res: Result<bool, Types.Error>)
      ensures Ensures(edk, res)
      decreases edk
    {
      if edk.keyProviderId != providerId {
        return Success(false);
      }
      if !UTF8.ValidUTF8Seq(edk.keyProviderInfo) {
        return Failure(Types.AwsCryptographicMaterialProvidersException(message := ""Invalid AWS KMS encoding, provider info is not UTF8.""));
      }
      var keyId :- UTF8.Decode(edk.keyProviderInfo).MapFailure(WrapStringToError);
      var arn :- AwsArnParsing.ParseAwsKmsArn(keyId).MapFailure(WrapStringToError);
      return Success(AwsKmsMrkMatchForDecrypt(awsKmsKey, AwsArnParsing.AwsKmsArnIdentifier(arn)));
    }
  }

  function method StringifyEncryptionContext(utf8EncCtx: Types.EncryptionContext): (res: Result<KMS.EncryptionContextType, Types.Error>)
    decreases utf8EncCtx
  {
    if |utf8EncCtx| == 0 then
      Success(map[])
    else
      var stringifyResults: map<UTF8.ValidUTF8Bytes, Result<(string, string), Types.Error>> := map utf8Key: UTF8.ValidUTF8Bytes {:trigger utf8EncCtx[utf8Key]} {:trigger utf8Key in utf8EncCtx.Keys} | utf8Key in utf8EncCtx.Keys :: utf8Key := StringifyEncryptionContextPair(utf8Key, utf8EncCtx[utf8Key]); if exists r: Result<(string, string), Types.Error> {:trigger r.Failure?} {:trigger r in stringifyResults.Values} | r in stringifyResults.Values :: r.Failure? then Failure(Types.AwsCryptographicMaterialProvidersException(message := ""Encryption context contains invalid UTF8"")) else assert forall r: Result<(string, string), Types.Error> {:trigger r.Success?} {:trigger r in stringifyResults.Values} | r in stringifyResults.Values :: r.Success?; var stringKeysUnique: bool := forall k: seq<uint8>, k': seq<uint8> {:trigger stringifyResults[k'], stringifyResults[k]} {:trigger stringifyResults[k'], k in stringifyResults} {:trigger stringifyResults[k], k' in stringifyResults} {:trigger k' in stringifyResults, k in stringifyResults} | k in stringifyResults && k' in stringifyResults :: k != k' ==> stringifyResults[k].value.0 != stringifyResults[k'].value.0; if !stringKeysUnique then Failure(Types.AwsCryptographicMaterialProvidersException(message := ""Encryption context keys are not unique"")) else Success(map r: Result<(string, string), Types.Error> {:trigger r.value} {:trigger r in stringifyResults.Values} | r in stringifyResults.Values :: r.value.0 := r.value.1)
  }

  function method StringifyEncryptionContextPair(utf8Key: UTF8.ValidUTF8Bytes, utf8Value: UTF8.ValidUTF8Bytes): (res: Result<(string, string), Types.Error>)
    ensures UTF8.Decode(utf8Key).Success? && UTF8.Decode(utf8Value).Success? <==> res.Success?
    decreases utf8Key, utf8Value
  {
    var key: string :- UTF8.Decode(utf8Key).MapFailure(WrapStringToError); var value: string :- UTF8.Decode(utf8Value).MapFailure(WrapStringToError); Success((key, value))
  }

  function method WrapStringToError(e: string): (ret: Types.Error)
    decreases e
  {
    Types.AwsCryptographicMaterialProvidersException(message := e)
  }

  function method ValidateKmsKeyId(keyId: string): (res: Result<(), Types.Error>)
    ensures res.Success? ==> AwsArnParsing.ParseAwsKmsIdentifier(keyId).Success? && UTF8.IsASCIIString(keyId) && 0 < |keyId| <= AwsArnParsing.MAX_AWS_KMS_IDENTIFIER_LENGTH
    decreases keyId
  {
    var _ /* _v0 */: AwsKmsIdentifier :- AwsArnParsing.ParseAwsKmsIdentifier(keyId).MapFailure(WrapStringToError); Need(UTF8.IsASCIIString(keyId), Types.AwsCryptographicMaterialProvidersException(message := ""Key identifier is not ASCII"")); Need(0 < |keyId| <= AwsArnParsing.MAX_AWS_KMS_IDENTIFIER_LENGTH, Types.AwsCryptographicMaterialProvidersException(message := ""Key identifier is too long"")); Success(())
  }

  function method GetValidGrantTokens(grantTokens: Option<Types.GrantTokenList>): (res: Result<Types.GrantTokenList, Types.Error>)
    ensures res.Success? ==> var tokens: Types.GrantTokenList := res.value; 0 <= |tokens| <= 10 && forall token: seq<char> {:trigger |token|} {:trigger token in tokens} | token in tokens :: 1 <= |token| && |token| <= 8192
    ensures res.Success? && grantTokens.Some? ==> res.value == grantTokens.value
    decreases grantTokens
  {
    var tokens: Types.GrantTokenList := grantTokens.UnwrapOr([]);
    Need(0 <= |tokens| <= 10, Types.AwsCryptographicMaterialProvidersException(message := ""Grant token list can have no more than 10 tokens"")); Need(forall token: seq<char> {:trigger |token|} {:trigger token in tokens} | token in tokens :: 1 <= |token| && |token| <= 8192, Types.AwsCryptographicMaterialProvidersException(message := ""Grant token list contains a grant token with invalid length"")); Success(tokens)
  }

  function method ParseKeyNamespaceAndName(keyNamespace: string, keyName: string): (res: Result<(UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes), Types.Error>)
    ensures res.Success? ==> var (namespace: UTF8.ValidUTF8Bytes, name: UTF8.ValidUTF8Bytes) := res.value; |namespace| < UINT16_LIMIT && |name| < UINT16_LIMIT
    decreases keyNamespace, keyName
  {
    var namespace: ValidUTF8Bytes :- UTF8.Encode(keyNamespace).MapFailure((e: string) => Types.AwsCryptographicMaterialProvidersException(message := ""Key namespace could not be UTF8-encoded"" + e)); Need(|namespace| < UINT16_LIMIT, Types.AwsCryptographicMaterialProvidersException(message := ""Key namespace too long"")); var name: ValidUTF8Bytes :- UTF8.Encode(keyName).MapFailure((e: string) => Types.AwsCryptographicMaterialProvidersException(message := ""Key name could not be UTF8-encoded"" + e)); Need(|name| < UINT16_LIMIT, Types.AwsCryptographicMaterialProvidersException(message := ""Key name too long"")); Success((namespace, name))
  }

  function method ValidateDiscoveryFilter(filter: Types.DiscoveryFilter): (res: Result<(), Types.Error>)
    ensures res.Success? ==> |filter.accountIds| > 0 && (forall accountId: seq<char> {:trigger |accountId|} {:trigger accountId in filter.accountIds} | accountId in filter.accountIds :: |accountId| > 0) && |filter.partition| > 0
    decreases filter
  {
    Need(|filter.accountIds| > 0, Types.AwsCryptographicMaterialProvidersException(message := ""Discovery filter must have at least one account ID"")); Need(forall accountId: seq<char> {:trigger |accountId|} {:trigger accountId in filter.accountIds} | accountId in filter.accountIds :: |accountId| > 0, Types.AwsCryptographicMaterialProvidersException(message := ""Discovery filter account IDs cannot be blank"")); Need(|filter.partition| > 0, Types.AwsCryptographicMaterialProvidersException(message := ""Discovery filter partition cannot be blank"")); Success(())
  }
}

module AwsKmsMrkMatchForDecrypt {

  import opened StandardLibrary

  import opened Wrappers

  import opened Seq

  import opened AwsArnParsing
  predicate method AwsKmsMrkMatchForDecrypt(configuredAwsKmsIdentifier: AwsKmsIdentifier, messageAwsKmsIdentifer: AwsKmsIdentifier)
    decreases configuredAwsKmsIdentifier, messageAwsKmsIdentifer
  {
    if configuredAwsKmsIdentifier == messageAwsKmsIdentifer then
      true
    else
      match (messageAwsKmsIdentifer, configuredAwsKmsIdentifier) { case (AwsKmsArnIdentifier(configuredAwsKmsArn), AwsKmsArnIdentifier(messageAwsKmsArn)) => (if !IsMultiRegionAwsKmsArn(configuredAwsKmsArn) || !IsMultiRegionAwsKmsArn(messageAwsKmsArn) then false else messageAwsKmsArn.partition == configuredAwsKmsArn.partition && messageAwsKmsArn.service == configuredAwsKmsArn.service && messageAwsKmsArn.account == configuredAwsKmsArn.account && messageAwsKmsArn.resource == configuredAwsKmsArn.resource) case (_ /* _v0 */, _ /* _v1 */) => false }
  }

  lemma AwsKmsMrkMatchForDecryptCorrect(config: string, message: string)
    ensures ghost var c: Result<AwsKmsIdentifier, string> := ParseAwsKmsIdentifier(config); ghost var m: Result<AwsKmsIdentifier, string> := ParseAwsKmsIdentifier(message); config == message && c.Success? && m.Success? ==> AwsKmsMrkMatchForDecrypt(c.value, m.value)
    ensures ghost var c: Result<AwsKmsArn, string> := ParseAwsKmsArn(config); ghost var m: Result<AwsKmsArn, string> := ParseAwsKmsArn(message); config != message && c.Success? && m.Success? && IsMultiRegionAwsKmsArn(c.value) != IsMultiRegionAwsKmsArn(m.value) ==> !AwsKmsMrkMatchForDecrypt(AwsKmsArnIdentifier(c.value), AwsKmsArnIdentifier(m.value))
    ensures ghost var c: Result<AwsKmsArn, string> := ParseAwsKmsArn(config); ghost var m: Result<AwsKmsArn, string> := ParseAwsKmsArn(message); c.Success? && m.Success? && IsMultiRegionAwsKmsArn(c.value) && IsMultiRegionAwsKmsArn(m.value) ==> AwsKmsMrkMatchForDecrypt(AwsKmsArnIdentifier(c.value), AwsKmsArnIdentifier(m.value)) == (m.value.partition == c.value.partition && m.value.service == c.value.service && m.value.account == c.value.account && m.value.resource == c.value.resource)
    decreases config, message
  {
  }
}

module GetKeys {

  import opened StandardLibrary

  import opened Wrappers

  import opened Seq

  import Structure

  import KMSKeystoreOperations

  import DDBKeystoreOperations

  import Types = AwsCryptographyKeyStoreTypes

  import DDB = ComAmazonawsDynamodbTypes

  import KMS = ComAmazonawsKmsTypes

  import UTF8
  method GetActiveKeyAndUnwrap(input: Types.GetActiveBranchKeyInput, tableName: DDB.TableName, logicalKeyStoreName: string, kmsConfiguration: Types.KMSConfiguration, grantTokens: KMS.GrantTokenList, kmsClient: KMS.IKMSClient, ddbClient: DDB.IDynamoDBClient)
      returns (output: Result<Types.GetActiveBranchKeyOutput, Types.Error>)
    requires ddbClient.Modifies !! kmsClient.Modifies
    requires kmsClient.ValidState() && ddbClient.ValidState()
    modifies ddbClient.Modifies, kmsClient.Modifies
    ensures ddbClient.ValidState() && kmsClient.ValidState()
    ensures |ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).input.Key == map[Structure.BRANCH_KEY_IDENTIFIER_FIELD := DDB.AttributeValue.S(input.branchKeyIdentifier), Structure.TYPE_FIELD := DDB.AttributeValue.S(Structure.BRANCH_KEY_ACTIVE_TYPE)]
    ensures output.Success? ==> Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && var activeItem: AttributeMap := Seq.Last(ddbClient.History.GetItem).output.value.Item.value; Structure.BranchKeyItem?(activeItem) && activeItem[Structure.HIERARCHY_VERSION].N? && Structure.BRANCH_KEY_ACTIVE_VERSION_FIELD in activeItem && KMSKeystoreOperations.AttemptKmsOperation?(kmsConfiguration, Structure.ToBranchKeyContext(activeItem, logicalKeyStoreName)) && |kmsClient.History.Decrypt| == |old(kmsClient.History.Decrypt)| + 1 && AwsKmsBranchKeyDecryption?(Seq.Last(ddbClient.History.GetItem), Seq.Last(kmsClient.History.Decrypt), kmsClient, ddbClient, kmsConfiguration, grantTokens, logicalKeyStoreName) && var versionEncryptionContext: BranchKeyContext := Structure.ToBranchKeyContext(activeItem, logicalKeyStoreName); true && var decryptResponse: DecryptResponse := Seq.Last(kmsClient.History.Decrypt).output.value; Structure.ToBranchKeyMaterials(versionEncryptionContext, decryptResponse.Plaintext.value).Success? && var branchKeyMaterials: Types.BranchKeyMaterials := Structure.ToBranchKeyMaterials(versionEncryptionContext, decryptResponse.Plaintext.value).value; output.value.branchKeyMaterials == branchKeyMaterials && output.value.branchKeyMaterials.branchKeyIdentifier == input.branchKeyIdentifier
    ensures (|ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && !Structure.ActiveBranchKeyItem?(Seq.Last(ddbClient.History.GetItem).output.value.Item.value) ==> output.Failure?) || (|kmsClient.History.Decrypt| == |old(kmsClient.History.Decrypt)| + 1 && Seq.Last(kmsClient.History.Decrypt).output.Failure? ==> output.Failure?)
    decreases input, tableName, logicalKeyStoreName, kmsConfiguration, grantTokens, kmsClient, ddbClient
  {
    var branchKeyItem :- DDBKeystoreOperations.GetActiveBranchKeyItem(input.branchKeyIdentifier, tableName, ddbClient);
    var encryptionContext := Structure.ToBranchKeyContext(branchKeyItem, logicalKeyStoreName);
    :- Need(KMSKeystoreOperations.AttemptKmsOperation?(kmsConfiguration, encryptionContext), Types.KeyStoreException(message := ""AWS KMS Key ARN does not match configured value""));
    var branchKey :- KMSKeystoreOperations.DecryptKey(encryptionContext, branchKeyItem, kmsConfiguration, grantTokens, kmsClient);
    var branchKeyMaterials :- Structure.ToBranchKeyMaterials(encryptionContext, branchKey.Plaintext.value);
    return Success(Types.GetActiveBranchKeyOutput(branchKeyMaterials := branchKeyMaterials));
  }

  method GetBranchKeyVersion(input: Types.GetBranchKeyVersionInput, tableName: DDB.TableName, logicalKeyStoreName: string, kmsConfiguration: Types.KMSConfiguration, grantTokens: KMS.GrantTokenList, kmsClient: KMS.IKMSClient, ddbClient: DDB.IDynamoDBClient)
      returns (output: Result<Types.GetBranchKeyVersionOutput, Types.Error>)
    requires ddbClient.Modifies !! kmsClient.Modifies
    requires kmsClient.ValidState() && ddbClient.ValidState()
    modifies ddbClient.Modifies, kmsClient.Modifies
    ensures ddbClient.ValidState() && kmsClient.ValidState()
    ensures |ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).input.Key == map[Structure.BRANCH_KEY_IDENTIFIER_FIELD := DDB.AttributeValue.S(input.branchKeyIdentifier), Structure.TYPE_FIELD := DDB.AttributeValue.S(Structure.BRANCH_KEY_TYPE_PREFIX + input.branchKeyVersion)]
    ensures output.Success? ==> Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && var versionItem: AttributeMap := Seq.Last(ddbClient.History.GetItem).output.value.Item.value; Structure.BranchKeyItem?(versionItem) && versionItem[Structure.HIERARCHY_VERSION].N? && Structure.BRANCH_KEY_ACTIVE_VERSION_FIELD !in versionItem && Structure.BRANCH_KEY_TYPE_PREFIX < versionItem[Structure.TYPE_FIELD].S && KMSKeystoreOperations.AttemptKmsOperation?(kmsConfiguration, Structure.ToBranchKeyContext(versionItem, logicalKeyStoreName)) && |kmsClient.History.Decrypt| == |old(kmsClient.History.Decrypt)| + 1 && AwsKmsBranchKeyDecryption?(Seq.Last(ddbClient.History.GetItem), Seq.Last(kmsClient.History.Decrypt), kmsClient, ddbClient, kmsConfiguration, grantTokens, logicalKeyStoreName) && var versionEncryptionContext: BranchKeyContext := Structure.ToBranchKeyContext(versionItem, logicalKeyStoreName); true && var decryptResponse: DecryptResponse := Seq.Last(kmsClient.History.Decrypt).output.value; Structure.ToBranchKeyMaterials(versionEncryptionContext, decryptResponse.Plaintext.value).Success? && var branchKeyMaterials: Types.BranchKeyMaterials := Structure.ToBranchKeyMaterials(versionEncryptionContext, decryptResponse.Plaintext.value).value; output.value.branchKeyMaterials == branchKeyMaterials && output.value.branchKeyMaterials.branchKeyIdentifier == input.branchKeyIdentifier
    ensures (|ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && !Structure.VersionBranchKeyItem?(Seq.Last(ddbClient.History.GetItem).output.value.Item.value) ==> output.Failure?) || (|kmsClient.History.Decrypt| == |old(kmsClient.History.Decrypt)| + 1 && Seq.Last(kmsClient.History.Decrypt).output.Failure? ==> output.Failure?)
    decreases input, tableName, logicalKeyStoreName, kmsConfiguration, grantTokens, kmsClient, ddbClient
  {
    var branchKeyItem :- DDBKeystoreOperations.GetVersionBranchKeyItem(input.branchKeyIdentifier, input.branchKeyVersion, tableName, ddbClient);
    var encryptionContext := Structure.ToBranchKeyContext(branchKeyItem, logicalKeyStoreName);
    :- Need(KMSKeystoreOperations.AttemptKmsOperation?(kmsConfiguration, encryptionContext), Types.KeyStoreException(message := ""AWS KMS Key ARN does not match configured value""));
    var branchKey :- KMSKeystoreOperations.DecryptKey(encryptionContext, branchKeyItem, kmsConfiguration, grantTokens, kmsClient);
    var branchKeyMaterials :- Structure.ToBranchKeyMaterials(encryptionContext, branchKey.Plaintext.value);
    return Success(Types.GetBranchKeyVersionOutput(branchKeyMaterials := branchKeyMaterials));
  }

  method GetBeaconKeyAndUnwrap(input: Types.GetBeaconKeyInput, tableName: DDB.TableName, logicalKeyStoreName: string, kmsConfiguration: Types.KMSConfiguration, grantTokens: KMS.GrantTokenList, kmsClient: KMS.IKMSClient, ddbClient: DDB.IDynamoDBClient)
      returns (output: Result<Types.GetBeaconKeyOutput, Types.Error>)
    requires ddbClient.Modifies !! kmsClient.Modifies
    requires kmsClient.ValidState() && ddbClient.ValidState()
    modifies ddbClient.Modifies, kmsClient.Modifies
    ensures ddbClient.ValidState() && kmsClient.ValidState()
    ensures |ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).input.Key == map[Structure.BRANCH_KEY_IDENTIFIER_FIELD := DDB.AttributeValue.S(input.branchKeyIdentifier), Structure.TYPE_FIELD := DDB.AttributeValue.S(Structure.BEACON_KEY_TYPE_VALUE)]
    ensures output.Success? ==> Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && var versionItem: AttributeMap := Seq.Last(ddbClient.History.GetItem).output.value.Item.value; Structure.BranchKeyItem?(versionItem) && versionItem[Structure.HIERARCHY_VERSION].N? && Structure.BRANCH_KEY_ACTIVE_VERSION_FIELD !in versionItem && versionItem[Structure.TYPE_FIELD].S == Structure.BEACON_KEY_TYPE_VALUE && KMSKeystoreOperations.AttemptKmsOperation?(kmsConfiguration, Structure.ToBranchKeyContext(versionItem, logicalKeyStoreName)) && |kmsClient.History.Decrypt| == |old(kmsClient.History.Decrypt)| + 1 && AwsKmsBranchKeyDecryption?(Seq.Last(ddbClient.History.GetItem), Seq.Last(kmsClient.History.Decrypt), kmsClient, ddbClient, kmsConfiguration, grantTokens, logicalKeyStoreName) && var versionEncryptionContext: BranchKeyContext := Structure.ToBranchKeyContext(versionItem, logicalKeyStoreName); true && var decryptResponse: DecryptResponse := Seq.Last(kmsClient.History.Decrypt).output.value; Structure.ToBeaconKeyMaterials(versionEncryptionContext, decryptResponse.Plaintext.value).Success? && var beaconKeyMaterials: Types.BeaconKeyMaterials := Structure.ToBeaconKeyMaterials(versionEncryptionContext, decryptResponse.Plaintext.value).value; output.value.beaconKeyMaterials == beaconKeyMaterials && output.value.beaconKeyMaterials.beaconKeyIdentifier == input.branchKeyIdentifier
    ensures (|ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && !Structure.BeaconKeyItem?(Seq.Last(ddbClient.History.GetItem).output.value.Item.value) ==> output.Failure?) || (|kmsClient.History.Decrypt| == |old(kmsClient.History.Decrypt)| + 1 && Seq.Last(kmsClient.History.Decrypt).output.Failure? ==> output.Failure?)
    decreases input, tableName, logicalKeyStoreName, kmsConfiguration, grantTokens, kmsClient, ddbClient
  {
    var branchKeyItem :- DDBKeystoreOperations.GetBeaconKeyItem(input.branchKeyIdentifier, tableName, ddbClient);
    var encryptionContext := Structure.ToBranchKeyContext(branchKeyItem, logicalKeyStoreName);
    :- Need(KMSKeystoreOperations.AttemptKmsOperation?(kmsConfiguration, encryptionContext), Types.KeyStoreException(message := ""AWS KMS Key ARN does not match configured value""));
    var branchKey :- KMSKeystoreOperations.DecryptKey(encryptionContext, branchKeyItem, kmsConfiguration, grantTokens, kmsClient);
    var branchKeyMaterials :- Structure.ToBeaconKeyMaterials(encryptionContext, branchKey.Plaintext.value);
    return Success(Types.GetBeaconKeyOutput(beaconKeyMaterials := branchKeyMaterials));
  }

  predicate AwsKmsBranchKeyDecryption?(getItemHistory: DDB.DafnyCallEvent<DDB.GetItemInput, Result<DDB.GetItemOutput, DDB.Error>>, decryptHistory: KMS.DafnyCallEvent<KMS.DecryptRequest, Result<KMS.DecryptResponse, KMS.Error>>, kmsClient: KMS.IKMSClient, ddbClient: DDB.IDynamoDBClient, kmsConfiguration: Types.KMSConfiguration, grantTokens: KMS.GrantTokenList, logicalKeyStoreName: string)
    requires getItemHistory.output.Success? && getItemHistory.output.value.Item.Some? && Structure.BranchKeyItem?(getItemHistory.output.value.Item.value) && getItemHistory.output.Success? && getItemHistory.output.value.Item.Some?
    requires decryptHistory in kmsClient.History.Decrypt
    requires getItemHistory in ddbClient.History.GetItem
    reads kmsClient.History, ddbClient.History
    decreases {kmsClient.History, ddbClient.History}, getItemHistory, decryptHistory, kmsClient, ddbClient, kmsConfiguration, grantTokens, logicalKeyStoreName
  {
    ghost var versionItem: AttributeMap := getItemHistory.output.value.Item.value;
    ghost var versionEncryptionContext: BranchKeyContext := Structure.ToBranchKeyContext(versionItem, logicalKeyStoreName);
    versionEncryptionContext.Keys - {Structure.TABLE_FIELD} < versionItem.Keys &&
    (forall k: seq<char> {:trigger versionItem[k]} {:trigger versionEncryptionContext[k]} {:trigger k in versionEncryptionContext.Keys - {Structure.TABLE_FIELD}} | k in versionEncryptionContext.Keys - {Structure.TABLE_FIELD} :: 
      if k == Structure.HIERARCHY_VERSION then versionEncryptionContext[Structure.HIERARCHY_VERSION] == versionItem[Structure.HIERARCHY_VERSION].N else versionEncryptionContext[k] == versionItem[k].S) &&
    Structure.BRANCH_KEY_FIELD !in versionEncryptionContext &&
    ghost var decryptRequest: KMS.DecryptRequest := decryptHistory.input; decryptRequest.KeyId == Some(kmsConfiguration.kmsKeyArn) && decryptRequest.CiphertextBlob == versionItem[Structure.BRANCH_KEY_FIELD].B && decryptRequest.EncryptionContext == Some(versionEncryptionContext) && decryptRequest.GrantTokens == Some(grantTokens) && decryptHistory.output.Success? && decryptHistory.output.value.Plaintext.Some?
  }
}

module {:options ""/functionSyntax:4""} Structure {

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import Types = AwsCryptographyKeyStoreTypes

  import DDB = ComAmazonawsDynamodbTypes

  import KMS = ComAmazonawsKmsTypes

  import UTF8
  type BranchKeyContext = m: map<string, string>
    | BranchKeyContext?(m)
    witness *

  type BranchKeyItem = m: DDB.AttributeMap
    | BranchKeyItem?(m)
    witness *

  type ActiveBranchKeyItem = m: DDB.AttributeMap
    | ActiveBranchKeyItem?(m)
    witness *

  type VersionBranchKeyItem = m: DDB.AttributeMap
    | VersionBranchKeyItem?(m)
    witness *

  type BeaconKeyItem = m: DDB.AttributeMap
    | BeaconKeyItem?(m)
    witness *

  const BRANCH_KEY_IDENTIFIER_FIELD := ""branch-key-id""
  const TYPE_FIELD := ""type""
  const KEY_CREATE_TIME := ""create-time""
  const HIERARCHY_VERSION := ""hierarchy-version""
  const TABLE_FIELD := ""tablename""
  const KMS_FIELD := ""kms-arn""
  const BRANCH_KEY_FIELD := ""enc""
  const BRANCH_KEY_ACTIVE_VERSION_FIELD := ""version""
  const BRANCH_KEY_TYPE_PREFIX := ""branch:version:""
  const BRANCH_KEY_ACTIVE_TYPE := ""branch:ACTIVE""
  const BEACON_KEY_TYPE_VALUE := ""beacon:ACTIVE""
  const ENCRYPTION_CONTEXT_PREFIX := ""aws-crypto-ec:""
  const KMS_GEN_KEY_NO_PLAINTEXT_LENGTH_32 := 184

  predicate method BranchKeyContext?(m: map<string, string>)
    decreases m
  {
    BRANCH_KEY_IDENTIFIER_FIELD in m &&
    TYPE_FIELD in m &&
    KEY_CREATE_TIME in m &&
    HIERARCHY_VERSION in m &&
    TABLE_FIELD in m &&
    KMS_FIELD in m &&
    BRANCH_KEY_FIELD !in m.Keys &&
    0 < |m[BRANCH_KEY_IDENTIFIER_FIELD]| &&
    0 < |m[TYPE_FIELD]| &&
    (forall k: string {:trigger _default.IsValid_AttributeName(k)} {:trigger k in m.Keys} | k in m.Keys :: 
      _default.IsValid_AttributeName(k)) &&
    (BRANCH_KEY_ACTIVE_VERSION_FIELD in m <==> true && m[TYPE_FIELD] == BRANCH_KEY_ACTIVE_TYPE) &&
    (BRANCH_KEY_ACTIVE_VERSION_FIELD in m ==>
      true &&
      BRANCH_KEY_TYPE_PREFIX < m[BRANCH_KEY_ACTIVE_VERSION_FIELD]) &&
    (BRANCH_KEY_ACTIVE_VERSION_FIELD !in m <==> m[TYPE_FIELD] == BEACON_KEY_TYPE_VALUE || BRANCH_KEY_TYPE_PREFIX < m[TYPE_FIELD])
  }

  function method ToAttributeMap(encryptionContext: BranchKeyContext, encryptedKey: seq<uint8>): (output: DDB.AttributeMap)
    requires KMS.IsValid_CiphertextType(encryptedKey)
    ensures BranchKeyItem?(output)
    ensures ToBranchKeyContext(output, encryptionContext[TABLE_FIELD]) == encryptionContext
    decreases encryptionContext, encryptedKey
  {
    map k: AttributeName {:trigger encryptionContext[k]} {:trigger k in encryptionContext.Keys + {BRANCH_KEY_FIELD} - {TABLE_FIELD}} | k in encryptionContext.Keys + {BRANCH_KEY_FIELD} - {TABLE_FIELD} :: k := if k == HIERARCHY_VERSION then DDB.AttributeValue.N(encryptionContext[HIERARCHY_VERSION]) else if k == BRANCH_KEY_FIELD then DDB.AttributeValue.B(encryptedKey) else DDB.AttributeValue.S(encryptionContext[k])
  }

  function method ToBranchKeyContext(item: DDB.AttributeMap, logicalKeyStoreName: string): (output: BranchKeyContext)
    requires BranchKeyItem?(item)
    decreases item, logicalKeyStoreName
  {
    map k: seq<char> {:trigger item[k]} {:trigger k in item.Keys - {BRANCH_KEY_FIELD} + {TABLE_FIELD}} | k in item.Keys - {BRANCH_KEY_FIELD} + {TABLE_FIELD} :: k := if k == HIERARCHY_VERSION then item[k].N else if k == TABLE_FIELD then logicalKeyStoreName else item[k].S
  }

  function method ToBranchKeyMaterials(encryptionContext: BranchKeyContext, plaintextKey: seq<uint8>): (output: Result<Types.BranchKeyMaterials, Types.Error>)
    requires encryptionContext[TYPE_FIELD] == BRANCH_KEY_ACTIVE_TYPE || BRANCH_KEY_TYPE_PREFIX < encryptionContext[TYPE_FIELD]
    ensures output.Success? ==> output.value.branchKey == plaintextKey && output.value.branchKeyIdentifier == encryptionContext[BRANCH_KEY_IDENTIFIER_FIELD] && var versionInformation: seq<char> := if BRANCH_KEY_ACTIVE_VERSION_FIELD in encryptionContext then encryptionContext[BRANCH_KEY_ACTIVE_VERSION_FIELD] else encryptionContext[TYPE_FIELD]; BRANCH_KEY_TYPE_PREFIX < versionInformation && UTF8.Encode(versionInformation[|BRANCH_KEY_TYPE_PREFIX|..]).Success? && output.value.branchKeyVersion == UTF8.Encode(versionInformation[|BRANCH_KEY_TYPE_PREFIX|..]).value && ExtractCustomEncryptionContext(encryptionContext).Success? && output.value.encryptionContext == ExtractCustomEncryptionContext(encryptionContext).value
    decreases encryptionContext, plaintextKey
  {
    var versionInformation: seq<char> := if BRANCH_KEY_ACTIVE_VERSION_FIELD in encryptionContext then encryptionContext[BRANCH_KEY_ACTIVE_VERSION_FIELD] else encryptionContext[TYPE_FIELD];
    var branchKeyVersion: seq<char> := versionInformation[|BRANCH_KEY_TYPE_PREFIX|..];
    var branchKeyVersionUtf8: ValidUTF8Bytes :- UTF8.Encode(branchKeyVersion).MapFailure((e: seq<char>) => Types.KeyStoreException(message := e)); var customEncryptionContext: Types.EncryptionContext :- ExtractCustomEncryptionContext(encryptionContext); Success(Types.BranchKeyMaterials(branchKeyIdentifier := encryptionContext[BRANCH_KEY_IDENTIFIER_FIELD], branchKeyVersion := branchKeyVersionUtf8, branchKey := plaintextKey, encryptionContext := customEncryptionContext))
  }

  function method ToBeaconKeyMaterials(encryptionContext: BranchKeyContext, plaintextKey: seq<uint8>): (output: Result<Types.BeaconKeyMaterials, Types.Error>)
    requires encryptionContext[TYPE_FIELD] == BEACON_KEY_TYPE_VALUE
    decreases encryptionContext, plaintextKey
  {
    var customEncryptionContext: Types.EncryptionContext :- ExtractCustomEncryptionContext(encryptionContext); Success(Types.BeaconKeyMaterials(beaconKeyIdentifier := encryptionContext[BRANCH_KEY_IDENTIFIER_FIELD], beaconKey := Some(plaintextKey), hmacKeys := None, encryptionContext := customEncryptionContext))
  }

  function method ExtractCustomEncryptionContext(encryptionContext: BranchKeyContext): (output: Result<Types.EncryptionContext, Types.Error>)
    ensures output.Success? ==> (forall k: seq<BoundedInts.uint8> {:trigger UTF8.Decode(k)} {:trigger k in output.value} | k in output.value :: UTF8.Decode(k).Success? && ENCRYPTION_CONTEXT_PREFIX + UTF8.Decode(k).value in encryptionContext) && (forall k: seq<BoundedInts.uint8> {:trigger output.value[k]} {:trigger k in output.value} | k in output.value :: UTF8.Decode(output.value[k]).Success?) && forall k: seq<BoundedInts.uint8> {:trigger output.value[k]} {:trigger ENCRYPTION_CONTEXT_PREFIX + UTF8.Decode(k).value} {:trigger k in output.value} | k in output.value :: encryptionContext[ENCRYPTION_CONTEXT_PREFIX + UTF8.Decode(k).value] == UTF8.Decode(output.value[k]).value
    decreases encryptionContext
  {
    assert forall k: seq<char> {:trigger k[|ENCRYPTION_CONTEXT_PREFIX|..]} {:trigger k in encryptionContext.Keys} | k in encryptionContext.Keys && ENCRYPTION_CONTEXT_PREFIX < k :: k == ENCRYPTION_CONTEXT_PREFIX + k[|ENCRYPTION_CONTEXT_PREFIX|..];
    var encodedEncryptionContext: set<(Result<ValidUTF8Bytes, seq<char>>, Result<ValidUTF8Bytes, seq<char>>)> := set k: seq<char> {:trigger encryptionContext[k]} {:trigger k[|ENCRYPTION_CONTEXT_PREFIX|..]} {:trigger k in encryptionContext} | k in encryptionContext && ENCRYPTION_CONTEXT_PREFIX < k :: (UTF8.Encode(k[|ENCRYPTION_CONTEXT_PREFIX|..]), UTF8.Encode(encryptionContext[k]));
    Need(forall i: (Result<ValidUTF8Bytes, seq<char>>, Result<ValidUTF8Bytes, seq<char>>) {:trigger i.1} {:trigger i.0} {:trigger i in encodedEncryptionContext} | i in encodedEncryptionContext :: i.0.Success? && i.1.Success?, Types.KeyStoreException(message := ""Unable to encode string"")); Success(map i: (Result<ValidUTF8Bytes, seq<char>>, Result<ValidUTF8Bytes, seq<char>>) {:trigger i.1} {:trigger i.0} {:trigger i in encodedEncryptionContext} | i in encodedEncryptionContext :: i.0.value := i.1.value)
  }

  function method {:fuel 0, 0} DecryptOnlyBranchKeyEncryptionContext(branchKeyId: string, branchKeyVersion: string, timestamp: string, logicalKeyStoreName: string, kmsKeyArn: string, customEncryptionContext: map<string, string>): (output: map<string, string>)
    requires 0 < |branchKeyId|
    requires 0 < |branchKeyVersion|
    requires forall k: seq<char> {:trigger ENCRYPTION_CONTEXT_PREFIX + k} {:trigger k in customEncryptionContext} | k in customEncryptionContext :: _default.IsValid_AttributeName(ENCRYPTION_CONTEXT_PREFIX + k)
    ensures BranchKeyContext?(output)
    ensures BRANCH_KEY_TYPE_PREFIX < output[TYPE_FIELD]
    ensures BRANCH_KEY_ACTIVE_VERSION_FIELD !in output
    ensures output[KMS_FIELD] == kmsKeyArn
    ensures output[TABLE_FIELD] == logicalKeyStoreName
    ensures forall k: seq<char> {:trigger customEncryptionContext[k]} {:trigger ENCRYPTION_CONTEXT_PREFIX + k} {:trigger k in customEncryptionContext} | k in customEncryptionContext :: ENCRYPTION_CONTEXT_PREFIX + k in output && output[ENCRYPTION_CONTEXT_PREFIX + k] == customEncryptionContext[k]
    decreases branchKeyId, branchKeyVersion, timestamp, logicalKeyStoreName, kmsKeyArn, customEncryptionContext
  {
    assert forall k: seq<char> {:trigger ENCRYPTION_CONTEXT_PREFIX + k} {:trigger k in customEncryptionContext.Keys} | k in customEncryptionContext.Keys :: k == (ENCRYPTION_CONTEXT_PREFIX + k)[|ENCRYPTION_CONTEXT_PREFIX|..];
    map[BRANCH_KEY_IDENTIFIER_FIELD := branchKeyId, TYPE_FIELD := BRANCH_KEY_TYPE_PREFIX + branchKeyVersion, KEY_CREATE_TIME := timestamp, TABLE_FIELD := logicalKeyStoreName, KMS_FIELD := kmsKeyArn, HIERARCHY_VERSION := ""1""] + map k: seq<char> {:trigger customEncryptionContext[k]} {:trigger ENCRYPTION_CONTEXT_PREFIX + k} {:trigger k in customEncryptionContext} | k in customEncryptionContext :: ENCRYPTION_CONTEXT_PREFIX + k := customEncryptionContext[k]
  }

  function method ActiveBranchKeyEncryptionContext(decryptOnlyEncryptionContext: map<string, string>): (output: map<string, string>)
    requires BranchKeyContext?(decryptOnlyEncryptionContext)
    requires BRANCH_KEY_TYPE_PREFIX < decryptOnlyEncryptionContext[TYPE_FIELD] && BRANCH_KEY_ACTIVE_VERSION_FIELD !in decryptOnlyEncryptionContext
    ensures BranchKeyContext?(output)
    ensures BRANCH_KEY_ACTIVE_VERSION_FIELD in output
    decreases decryptOnlyEncryptionContext
  {
    decryptOnlyEncryptionContext + map[BRANCH_KEY_ACTIVE_VERSION_FIELD := decryptOnlyEncryptionContext[TYPE_FIELD], TYPE_FIELD := BRANCH_KEY_ACTIVE_TYPE]
  }

  function method BeaconKeyEncryptionContext(decryptOnlyEncryptionContext: map<string, string>): (output: map<string, string>)
    requires BranchKeyContext?(decryptOnlyEncryptionContext)
    requires BRANCH_KEY_TYPE_PREFIX < decryptOnlyEncryptionContext[TYPE_FIELD] && BRANCH_KEY_ACTIVE_VERSION_FIELD !in decryptOnlyEncryptionContext
    ensures BranchKeyContext?(output)
    ensures output[TYPE_FIELD] == BEACON_KEY_TYPE_VALUE
    decreases decryptOnlyEncryptionContext
  {
    decryptOnlyEncryptionContext + map[TYPE_FIELD := BEACON_KEY_TYPE_VALUE]
  }

  function method NewVersionFromActiveBranchKeyEncryptionContext(activeBranchKeyEncryptionContext: map<string, string>, branchKeyVersion: string, timestamp: string): (output: map<string, string>)
    requires BranchKeyContext?(activeBranchKeyEncryptionContext)
    requires BRANCH_KEY_ACTIVE_VERSION_FIELD in activeBranchKeyEncryptionContext
    requires 0 < |branchKeyVersion|
    ensures BranchKeyContext?(output)
    ensures BRANCH_KEY_TYPE_PREFIX < output[TYPE_FIELD]
    ensures BRANCH_KEY_ACTIVE_VERSION_FIELD !in output
    decreases activeBranchKeyEncryptionContext, branchKeyVersion, timestamp
  {
    activeBranchKeyEncryptionContext + map[TYPE_FIELD := BRANCH_KEY_TYPE_PREFIX + branchKeyVersion, KEY_CREATE_TIME := timestamp] - {BRANCH_KEY_ACTIVE_VERSION_FIELD}
  }

  predicate method BranchKeyItem?(m: DDB.AttributeMap)
    decreases m
  {
    BRANCH_KEY_IDENTIFIER_FIELD in m &&
    m[BRANCH_KEY_IDENTIFIER_FIELD].S? &&
    TYPE_FIELD in m &&
    m[TYPE_FIELD].S? &&
    KEY_CREATE_TIME in m &&
    m[KEY_CREATE_TIME].S? &&
    HIERARCHY_VERSION in m &&
    m[HIERARCHY_VERSION].N? &&
    TABLE_FIELD !in m &&
    KMS_FIELD in m &&
    m[KMS_FIELD].S? &&
    BRANCH_KEY_FIELD in m &&
    m[BRANCH_KEY_FIELD].B? &&
    0 < |m[BRANCH_KEY_IDENTIFIER_FIELD].S| &&
    0 < |m[TYPE_FIELD].S| &&
    (forall k: seq<char> {:trigger m[k]} {:trigger k in m.Keys - {BRANCH_KEY_FIELD, HIERARCHY_VERSION}} | k in m.Keys - {BRANCH_KEY_FIELD, HIERARCHY_VERSION} :: 
      m[k].S?) &&
    (BRANCH_KEY_ACTIVE_VERSION_FIELD in m <==> true && m[TYPE_FIELD].S == BRANCH_KEY_ACTIVE_TYPE) &&
    (BRANCH_KEY_ACTIVE_VERSION_FIELD in m ==>
      true &&
      BRANCH_KEY_TYPE_PREFIX < m[BRANCH_KEY_ACTIVE_VERSION_FIELD].S) &&
    (BRANCH_KEY_ACTIVE_VERSION_FIELD !in m <==> m[TYPE_FIELD].S == BEACON_KEY_TYPE_VALUE || BRANCH_KEY_TYPE_PREFIX < m[TYPE_FIELD].S) &&
    KMS.IsValid_CiphertextType(m[BRANCH_KEY_FIELD].B)
  }

  predicate method ActiveBranchKeyItem?(m: DDB.AttributeMap)
    decreases m
  {
    BranchKeyItem?(m) &&
    m[TYPE_FIELD].S == BRANCH_KEY_ACTIVE_TYPE &&
    BRANCH_KEY_ACTIVE_VERSION_FIELD in m &&
    m[BRANCH_KEY_ACTIVE_VERSION_FIELD].S? &&
    BRANCH_KEY_TYPE_PREFIX < m[BRANCH_KEY_ACTIVE_VERSION_FIELD].S
  }

  predicate method VersionBranchKeyItem?(m: DDB.AttributeMap)
    decreases m
  {
    BranchKeyItem?(m) &&
    BRANCH_KEY_ACTIVE_VERSION_FIELD !in m &&
    BRANCH_KEY_TYPE_PREFIX < m[TYPE_FIELD].S
  }

  predicate method BeaconKeyItem?(m: DDB.AttributeMap)
    decreases m
  {
    BranchKeyItem?(m) &&
    BRANCH_KEY_ACTIVE_VERSION_FIELD !in m &&
    m[TYPE_FIELD].S == BEACON_KEY_TYPE_VALUE
  }

  lemma BranchKeyItemsDoNotCollide(a: ActiveBranchKeyItem, b: VersionBranchKeyItem, c: BeaconKeyItem)
    requires a[BRANCH_KEY_IDENTIFIER_FIELD] == b[BRANCH_KEY_IDENTIFIER_FIELD] == c[BRANCH_KEY_IDENTIFIER_FIELD]
    ensures a[TYPE_FIELD] != b[TYPE_FIELD]
    ensures a[TYPE_FIELD] != c[TYPE_FIELD]
    ensures c[TYPE_FIELD] != b[TYPE_FIELD]
    decreases a, b, c
  {
  }

  lemma ToAttributeMapIsCorrect(encryptionContext: BranchKeyContext, encryptedKey: seq<uint8>, item: DDB.AttributeMap)
    requires KMS.IsValid_CiphertextType(encryptedKey)
    requires item == ToAttributeMap(encryptionContext, encryptedKey)
    ensures item.Keys == encryptionContext.Keys + {BRANCH_KEY_FIELD} - {TABLE_FIELD}
    ensures item[BRANCH_KEY_FIELD].B == encryptedKey
    ensures (forall k: seq<char> {:trigger encryptionContext[k]} {:trigger item[k]} {:trigger k in item.Keys - {BRANCH_KEY_FIELD, HIERARCHY_VERSION}} | k in item.Keys - {BRANCH_KEY_FIELD, HIERARCHY_VERSION} :: item[k].S? && encryptionContext[k] == item[k].S) && encryptionContext[HIERARCHY_VERSION] == item[HIERARCHY_VERSION].N
    decreases encryptionContext, encryptedKey, item
  {
  }

  lemma ToBranchKeyContextIsCorrect(encryptionContext: map<string, string>, logicalKeyStoreName: string, item: DDB.AttributeMap)
    requires BranchKeyItem?(item)
    requires encryptionContext == ToBranchKeyContext(item, logicalKeyStoreName)
    ensures encryptionContext.Keys == item.Keys - {BRANCH_KEY_FIELD} + {TABLE_FIELD}
    ensures encryptionContext[TABLE_FIELD] == logicalKeyStoreName
    ensures forall k: seq<char> {:trigger item[k]} {:trigger encryptionContext[k]} {:trigger k in encryptionContext.Keys - {BRANCH_KEY_FIELD, TABLE_FIELD}} | k in encryptionContext.Keys - {BRANCH_KEY_FIELD, TABLE_FIELD} :: if k == HIERARCHY_VERSION then encryptionContext[k] == item[k].N else encryptionContext[k] == item[k].S
    ensures BRANCH_KEY_FIELD !in encryptionContext
    decreases encryptionContext, logicalKeyStoreName, item
  {
  }

  lemma EncryptionContextConstructorsAreCorrect(branchKeyId: string, branchKeyVersion: string, timestamp: string, logicalKeyStoreName: string, kmsKeyArn: string, encryptionContext: map<string, string>)
    requires 0 < |branchKeyId|
    requires 0 < |branchKeyVersion|
    requires forall k: seq<char> {:trigger ENCRYPTION_CONTEXT_PREFIX + k} {:trigger k in encryptionContext} | k in encryptionContext :: _default.IsValid_AttributeName(ENCRYPTION_CONTEXT_PREFIX + k)
    ensures ghost var decryptOnly: map<string, string> := DecryptOnlyBranchKeyEncryptionContext(branchKeyId, branchKeyVersion, timestamp, logicalKeyStoreName, kmsKeyArn, encryptionContext); ghost var active: map<string, string> := ActiveBranchKeyEncryptionContext(decryptOnly); ghost var beacon: map<string, string> := BeaconKeyEncryptionContext(decryptOnly); decryptOnly[TYPE_FIELD] != active[TYPE_FIELD] && decryptOnly[TYPE_FIELD] != beacon[TYPE_FIELD] && active[TYPE_FIELD] != beacon[TYPE_FIELD] && (forall k: seq<char> {:trigger beacon[k]} {:trigger active[k]} {:trigger decryptOnly[k]} {:trigger k in decryptOnly.Keys - {TYPE_FIELD}} | k in decryptOnly.Keys - {TYPE_FIELD} :: decryptOnly[k] == active[k] && active[k] == beacon[k]) && active[BRANCH_KEY_ACTIVE_VERSION_FIELD] == decryptOnly[TYPE_FIELD] && forall k: seq<char> {:trigger encryptionContext[k]} {:trigger ENCRYPTION_CONTEXT_PREFIX + k} {:trigger k in encryptionContext} | k in encryptionContext :: ENCRYPTION_CONTEXT_PREFIX + k in decryptOnly && ENCRYPTION_CONTEXT_PREFIX + k in active && ENCRYPTION_CONTEXT_PREFIX + k in beacon && encryptionContext[k] == decryptOnly[ENCRYPTION_CONTEXT_PREFIX + k] && decryptOnly[ENCRYPTION_CONTEXT_PREFIX + k] == active[ENCRYPTION_CONTEXT_PREFIX + k] && active[ENCRYPTION_CONTEXT_PREFIX + k] == beacon[ENCRYPTION_CONTEXT_PREFIX + k]
    decreases branchKeyId, branchKeyVersion, timestamp, logicalKeyStoreName, kmsKeyArn, encryptionContext
  {
  }

  lemma ToAttributeMapAndToBranchKeyContextAreInverse(encryptionContext: map<string, string>, item: DDB.AttributeMap)
    requires BranchKeyItem?(item) && BranchKeyContext?(encryptionContext)
    ensures item == ToAttributeMap(encryptionContext, item[BRANCH_KEY_FIELD].B) <==> ToBranchKeyContext(item, encryptionContext[TABLE_FIELD]) == encryptionContext
    decreases encryptionContext, item
  {
  }
}

module DDBKeystoreOperations {

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import Seq

  import Types = AwsCryptographyKeyStoreTypes

  import DDB = ComAmazonawsDynamodbTypes

  import UTF8

  import Structure
  datatype ConditionExpression = BRANCH_KEY_NOT_EXIST | BRANCH_KEY_EXISTS

  const BRANCH_KEY_EXISTS_EXPRESSION_ATTRIBUTE_NAME := ""#BranchKeyIdentifierField""
  const BRANCH_KEY_EXISTS_EXPRESSION_ATTRIBUTE_NAMES := map[BRANCH_KEY_EXISTS_EXPRESSION_ATTRIBUTE_NAME := Structure.BRANCH_KEY_IDENTIFIER_FIELD]
  const BRANCH_KEY_NOT_EXIST_CONDITION := ""attribute_not_exists("" + BRANCH_KEY_EXISTS_EXPRESSION_ATTRIBUTE_NAME + "")""
  const BRANCH_KEY_EXISTS_CONDITION := ""attribute_exists("" + BRANCH_KEY_EXISTS_EXPRESSION_ATTRIBUTE_NAME + "")""

  method WriteNewKeyToStore(versionBranchKeyItem: Structure.VersionBranchKeyItem, activeBranchKeyItem: Structure.ActiveBranchKeyItem, beaconKeyItem: Structure.BeaconKeyItem, tableName: DDB.TableName, ddbClient: DDB.IDynamoDBClient)
      returns (output: Result<DDB.TransactWriteItemsOutput, Types.Error>)
    requires activeBranchKeyItem[Structure.BRANCH_KEY_IDENTIFIER_FIELD] == versionBranchKeyItem[Structure.BRANCH_KEY_IDENTIFIER_FIELD] == beaconKeyItem[Structure.BRANCH_KEY_IDENTIFIER_FIELD] && activeBranchKeyItem[Structure.BRANCH_KEY_ACTIVE_VERSION_FIELD] == versionBranchKeyItem[Structure.TYPE_FIELD]
    requires ddbClient.ValidState()
    modifies ddbClient.Modifies
    ensures ddbClient.ValidState()
    ensures |ddbClient.History.TransactWriteItems| == |old(ddbClient.History.TransactWriteItems)| + 1 && DDB.TransactWriteItemsInput(TransactItems := [CreateTransactWritePutItem(versionBranchKeyItem, tableName, BRANCH_KEY_NOT_EXIST), CreateTransactWritePutItem(activeBranchKeyItem, tableName, BRANCH_KEY_NOT_EXIST), CreateTransactWritePutItem(beaconKeyItem, tableName, BRANCH_KEY_NOT_EXIST)], ReturnConsumedCapacity := None, ReturnItemCollectionMetrics := None, ClientRequestToken := None) == Seq.Last(ddbClient.History.TransactWriteItems).input && old(ddbClient.History.TransactWriteItems) < ddbClient.History.TransactWriteItems
    ensures output.Success? ==> Seq.Last(ddbClient.History.TransactWriteItems).output.Success?
    ensures Seq.Last(ddbClient.History.TransactWriteItems).output.Failure? ==> output.Failure?
    decreases versionBranchKeyItem, activeBranchKeyItem, beaconKeyItem, tableName, ddbClient
  {
    var items: DDB.TransactWriteItemList := [CreateTransactWritePutItem(versionBranchKeyItem, tableName, BRANCH_KEY_NOT_EXIST), CreateTransactWritePutItem(activeBranchKeyItem, tableName, BRANCH_KEY_NOT_EXIST), CreateTransactWritePutItem(beaconKeyItem, tableName, BRANCH_KEY_NOT_EXIST)];
    var transactRequest := DDB.TransactWriteItemsInput(TransactItems := items, ReturnConsumedCapacity := None, ReturnItemCollectionMetrics := None, ClientRequestToken := None);
    var maybeTransactWriteResponse := ddbClient.TransactWriteItems(transactRequest);
    var transactWriteItemsResponse :- maybeTransactWriteResponse.MapFailure((e: Error) => Types.ComAmazonawsDynamodb(ComAmazonawsDynamodb := e));
    output := Success(transactWriteItemsResponse);
  }

  method WriteNewBranchKeyVersionToKeystore(versionBranchKeyItem: Structure.VersionBranchKeyItem, activeBranchKeyItem: Structure.ActiveBranchKeyItem, tableName: DDB.TableName, ddbClient: DDB.IDynamoDBClient)
      returns (output: Result<DDB.TransactWriteItemsOutput, Types.Error>)
    requires activeBranchKeyItem[Structure.BRANCH_KEY_IDENTIFIER_FIELD] == versionBranchKeyItem[Structure.BRANCH_KEY_IDENTIFIER_FIELD] && activeBranchKeyItem[Structure.BRANCH_KEY_ACTIVE_VERSION_FIELD] == versionBranchKeyItem[Structure.TYPE_FIELD]
    requires ddbClient.ValidState()
    modifies ddbClient.Modifies
    ensures ddbClient.ValidState()
    ensures |ddbClient.History.TransactWriteItems| == |old(ddbClient.History.TransactWriteItems)| + 1 && DDB.TransactWriteItemsInput(TransactItems := [CreateTransactWritePutItem(versionBranchKeyItem, tableName, BRANCH_KEY_NOT_EXIST), CreateTransactWritePutItem(activeBranchKeyItem, tableName, BRANCH_KEY_EXISTS)], ReturnConsumedCapacity := None, ReturnItemCollectionMetrics := None, ClientRequestToken := None) == Seq.Last(ddbClient.History.TransactWriteItems).input
    ensures output.Success? ==> Seq.Last(ddbClient.History.TransactWriteItems).output.Success?
    ensures Seq.Last(ddbClient.History.TransactWriteItems).output.Failure? ==> output.Failure?
    ensures old(ddbClient.History.TransactWriteItems) < ddbClient.History.TransactWriteItems && old(ddbClient.History.GetItem) == ddbClient.History.GetItem
    decreases versionBranchKeyItem, activeBranchKeyItem, tableName, ddbClient
  {
    var items: DDB.TransactWriteItemList := [CreateTransactWritePutItem(versionBranchKeyItem, tableName, BRANCH_KEY_NOT_EXIST), CreateTransactWritePutItem(activeBranchKeyItem, tableName, BRANCH_KEY_EXISTS)];
    var transactRequest := DDB.TransactWriteItemsInput(TransactItems := items, ReturnConsumedCapacity := None, ReturnItemCollectionMetrics := None, ClientRequestToken := None);
    var maybeTransactWriteResponse := ddbClient.TransactWriteItems(transactRequest);
    var transactWriteItemsResponse :- maybeTransactWriteResponse.MapFailure((e: Error) => Types.ComAmazonawsDynamodb(ComAmazonawsDynamodb := e));
    output := Success(transactWriteItemsResponse);
  }

  method GetActiveBranchKeyItem(branchKeyIdentifier: string, tableName: DDB.TableName, ddbClient: DDB.IDynamoDBClient)
      returns (output: Result<Structure.ActiveBranchKeyItem, Types.Error>)
    requires DDB.IsValid_TableName(tableName)
    requires ddbClient.ValidState()
    modifies ddbClient.Modifies
    ensures ddbClient.ValidState()
    ensures |ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).input.Key == map[Structure.BRANCH_KEY_IDENTIFIER_FIELD := DDB.AttributeValue.S(branchKeyIdentifier), Structure.TYPE_FIELD := DDB.AttributeValue.S(Structure.BRANCH_KEY_ACTIVE_TYPE)]
    ensures output.Success? ==> output.value[Structure.BRANCH_KEY_IDENTIFIER_FIELD].S == branchKeyIdentifier && Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && output == Success(Seq.Last(ddbClient.History.GetItem).output.value.Item.value)
    ensures old(ddbClient.History.GetItem) < ddbClient.History.GetItem && old(ddbClient.History.TransactWriteItems) == ddbClient.History.TransactWriteItems
    ensures |ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && !Structure.ActiveBranchKeyItem?(Seq.Last(ddbClient.History.GetItem).output.value.Item.value) ==> output.Failure?
    decreases branchKeyIdentifier, tableName, ddbClient
  {
    var dynamoDbKey: DDB.Key := map[Structure.BRANCH_KEY_IDENTIFIER_FIELD := DDB.AttributeValue.S(branchKeyIdentifier), Structure.TYPE_FIELD := DDB.AttributeValue.S(Structure.BRANCH_KEY_ACTIVE_TYPE)];
    var ItemRequest := DDB.GetItemInput(Key := dynamoDbKey, TableName := tableName, AttributesToGet := None, ConsistentRead := None, ReturnConsumedCapacity := None, ProjectionExpression := None, ExpressionAttributeNames := None);
    var maybeGetItem := ddbClient.GetItem(ItemRequest);
    var getItemResponse :- maybeGetItem.MapFailure((e: Error) => Types.ComAmazonawsDynamodb(ComAmazonawsDynamodb := e));
    :- Need(getItemResponse.Item.Some?, Types.KeyStoreException(message := ""No item found for corresponding branch key identifier.""));
    :- Need(Structure.ActiveBranchKeyItem?(getItemResponse.Item.value) && getItemResponse.Item.value[Structure.BRANCH_KEY_IDENTIFIER_FIELD].S == branchKeyIdentifier, Types.KeyStoreException(message := ""Item found is not a valid active branch key.""));
    output := Success(getItemResponse.Item.value);
  }

  method GetVersionBranchKeyItem(branchKeyIdentifier: string, branchKeyVersion: string, tableName: DDB.TableName, ddbClient: DDB.IDynamoDBClient)
      returns (output: Result<Structure.VersionBranchKeyItem, Types.Error>)
    requires DDB.IsValid_TableName(tableName)
    requires ddbClient.ValidState()
    modifies ddbClient.Modifies
    ensures ddbClient.ValidState()
    ensures |ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).input.Key == map[Structure.BRANCH_KEY_IDENTIFIER_FIELD := DDB.AttributeValue.S(branchKeyIdentifier), Structure.TYPE_FIELD := DDB.AttributeValue.S(Structure.BRANCH_KEY_TYPE_PREFIX + branchKeyVersion)]
    ensures output.Success? ==> output.value[Structure.BRANCH_KEY_IDENTIFIER_FIELD].S == branchKeyIdentifier && output.value[Structure.TYPE_FIELD].S == Structure.BRANCH_KEY_TYPE_PREFIX + branchKeyVersion && Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && output == Success(Seq.Last(ddbClient.History.GetItem).output.value.Item.value)
    ensures |ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && !Structure.VersionBranchKeyItem?(Seq.Last(ddbClient.History.GetItem).output.value.Item.value) ==> output.Failure?
    decreases branchKeyIdentifier, branchKeyVersion, tableName, ddbClient
  {
    var dynamoDbKey: DDB.Key := map[Structure.BRANCH_KEY_IDENTIFIER_FIELD := DDB.AttributeValue.S(branchKeyIdentifier), Structure.TYPE_FIELD := DDB.AttributeValue.S(Structure.BRANCH_KEY_TYPE_PREFIX + branchKeyVersion)];
    var ItemRequest := DDB.GetItemInput(Key := dynamoDbKey, TableName := tableName, AttributesToGet := None, ConsistentRead := None, ReturnConsumedCapacity := None, ProjectionExpression := None, ExpressionAttributeNames := None);
    var maybeGetItem := ddbClient.GetItem(ItemRequest);
    var getItemResponse :- maybeGetItem.MapFailure((e: Error) => Types.ComAmazonawsDynamodb(ComAmazonawsDynamodb := e));
    :- Need(getItemResponse.Item.Some?, Types.KeyStoreException(message := ""No item found for corresponding branch key identifier.""));
    :- Need(Structure.VersionBranchKeyItem?(getItemResponse.Item.value) && getItemResponse.Item.value[Structure.BRANCH_KEY_IDENTIFIER_FIELD].S == branchKeyIdentifier && getItemResponse.Item.value[Structure.TYPE_FIELD].S == Structure.BRANCH_KEY_TYPE_PREFIX + branchKeyVersion, Types.KeyStoreException(message := ""Item found is not a valid branch key version.""));
    output := Success(getItemResponse.Item.value);
  }

  method GetBeaconKeyItem(branchKeyIdentifier: string, tableName: DDB.TableName, ddbClient: DDB.IDynamoDBClient)
      returns (output: Result<Structure.BeaconKeyItem, Types.Error>)
    requires DDB.IsValid_TableName(tableName)
    requires ddbClient.ValidState()
    modifies ddbClient.Modifies
    ensures ddbClient.ValidState()
    ensures output.Success? ==> output.value[Structure.BRANCH_KEY_IDENTIFIER_FIELD].S == branchKeyIdentifier
    ensures |ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).input.Key == map[Structure.BRANCH_KEY_IDENTIFIER_FIELD := DDB.AttributeValue.S(branchKeyIdentifier), Structure.TYPE_FIELD := DDB.AttributeValue.S(Structure.BEACON_KEY_TYPE_VALUE)]
    ensures output.Success? ==> output.value[Structure.BRANCH_KEY_IDENTIFIER_FIELD].S == branchKeyIdentifier && output.value[Structure.TYPE_FIELD].S == Structure.BEACON_KEY_TYPE_VALUE && Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && output == Success(Seq.Last(ddbClient.History.GetItem).output.value.Item.value)
    ensures |ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && !Structure.BeaconKeyItem?(Seq.Last(ddbClient.History.GetItem).output.value.Item.value) ==> output.Failure?
    decreases branchKeyIdentifier, tableName, ddbClient
  {
    var dynamoDbKey: DDB.Key := map[Structure.BRANCH_KEY_IDENTIFIER_FIELD := DDB.AttributeValue.S(branchKeyIdentifier), Structure.TYPE_FIELD := DDB.AttributeValue.S(Structure.BEACON_KEY_TYPE_VALUE)];
    var ItemRequest := DDB.GetItemInput(Key := dynamoDbKey, TableName := tableName, AttributesToGet := None, ConsistentRead := None, ReturnConsumedCapacity := None, ProjectionExpression := None, ExpressionAttributeNames := None);
    var maybeGetItem := ddbClient.GetItem(ItemRequest);
    var getItemResponse :- maybeGetItem.MapFailure((e: Error) => Types.ComAmazonawsDynamodb(ComAmazonawsDynamodb := e));
    :- Need(getItemResponse.Item.Some?, Types.KeyStoreException(message := ""No item found for corresponding branch key identifier.""));
    :- Need(Structure.BeaconKeyItem?(getItemResponse.Item.value) && getItemResponse.Item.value[Structure.BRANCH_KEY_IDENTIFIER_FIELD].S == branchKeyIdentifier, Types.KeyStoreException(message := ""Item found is not a valid beacon key.""));
    output := Success(getItemResponse.Item.value);
  }

  function method CreateTransactWritePutItem(item: DDB.AttributeMap, tableName: DDB.TableName, ConditionExpression: ConditionExpression): (output: DDB.TransactWriteItem)
    decreases item, tableName, ConditionExpression
  {
    DDB.TransactWriteItem(ConditionCheck := None, Put := Some(DDB.Put(Item := item, TableName := tableName, ConditionExpression := Some(match ConditionExpression case BRANCH_KEY_NOT_EXIST() => BRANCH_KEY_NOT_EXIST_CONDITION case BRANCH_KEY_EXISTS() => BRANCH_KEY_EXISTS_CONDITION), ExpressionAttributeNames := Some(BRANCH_KEY_EXISTS_EXPRESSION_ATTRIBUTE_NAMES), ExpressionAttributeValues := None, ReturnValuesOnConditionCheckFailure := None)), Delete := None, Update := None)
  }
}

module {:options ""/functionSyntax:4""} KMSKeystoreOperations {

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import Seq

  import Types = AwsCryptographyKeyStoreTypes

  import DDB = ComAmazonawsDynamodbTypes

  import KMS = ComAmazonawsKmsTypes

  import UTF8

  import Structure
  predicate method AttemptKmsOperation?(kmsConfiguration: Types.KMSConfiguration, encryptionContext: Structure.BranchKeyContext)
    decreases kmsConfiguration, encryptionContext
  {
    match kmsConfiguration
    case kmsKeyArn(arn) =>
      arn == encryptionContext[Structure.KMS_FIELD]
  }

  method GenerateKey(encryptionContext: Structure.BranchKeyContext, kmsConfiguration: Types.KMSConfiguration, grantTokens: KMS.GrantTokenList, kmsClient: KMS.IKMSClient)
      returns (res: Result<KMS.GenerateDataKeyWithoutPlaintextResponse, Types.Error>)
    requires AttemptKmsOperation?(kmsConfiguration, encryptionContext)
    requires kmsClient.ValidState()
    modifies kmsClient.Modifies
    ensures kmsClient.ValidState()
    ensures |kmsClient.History.GenerateDataKeyWithoutPlaintext| == |old(kmsClient.History.GenerateDataKeyWithoutPlaintext)| + 1 && KMS.GenerateDataKeyWithoutPlaintextRequest(KeyId := kmsConfiguration.kmsKeyArn, EncryptionContext := Some(encryptionContext), KeySpec := None, NumberOfBytes := Some(32), GrantTokens := Some(grantTokens)) == Seq.Last(kmsClient.History.GenerateDataKeyWithoutPlaintext).input && old(kmsClient.History.GenerateDataKeyWithoutPlaintext) < kmsClient.History.GenerateDataKeyWithoutPlaintext && old(kmsClient.History.ReEncrypt) == kmsClient.History.ReEncrypt
    ensures res.Success? ==> res.value.KeyId.Some? && res.value.CiphertextBlob.Some? && |res.value.CiphertextBlob.value| == Structure.KMS_GEN_KEY_NO_PLAINTEXT_LENGTH_32 && KMS.IsValid_CiphertextType(res.value.CiphertextBlob.value) && var kmsOperationOutput: Result<GenerateDataKeyWithoutPlaintextResponse, Error> := Seq.Last(kmsClient.History.GenerateDataKeyWithoutPlaintext).output; kmsOperationOutput.Success? && kmsOperationOutput.value == res.value
    decreases encryptionContext, kmsConfiguration, grantTokens, kmsClient
  {
    var generatorRequest := KMS.GenerateDataKeyWithoutPlaintextRequest(KeyId := kmsConfiguration.kmsKeyArn, EncryptionContext := Some(encryptionContext), KeySpec := None, NumberOfBytes := Some(32), GrantTokens := Some(grantTokens));
    var maybeGenerateResponse := kmsClient.GenerateDataKeyWithoutPlaintext(generatorRequest);
    var generateResponse :- maybeGenerateResponse.MapFailure((e: Error) => Types.ComAmazonawsKms(ComAmazonawsKms := e));
    :- Need(true && generateResponse.KeyId.Some?, Types.KeyStoreException(message := ""Invalid response from KMS GenerateDataKey:: Invalid Key Id""));
    :- Need(generateResponse.CiphertextBlob.Some? && |generateResponse.CiphertextBlob.value| == Structure.KMS_GEN_KEY_NO_PLAINTEXT_LENGTH_32 && KMS.IsValid_CiphertextType(generateResponse.CiphertextBlob.value), Types.KeyStoreException(message := ""Invalid response from AWS KMS GeneratedDataKey: Invalid ciphertext""));
    return Success(generateResponse);
  }

  method ReEncryptKey(ciphertext: seq<uint8>, sourceEncryptionContext: Structure.BranchKeyContext, destinationEncryptionContext: Structure.BranchKeyContext, kmsConfiguration: Types.KMSConfiguration, grantTokens: KMS.GrantTokenList, kmsClient: KMS.IKMSClient)
      returns (res: Result<KMS.ReEncryptResponse, Types.Error>)
    requires KMS.IsValid_CiphertextType(ciphertext)
    requires destinationEncryptionContext == sourceEncryptionContext || (Structure.BRANCH_KEY_TYPE_PREFIX < sourceEncryptionContext[Structure.TYPE_FIELD] && Structure.BRANCH_KEY_ACTIVE_VERSION_FIELD !in sourceEncryptionContext && destinationEncryptionContext == Structure.ActiveBranchKeyEncryptionContext(sourceEncryptionContext))
    requires AttemptKmsOperation?(kmsConfiguration, destinationEncryptionContext)
    requires kmsClient.ValidState()
    modifies kmsClient.Modifies
    ensures kmsClient.ValidState()
    ensures |kmsClient.History.ReEncrypt| == |old(kmsClient.History.ReEncrypt)| + 1 && KMS.ReEncryptRequest(CiphertextBlob := ciphertext, SourceEncryptionContext := Some(sourceEncryptionContext), SourceKeyId := Some(kmsConfiguration.kmsKeyArn), DestinationKeyId := kmsConfiguration.kmsKeyArn, DestinationEncryptionContext := Some(destinationEncryptionContext), SourceEncryptionAlgorithm := None, DestinationEncryptionAlgorithm := None, GrantTokens := Some(grantTokens)) == Seq.Last(kmsClient.History.ReEncrypt).input && old(kmsClient.History.ReEncrypt) < kmsClient.History.ReEncrypt && old(kmsClient.History.GenerateDataKeyWithoutPlaintext) == kmsClient.History.GenerateDataKeyWithoutPlaintext
    ensures res.Success? ==> res.value.CiphertextBlob.Some? && res.value.SourceKeyId.Some? && res.value.KeyId.Some? && res.value.SourceKeyId.value == kmsConfiguration.kmsKeyArn && res.value.KeyId.value == kmsConfiguration.kmsKeyArn && KMS.IsValid_CiphertextType(res.value.CiphertextBlob.value) && var kmsOperationOutput: Result<ReEncryptResponse, Error> := Seq.Last(kmsClient.History.ReEncrypt).output; kmsOperationOutput.Success? && kmsOperationOutput.value == res.value
    decreases ciphertext, sourceEncryptionContext, destinationEncryptionContext, kmsConfiguration, grantTokens, kmsClient
  {
    var reEncryptRequest := KMS.ReEncryptRequest(CiphertextBlob := ciphertext, SourceEncryptionContext := Some(sourceEncryptionContext), SourceKeyId := Some(kmsConfiguration.kmsKeyArn), DestinationKeyId := kmsConfiguration.kmsKeyArn, DestinationEncryptionContext := Some(destinationEncryptionContext), SourceEncryptionAlgorithm := None, DestinationEncryptionAlgorithm := None, GrantTokens := Some(grantTokens));
    var maybeReEncryptResponse := kmsClient.ReEncrypt(reEncryptRequest);
    var reEncryptResponse :- maybeReEncryptResponse.MapFailure((e: Error) => Types.ComAmazonawsKms(ComAmazonawsKms := e));
    :- Need(reEncryptResponse.SourceKeyId.Some? && reEncryptResponse.KeyId.Some? && reEncryptResponse.SourceKeyId.value == kmsConfiguration.kmsKeyArn && reEncryptResponse.KeyId.value == kmsConfiguration.kmsKeyArn, Types.KeyStoreException(message := ""Invalid response from KMS GenerateDataKey:: Invalid Key Id""));
    :- Need(reEncryptResponse.CiphertextBlob.Some? && KMS.IsValid_CiphertextType(reEncryptResponse.CiphertextBlob.value), Types.KeyStoreException(message := ""Invalid response from AWS KMS GeneratedDataKey: Invalid ciphertext""));
    return Success(reEncryptResponse);
  }

  method DecryptKey(encryptionContext: Structure.BranchKeyContext, item: Structure.BranchKeyItem, kmsConfiguration: Types.KMSConfiguration, grantTokens: KMS.GrantTokenList, kmsClient: KMS.IKMSClient)
      returns (output: Result<KMS.DecryptResponse, Types.Error>)
    requires AttemptKmsOperation?(kmsConfiguration, encryptionContext)
    requires item == Structure.ToAttributeMap(encryptionContext, item[Structure.BRANCH_KEY_FIELD].B)
    requires kmsClient.ValidState()
    modifies kmsClient.Modifies
    ensures kmsClient.ValidState()
    ensures |kmsClient.History.Decrypt| == |old(kmsClient.History.Decrypt)| + 1 && KMS.DecryptRequest(CiphertextBlob := item[Structure.BRANCH_KEY_FIELD].B, EncryptionContext := Some(encryptionContext), GrantTokens := Some(grantTokens), KeyId := Some(kmsConfiguration.kmsKeyArn), EncryptionAlgorithm := None) == Seq.Last(kmsClient.History.Decrypt).input
    ensures output.Success? ==> Seq.Last(kmsClient.History.Decrypt).output.Success? && output.value == Seq.Last(kmsClient.History.Decrypt).output.value && output.value.Plaintext.Some? && 32 == |output.value.Plaintext.value|
    decreases encryptionContext, item, kmsConfiguration, grantTokens, kmsClient
  {
    var maybeDecryptResponse := kmsClient.Decrypt(KMS.DecryptRequest(CiphertextBlob := item[Structure.BRANCH_KEY_FIELD].B, EncryptionContext := Some(encryptionContext), GrantTokens := Some(grantTokens), KeyId := Some(kmsConfiguration.kmsKeyArn), EncryptionAlgorithm := None));
    var decryptResponse :- maybeDecryptResponse.MapFailure((e: Error) => Types.ComAmazonawsKms(e));
    :- Need(decryptResponse.Plaintext.Some? && 32 == |decryptResponse.Plaintext.value|, Types.KeyStoreException(message := ""Invalid response from AWS KMS Decrypt: Key is not 32 bytes.""));
    output := Success(decryptResponse);
  }
}

module CreateKeyStoreTable {

  import opened StandardLibrary

  import opened Wrappers

  import opened Seq

  import Types = AwsCryptographyKeyStoreTypes

  import DDB = ComAmazonawsDynamodbTypes

  import Structure
  type keyStoreDescription = t: DDB.TableDescription
    | keyStoreHasExpectedConstruction?(t)
    witness *

  const ATTRIBUTE_DEFINITIONS: DDB.AttributeDefinitions := [DDB.AttributeDefinition(AttributeName := Structure.BRANCH_KEY_IDENTIFIER_FIELD, AttributeType := DDB.ScalarAttributeType.S), DDB.AttributeDefinition(AttributeName := Structure.TYPE_FIELD, AttributeType := DDB.ScalarAttributeType.S)]
  const KEY_SCHEMA: DDB.KeySchema := [DDB.KeySchemaElement(AttributeName := Structure.BRANCH_KEY_IDENTIFIER_FIELD, KeyType := DDB.KeyType.HASH), DDB.KeySchemaElement(AttributeName := Structure.TYPE_FIELD, KeyType := DDB.KeyType.RANGE)]

  predicate method keyStoreHasExpectedConstruction?(t: DDB.TableDescription)
    decreases t
  {
    t.AttributeDefinitions.Some? &&
    t.KeySchema.Some? &&
    t.TableName.Some? &&
    t.TableArn.Some? &&
    ToSet(t.AttributeDefinitions.value) >= ToSet(ATTRIBUTE_DEFINITIONS) &&
    ToSet(t.KeySchema.value) >= ToSet(KEY_SCHEMA)
  }

  method CreateKeyStoreTable(tableName: DDB.TableName, ddbClient: DDB.IDynamoDBClient) returns (res: Result<string, Types.Error>)
    requires ddbClient.ValidState()
    requires DDB.IsValid_TableName(tableName)
    modifies ddbClient.Modifies
    ensures ddbClient.ValidState()
    ensures |ddbClient.History.DescribeTable| == |old(ddbClient.History.DescribeTable)| + 1 && Seq.Last(ddbClient.History.DescribeTable).input.TableName == tableName && (Seq.Last(ddbClient.History.DescribeTable).output.Success? ==> |ddbClient.History.CreateTable| == |old(ddbClient.History.CreateTable)|)
    ensures Seq.Last(ddbClient.History.DescribeTable).output.Failure? && Seq.Last(ddbClient.History.DescribeTable).output.error.ResourceNotFoundException? ==> |ddbClient.History.CreateTable| == |old(ddbClient.History.CreateTable)| + 1 && var CreateTableInput: CreateTableInput := Seq.Last(ddbClient.History.CreateTable).input; CreateTableInput.TableName == tableName && CreateTableInput.KeySchema == KEY_SCHEMA && (Seq.Last(ddbClient.History.CreateTable).output.Failure? ==> res.Failure?) && (Seq.Last(ddbClient.History.CreateTable).output.Success? && Seq.Last(ddbClient.History.CreateTable).output.value.TableDescription.Some? && keyStoreHasExpectedConstruction?(Seq.Last(ddbClient.History.CreateTable).output.value.TableDescription.value) ==> res.Success? && res.value == Seq.Last(ddbClient.History.CreateTable).output.value.TableDescription.value.TableArn.value)
    ensures true && Seq.Last(ddbClient.History.DescribeTable).output.Success? ==> var DescribeTableResult: DescribeTableOutput := Seq.Last(ddbClient.History.DescribeTable).output.value; if DescribeTableResult.Table.Some? && keyStoreHasExpectedConstruction?(DescribeTableResult.Table.value) then true && (DescribeTableResult.Table.value.GlobalSecondaryIndexes.Some? || DescribeTableResult.Table.value.GlobalSecondaryIndexes.None?) else true && res.Failure?
    decreases tableName, ddbClient
  {
    var maybeDescribeTableResponse := ddbClient.DescribeTable(DDB.DescribeTableInput(TableName := tableName));
    if maybeDescribeTableResponse.Failure? {
      var error := maybeDescribeTableResponse.error;
      if error.ResourceNotFoundException? {
        var maybeCreateTableResponse := ddbClient.CreateTable(DDB.CreateTableInput(AttributeDefinitions := ATTRIBUTE_DEFINITIONS, TableName := tableName, KeySchema := KEY_SCHEMA, LocalSecondaryIndexes := None, GlobalSecondaryIndexes := None, BillingMode := Some(DDB.BillingMode.PAY_PER_REQUEST), ProvisionedThroughput := None, StreamSpecification := None, SSESpecification := None, Tags := None, TableClass := None));
        if maybeCreateTableResponse.Failure? {
          res := Failure(Types.ComAmazonawsDynamodb(maybeCreateTableResponse.error));
        } else {
          :- Need(maybeCreateTableResponse.value.TableDescription.Some? && keyStoreHasExpectedConstruction?(maybeCreateTableResponse.value.TableDescription.value), E(""Configured table name does not conform to expected Key Store construction.""));
          res := Success(maybeCreateTableResponse.value.TableDescription.value.TableArn.value);
        }
      } else {
        res := Failure(Types.ComAmazonawsDynamodb(error));
      }
    } else {
      :- Need(maybeDescribeTableResponse.value.Table.Some? && keyStoreHasExpectedConstruction?(maybeDescribeTableResponse.value.Table.value), E(""Configured table name does not conform to expected Key Store construction.""));
      res := Success(maybeDescribeTableResponse.value.Table.value.TableArn.value);
    }
  }

  function method E(s: string): Types.Error
    decreases s
  {
    Types.KeyStoreException(message := s)
  }
}

module {:options ""/functionSyntax:4""} CreateKeys {

  import opened StandardLibrary

  import opened Wrappers

  import Structure

  import KMSKeystoreOperations

  import DDBKeystoreOperations

  import opened Seq

  import opened UInt = StandardLibrary.UInt

  import Types = AwsCryptographyKeyStoreTypes

  import DDB = ComAmazonawsDynamodbTypes

  import KMS = ComAmazonawsKmsTypes
  method CreateBranchAndBeaconKeys(branchKeyIdentifier: string, customEncryptionContext: map<string, string>, timestamp: string, branchKeyVersion: string, ddbTableName: DDB.TableName, logicalKeyStoreName: string, kmsConfiguration: Types.KMSConfiguration, grantTokens: KMS.GrantTokenList, kmsClient: KMS.IKMSClient, ddbClient: DDB.IDynamoDBClient)
      returns (output: Result<Types.CreateKeyOutput, Types.Error>)
    requires 0 < |branchKeyIdentifier|
    requires 0 < |branchKeyVersion|
    requires forall k: seq<char> {:trigger Structure.ENCRYPTION_CONTEXT_PREFIX + k} {:trigger k in customEncryptionContext} | k in customEncryptionContext :: _default.IsValid_AttributeName(Structure.ENCRYPTION_CONTEXT_PREFIX + k)
    requires ddbClient.Modifies !! kmsClient.Modifies
    requires kmsClient.ValidState() && ddbClient.ValidState()
    modifies ddbClient.Modifies, kmsClient.Modifies
    ensures ddbClient.ValidState() && kmsClient.ValidState()
    ensures output.Success? ==> |kmsClient.History.GenerateDataKeyWithoutPlaintext| == |old(kmsClient.History.GenerateDataKeyWithoutPlaintext)| + 2 && |kmsClient.History.ReEncrypt| == |old(kmsClient.History.ReEncrypt)| + 1 && var decryptOnlyEncryptionContext: map<string, string> := Structure.DecryptOnlyBranchKeyEncryptionContext(branchKeyIdentifier, branchKeyVersion, timestamp, logicalKeyStoreName, kmsConfiguration.kmsKeyArn, customEncryptionContext); decryptOnlyEncryptionContext[Structure.TABLE_FIELD] == logicalKeyStoreName && WrappedBranchKeyCreation?(Seq.Last(Seq.DropLast(kmsClient.History.GenerateDataKeyWithoutPlaintext)), Seq.Last(kmsClient.History.ReEncrypt), kmsClient, kmsConfiguration, grantTokens, decryptOnlyEncryptionContext) && var beaconKmsInput: GenerateDataKeyWithoutPlaintextRequest := Seq.Last(kmsClient.History.GenerateDataKeyWithoutPlaintext).input; beaconKmsInput.KeyId == kmsConfiguration.kmsKeyArn && beaconKmsInput.NumberOfBytes == Some(32) && beaconKmsInput.EncryptionContext == Some(Structure.BeaconKeyEncryptionContext(decryptOnlyEncryptionContext)) && beaconKmsInput.GrantTokens == Some(grantTokens) && Seq.Last(kmsClient.History.GenerateDataKeyWithoutPlaintext).output.Success? && var beaconKmsOutput: GenerateDataKeyWithoutPlaintextResponse := Seq.Last(kmsClient.History.GenerateDataKeyWithoutPlaintext).output.value; beaconKmsOutput.CiphertextBlob.Some? && |ddbClient.History.TransactWriteItems| == |old(ddbClient.History.TransactWriteItems)| + 1 && var writeNewKey: TransactWriteItemsInput := Seq.Last(ddbClient.History.TransactWriteItems).input; 3 == |writeNewKey.TransactItems| && writeNewKey.TransactItems[0].Put.Some? && writeNewKey.TransactItems[0].Put.value.Item == Structure.ToAttributeMap(decryptOnlyEncryptionContext, Seq.Last(Seq.DropLast(kmsClient.History.GenerateDataKeyWithoutPlaintext)).output.value.CiphertextBlob.value) && writeNewKey.TransactItems[1].Put.Some? && writeNewKey.TransactItems[1].Put.value.Item == Structure.ToAttributeMap(Structure.ActiveBranchKeyEncryptionContext(decryptOnlyEncryptionContext), Seq.Last(kmsClient.History.ReEncrypt).output.value.CiphertextBlob.value) && writeNewKey.TransactItems[2].Put.Some? && writeNewKey.TransactItems[2].Put.value.Item == Structure.ToAttributeMap(Structure.BeaconKeyEncryptionContext(decryptOnlyEncryptionContext), beaconKmsOutput.CiphertextBlob.value) && Seq.Last(ddbClient.History.TransactWriteItems).output.Success? && output.value.branchKeyIdentifier == branchKeyIdentifier
    ensures (|kmsClient.History.GenerateDataKeyWithoutPlaintext| == |old(kmsClient.History.GenerateDataKeyWithoutPlaintext)| + 1 && Seq.Last(kmsClient.History.GenerateDataKeyWithoutPlaintext).output.Failure? ==> output.Failure?) || (|kmsClient.History.ReEncrypt| == |old(kmsClient.History.ReEncrypt)| + 1 && Seq.Last(kmsClient.History.ReEncrypt).output.Failure? ==> output.Failure?) || (|kmsClient.History.GenerateDataKeyWithoutPlaintext| == |old(kmsClient.History.GenerateDataKeyWithoutPlaintext)| + 2 && Seq.Last(kmsClient.History.GenerateDataKeyWithoutPlaintext).output.Failure? ==> output.Failure?) || (|ddbClient.History.TransactWriteItems| == |old(ddbClient.History.TransactWriteItems)| + 1 && Seq.Last(ddbClient.History.TransactWriteItems).output.Failure? ==> output.Failure?)
    decreases branchKeyIdentifier, customEncryptionContext, timestamp, branchKeyVersion, ddbTableName, logicalKeyStoreName, kmsConfiguration, grantTokens, kmsClient, ddbClient
  {
    var decryptOnlyEncryptionContext := Structure.DecryptOnlyBranchKeyEncryptionContext(branchKeyIdentifier, branchKeyVersion, timestamp, logicalKeyStoreName, kmsConfiguration.kmsKeyArn, customEncryptionContext);
    var activeEncryptionContext := Structure.ActiveBranchKeyEncryptionContext(decryptOnlyEncryptionContext);
    var beaconEncryptionContext := Structure.BeaconKeyEncryptionContext(decryptOnlyEncryptionContext);
    var wrappedDecryptOnlyBranchKey :- KMSKeystoreOperations.GenerateKey(decryptOnlyEncryptionContext, kmsConfiguration, grantTokens, kmsClient);
    var wrappedActiveBranchKey :- KMSKeystoreOperations.ReEncryptKey(wrappedDecryptOnlyBranchKey.CiphertextBlob.value, decryptOnlyEncryptionContext, activeEncryptionContext, kmsConfiguration, grantTokens, kmsClient);
    var wrappedBeaconKey :- KMSKeystoreOperations.GenerateKey(beaconEncryptionContext, kmsConfiguration, grantTokens, kmsClient);
    var decryptOnlyBranchKeyItem := Structure.ToAttributeMap(decryptOnlyEncryptionContext, wrappedDecryptOnlyBranchKey.CiphertextBlob.value);
    var activeBranchKeyItem := Structure.ToAttributeMap(activeEncryptionContext, wrappedActiveBranchKey.CiphertextBlob.value);
    var beaconKeyItem := Structure.ToAttributeMap(beaconEncryptionContext, wrappedBeaconKey.CiphertextBlob.value);
    var _ /* _v0 */ :- DDBKeystoreOperations.WriteNewKeyToStore(decryptOnlyBranchKeyItem, activeBranchKeyItem, beaconKeyItem, ddbTableName, ddbClient);
    output := Success(Types.CreateKeyOutput(branchKeyIdentifier := branchKeyIdentifier));
  }

  method VersionActiveBranchKey(input: Types.VersionKeyInput, timestamp: string, branchKeyVersion: string, ddbTableName: DDB.TableName, logicalKeyStoreName: string, kmsConfiguration: Types.KMSConfiguration, grantTokens: KMS.GrantTokenList, kmsClient: KMS.IKMSClient, ddbClient: DDB.IDynamoDBClient)
      returns (output: Result<Types.VersionKeyOutput, Types.Error>)
    requires 0 < |input.branchKeyIdentifier| && 0 < |branchKeyVersion|
    requires ddbClient.Modifies !! kmsClient.Modifies
    requires kmsClient.ValidState() && ddbClient.ValidState()
    modifies ddbClient.Modifies, kmsClient.Modifies
    ensures ddbClient.ValidState() && kmsClient.ValidState()
    ensures output.Success? ==> |ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).input.Key == map[Structure.BRANCH_KEY_IDENTIFIER_FIELD := DDB.AttributeValue.S(input.branchKeyIdentifier), Structure.TYPE_FIELD := DDB.AttributeValue.S(Structure.BRANCH_KEY_ACTIVE_TYPE)] && Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && var oldActiveItem: AttributeMap := Seq.Last(ddbClient.History.GetItem).output.value.Item.value; Structure.BranchKeyItem?(oldActiveItem) && Structure.BRANCH_KEY_ACTIVE_VERSION_FIELD in oldActiveItem && KMSKeystoreOperations.AttemptKmsOperation?(kmsConfiguration, Structure.ToBranchKeyContext(oldActiveItem, logicalKeyStoreName)) && |kmsClient.History.ReEncrypt| == |old(kmsClient.History.ReEncrypt)| + 2 && var reEncryptInput: ReEncryptRequest := Seq.Last(Seq.DropLast(kmsClient.History.ReEncrypt)).input; reEncryptInput.SourceEncryptionContext == Some(Structure.ToBranchKeyContext(oldActiveItem, logicalKeyStoreName)) && reEncryptInput.SourceKeyId == Some(kmsConfiguration.kmsKeyArn) && reEncryptInput.CiphertextBlob == oldActiveItem[Structure.BRANCH_KEY_FIELD].B && reEncryptInput.GrantTokens == Some(grantTokens) && reEncryptInput.DestinationKeyId == kmsConfiguration.kmsKeyArn && reEncryptInput.DestinationEncryptionContext == Some(Structure.ToBranchKeyContext(oldActiveItem, logicalKeyStoreName)) && |kmsClient.History.GenerateDataKeyWithoutPlaintext| == |old(kmsClient.History.GenerateDataKeyWithoutPlaintext)| + 1 && var decryptOnlyEncryptionContext: map<string, string> := Structure.NewVersionFromActiveBranchKeyEncryptionContext(Structure.ToBranchKeyContext(oldActiveItem, logicalKeyStoreName), branchKeyVersion, timestamp); WrappedBranchKeyCreation?(Seq.Last(kmsClient.History.GenerateDataKeyWithoutPlaintext), Seq.Last(kmsClient.History.ReEncrypt), kmsClient, kmsConfiguration, grantTokens, decryptOnlyEncryptionContext) && |ddbClient.History.TransactWriteItems| == |old(ddbClient.History.TransactWriteItems)| + 1 && var writeNewKey: TransactWriteItemsInput := Seq.Last(ddbClient.History.TransactWriteItems).input; 2 == |writeNewKey.TransactItems| && writeNewKey.TransactItems[0].Put.Some? && writeNewKey.TransactItems[0].Put.value.Item == Structure.ToAttributeMap(decryptOnlyEncryptionContext, Seq.Last(kmsClient.History.GenerateDataKeyWithoutPlaintext).output.value.CiphertextBlob.value) && writeNewKey.TransactItems[1].Put.Some? && writeNewKey.TransactItems[1].Put.value.Item == Structure.ToAttributeMap(Structure.ActiveBranchKeyEncryptionContext(decryptOnlyEncryptionContext), Seq.Last(kmsClient.History.ReEncrypt).output.value.CiphertextBlob.value) && Seq.Last(ddbClient.History.TransactWriteItems).output.Success? && output == Success(Types.VersionKeyOutput)
    ensures (|kmsClient.History.ReEncrypt| == |old(kmsClient.History.ReEncrypt)| + 1 && Seq.Last(kmsClient.History.ReEncrypt).output.Failure? ==> output.Failure?) || (|kmsClient.History.GenerateDataKeyWithoutPlaintext| == |old(kmsClient.History.GenerateDataKeyWithoutPlaintext)| + 1 && Seq.Last(kmsClient.History.GenerateDataKeyWithoutPlaintext).output.Failure? ==> output.Failure?) || (|kmsClient.History.ReEncrypt| == |old(kmsClient.History.ReEncrypt)| + 2 && Seq.Last(kmsClient.History.ReEncrypt).output.Failure? ==> output.Failure?) || (|ddbClient.History.TransactWriteItems| == |old(ddbClient.History.TransactWriteItems)| + 1 && Seq.Last(ddbClient.History.TransactWriteItems).output.Failure? ==> output.Failure?)
    decreases input, timestamp, branchKeyVersion, ddbTableName, logicalKeyStoreName, kmsConfiguration, grantTokens, kmsClient, ddbClient
  {
    var oldActiveItem :- DDBKeystoreOperations.GetActiveBranchKeyItem(input.branchKeyIdentifier, ddbTableName, ddbClient);
    var oldActiveEncryptionContext := Structure.ToBranchKeyContext(oldActiveItem, logicalKeyStoreName);
    :- Need(true && KMSKeystoreOperations.AttemptKmsOperation?(kmsConfiguration, oldActiveEncryptionContext), Types.KeyStoreException(message := ""Wrapping AWS KMS key in dynamodb does not match configured AWS KMS information.""));
    var _ /* _v1 */ :- KMSKeystoreOperations.ReEncryptKey(oldActiveItem[Structure.BRANCH_KEY_FIELD].B, oldActiveEncryptionContext, oldActiveEncryptionContext, kmsConfiguration, grantTokens, kmsClient);
    var decryptOnlyEncryptionContext := Structure.NewVersionFromActiveBranchKeyEncryptionContext(oldActiveEncryptionContext, branchKeyVersion, timestamp);
    var activeEncryptionContext := Structure.ActiveBranchKeyEncryptionContext(decryptOnlyEncryptionContext);
    var wrappedDecryptOnlyBranchKey :- KMSKeystoreOperations.GenerateKey(decryptOnlyEncryptionContext, kmsConfiguration, grantTokens, kmsClient);
    var wrappedActiveBranchKey :- KMSKeystoreOperations.ReEncryptKey(wrappedDecryptOnlyBranchKey.CiphertextBlob.value, decryptOnlyEncryptionContext, activeEncryptionContext, kmsConfiguration, grantTokens, kmsClient);
    var decryptOnlyBranchKeyItem: Structure.VersionBranchKeyItem := Structure.ToAttributeMap(decryptOnlyEncryptionContext, wrappedDecryptOnlyBranchKey.CiphertextBlob.value);
    var activeBranchKeyItem: Structure.ActiveBranchKeyItem := Structure.ToAttributeMap(activeEncryptionContext, wrappedActiveBranchKey.CiphertextBlob.value);
    var _ /* _v2 */ :- DDBKeystoreOperations.WriteNewBranchKeyVersionToKeystore(decryptOnlyBranchKeyItem, activeBranchKeyItem, ddbTableName, ddbClient);
    assert true && |ddbClient.History.TransactWriteItems| == |old(ddbClient.History.TransactWriteItems)| + 1;
    output := Success(Types.VersionKeyOutput());
  }

  predicate WrappedBranchKeyCreation?(generateHistory: KMS.DafnyCallEvent<KMS.GenerateDataKeyWithoutPlaintextRequest, Result<KMS.GenerateDataKeyWithoutPlaintextResponse, KMS.Error>>, reEncryptHistory: KMS.DafnyCallEvent<KMS.ReEncryptRequest, Result<KMS.ReEncryptResponse, KMS.Error>>, kmsClient: KMS.IKMSClient, kmsConfiguration: Types.KMSConfiguration, grantTokens: KMS.GrantTokenList, decryptOnlyEncryptionContext: map<string, string>)
    requires Structure.BranchKeyContext?(decryptOnlyEncryptionContext)
    requires Structure.BRANCH_KEY_TYPE_PREFIX < decryptOnlyEncryptionContext[Structure.TYPE_FIELD]
    requires generateHistory in kmsClient.History.GenerateDataKeyWithoutPlaintext
    requires reEncryptHistory in kmsClient.History.ReEncrypt
    reads kmsClient.History
    decreases {kmsClient.History}, generateHistory, reEncryptHistory, kmsClient, kmsConfiguration, grantTokens, decryptOnlyEncryptionContext
  {
    true &&
    ghost var decryptOnlyKmsInput: KMS.GenerateDataKeyWithoutPlaintextRequest := generateHistory.input; decryptOnlyKmsInput.KeyId == kmsConfiguration.kmsKeyArn && decryptOnlyKmsInput.NumberOfBytes == Some(32) && decryptOnlyKmsInput.EncryptionContext == Some(decryptOnlyEncryptionContext) && decryptOnlyKmsInput.GrantTokens == Some(grantTokens) && generateHistory.output.Success? && generateHistory.output.value.CiphertextBlob.Some? && ghost var activeInput: KMS.ReEncryptRequest := reEncryptHistory.input; activeInput.SourceKeyId == Some(kmsConfiguration.kmsKeyArn) && activeInput.DestinationKeyId == kmsConfiguration.kmsKeyArn && activeInput.GrantTokens == Some(grantTokens) && activeInput.CiphertextBlob == generateHistory.output.value.CiphertextBlob.value && activeInput.SourceEncryptionContext == Some(decryptOnlyEncryptionContext) && activeInput.DestinationEncryptionContext == Some(Structure.ActiveBranchKeyEncryptionContext(decryptOnlyEncryptionContext)) && reEncryptHistory.output.Success? && reEncryptHistory.output.value.CiphertextBlob.Some?
  }
}

module StrictMultiKeyring {

  import opened Wrappers

  import Seq

  import Types = AwsCryptographyMaterialProvidersTypes

  import KMS = Types.ComAmazonawsKmsTypes

  import MultiKeyring

  import AwsArnParsing

  import AwsKmsMrkAreUnique

  import AwsKmsKeyring

  import opened AwsKmsUtils
  method {:vcs_split_on_every_assert} StrictMultiKeyring(generator: Option<string>, awsKmsKeys: Option<seq<string>>, clientSupplier: Types.IClientSupplier, grantTokens: Option<KMS.GrantTokenList>)
      returns (output: Result<MultiKeyring.MultiKeyring, Types.Error>)
    requires clientSupplier.ValidState()
    modifies clientSupplier.Modifies
    ensures output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.History) && fresh(output.value.Modifies - clientSupplier.Modifies)
    ensures (generator.Some? && generator.value == """") || (awsKmsKeys.Some? && exists k: seq<char> {:trigger k in awsKmsKeys.value} | k in awsKmsKeys.value :: k == """") ==> output.Failure?
    ensures var allStrings: seq<seq<char>> := if generator.Some? then [generator.value] + awsKmsKeys.UnwrapOr([]) else awsKmsKeys.UnwrapOr([]); var allIdentifiers: Result<seq<AwsKmsIdentifier>, string> := Seq.MapWithResult(AwsArnParsing.IsAwsKmsIdentifierString, allStrings); true && allIdentifiers.Failure? ==> output.Failure?
    ensures true && output.Success? ==> (generator.Some? ==> output.value.generatorKeyring.Some? && output.value.generatorKeyring.value is AwsKmsKeyring.AwsKmsKeyring && var g: AwsKmsKeyring.AwsKmsKeyring := output.value.generatorKeyring.value as AwsKmsKeyring.AwsKmsKeyring; g.awsKmsKey == generator.value && (grantTokens.Some? ==> g.grantTokens == grantTokens.value)) && (generator.None? ==> true && output.value.generatorKeyring.None?) && (awsKmsKeys.Some? ==> |awsKmsKeys.value| == |output.value.childKeyrings| && forall index: int {:trigger awsKmsKeys.value[index]} {:trigger output.value.childKeyrings[index]} | 0 <= index < |awsKmsKeys.value| :: var childKeyring: Types.IKeyring := output.value.childKeyrings[index]; childKeyring is AwsKmsKeyring.AwsKmsKeyring && var awsKmsChild: AwsKmsKeyring.AwsKmsKeyring := childKeyring as AwsKmsKeyring.AwsKmsKeyring; awsKmsChild.awsKmsKey == awsKmsKeys.value[index] && (grantTokens.Some? ==> awsKmsChild.grantTokens == grantTokens.value)) && (awsKmsKeys.None? ==> true && output.value.childKeyrings == [])
    decreases generator, awsKmsKeys, clientSupplier, grantTokens
  {
    var allStrings := match generator { case Some(g) => [g] + awsKmsKeys.UnwrapOr([]) case None() => awsKmsKeys.UnwrapOr([]) };
    assert generator.Some? ==> generator.value in allStrings;
    assert awsKmsKeys.Some? ==> forall k: seq<char> {:trigger k in allStrings} {:trigger k in awsKmsKeys.value} | k in awsKmsKeys.value :: k in allStrings;
    var allIdentifiers :- Seq.MapWithResult(AwsArnParsing.IsAwsKmsIdentifierString, allStrings).MapFailure(WrapStringToError);
    var generatorKeyring: Option<AwsKmsKeyring.AwsKmsKeyring>;
    match generator {
      case {:split false} Some(generatorIdentifier) =>
        var arn :- AwsArnParsing.IsAwsKmsIdentifierString(generatorIdentifier).MapFailure(WrapStringToError);
        var region := AwsArnParsing.GetRegion(arn);
        var client :- clientSupplier.GetClient(Types.GetClientInput(region := region.UnwrapOr("""")));
        var g := new AwsKmsKeyring.AwsKmsKeyring(client, generatorIdentifier, grantTokens.UnwrapOr([]));
        generatorKeyring := Some(g);
      case {:split false} None() =>
        generatorKeyring := None();
    }
    var children: seq<AwsKmsKeyring.AwsKmsKeyring> := [];
    match awsKmsKeys {
      case {:split false} Some(childIdentifiers) =>
        for index: int := 0 to |childIdentifiers|
          invariant |awsKmsKeys.value[..index]| == |children|
          invariant fresh(MultiKeyring.GatherModifies(generatorKeyring, children) - clientSupplier.Modifies)
          invariant forall i: int {:trigger awsKmsKeys.value[i]} {:trigger children[i]} | 0 <= i < |children[..index]| :: children[i].awsKmsKey == awsKmsKeys.value[i] && (grantTokens.Some? ==> children[i].grantTokens == grantTokens.value) && children[i].ValidState()
        {
          var childIdentifier := childIdentifiers[index];
          var info :- AwsArnParsing.IsAwsKmsIdentifierString(childIdentifier).MapFailure(WrapStringToError);
          var region := AwsArnParsing.GetRegion(info);
          var client :- clientSupplier.GetClient(Types.GetClientInput(region := region.UnwrapOr("""")));
          var keyring := new AwsKmsKeyring.AwsKmsKeyring(client, childIdentifier, grantTokens.UnwrapOr([]));
          children := children + [keyring];
        }
      case {:split false} None() =>
        children := [];
    }
    :- Need(generatorKeyring.Some? || |children| > 0, Types.AwsCryptographicMaterialProvidersException(message := ""generatorKeyring or child Keryings needed to create a multi keyring""));
    var keyring := new MultiKeyring.MultiKeyring(generatorKeyring, children);
    return Success(keyring);
  }
}

module MultiKeyring {

  import opened StandardLibrary

  import opened Wrappers

  import Types = AwsCryptographyMaterialProvidersTypes

  import Keyring

  import Materials

  import UTF8

  import Seq
  class MultiKeyring extends Keyring.VerifiableInterface, Types.IKeyring {
    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      (generatorKeyring.Some? ==>
        History !in generatorKeyring.value.Modifies &&
        generatorKeyring.value.ValidState() &&
        generatorKeyring.value.Modifies <= Modifies) &&
      forall k: Types.IKeyring {:trigger k.ValidState()} {:trigger k.Modifies} {:trigger k in childKeyrings} | k in childKeyrings :: 
        History !in k.Modifies &&
        k.ValidState() &&
        k.Modifies <= Modifies
    }

    const generatorKeyring: Option<Types.IKeyring>
    const childKeyrings: seq<Types.IKeyring>

    constructor (generatorKeyring: Option<Types.IKeyring>, childKeyrings: seq<Types.IKeyring>)
      requires generatorKeyring.Some? || |childKeyrings| > 0
      requires (generatorKeyring.Some? ==> generatorKeyring.value.ValidState()) && forall k: Types.IKeyring {:trigger k.ValidState()} {:trigger k in childKeyrings} | k in childKeyrings :: k.ValidState()
      requires |childKeyrings| == 0 ==> generatorKeyring.Some?
      requires generatorKeyring.None? ==> |childKeyrings| > 0
      ensures this.generatorKeyring == generatorKeyring
      ensures this.childKeyrings == childKeyrings
      ensures ValidState() && fresh(this) && fresh(History) && fresh(Modifies - GatherModifies(generatorKeyring, childKeyrings))
      decreases generatorKeyring, childKeyrings
    {
      this.generatorKeyring := generatorKeyring;
      this.childKeyrings := childKeyrings;
      History := new Types.IKeyringCallHistory();
      Modifies := {History} + GatherModifies(generatorKeyring, childKeyrings);
      new;
      assert true && History in Modifies;
      assert true && (generatorKeyring.Some? ==> History !in generatorKeyring.value.Modifies && generatorKeyring.value.ValidState() && generatorKeyring.value.Modifies <= Modifies);
      assert true && forall k: Types.IKeyring {:trigger k.ValidState()} {:trigger k.Modifies} {:trigger k in childKeyrings} | k in childKeyrings :: History !in k.Modifies && k.ValidState() && k.Modifies <= Modifies;
    }

    predicate OnEncryptEnsuresPublicly(input: Types.OnEncryptInput, output: Result<Types.OnEncryptOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method OnEncrypt'(input: Types.OnEncryptInput) returns (res: Result<Types.OnEncryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnEncryptEnsuresPublicly(input, res)
      ensures unchanged(History)
      ensures res.Success? ==> true && Materials.ValidEncryptionMaterialsTransition(input.materials, res.value.materials)
      ensures res.Success? ==> true && res.value.materials.plaintextDataKey.Some?
      ensures this.generatorKeyring.None? && input.materials.plaintextDataKey.None? ==> res.Failure?
      ensures this.generatorKeyring.Some? && input.materials.plaintextDataKey.Some? ==> res.Failure?
      decreases Modifies - {History}
    {
      if this.generatorKeyring.None? && input.materials.plaintextDataKey.None? {
        var exception := ""Need either a generator keyring or input encryption materials which contain a plaintext data key"";
        return Failure(Types.AwsCryptographicMaterialProvidersException(message := exception));
      }
      var returnMaterials := input.materials;
      if this.generatorKeyring.Some? {
        :- Need(input.materials.plaintextDataKey.None?, Types.AwsCryptographicMaterialProvidersException(message := ""This multi keyring has a generator but provided Encryption Materials already contain plaintext data key""));
        var onEncryptOutput := this.generatorKeyring.value.OnEncrypt(input);
        :- Need(onEncryptOutput.Success?, Types.AwsCryptographicMaterialProvidersException(message := ""Generator keyring failed to generate plaintext data key""));
        :- Need(Materials.ValidEncryptionMaterialsTransition(input.materials, onEncryptOutput.value.materials), Types.AwsCryptographicMaterialProvidersException(message := ""Generator keyring returned invalid encryption materials""));
        returnMaterials := onEncryptOutput.value.materials;
      }
      for i: int := 0 to |this.childKeyrings|
        invariant returnMaterials.plaintextDataKey.Some?
        invariant unchanged(History)
        invariant i < |this.childKeyrings| ==> this.childKeyrings[i].Modifies <= Modifies
      {
        var onEncryptInput := Types.OnEncryptInput(materials := returnMaterials);
        var onEncryptOutput := this.childKeyrings[i].OnEncrypt(onEncryptInput);
        :- Need(onEncryptOutput.Success?, Types.AwsCryptographicMaterialProvidersException(message := ""Child keyring failed to encrypt plaintext data key""));
        :- Need(Materials.ValidEncryptionMaterialsTransition(returnMaterials, onEncryptOutput.value.materials), Types.AwsCryptographicMaterialProvidersException(message := ""Child keyring performed invalid transition on encryption materials""));
        returnMaterials := onEncryptOutput.value.materials;
      }
      :- Need(Materials.ValidEncryptionMaterialsTransition(input.materials, returnMaterials), Types.AwsCryptographicMaterialProvidersException(message := ""A child or generator keyring modified the encryption materials in illegal ways.""));
      return Success(Types.OnEncryptOutput(materials := returnMaterials));
    }

    predicate OnDecryptEnsuresPublicly(input: Types.OnDecryptInput, output: Result<Types.OnDecryptOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method OnDecrypt'(input: Types.OnDecryptInput) returns (res: Result<Types.OnDecryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnDecryptEnsuresPublicly(input, res)
      ensures unchanged(History)
      ensures res.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, res.value.materials)
      ensures Materials.DecryptionMaterialsWithPlaintextDataKey(input.materials) ==> res.Failure?
      decreases Modifies - {History}
    {
      var materials := input.materials;
      :- Need(Materials.DecryptionMaterialsWithoutPlaintextDataKey(input.materials), Types.AwsCryptographicMaterialProvidersException(message := ""Keyring received decryption materials that already contain a plaintext data key.""));
      var failures: seq<Types.Error> := [];
      if this.generatorKeyring.Some? {
        var result := AttemptDecryptDataKey(this.generatorKeyring.value, input);
        if result.Success? {
          if result.value.materials.plaintextDataKey.Some? {
            return Success(result.value);
          }
        } else {
          failures := failures + [result.error];
        }
      }
      for j: int := 0 to |this.childKeyrings|
        invariant Materials.DecryptionMaterialsWithoutPlaintextDataKey(materials)
        invariant unchanged(History)
      {
        var result := AttemptDecryptDataKey(this.childKeyrings[j], input);
        if result.Success? {
          return Success(result.value);
        } else {
          failures := failures + [result.error];
        }
      }
      var combinedResult := Types.CollectionOfErrors(list := failures, message := ""No Configured Keyring was able to decrypt the Data Key. The list of encountered Exceptions is available via `list`."");
      return Failure(combinedResult);
    }
  }

  method AttemptDecryptDataKey(keyring: Types.IKeyring, input: Types.OnDecryptInput) returns (res: Result<Types.OnDecryptOutput, Types.Error>)
    requires keyring.ValidState()
    modifies keyring.Modifies
    ensures keyring.ValidState()
    ensures res.Success? ==> res.value.materials.plaintextDataKey.Some? && Materials.DecryptionMaterialsTransitionIsValid(input.materials, res.value.materials)
    decreases keyring, input
  {
    var output :- keyring.OnDecrypt(input);
    :- Need(Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.materials), Types.AwsCryptographicMaterialProvidersException(message := ""Keyring performed invalid material transition""));
    return Success(output);
  }

  function GatherModifies(generatorKeyring: Option<Types.IKeyring>, childKeyrings: seq<Types.IKeyring>): (mod: set<object>)
    decreases generatorKeyring, childKeyrings
  {
    (set k: Types.IKeyring, m: object {:trigger m in k.Modifies} | k in childKeyrings && m in k.Modifies :: m) + if generatorKeyring.Some? then generatorKeyring.value.Modifies else {}
  }
}

module Keyring {

  import opened Wrappers

  import Types = AwsCryptographyMaterialProvidersTypes

  import Materials
  trait {:termination false} VerifiableInterface extends Types.IKeyring {
    method OnEncrypt'(input: Types.OnEncryptInput) returns (output: Result<Types.OnEncryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnEncryptEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures output.Success? ==> true && Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
      decreases Modifies - {History}

    method OnDecrypt'(input: Types.OnDecryptInput) returns (output: Result<Types.OnDecryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnDecryptEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures output.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
      decreases Modifies - {History}
  }
}

module Materials {

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import Base64

  import UTF8

  import Types = AwsCryptographyMaterialProvidersTypes

  import AS = AlgorithmSuites
  type DecryptionMaterialsPendingPlaintextDataKey = d: Types.DecryptionMaterials
    | DecryptionMaterialsWithoutPlaintextDataKey(d)
    witness *

  type SealedDecryptionMaterials = d: Types.DecryptionMaterials
    | DecryptionMaterialsWithPlaintextDataKey(d)
    witness *

  const EC_PUBLIC_KEY_FIELD: UTF8.ValidUTF8Bytes := var s: seq<BoundedInts.uint8> := [97, 119, 115, 45, 99, 114, 121, 112, 116, 111, 45, 112, 117, 98, 108, 105, 99, 45, 107, 101, 121]; assert UTF8.ValidUTF8Range(s, 0, 21); s
  const RESERVED_KEY_VALUES := {EC_PUBLIC_KEY_FIELD}

  function method InitializeEncryptionMaterials(input: Types.InitializeEncryptionMaterialsInput): (res: Result<Types.EncryptionMaterials, Types.Error>)
    ensures true && res.Success? ==> ValidEncryptionMaterials(res.value) && var suite: AlgorithmSuite := AS.GetSuite(input.algorithmSuiteId); res.value.algorithmSuite == suite && (!suite.signature.None? <==> EC_PUBLIC_KEY_FIELD in res.value.encryptionContext) && (suite.signature.None? <==> res.value.signingKey.None?)
    ensures true && EC_PUBLIC_KEY_FIELD in input.encryptionContext ==> true && res.Failure?
    decreases input
  {
    Need(EC_PUBLIC_KEY_FIELD !in input.encryptionContext, Types.AwsCryptographicMaterialProvidersException(message := ""Encryption Context "")); Need(forall key: ValidUTF8Bytes {:trigger key in input.encryptionContext} {:trigger key in input.requiredEncryptionContextKeys} | key in input.requiredEncryptionContextKeys :: key in input.encryptionContext, Types.AwsCryptographicMaterialProvidersException(message := ""Required encryption context keys do not exist in provided encryption context."")); var suite: AlgorithmSuite := AS.GetSuite(input.algorithmSuiteId); Need(suite.signature.ECDSA? <==> input.signingKey.Some? && input.verificationKey.Some?, Types.Error.AwsCryptographicMaterialProvidersException(message := ""Missing signature key for signed suite."")); Need(suite.signature.None? <==> input.signingKey.None? && input.verificationKey.None?, Types.Error.AwsCryptographicMaterialProvidersException(message := ""Signature key not allowed for non-signed suites."")); var encryptionContext: map<ValidUTF8Bytes, ValidUTF8Bytes> :- match suite.signature case ECDSA(curve) => (var enc_vk: ValidUTF8Bytes :- UTF8.Encode(Base64.Encode(input.verificationKey.value)).MapFailure((e: string) => Types.AwsCryptographicMaterialProvidersException(message := e)); Success(input.encryptionContext[EC_PUBLIC_KEY_FIELD := enc_vk])) case None => Success(input.encryptionContext); Success(Types.EncryptionMaterials(algorithmSuite := suite, encryptionContext := encryptionContext, encryptedDataKeys := [], plaintextDataKey := Option.None, signingKey := input.signingKey, symmetricSigningKeys := if suite.symmetricSignature.None? then None else Some([]), requiredEncryptionContextKeys := input.requiredEncryptionContextKeys))
  }

  function method InitializeDecryptionMaterials(input: Types.InitializeDecryptionMaterialsInput): (res: Result<Types.DecryptionMaterials, Types.Error>)
    ensures true && res.Success? ==> ValidDecryptionMaterials(res.value) && var suite: AlgorithmSuite := AS.GetSuite(input.algorithmSuiteId); res.value.algorithmSuite == suite && (suite.signature.None? <==> EC_PUBLIC_KEY_FIELD !in input.encryptionContext) && var verificationKey: Result<Option<seq<uint8>>, Types.Error> := DecodeVerificationKey(input.encryptionContext); true && (verificationKey.Success? && verificationKey.value.Some? ==> res.value.verificationKey == Some(verificationKey.value.value))
    decreases input
  {
    Need(forall key: ValidUTF8Bytes {:trigger key in input.encryptionContext} {:trigger key in input.requiredEncryptionContextKeys} | key in input.requiredEncryptionContextKeys :: key in input.encryptionContext, Types.AwsCryptographicMaterialProvidersException(message := ""Reporoduced encryption context key did not exist in provided encryption context."")); var suite: AlgorithmSuite := AS.GetSuite(input.algorithmSuiteId); Need(suite.signature.ECDSA? <==> EC_PUBLIC_KEY_FIELD in input.encryptionContext, Types.Error.AwsCryptographicMaterialProvidersException(message := ""Encryption Context missing verification key."")); Need(suite.signature.None? <==> EC_PUBLIC_KEY_FIELD !in input.encryptionContext, Types.Error.AwsCryptographicMaterialProvidersException(message := ""Verification key can not exist in non-signed Algorithm Suites."")); var verificationKey: Option<seq<uint8>> :- DecodeVerificationKey(input.encryptionContext); Success(Types.DecryptionMaterials(encryptionContext := input.encryptionContext, algorithmSuite := suite, plaintextDataKey := Wrappers.None, verificationKey := verificationKey, symmetricSigningKey := Wrappers.None, requiredEncryptionContextKeys := input.requiredEncryptionContextKeys))
  }

  function method DecodeVerificationKey(encryptionContext: Types.EncryptionContext): (res: Result<Option<seq<uint8>>, Types.Error>)
    decreases encryptionContext
  {
    if EC_PUBLIC_KEY_FIELD in encryptionContext then
      var utf8Key: UTF8.ValidUTF8Bytes := encryptionContext[EC_PUBLIC_KEY_FIELD];
      var base64Key: string :- UTF8.Decode(utf8Key).MapFailure((e: string) => Types.AwsCryptographicMaterialProvidersException(message := e)); var key: seq<uint8> :- Base64.Decode(base64Key).MapFailure((e: string) => Types.AwsCryptographicMaterialProvidersException(message := e)); Success(Some(key))
    else
      Success(None)
  }

  predicate method ValidEncryptionMaterialsTransition(oldMat: Types.EncryptionMaterials, newMat: Types.EncryptionMaterials)
    decreases oldMat, newMat
  {
    newMat.algorithmSuite == oldMat.algorithmSuite &&
    newMat.encryptionContext == oldMat.encryptionContext &&
    newMat.requiredEncryptionContextKeys == oldMat.requiredEncryptionContextKeys &&
    newMat.signingKey == oldMat.signingKey &&
    ((oldMat.plaintextDataKey.None? && newMat.plaintextDataKey.Some?) || oldMat.plaintextDataKey == newMat.plaintextDataKey) &&
    newMat.plaintextDataKey.Some? &&
    |oldMat.encryptedDataKeys| <= |newMat.encryptedDataKeys| &&
    multiset(oldMat.encryptedDataKeys) <= multiset(newMat.encryptedDataKeys) &&
    (!oldMat.algorithmSuite.symmetricSignature.None? ==>
      newMat.symmetricSigningKeys.Some? &&
      oldMat.symmetricSigningKeys.Some? &&
      multiset(oldMat.symmetricSigningKeys.value) <= multiset(newMat.symmetricSigningKeys.value)) &&
    ValidEncryptionMaterials(oldMat) &&
    ValidEncryptionMaterials(newMat)
  }

  lemma TransitionImplyValidEncryptionMaterials(oldMat: Types.EncryptionMaterials, newMat: Types.EncryptionMaterials)
    ensures !ValidEncryptionMaterials(oldMat) ==> !ValidEncryptionMaterialsTransition(oldMat, newMat)
    ensures !ValidEncryptionMaterials(newMat) ==> !ValidEncryptionMaterialsTransition(oldMat, newMat)
    ensures true && newMat.plaintextDataKey.None? ==> !ValidEncryptionMaterialsTransition(oldMat, newMat)
    decreases oldMat, newMat
  {
  }

  predicate method ValidEncryptionMaterials(encryptionMaterials: Types.EncryptionMaterials)
    decreases encryptionMaterials
  {
    AS.AlgorithmSuite?(encryptionMaterials.algorithmSuite) &&
    var suite: AlgorithmSuiteInfo := encryptionMaterials.algorithmSuite; (suite.signature.None? <==> encryptionMaterials.signingKey.None?) && (encryptionMaterials.plaintextDataKey.Some? ==> AS.GetEncryptKeyLength(suite) as nat == |encryptionMaterials.plaintextDataKey.value|) && (encryptionMaterials.plaintextDataKey.None? ==> |encryptionMaterials.encryptedDataKeys| == 0) && (!suite.signature.None? <==> EC_PUBLIC_KEY_FIELD in encryptionMaterials.encryptionContext) && (suite.signature.ECDSA? <==> encryptionMaterials.signingKey.Some?) && (!suite.signature.None? <==> EC_PUBLIC_KEY_FIELD in encryptionMaterials.encryptionContext) && (suite.symmetricSignature.HMAC? && encryptionMaterials.symmetricSigningKeys.Some? ==> |encryptionMaterials.symmetricSigningKeys.value| == |encryptionMaterials.encryptedDataKeys|) && (suite.symmetricSignature.HMAC? ==> encryptionMaterials.symmetricSigningKeys.Some?) && (suite.symmetricSignature.None? ==> encryptionMaterials.symmetricSigningKeys.None?) && forall key: ValidUTF8Bytes {:trigger key in encryptionMaterials.encryptionContext} {:trigger key in encryptionMaterials.requiredEncryptionContextKeys} | key in encryptionMaterials.requiredEncryptionContextKeys :: key in encryptionMaterials.encryptionContext
  }

  predicate method EncryptionMaterialsHasPlaintextDataKey(encryptionMaterials: Types.EncryptionMaterials)
    decreases encryptionMaterials
  {
    encryptionMaterials.plaintextDataKey.Some? &&
    |encryptionMaterials.encryptedDataKeys| > 0 &&
    ValidEncryptionMaterials(encryptionMaterials)
  }

  function method EncryptionMaterialAddEncryptedDataKeys(encryptionMaterials: Types.EncryptionMaterials, encryptedDataKeysToAdd: Types.EncryptedDataKeyList, symmetricSigningKeysToAdd: Option<Types.SymmetricSigningKeyList>): (res: Result<Types.EncryptionMaterials, Types.Error>)
    requires |encryptedDataKeysToAdd| > 0
    requires symmetricSigningKeysToAdd.Some? ==> |encryptedDataKeysToAdd| == |symmetricSigningKeysToAdd.value|
    ensures res.Success? ==> EncryptionMaterialsHasPlaintextDataKey(res.value) && ValidEncryptionMaterialsTransition(encryptionMaterials, res.value)
    decreases encryptionMaterials, encryptedDataKeysToAdd, symmetricSigningKeysToAdd
  {
    Need(ValidEncryptionMaterials(encryptionMaterials), Types.InvalidEncryptionMaterialsTransition(message := ""Attempt to modify invalid encryption material."")); Need(encryptionMaterials.plaintextDataKey.Some?, Types.InvalidEncryptionMaterialsTransition(message := ""Adding encrypted data keys without a plaintext data key is not allowed."")); Need(symmetricSigningKeysToAdd.None? ==> encryptionMaterials.algorithmSuite.symmetricSignature.None?, Types.InvalidEncryptionMaterialsTransition(message := ""Adding encrypted data keys without a symmetric signing key when using symmetric signing is not allowed."")); Need(symmetricSigningKeysToAdd.Some? ==> !encryptionMaterials.algorithmSuite.symmetricSignature.None?, Types.InvalidEncryptionMaterialsTransition(message := ""Adding encrypted data keys with a symmetric signing key when not using symmetric signing is not allowed."")); var symmetricSigningKeys: Option<SymmetricSigningKeyList> := if symmetricSigningKeysToAdd.None? then encryptionMaterials.symmetricSigningKeys else Some(encryptionMaterials.symmetricSigningKeys.value + symmetricSigningKeysToAdd.value); Success(Types.EncryptionMaterials(plaintextDataKey := encryptionMaterials.plaintextDataKey, encryptedDataKeys := encryptionMaterials.encryptedDataKeys + encryptedDataKeysToAdd, algorithmSuite := encryptionMaterials.algorithmSuite, encryptionContext := encryptionMaterials.encryptionContext, signingKey := encryptionMaterials.signingKey, symmetricSigningKeys := symmetricSigningKeys, requiredEncryptionContextKeys := encryptionMaterials.requiredEncryptionContextKeys))
  }

  function method EncryptionMaterialAddDataKey(encryptionMaterials: Types.EncryptionMaterials, plaintextDataKey: seq<uint8>, encryptedDataKeysToAdd: Types.EncryptedDataKeyList, symmetricSigningKeysToAdd: Option<Types.SymmetricSigningKeyList>): (res: Result<Types.EncryptionMaterials, Types.Error>)
    requires |encryptedDataKeysToAdd| > 0
    requires symmetricSigningKeysToAdd.Some? ==> |encryptedDataKeysToAdd| == |symmetricSigningKeysToAdd.value|
    ensures res.Success? ==> EncryptionMaterialsHasPlaintextDataKey(res.value) && ValidEncryptionMaterialsTransition(encryptionMaterials, res.value)
    decreases encryptionMaterials, plaintextDataKey, encryptedDataKeysToAdd, symmetricSigningKeysToAdd
  {
    var suite: AlgorithmSuiteInfo := encryptionMaterials.algorithmSuite;
    Need(ValidEncryptionMaterials(encryptionMaterials), Types.InvalidEncryptionMaterialsTransition(message := ""Attempt to modify invalid encryption material."")); Need(encryptionMaterials.plaintextDataKey.None?, Types.InvalidEncryptionMaterialsTransition(message := ""Attempt to modify plaintextDataKey."")); Need(AS.GetEncryptKeyLength(suite) as nat == |plaintextDataKey|, Types.InvalidEncryptionMaterialsTransition(message := ""plaintextDataKey does not match Algorithm Suite specification."")); Need(symmetricSigningKeysToAdd.None? == encryptionMaterials.algorithmSuite.symmetricSignature.None?, Types.InvalidEncryptionMaterialsTransition(message := ""Adding encrypted data keys without a symmetric signing key when using symmetric signing is not allowed."")); Need(symmetricSigningKeysToAdd.Some? == !encryptionMaterials.algorithmSuite.symmetricSignature.None?, Types.InvalidEncryptionMaterialsTransition(message := ""Adding encrypted data keys with a symmetric signing key when not using symmetric signing is not allowed."")); var symmetricSigningKeys: Option<SymmetricSigningKeyList> := if symmetricSigningKeysToAdd.None? then encryptionMaterials.symmetricSigningKeys else Some(encryptionMaterials.symmetricSigningKeys.value + symmetricSigningKeysToAdd.value); Success(Types.EncryptionMaterials(plaintextDataKey := Some(plaintextDataKey), encryptedDataKeys := encryptionMaterials.encryptedDataKeys + encryptedDataKeysToAdd, algorithmSuite := encryptionMaterials.algorithmSuite, encryptionContext := encryptionMaterials.encryptionContext, signingKey := encryptionMaterials.signingKey, symmetricSigningKeys := symmetricSigningKeys, requiredEncryptionContextKeys := encryptionMaterials.requiredEncryptionContextKeys))
  }

  predicate method DecryptionMaterialsTransitionIsValid(oldMat: Types.DecryptionMaterials, newMat: Types.DecryptionMaterials)
    decreases oldMat, newMat
  {
    newMat.algorithmSuite == oldMat.algorithmSuite &&
    newMat.encryptionContext == oldMat.encryptionContext &&
    newMat.requiredEncryptionContextKeys == oldMat.requiredEncryptionContextKeys &&
    newMat.verificationKey == oldMat.verificationKey &&
    oldMat.plaintextDataKey.None? &&
    newMat.plaintextDataKey.Some? &&
    oldMat.symmetricSigningKey.None? &&
    ValidDecryptionMaterials(oldMat) &&
    ValidDecryptionMaterials(newMat)
  }

  lemma TransitionImplyValidDecryptionMaterials(oldMat: Types.DecryptionMaterials, newMat: Types.DecryptionMaterials)
    ensures !ValidDecryptionMaterials(oldMat) ==> !DecryptionMaterialsTransitionIsValid(oldMat, newMat)
    ensures !ValidDecryptionMaterials(newMat) ==> !DecryptionMaterialsTransitionIsValid(oldMat, newMat)
    decreases oldMat, newMat
  {
  }

  predicate method ValidDecryptionMaterials(decryptionMaterials: Types.DecryptionMaterials)
    decreases decryptionMaterials
  {
    AS.AlgorithmSuite?(decryptionMaterials.algorithmSuite) &&
    var suite: AlgorithmSuiteInfo := decryptionMaterials.algorithmSuite; (decryptionMaterials.plaintextDataKey.Some? ==> AS.GetEncryptKeyLength(suite) as nat == |decryptionMaterials.plaintextDataKey.value|) && (!suite.signature.None? <==> EC_PUBLIC_KEY_FIELD in decryptionMaterials.encryptionContext) && (suite.signature.ECDSA? <==> decryptionMaterials.verificationKey.Some?) && (!suite.signature.None? <==> EC_PUBLIC_KEY_FIELD in decryptionMaterials.encryptionContext) && (!suite.symmetricSignature.None? ==> (decryptionMaterials.plaintextDataKey.Some? <==> decryptionMaterials.symmetricSigningKey.Some?)) && (suite.symmetricSignature.None? ==> decryptionMaterials.symmetricSigningKey.None?) && forall k: ValidUTF8Bytes {:trigger k in decryptionMaterials.encryptionContext} {:trigger k in decryptionMaterials.requiredEncryptionContextKeys} | k in decryptionMaterials.requiredEncryptionContextKeys :: k in decryptionMaterials.encryptionContext
  }

  function method DecryptionMaterialsAddDataKey(decryptionMaterials: Types.DecryptionMaterials, plaintextDataKey: seq<uint8>, symmetricSigningKey: Option<seq<uint8>>): (res: Result<Types.DecryptionMaterials, Types.Error>)
    ensures res.Success? ==> DecryptionMaterialsWithPlaintextDataKey(res.value) && DecryptionMaterialsTransitionIsValid(decryptionMaterials, res.value)
    decreases decryptionMaterials, plaintextDataKey, symmetricSigningKey
  {
    var suite: AlgorithmSuiteInfo := decryptionMaterials.algorithmSuite;
    Need(ValidDecryptionMaterials(decryptionMaterials), Types.InvalidDecryptionMaterialsTransition(message := ""Attempt to modify invalid decryption material."")); Need(decryptionMaterials.plaintextDataKey.None?, Types.InvalidDecryptionMaterialsTransition(message := ""Attempt to modify plaintextDataKey."")); Need(AS.GetEncryptKeyLength(suite) as nat == |plaintextDataKey|, Types.InvalidDecryptionMaterialsTransition(message := ""plaintextDataKey does not match Algorithm Suite specification."")); Need(symmetricSigningKey.Some? == !decryptionMaterials.algorithmSuite.symmetricSignature.None?, Types.InvalidDecryptionMaterialsTransition(message := ""symmetric signature key must be added with plaintextDataKey if using an algorithm suite with symmetric signing."")); Need(symmetricSigningKey.None? == decryptionMaterials.algorithmSuite.symmetricSignature.None?, Types.InvalidDecryptionMaterialsTransition(message := ""symmetric signature key cannot be added with plaintextDataKey if using an algorithm suite without symmetric signing."")); Success(Types.DecryptionMaterials(plaintextDataKey := Some(plaintextDataKey), algorithmSuite := decryptionMaterials.algorithmSuite, encryptionContext := decryptionMaterials.encryptionContext, verificationKey := decryptionMaterials.verificationKey, symmetricSigningKey := symmetricSigningKey, requiredEncryptionContextKeys := decryptionMaterials.requiredEncryptionContextKeys))
  }

  predicate method DecryptionMaterialsWithoutPlaintextDataKey(decryptionMaterials: Types.DecryptionMaterials)
    decreases decryptionMaterials
  {
    decryptionMaterials.plaintextDataKey.None? &&
    ValidDecryptionMaterials(decryptionMaterials)
  }

  predicate method DecryptionMaterialsWithPlaintextDataKey(decryptionMaterials: Types.DecryptionMaterials)
    decreases decryptionMaterials
  {
    decryptionMaterials.plaintextDataKey.Some? &&
    ValidDecryptionMaterials(decryptionMaterials)
  }
}

module AlgorithmSuites {

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened AwsCryptographyMaterialProvidersTypes

  import Wrappers
  type AlgorithmSuite = a: AlgorithmSuiteInfo
    | AlgorithmSuite?(a)
    witness *

  predicate method SupportedESDKEncrypt?(e: Encrypt)
    decreases e
  {
    e.AES_GCM? &&
    (e.AES_GCM.keyLength == 32 || e.AES_GCM.keyLength == 24 || e.AES_GCM.keyLength == 16) &&
    e.AES_GCM.tagLength == 16 &&
    e.AES_GCM.ivLength == 12
  }

  predicate method SupportedDBEEncrypt?(e: Encrypt)
    decreases e
  {
    e.AES_GCM? &&
    e.AES_GCM.keyLength == 32 &&
    e.AES_GCM.tagLength == 16 &&
    e.AES_GCM.ivLength == 12
  }

  predicate method SupportedDBEEDKWrapping?(p: EdkWrappingAlgorithm)
    decreases p
  {
    p.IntermediateKeyWrapping? &&
    p.IntermediateKeyWrapping.pdkEncryptAlgorithm.AES_GCM? &&
    p.IntermediateKeyWrapping.pdkEncryptAlgorithm.AES_GCM.keyLength == 32 &&
    p.IntermediateKeyWrapping.pdkEncryptAlgorithm.AES_GCM.tagLength == 16 &&
    p.IntermediateKeyWrapping.pdkEncryptAlgorithm.AES_GCM.ivLength == 12 &&
    p.IntermediateKeyWrapping.macKeyKdf.HKDF? &&
    p.IntermediateKeyWrapping.keyEncryptionKeyKdf.HKDF?
  }

  predicate method KeyDerivationAlgorithm?(kdf: DerivationAlgorithm)
    decreases kdf
  {
    (true &&
    kdf.HKDF? ==>
      kdf.HKDF.inputKeyLength == kdf.HKDF.outputKeyLength &&
      (kdf.HKDF.hmac == AwsCryptographyPrimitivesTypes.SHA_512 ==>
        kdf.HKDF.inputKeyLength == 32)) &&
    !kdf.None?
  }

  predicate method CommitmentDerivationAlgorithm?(kdf: DerivationAlgorithm)
    decreases kdf
  {
    (true &&
    kdf.HKDF? ==>
      kdf.HKDF.hmac.SHA_512? &&
      kdf.HKDF.saltLength == 32 &&
      kdf.HKDF.inputKeyLength == 32 &&
      kdf.HKDF.outputKeyLength == 32) &&
    !kdf.IDENTITY?
  }

  predicate method EdkWrappingAlgorithm?(alg: EdkWrappingAlgorithm)
    decreases alg
  {
    (alg.IntermediateKeyWrapping? && alg.IntermediateKeyWrapping.keyEncryptionKeyKdf.HKDF? && alg.IntermediateKeyWrapping.macKeyKdf.HKDF? && alg.IntermediateKeyWrapping.pdkEncryptAlgorithm.AES_GCM? && alg.IntermediateKeyWrapping.pdkEncryptAlgorithm.AES_GCM.keyLength == 32) || alg.DIRECT_KEY_WRAPPING?
  }

  predicate method AlgorithmSuiteInfo?(a: AlgorithmSuiteInfo)
    decreases a
  {
    KeyDerivationAlgorithm?(a.kdf) &&
    CommitmentDerivationAlgorithm?(a.commitment) &&
    EdkWrappingAlgorithm?(a.edkWrapping) &&
    (a.kdf.HKDF? ==>
      true &&
      a.kdf.HKDF.outputKeyLength == a.encrypt.AES_GCM.keyLength) &&
    (a.signature.ECDSA? ==>
      a.kdf.HKDF?) &&
    (a.commitment.HKDF? ==>
      a.commitment.HKDF.saltLength == 32 &&
      a.commitment == a.kdf) &&
    (a.edkWrapping.IntermediateKeyWrapping? ==>
      a.kdf.HKDF? &&
      a.edkWrapping.IntermediateKeyWrapping.keyEncryptionKeyKdf == a.kdf &&
      a.edkWrapping.IntermediateKeyWrapping.macKeyKdf == a.kdf) &&
    (a.kdf.HKDF? &&
    a.commitment.None? ==>
      a.kdf.HKDF.saltLength == 0) &&
    (!a.symmetricSignature.None? ==>
      true &&
      a.edkWrapping.IntermediateKeyWrapping?)
  }

  predicate method ESDKAlgorithmSuite?(a: AlgorithmSuiteInfo)
    requires a.id.ESDK?
    decreases a
  {
    AlgorithmSuiteInfo?(a) &&
    SupportedESDKEncrypt?(a.encrypt) &&
    match a.id.ESDK case ALG_AES_128_GCM_IV12_TAG16_NO_KDF() => a.binaryId == [0, 20] && a.messageVersion == 1 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 16 && a.kdf.IDENTITY? && a.signature.None? && a.commitment.None? && a.symmetricSignature.None? && a.edkWrapping.DIRECT_KEY_WRAPPING? case ALG_AES_192_GCM_IV12_TAG16_NO_KDF() => a.binaryId == [0, 70] && a.messageVersion == 1 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 24 && a.kdf.IDENTITY? && a.signature.None? && a.commitment.None? && a.symmetricSignature.None? && a.edkWrapping.DIRECT_KEY_WRAPPING? case ALG_AES_256_GCM_IV12_TAG16_NO_KDF() => a.binaryId == [0, 120] && a.messageVersion == 1 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 32 && a.kdf.IDENTITY? && a.signature.None? && a.commitment.None? && a.symmetricSignature.None? && a.edkWrapping.DIRECT_KEY_WRAPPING? case ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256() => a.binaryId == [1, 20] && a.messageVersion == 1 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 16 && a.kdf.HKDF? && a.kdf.HKDF.hmac == AwsCryptographyPrimitivesTypes.SHA_256 && a.signature.None? && a.commitment.None? && a.symmetricSignature.None? && a.edkWrapping.DIRECT_KEY_WRAPPING? case ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA256() => a.binaryId == [1, 70] && a.messageVersion == 1 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 24 && a.kdf.HKDF? && a.kdf.HKDF.hmac == AwsCryptographyPrimitivesTypes.SHA_256 && a.signature.None? && a.commitment.None? && a.symmetricSignature.None? && a.edkWrapping.DIRECT_KEY_WRAPPING? case ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA256() => a.binaryId == [1, 120] && a.messageVersion == 1 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 32 && a.kdf.HKDF? && a.kdf.HKDF.hmac == AwsCryptographyPrimitivesTypes.SHA_256 && a.signature.None? && a.commitment.None? && a.symmetricSignature.None? && a.edkWrapping.DIRECT_KEY_WRAPPING? case ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256() => a.binaryId == [2, 20] && a.messageVersion == 1 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 16 && a.kdf.HKDF? && a.kdf.HKDF.hmac == AwsCryptographyPrimitivesTypes.SHA_256 && a.signature.ECDSA? && a.signature.ECDSA.curve == AwsCryptographyPrimitivesTypes.ECDSA_P256 && a.commitment.None? && a.symmetricSignature.None? && a.edkWrapping.DIRECT_KEY_WRAPPING? case ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384() => a.binaryId == [3, 70] && a.messageVersion == 1 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 24 && a.kdf.HKDF? && a.kdf.HKDF.hmac == AwsCryptographyPrimitivesTypes.SHA_384 && a.signature.ECDSA? && a.signature.ECDSA.curve == AwsCryptographyPrimitivesTypes.ECDSA_P384 && a.commitment.None? && a.symmetricSignature.None? && a.edkWrapping.DIRECT_KEY_WRAPPING? case ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384() => a.binaryId == [3, 120] && a.messageVersion == 1 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 32 && a.kdf.HKDF? && a.kdf.HKDF.hmac == AwsCryptographyPrimitivesTypes.SHA_384 && a.signature.ECDSA? && a.signature.ECDSA.curve == AwsCryptographyPrimitivesTypes.ECDSA_P384 && a.commitment.None? && a.symmetricSignature.None? && a.edkWrapping.DIRECT_KEY_WRAPPING? case ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY() => a.binaryId == [4, 120] && a.messageVersion == 2 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 32 && a.kdf.HKDF? && a.kdf.HKDF.hmac == AwsCryptographyPrimitivesTypes.SHA_512 && a.signature.None? && a.commitment.HKDF? && a.symmetricSignature.None? && a.edkWrapping.DIRECT_KEY_WRAPPING? case ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384() => a.binaryId == [5, 120] && a.messageVersion == 2 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 32 && a.kdf.HKDF? && a.kdf.HKDF.hmac == AwsCryptographyPrimitivesTypes.SHA_512 && a.signature.ECDSA? && a.signature.ECDSA.curve == AwsCryptographyPrimitivesTypes.ECDSA_P384 && a.commitment.HKDF? && a.symmetricSignature.None? && a.edkWrapping.DIRECT_KEY_WRAPPING?
  }

  predicate method DBEAlgorithmSuite?(a: AlgorithmSuiteInfo)
    requires a.id.DBE?
    decreases a
  {
    AlgorithmSuiteInfo?(a) &&
    SupportedDBEEncrypt?(a.encrypt) &&
    SupportedDBEEDKWrapping?(a.edkWrapping) &&
    match a.id.DBE case ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_SYMSIG_HMAC_SHA384() => a.binaryId == [103, 0] && a.messageVersion == 1 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 32 && a.kdf.HKDF? && a.kdf.HKDF.hmac == AwsCryptographyPrimitivesTypes.SHA_512 && a.signature.None? && a.commitment.HKDF? && a.symmetricSignature.HMAC? && a.symmetricSignature.HMAC == AwsCryptographyPrimitivesTypes.SHA_384 && a.edkWrapping.IntermediateKeyWrapping? && a.edkWrapping.IntermediateKeyWrapping.pdkEncryptAlgorithm.AES_GCM? && a.edkWrapping.IntermediateKeyWrapping.pdkEncryptAlgorithm.AES_GCM.keyLength == 32 case ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384_SYMSIG_HMAC_SHA384() => a.binaryId == [103, 1] && a.messageVersion == 1 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 32 && a.kdf.HKDF? && a.kdf.HKDF.hmac == AwsCryptographyPrimitivesTypes.SHA_512 && a.signature.ECDSA? && a.signature.ECDSA.curve == AwsCryptographyPrimitivesTypes.ECDSA_P384 && a.commitment.HKDF? && a.symmetricSignature.HMAC? && a.symmetricSignature.HMAC == AwsCryptographyPrimitivesTypes.SHA_384 && a.edkWrapping.IntermediateKeyWrapping? && a.edkWrapping.IntermediateKeyWrapping.pdkEncryptAlgorithm.AES_GCM? && a.edkWrapping.IntermediateKeyWrapping.pdkEncryptAlgorithm.AES_GCM.keyLength == 32
  }

  predicate method AlgorithmSuite?(a: AlgorithmSuiteInfo)
    decreases a
  {
    match a.id
    case ESDK(_ /* _v0 */) =>
      ESDKAlgorithmSuite?(a)
    case DBE(_ /* _v1 */) =>
      DBEAlgorithmSuite?(a)
  }

  const Bits256 := 32 as int32
  const Bits192 := 24 as int32
  const Bits128 := 16 as int32
  const TagLen := 16 as int32
  const IvLen := 12 as int32
  const AES_128_GCM_IV12_TAG16 := Encrypt.AES_GCM(AwsCryptographyPrimitivesTypes.AES_GCM(keyLength := Bits128, tagLength := TagLen, ivLength := IvLen))
  const AES_192_GCM_IV12_TAG16 := Encrypt.AES_GCM(AwsCryptographyPrimitivesTypes.AES_GCM(keyLength := Bits192, tagLength := TagLen, ivLength := IvLen))
  const AES_256_GCM_IV12_TAG16 := Encrypt.AES_GCM(AwsCryptographyPrimitivesTypes.AES_GCM(keyLength := Bits256, tagLength := TagLen, ivLength := IvLen))

  function method HKDF_SHA_256(keyLength: AwsCryptographyPrimitivesTypes.SymmetricKeyLength): (res: DerivationAlgorithm)
    decreases keyLength
  {
    DerivationAlgorithm.HKDF(HKDF.HKDF(hmac := AwsCryptographyPrimitivesTypes.SHA_256, saltLength := 0 as int32, inputKeyLength := keyLength, outputKeyLength := keyLength))
  }

  function method HKDF_SHA_384(keyLength: AwsCryptographyPrimitivesTypes.SymmetricKeyLength): (res: DerivationAlgorithm)
    decreases keyLength
  {
    DerivationAlgorithm.HKDF(HKDF.HKDF(hmac := AwsCryptographyPrimitivesTypes.SHA_384, saltLength := 0 as int32, inputKeyLength := keyLength, outputKeyLength := keyLength))
  }

  function method HKDF_SHA_512(keyLength: AwsCryptographyPrimitivesTypes.SymmetricKeyLength): (res: DerivationAlgorithm)
    decreases keyLength
  {
    DerivationAlgorithm.HKDF(HKDF.HKDF(hmac := AwsCryptographyPrimitivesTypes.SHA_512, saltLength := 32 as int32, inputKeyLength := keyLength, outputKeyLength := keyLength))
  }

  const EDK_INTERMEDIATE_WRAPPING_AES_GCM_256_HKDF_SHA_512 := EdkWrappingAlgorithm.IntermediateKeyWrapping(IntermediateKeyWrapping.IntermediateKeyWrapping(keyEncryptionKeyKdf := HKDF_SHA_512(Bits256), macKeyKdf := HKDF_SHA_512(Bits256), pdkEncryptAlgorithm := AES_256_GCM_IV12_TAG16))
  const DBE_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_SYMSIG_HMAC_SHA384: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.DBE(DBEAlgorithmSuiteId.ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_SYMSIG_HMAC_SHA384), binaryId := [103, 0], messageVersion := 1, encrypt := AES_256_GCM_IV12_TAG16, kdf := HKDF_SHA_512(Bits256), commitment := HKDF_SHA_512(Bits256), signature := SignatureAlgorithm.None(None.None), symmetricSignature := SymmetricSignatureAlgorithm.HMAC(AwsCryptographyPrimitivesTypes.SHA_384), edkWrapping := EDK_INTERMEDIATE_WRAPPING_AES_GCM_256_HKDF_SHA_512)
  const DBE_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384_SYMSIG_HMAC_SHA384: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.DBE(DBEAlgorithmSuiteId.ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384_SYMSIG_HMAC_SHA384), binaryId := [103, 1], messageVersion := 1, encrypt := AES_256_GCM_IV12_TAG16, kdf := HKDF_SHA_512(Bits256), commitment := HKDF_SHA_512(Bits256), signature := SignatureAlgorithm.ECDSA(ECDSA.ECDSA(curve := AwsCryptographyPrimitivesTypes.ECDSA_P384)), symmetricSignature := SymmetricSignatureAlgorithm.HMAC(AwsCryptographyPrimitivesTypes.SHA_384), edkWrapping := EDK_INTERMEDIATE_WRAPPING_AES_GCM_256_HKDF_SHA_512)
  const ESDK_ALG_AES_128_GCM_IV12_TAG16_NO_KDF: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.ESDK(ESDKAlgorithmSuiteId.ALG_AES_128_GCM_IV12_TAG16_NO_KDF), binaryId := [0, 20], messageVersion := 1, encrypt := AES_128_GCM_IV12_TAG16, kdf := DerivationAlgorithm.IDENTITY(IDENTITY.IDENTITY), commitment := DerivationAlgorithm.None(None.None), signature := SignatureAlgorithm.None(None.None), symmetricSignature := SymmetricSignatureAlgorithm.None(None.None), edkWrapping := EdkWrappingAlgorithm.DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING.DIRECT_KEY_WRAPPING))
  const ESDK_ALG_AES_192_GCM_IV12_TAG16_NO_KDF: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.ESDK(ESDKAlgorithmSuiteId.ALG_AES_192_GCM_IV12_TAG16_NO_KDF), binaryId := [0, 70], messageVersion := 1, encrypt := AES_192_GCM_IV12_TAG16, kdf := DerivationAlgorithm.IDENTITY(IDENTITY.IDENTITY), commitment := DerivationAlgorithm.None(None.None), signature := SignatureAlgorithm.None(None.None), symmetricSignature := SymmetricSignatureAlgorithm.None(None.None), edkWrapping := EdkWrappingAlgorithm.DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING.DIRECT_KEY_WRAPPING))
  const ESDK_ALG_AES_256_GCM_IV12_TAG16_NO_KDF: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.ESDK(ESDKAlgorithmSuiteId.ALG_AES_256_GCM_IV12_TAG16_NO_KDF), binaryId := [0, 120], messageVersion := 1, encrypt := AES_256_GCM_IV12_TAG16, kdf := DerivationAlgorithm.IDENTITY(IDENTITY.IDENTITY), commitment := DerivationAlgorithm.None(None.None), signature := SignatureAlgorithm.None(None.None), symmetricSignature := SymmetricSignatureAlgorithm.None(None.None), edkWrapping := EdkWrappingAlgorithm.DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING.DIRECT_KEY_WRAPPING))
  const ESDK_ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.ESDK(ESDKAlgorithmSuiteId.ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256), binaryId := [1, 20], messageVersion := 1, encrypt := AES_128_GCM_IV12_TAG16, kdf := HKDF_SHA_256(Bits128), commitment := DerivationAlgorithm.None(None.None), signature := SignatureAlgorithm.None(None.None), symmetricSignature := SymmetricSignatureAlgorithm.None(None.None), edkWrapping := EdkWrappingAlgorithm.DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING.DIRECT_KEY_WRAPPING))
  const ESDK_ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA256: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.ESDK(ESDKAlgorithmSuiteId.ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA256), binaryId := [1, 70], messageVersion := 1, encrypt := AES_192_GCM_IV12_TAG16, kdf := HKDF_SHA_256(Bits192), commitment := DerivationAlgorithm.None(None.None), signature := SignatureAlgorithm.None(None.None), symmetricSignature := SymmetricSignatureAlgorithm.None(None.None), edkWrapping := EdkWrappingAlgorithm.DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING.DIRECT_KEY_WRAPPING))
  const ESDK_ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA256: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.ESDK(ESDKAlgorithmSuiteId.ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA256), binaryId := [1, 120], messageVersion := 1, encrypt := AES_256_GCM_IV12_TAG16, kdf := HKDF_SHA_256(Bits256), commitment := DerivationAlgorithm.None(None.None), signature := SignatureAlgorithm.None(None.None), symmetricSignature := SymmetricSignatureAlgorithm.None(None.None), edkWrapping := EdkWrappingAlgorithm.DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING.DIRECT_KEY_WRAPPING))
  const ESDK_ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.ESDK(ESDKAlgorithmSuiteId.ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256), binaryId := [2, 20], messageVersion := 1, encrypt := AES_128_GCM_IV12_TAG16, kdf := HKDF_SHA_256(Bits128), commitment := DerivationAlgorithm.None(None.None), signature := SignatureAlgorithm.ECDSA(ECDSA.ECDSA(curve := AwsCryptographyPrimitivesTypes.ECDSA_P256)), symmetricSignature := SymmetricSignatureAlgorithm.None(None.None), edkWrapping := EdkWrappingAlgorithm.DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING.DIRECT_KEY_WRAPPING))
  const ESDK_ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.ESDK(ESDKAlgorithmSuiteId.ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384), encrypt := AES_192_GCM_IV12_TAG16, binaryId := [3, 70], messageVersion := 1, kdf := HKDF_SHA_384(Bits192), commitment := DerivationAlgorithm.None(None.None), signature := SignatureAlgorithm.ECDSA(ECDSA.ECDSA(curve := AwsCryptographyPrimitivesTypes.ECDSA_P384)), symmetricSignature := SymmetricSignatureAlgorithm.None(None.None), edkWrapping := EdkWrappingAlgorithm.DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING.DIRECT_KEY_WRAPPING))
  const ESDK_ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.ESDK(ESDKAlgorithmSuiteId.ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384), binaryId := [3, 120], messageVersion := 1, encrypt := AES_256_GCM_IV12_TAG16, kdf := HKDF_SHA_384(Bits256), commitment := DerivationAlgorithm.None(None.None), signature := SignatureAlgorithm.ECDSA(ECDSA.ECDSA(curve := AwsCryptographyPrimitivesTypes.ECDSA_P384)), symmetricSignature := SymmetricSignatureAlgorithm.None(None.None), edkWrapping := EdkWrappingAlgorithm.DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING.DIRECT_KEY_WRAPPING))
  const ESDK_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.ESDK(ESDKAlgorithmSuiteId.ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY), binaryId := [4, 120], messageVersion := 2, encrypt := AES_256_GCM_IV12_TAG16, kdf := HKDF_SHA_512(Bits256), commitment := HKDF_SHA_512(Bits256), signature := SignatureAlgorithm.None(None.None), symmetricSignature := SymmetricSignatureAlgorithm.None(None.None), edkWrapping := EdkWrappingAlgorithm.DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING.DIRECT_KEY_WRAPPING))
  const ESDK_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.ESDK(ESDKAlgorithmSuiteId.ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384), binaryId := [5, 120], messageVersion := 2, encrypt := AES_256_GCM_IV12_TAG16, kdf := HKDF_SHA_512(Bits256), commitment := HKDF_SHA_512(Bits256), signature := SignatureAlgorithm.ECDSA(ECDSA.ECDSA(curve := AwsCryptographyPrimitivesTypes.ECDSA_P384)), symmetricSignature := SymmetricSignatureAlgorithm.None(None.None), edkWrapping := EdkWrappingAlgorithm.DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING.DIRECT_KEY_WRAPPING))

  function method GetSuite(id: AlgorithmSuiteId): (res: AlgorithmSuite)
    ensures res.id == id
    decreases id
  {
    match id
    case ESDK(e) =>
      GetESDKSuite(e)
    case DBE(e) =>
      GetDBESuite(e)
  }

  lemma LemmaAlgorithmSuiteIdImpliesEquality(id: AlgorithmSuiteId, suite: AlgorithmSuite)
    requires id == suite.id
    ensures GetSuite(id) == suite
    decreases id, suite
  {
  }

  lemma LemmaBinaryIdIsUnique(a: AlgorithmSuite, b: AlgorithmSuite)
    requires a.id != b.id
    ensures a.binaryId != b.binaryId
    decreases a, b
  {
  }

  const SupportedDBEAlgorithmSuites: map<DBEAlgorithmSuiteId, AlgorithmSuite> := map[DBEAlgorithmSuiteId.ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_SYMSIG_HMAC_SHA384 := DBE_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_SYMSIG_HMAC_SHA384, DBEAlgorithmSuiteId.ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384_SYMSIG_HMAC_SHA384 := DBE_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384_SYMSIG_HMAC_SHA384]

  lemma LemmaSupportedDBEAlgorithmSuitesIsComplete(id: DBEAlgorithmSuiteId)
    ensures id in SupportedDBEAlgorithmSuites
    decreases id
  {
  }

  function method GetDBESuite(id: DBEAlgorithmSuiteId): (res: AlgorithmSuite)
    ensures res.id.DBE? && res.id.DBE == id
    decreases id
  {
    LemmaSupportedDBEAlgorithmSuitesIsComplete(id);
    SupportedDBEAlgorithmSuites[id]
  }

  lemma LemmaDBEAlgorithmSuiteIdImpliesEquality(id: DBEAlgorithmSuiteId, suite: AlgorithmSuite)
    requires suite.id.DBE? && id == suite.id.DBE
    ensures GetDBESuite(id) == suite
    decreases id, suite
  {
  }

  const SupportedESDKAlgorithmSuites: map<ESDKAlgorithmSuiteId, AlgorithmSuite> := map[ESDKAlgorithmSuiteId.ALG_AES_128_GCM_IV12_TAG16_NO_KDF := ESDK_ALG_AES_128_GCM_IV12_TAG16_NO_KDF, ESDKAlgorithmSuiteId.ALG_AES_192_GCM_IV12_TAG16_NO_KDF := ESDK_ALG_AES_192_GCM_IV12_TAG16_NO_KDF, ESDKAlgorithmSuiteId.ALG_AES_256_GCM_IV12_TAG16_NO_KDF := ESDK_ALG_AES_256_GCM_IV12_TAG16_NO_KDF, ESDKAlgorithmSuiteId.ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256 := ESDK_ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256, ESDKAlgorithmSuiteId.ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA256 := ESDK_ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA256, ESDKAlgorithmSuiteId.ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA256 := ESDK_ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA256, ESDKAlgorithmSuiteId.ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256 := ESDK_ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256, ESDKAlgorithmSuiteId.ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384 := ESDK_ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384, ESDKAlgorithmSuiteId.ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384 := ESDK_ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384, ESDKAlgorithmSuiteId.ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY := ESDK_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY, ESDKAlgorithmSuiteId.ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384 := ESDK_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384]

  lemma LemmaSupportedESDKAlgorithmSuitesIsComplete(id: ESDKAlgorithmSuiteId)
    ensures id in SupportedESDKAlgorithmSuites
    decreases id
  {
  }

  function method GetESDKSuite(id: ESDKAlgorithmSuiteId): (res: AlgorithmSuite)
    ensures res.id.ESDK? && res.id.ESDK == id
    decreases id
  {
    LemmaSupportedESDKAlgorithmSuitesIsComplete(id);
    SupportedESDKAlgorithmSuites[id]
  }

  lemma LemmaESDKAlgorithmSuiteIdImpliesEquality(id: ESDKAlgorithmSuiteId, suite: AlgorithmSuite)
    requires suite.id.ESDK? && id == suite.id.ESDK
    ensures GetESDKSuite(id) == suite
    decreases id, suite
  {
  }

  function method GetEncryptKeyLength(a: AlgorithmSuiteInfo): (output: int32)
    ensures AwsCryptographyPrimitivesTypes.IsValid_PositiveInteger(output) && AwsCryptographyPrimitivesTypes.IsValid_SymmetricKeyLength(output)
    ensures a.encrypt.AES_GCM? ==> output == a.encrypt.AES_GCM.keyLength
    decreases a
  {
    match a.encrypt
    case AES_GCM(e) =>
      e.keyLength
  }

  function method GetEncryptTagLength(a: AlgorithmSuiteInfo): (output: int32)
    ensures AwsCryptographyPrimitivesTypes.IsValid_PositiveInteger(output) && AwsCryptographyPrimitivesTypes.IsValid_Uint8Bytes(output)
    ensures a.encrypt.AES_GCM? ==> output == a.encrypt.AES_GCM.tagLength
    decreases a
  {
    match a.encrypt
    case AES_GCM(e) =>
      e.tagLength
  }

  function method GetEncryptIvLength(a: AlgorithmSuiteInfo): (output: int32)
    ensures AwsCryptographyPrimitivesTypes.IsValid_PositiveInteger(output) && AwsCryptographyPrimitivesTypes.IsValid_Uint8Bits(output)
    ensures a.encrypt.AES_GCM? ==> output == a.encrypt.AES_GCM.ivLength
    decreases a
  {
    match a.encrypt
    case AES_GCM(e) =>
      e.ivLength
  }

  const AlgorithmSuiteInfoByBinaryId: map<seq<uint8>, AlgorithmSuite> := map[[0, 20] := ESDK_ALG_AES_128_GCM_IV12_TAG16_NO_KDF, [0, 70] := ESDK_ALG_AES_192_GCM_IV12_TAG16_NO_KDF, [0, 120] := ESDK_ALG_AES_256_GCM_IV12_TAG16_NO_KDF, [1, 20] := ESDK_ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256, [1, 70] := ESDK_ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA256, [1, 120] := ESDK_ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA256, [2, 20] := ESDK_ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256, [3, 70] := ESDK_ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384, [3, 120] := ESDK_ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384, [4, 120] := ESDK_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY, [5, 120] := ESDK_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384, [103, 0] := DBE_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_SYMSIG_HMAC_SHA384, [103, 1] := DBE_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384_SYMSIG_HMAC_SHA384]

  lemma AlgorithmSuiteInfoByBinaryIdIsComplete(a: AlgorithmSuite)
    ensures a == AlgorithmSuiteInfoByBinaryId[a.binaryId]
    decreases a
  {
  }

  function method GetAlgorithmSuiteInfo(binaryId?: seq<uint8>): (output: Wrappers.Result<AlgorithmSuiteInfo, Error>)
    decreases binaryId?
  {
    Wrappers.Need(binaryId? in AlgorithmSuiteInfoByBinaryId, AwsCryptographicMaterialProvidersException(message := ""Invalid BinaryId"")); Wrappers.Success(AlgorithmSuiteInfoByBinaryId[binaryId?])
  }

  lemma ReservedAlgorithmSuiteId(a: AlgorithmSuite)
    ensures a.binaryId != [0, 0]
    decreases a
  {
  }

  lemma AlgorithmSuiteIdIsUnique(a: AlgorithmSuite, b: AlgorithmSuite)
    requires a.id != b.id
    ensures a.binaryId != b.binaryId
    decreases a, b
  {
  }
}

module AwsKmsMrkAreUnique {

  import opened StandardLibrary

  import opened Wrappers

  import opened Seq

  import opened AwsArnParsing

  import Types = AwsCryptographyMaterialProvidersTypes
  function method AwsKmsMrkAreUnique(identifiers: seq<AwsKmsIdentifier>): (result: Outcome<Types.Error>)
    decreases identifiers
  {
    var mrks: seq<AwsKmsIdentifier> := Seq.Filter(IsMultiRegionAwsKmsIdentifier, identifiers);
    if |mrks| == 0 then
      Pass
    else
      var mrkKeyIds: seq<seq<char>> := Seq.Map(GetKeyId, mrks); var setMrks: set<seq<char>> := ToSet(mrkKeyIds); if |mrkKeyIds| == |setMrks| then Pass else var duplicateMrkIds: set<seq<char>> := set x: seq<char> {:trigger multiset(mrkKeyIds)[x]} {:trigger x in mrkKeyIds} | x in mrkKeyIds && multiset(mrkKeyIds)[x] >= 1; var isDuplicate: AwsKmsIdentifier -> bool := (identifier: AwsKmsIdentifier) => GetKeyId(identifier) in duplicateMrkIds; var identifierToString: AwsKmsIdentifier -> string := (i: AwsKmsIdentifier) => i.ToString(); var duplicateIdentifiers: seq<AwsKmsIdentifier> := Seq.Filter(isDuplicate, identifiers); assert |identifiers| >= |mrkKeyIds|; assert |mrks| == |mrkKeyIds|; var duplicates: seq<string> := Seq.Map(identifierToString, duplicateIdentifiers); if |duplicates| == 0 then Fail(Types.AwsCryptographicMaterialProvidersException(message := ""Impossible"")) else Fail(Types.AwsCryptographicMaterialProvidersException(message := ""Related multi-Region keys: "" + Join(duplicates, "","") + ""are not allowed.""))
  }

  function method GetKeyId(identifier: AwsKmsIdentifier): (result: string)
    decreases identifier
  {
    match identifier {
      case AwsKmsArnIdentifier(a) =>
        a.resource.value
      case AwsKmsRawResourceIdentifier(i) =>
        i.value
    }
  }

  lemma /*{:_induction identifiers}*/ AwsKmsMrkAreUniqueCorrect(identifiers: seq<AwsKmsIdentifier>)
    ensures |Seq.Filter(IsMultiRegionAwsKmsIdentifier, identifiers)| == 0 ==> AwsKmsMrkAreUnique(identifiers).Pass?
    ensures ghost var mrks: seq<AwsKmsIdentifier> := Seq.Filter(IsMultiRegionAwsKmsIdentifier, identifiers); ghost var ids: seq<string> := Seq.Map(GetKeyId, mrks); |mrks| > 0 && Seq.HasNoDuplicates(ids) ==> AwsKmsMrkAreUnique(identifiers).Pass?
    ensures ghost var mrks: seq<AwsKmsIdentifier> := Seq.Filter(IsMultiRegionAwsKmsIdentifier, identifiers); ghost var ids: seq<string> := Seq.Map(GetKeyId, mrks); |mrks| > 0 && !Seq.HasNoDuplicates(ids) ==> AwsKmsMrkAreUnique(identifiers).Fail?
    decreases identifiers
  {
  }
}

module AwsKmsKeyring {

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened AwsArnParsing

  import opened AwsKmsUtils

  import opened Seq

  import opened Actions

  import opened Constants

  import opened A = AwsKmsMrkMatchForDecrypt

  import Keyring

  import Materials

  import AlgorithmSuites

  import Types = AwsCryptographyMaterialProvidersTypes

  import KMS = ComAmazonawsKmsTypes

  import UTF8

  import EdkWrapping

  import MaterialWrapping
  class AwsKmsKeyring extends Keyring.VerifiableInterface {
    const client: KMS.IKMSClient
    const awsKmsKey: AwsKmsIdentifierString
    const awsKmsArn: AwsKmsIdentifier
    const grantTokens: KMS.GrantTokenList

    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      client.ValidState() &&
      client.Modifies <= Modifies &&
      History !in client.Modifies
    }

    constructor (client: KMS.IKMSClient, awsKmsKey: string, grantTokens: KMS.GrantTokenList)
      requires ParseAwsKmsIdentifier(awsKmsKey).Success?
      requires UTF8.IsASCIIString(awsKmsKey)
      requires 0 < |awsKmsKey| <= MAX_AWS_KMS_IDENTIFIER_LENGTH
      requires client.ValidState()
      ensures this.client == client && this.awsKmsKey == awsKmsKey && this.grantTokens == grantTokens
      ensures ValidState() && fresh(this) && fresh(History) && fresh(Modifies - client.Modifies)
      decreases client, awsKmsKey, grantTokens
    {
      var parsedAwsKmsId := ParseAwsKmsIdentifier(awsKmsKey);
      this.client := client;
      this.awsKmsKey := awsKmsKey;
      this.awsKmsArn := parsedAwsKmsId.value;
      this.grantTokens := grantTokens;
      History := new Types.IKeyringCallHistory();
      Modifies := {History} + client.Modifies;
    }

    predicate OnEncryptEnsuresPublicly(input: Types.OnEncryptInput, output: Result<Types.OnEncryptOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method OnEncrypt'(input: Types.OnEncryptInput) returns (res: Result<Types.OnEncryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnEncryptEnsuresPublicly(input, res)
      ensures unchanged(History)
      ensures res.Success? ==> true && Materials.ValidEncryptionMaterialsTransition(input.materials, res.value.materials)
      ensures StringifyEncryptionContext(input.materials.encryptionContext).Failure? ==> res.Failure?
      ensures !KMS.IsValid_KeyIdType(awsKmsKey) ==> res.Failure?
      ensures input.materials.plaintextDataKey.Some? && !KMS.IsValid_PlaintextType(input.materials.plaintextDataKey.value) ==> res.Failure?
      ensures res.Success? && input.materials.plaintextDataKey.None? && (false || (input.materials.plaintextDataKey.Some? && input.materials.algorithmSuite.edkWrapping.IntermediateKeyWrapping?)) ==> true && var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(input.materials.encryptionContext); maybeStringifiedEncCtx.Success? && 0 < |client.History.GenerateDataKey| && Last(client.History.GenerateDataKey).input == KMS.GenerateDataKeyRequest(EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), KeyId := awsKmsKey, NumberOfBytes := Some(AlgorithmSuites.GetEncryptKeyLength(input.materials.algorithmSuite)), KeySpec := None)
      ensures input.materials.plaintextDataKey.None? && res.Success? ==> res.value.materials.plaintextDataKey.Some? && |res.value.materials.encryptedDataKeys| == |input.materials.encryptedDataKeys| + 1 && var algSuite: AlgorithmSuiteInfo := input.materials.algorithmSuite; true && var maybeProviderWrappedMaterial: Result<seq<uint8>, Types.Error> := EdkWrapping.GetProviderWrappedMaterial(Last(res.value.materials.encryptedDataKeys).ciphertext, input.materials.algorithmSuite); maybeProviderWrappedMaterial.Success? && KMS.IsValid_CiphertextType(maybeProviderWrappedMaterial.value) && |client.History.GenerateDataKey| > 0 && Last(client.History.GenerateDataKey).output.Success? && AlgorithmSuites.GetEncryptKeyLength(algSuite) as int == |res.value.materials.plaintextDataKey.value| && exists returnedKeyId: KeyIdType, kmsPlaintext: PlaintextType {:trigger Some(returnedKeyId), Some(kmsPlaintext)} :: Last(client.History.GenerateDataKey).output.value == KMS.GenerateDataKeyResponse(KeyId := Some(returnedKeyId), CiphertextBlob := Some(maybeProviderWrappedMaterial.value), Plaintext := Some(kmsPlaintext)) && (res.value.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> kmsPlaintext == res.value.materials.plaintextDataKey.value)
      ensures res.Success? && input.materials.plaintextDataKey.Some? && input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> KMS.IsValid_PlaintextType(input.materials.plaintextDataKey.value) && StringifyEncryptionContext(input.materials.encryptionContext).Success? && var stringifiedEncCtx: KMS.EncryptionContextType := StringifyEncryptionContext(input.materials.encryptionContext).Extract(); 0 < |client.History.Encrypt| && Last(client.History.Encrypt).input == KMS.EncryptRequest(EncryptionContext := Some(stringifiedEncCtx), GrantTokens := Some(grantTokens), KeyId := awsKmsKey, Plaintext := input.materials.plaintextDataKey.value, EncryptionAlgorithm := None)
      ensures input.materials.plaintextDataKey.Some? && res.Success? && input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> |res.value.materials.encryptedDataKeys| == |input.materials.encryptedDataKeys| + 1 && KMS.IsValid_CiphertextType(Last(res.value.materials.encryptedDataKeys).ciphertext) && 0 < |client.History.Encrypt| && Last(client.History.Encrypt).output.Success? && exists returnedKeyId: Option<KeyIdType>, returnedEncryptionAlgorithm: Option<EncryptionAlgorithmSpec> {:trigger KMS.EncryptResponse(CiphertextBlob := Some(Last(res.value.materials.encryptedDataKeys).ciphertext), KeyId := returnedKeyId, EncryptionAlgorithm := returnedEncryptionAlgorithm)} :: true && Last(client.History.Encrypt).output.value == KMS.EncryptResponse(CiphertextBlob := Some(Last(res.value.materials.encryptedDataKeys).ciphertext), KeyId := returnedKeyId, EncryptionAlgorithm := returnedEncryptionAlgorithm)
      decreases Modifies - {History}
    {
      var materials := input.materials;
      var suite := input.materials.algorithmSuite;
      var stringifiedEncCtx :- StringifyEncryptionContext(input.materials.encryptionContext);
      var kmsGenerateAndWrap := new KmsGenerateAndWrapKeyMaterial(client, awsKmsKey, grantTokens);
      var kmsWrap := new KmsWrapKeyMaterial(client, awsKmsKey, grantTokens);
      var wrapOutput :- EdkWrapping.WrapEdkMaterial<KmsWrapInfo>(encryptionMaterials := materials, wrap := kmsWrap, generateAndWrap := kmsGenerateAndWrap);
      var kmsKeyArn := wrapOutput.wrapInfo.kmsKeyArn;
      var symmetricSigningKeyList := if wrapOutput.symmetricSigningKey.Some? then Some([wrapOutput.symmetricSigningKey.value]) else None;
      var providerInfo :- UTF8.Encode(kmsKeyArn).MapFailure(WrapStringToError);
      :- Need(|providerInfo| < UINT16_LIMIT, Types.AwsCryptographicMaterialProvidersException(message := ""Invalid response from AWS KMS GenerateDataKey: Key ID too long.""));
      var edk := Types.EncryptedDataKey(keyProviderId := PROVIDER_ID, keyProviderInfo := providerInfo, ciphertext := wrapOutput.wrappedMaterial);
      if wrapOutput.GenerateAndWrapEdkMaterialOutput? {
        var result :- Materials.EncryptionMaterialAddDataKey(materials, wrapOutput.plaintextDataKey, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      } else if wrapOutput.WrapOnlyEdkMaterialOutput? {
        var result :- Materials.EncryptionMaterialAddEncryptedDataKeys(materials, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      }
    }

    predicate OnDecryptEnsuresPublicly(input: Types.OnDecryptInput, output: Result<Types.OnDecryptOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method {:vcs_split_on_every_assert} OnDecrypt'(input: Types.OnDecryptInput) returns (res: Result<Types.OnDecryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnDecryptEnsuresPublicly(input, res)
      ensures unchanged(History)
      ensures res.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, res.value.materials)
      ensures input.materials.plaintextDataKey.Some? ==> res.Failure?
      ensures true && res.Success? ==> true && var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(input.materials.encryptionContext); maybeStringifiedEncCtx.Success? && 0 < |client.History.Decrypt| && AlgorithmSuites.GetEncryptKeyLength(input.materials.algorithmSuite) as nat == |res.value.materials.plaintextDataKey.value| && var LastDecrypt: DafnyCallEvent<DecryptRequest, Result<DecryptResponse, Error>> := Last(client.History.Decrypt); LastDecrypt.output.Success? && exists edk: EncryptedDataKey {:trigger edk.keyProviderId} {:trigger edk.ciphertext} {:trigger edk in input.encryptedDataKeys} | edk in input.encryptedDataKeys :: true && var maybeWrappedMaterial: Result<seq<uint8>, Types.Error> := EdkWrapping.GetProviderWrappedMaterial(edk.ciphertext, input.materials.algorithmSuite); maybeWrappedMaterial.Success? && edk.keyProviderId == PROVIDER_ID && KMS.IsValid_CiphertextType(maybeWrappedMaterial.value) && KMS.DecryptRequest(KeyId := Some(awsKmsKey), CiphertextBlob := maybeWrappedMaterial.value, EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), EncryptionAlgorithm := None) == LastDecrypt.input && LastDecrypt.output.value.KeyId == Some(awsKmsKey) && (input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> LastDecrypt.output.value.Plaintext == res.value.materials.plaintextDataKey)
      decreases Modifies - {History}
    {
      var materials := input.materials;
      var suite := input.materials.algorithmSuite;
      :- Need(Materials.DecryptionMaterialsWithoutPlaintextDataKey(materials), Types.AwsCryptographicMaterialProvidersException(message := ""Keyring received decryption materials that already contain a plaintext data key.""));
      var filter := new OnDecryptEncryptedDataKeyFilter(awsKmsKey);
      var edksToAttempt :- FilterWithResult(filter, input.encryptedDataKeys);
      :- Need(0 < |edksToAttempt|, Types.AwsCryptographicMaterialProvidersException(message := ""Unable to decrypt data key: No Encrypted Data Keys found to match.""));
      var decryptClosure := new DecryptSingleEncryptedDataKey(materials, client, awsKmsKey, grantTokens);
      var outcome, attempts := ReduceToSuccess(decryptClosure, edksToAttempt);
      var SealedDecryptionMaterials :- outcome.MapFailure((errors: seq<Types.Error>) => Types.CollectionOfErrors(list := errors, message := ""No Configured KMS Key was able to decrypt the Data Key. The list of encountered Exceptions is available via `list`.""));
      assert decryptClosure.Ensures(Last(attempts).input, Success(SealedDecryptionMaterials), DropLast(attempts));
      return Success(Types.OnDecryptOutput(materials := SealedDecryptionMaterials));
    }
  }

  class OnDecryptEncryptedDataKeyFilter extends DeterministicActionWithResult<Types.EncryptedDataKey, bool, Types.Error> {
    const awsKmsKey: AwsKmsIdentifierString

    constructor (awsKmsKey: AwsKmsIdentifierString)
      decreases awsKmsKey
    {
      this.awsKmsKey := awsKmsKey;
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<bool, Types.Error>)
      decreases edk, res
    {
      true &&
      (res.Success? &&
      res.value ==>
        edk.keyProviderId == PROVIDER_ID)
    }

    method Invoke(edk: Types.EncryptedDataKey) returns (res: Result<bool, Types.Error>)
      ensures Ensures(edk, res)
      decreases edk
    {
      if edk.keyProviderId != PROVIDER_ID {
        return Success(false);
      }
      if !UTF8.ValidUTF8Seq(edk.keyProviderInfo) {
        return Failure(Types.AwsCryptographicMaterialProvidersException(message := ""Invalid AWS KMS encoding, provider info is not UTF8.""));
      }
      var keyId :- UTF8.Decode(edk.keyProviderInfo).MapFailure(WrapStringToError);
      var _ /* _v0 */ :- ParseAwsKmsArn(keyId).MapFailure(WrapStringToError);
      return Success(this.awsKmsKey == keyId);
    }
  }

  class DecryptSingleEncryptedDataKey extends ActionWithResult<Types.EncryptedDataKey, Materials.SealedDecryptionMaterials, Types.Error> {
    const materials: Materials.DecryptionMaterialsPendingPlaintextDataKey
    const client: KMS.IKMSClient
    const awsKmsKey: AwsKmsIdentifierString
    const grantTokens: KMS.GrantTokenList

    constructor (materials: Materials.DecryptionMaterialsPendingPlaintextDataKey, client: KMS.IKMSClient, awsKmsKey: AwsKmsIdentifierString, grantTokens: KMS.GrantTokenList)
      requires client.ValidState()
      ensures this.materials == materials && this.client == client && this.awsKmsKey == awsKmsKey && this.grantTokens == grantTokens
      ensures Invariant()
      decreases materials, client, awsKmsKey, grantTokens
    {
      this.materials := materials;
      this.client := client;
      this.awsKmsKey := awsKmsKey;
      this.grantTokens := grantTokens;
      Modifies := client.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      client.ValidState() &&
      client.Modifies == Modifies
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<Materials.SealedDecryptionMaterials, Types.Error>, attemptsState: seq<ActionInvoke<Types.EncryptedDataKey, Result<Materials.SealedDecryptionMaterials, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        Invariant() &&
        ghost var maybeWrappedMaterial: Result<seq<uint8>, Types.Error> := EdkWrapping.GetProviderWrappedMaterial(edk.ciphertext, materials.algorithmSuite); maybeWrappedMaterial.Success? && KMS.IsValid_CiphertextType(maybeWrappedMaterial.value) && Materials.DecryptionMaterialsTransitionIsValid(materials, res.value) && ghost var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(materials.encryptionContext); maybeStringifiedEncCtx.Success? && 0 < |client.History.Decrypt| && KMS.DecryptRequest(KeyId := Some(awsKmsKey), CiphertextBlob := maybeWrappedMaterial.value, EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), EncryptionAlgorithm := None) == Last(client.History.Decrypt).input && Last(client.History.Decrypt).output.Success? && Last(client.History.Decrypt).output.value.Plaintext.Some? && (materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> Last(client.History.Decrypt).output.value.Plaintext == res.value.plaintextDataKey) && Last(client.History.Decrypt).output.value.KeyId == Some(awsKmsKey)
    }

    method Invoke(edk: Types.EncryptedDataKey, ghost attemptsState: seq<ActionInvoke<Types.EncryptedDataKey, Result<Materials.SealedDecryptionMaterials, Types.Error>>>) returns (res: Result<Materials.SealedDecryptionMaterials, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(edk, res, attemptsState)
      decreases Modifies
    {
      var kmsUnwrap := new KmsUnwrapKeyMaterial(client, awsKmsKey, grantTokens);
      var unwrapOutputRes := EdkWrapping.UnwrapEdkMaterial(edk.ciphertext, materials, kmsUnwrap);
      var unwrapOutput :- unwrapOutputRes;
      var result :- Materials.DecryptionMaterialsAddDataKey(materials, unwrapOutput.plaintextDataKey, unwrapOutput.symmetricSigningKey);
      return Success(result);
    }
  }

  datatype KmsUnwrapInfo = KmsUnwrapInfo

  datatype KmsWrapInfo = KmsWrapInfo(kmsKeyArn: string)

  class KmsUnwrapKeyMaterial extends MaterialWrapping.UnwrapMaterial<KmsUnwrapInfo> {
    const client: KMS.IKMSClient
    const awsKmsKey: AwsKmsIdentifierString
    const grantTokens: KMS.GrantTokenList

    constructor (client: KMS.IKMSClient, awsKmsKey: AwsKmsIdentifierString, grantTokens: KMS.GrantTokenList)
      requires client.ValidState()
      ensures this.client == client && this.awsKmsKey == awsKmsKey && this.grantTokens == grantTokens
      ensures Invariant()
      decreases client, awsKmsKey, grantTokens
    {
      this.client := client;
      this.awsKmsKey := awsKmsKey;
      this.grantTokens := grantTokens;
      Modifies := client.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      client.ValidState() &&
      client.Modifies == Modifies
    }

    predicate Ensures(input: MaterialWrapping.UnwrapInput, res: Result<MaterialWrapping.UnwrapOutput<KmsUnwrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.UnwrapInput, Result<MaterialWrapping.UnwrapOutput<KmsUnwrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        Invariant() &&
        ghost var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(input.encryptionContext); maybeStringifiedEncCtx.Success? && 0 < |client.History.Decrypt| && KMS.IsValid_CiphertextType(input.wrappedMaterial) && KMS.DecryptRequest(KeyId := Some(awsKmsKey), CiphertextBlob := input.wrappedMaterial, EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), EncryptionAlgorithm := None) == Last(client.History.Decrypt).input && Last(client.History.Decrypt).output.Success? && Last(client.History.Decrypt).output.value.Plaintext.Some? && Last(client.History.Decrypt).output.value.Plaintext == Some(res.value.unwrappedMaterial) && Last(client.History.Decrypt).output.value.KeyId == Some(awsKmsKey)
    }

    method Invoke(input: MaterialWrapping.UnwrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.UnwrapInput, Result<MaterialWrapping.UnwrapOutput<KmsUnwrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.UnwrapOutput<KmsUnwrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      ensures res.Success? ==> |res.value.unwrappedMaterial| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat
      decreases Modifies
    {
      :- Need(KMS.IsValid_CiphertextType(input.wrappedMaterial), Types.AwsCryptographicMaterialProvidersException(message := ""Ciphertext length invalid""));
      var stringifiedEncCtx :- StringifyEncryptionContext(input.encryptionContext);
      var decryptRequest := KMS.DecryptRequest(KeyId := Some(awsKmsKey), CiphertextBlob := input.wrappedMaterial, EncryptionContext := Some(stringifiedEncCtx), GrantTokens := Some(grantTokens), EncryptionAlgorithm := None);
      var maybeDecryptResponse := client.Decrypt(decryptRequest);
      var decryptResponse :- maybeDecryptResponse.MapFailure((e: Error) => Types.ComAmazonawsKms(ComAmazonawsKms := e));
      :- Need(decryptResponse.KeyId.Some? && decryptResponse.KeyId.value == awsKmsKey && decryptResponse.Plaintext.Some? && AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat == |decryptResponse.Plaintext.value|, Types.AwsCryptographicMaterialProvidersException(message := ""Invalid response from KMS Decrypt""));
      var output := MaterialWrapping.UnwrapOutput(unwrappedMaterial := decryptResponse.Plaintext.value, unwrapInfo := KmsUnwrapInfo());
      return Success(output);
    }
  }

  class KmsGenerateAndWrapKeyMaterial extends MaterialWrapping.GenerateAndWrapMaterial<KmsWrapInfo> {
    const client: KMS.IKMSClient
    const awsKmsKey: AwsKmsIdentifierString
    const grantTokens: KMS.GrantTokenList

    constructor (client: KMS.IKMSClient, awsKmsKey: AwsKmsIdentifierString, grantTokens: KMS.GrantTokenList)
      requires client.ValidState()
      ensures this.client == client && this.awsKmsKey == awsKmsKey && this.grantTokens == grantTokens
      ensures Invariant()
      decreases client, awsKmsKey, grantTokens
    {
      this.client := client;
      this.awsKmsKey := awsKmsKey;
      this.grantTokens := grantTokens;
      Modifies := client.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      client.ValidState() &&
      client.Modifies == Modifies
    }

    predicate Ensures(input: MaterialWrapping.GenerateAndWrapInput, res: Result<MaterialWrapping.GenerateAndWrapOutput<KmsWrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.GenerateAndWrapInput, Result<MaterialWrapping.GenerateAndWrapOutput<KmsWrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      true &&
      ghost var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(input.encryptionContext); true && (res.Success? ==> Invariant() && maybeStringifiedEncCtx.Success? && 0 < |client.History.GenerateDataKey| && KMS.GenerateDataKeyRequest(EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), KeyId := awsKmsKey, NumberOfBytes := Some(AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite)), KeySpec := None) == Last(client.History.GenerateDataKey).input && Last(client.History.GenerateDataKey).output.Success? && Last(client.History.GenerateDataKey).output.value.CiphertextBlob.Some? && Last(client.History.GenerateDataKey).output.value.CiphertextBlob == Some(res.value.wrappedMaterial) && Last(client.History.GenerateDataKey).output.value.Plaintext.Some? && Last(client.History.GenerateDataKey).output.value.Plaintext == Some(res.value.plaintextMaterial) && Last(client.History.GenerateDataKey).output.value.KeyId == Some(res.value.wrapInfo.kmsKeyArn) && ParseAwsKmsIdentifier(res.value.wrapInfo.kmsKeyArn).Success? && AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat == |res.value.plaintextMaterial| && KMS.IsValid_CiphertextType(res.value.wrappedMaterial) && Last(client.History.GenerateDataKey).output.value == KMS.GenerateDataKeyResponse(KeyId := Some(res.value.wrapInfo.kmsKeyArn), CiphertextBlob := Some(res.value.wrappedMaterial), Plaintext := Some(res.value.plaintextMaterial)))
    }

    method Invoke(input: MaterialWrapping.GenerateAndWrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.GenerateAndWrapInput, Result<MaterialWrapping.GenerateAndWrapOutput<KmsWrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.GenerateAndWrapOutput<KmsWrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      ensures res.Success? ==> |res.value.plaintextMaterial| == input.algorithmSuite.encrypt.AES_GCM.keyLength as nat
      decreases Modifies
    {
      var suite := input.algorithmSuite;
      var stringifiedEncCtx :- StringifyEncryptionContext(input.encryptionContext);
      var generatorRequest := KMS.GenerateDataKeyRequest(EncryptionContext := Some(stringifiedEncCtx), GrantTokens := Some(grantTokens), KeyId := awsKmsKey, NumberOfBytes := Some(AlgorithmSuites.GetEncryptKeyLength(suite)), KeySpec := None);
      var maybeGenerateResponse := client.GenerateDataKey(generatorRequest);
      var generateResponse :- maybeGenerateResponse.MapFailure((e: Error) => Types.ComAmazonawsKms(ComAmazonawsKms := e));
      :- Need(generateResponse.KeyId.Some? && ParseAwsKmsIdentifier(generateResponse.KeyId.value).Success?, Types.AwsCryptographicMaterialProvidersException(message := ""Invalid response from KMS GenerateDataKey:: Invalid Key Id""));
      :- Need(generateResponse.Plaintext.Some? && AlgorithmSuites.GetEncryptKeyLength(suite) as nat == |generateResponse.Plaintext.value|, Types.AwsCryptographicMaterialProvidersException(message := ""Invalid response from AWS KMS GenerateDataKey: Invalid data key""));
      :- Need(generateResponse.CiphertextBlob.Some? && KMS.IsValid_CiphertextType(generateResponse.CiphertextBlob.value), Types.AwsCryptographicMaterialProvidersException(message := ""Invalid response from AWS KMS GeneratedDataKey: Invalid ciphertext""));
      var output := MaterialWrapping.GenerateAndWrapOutput(plaintextMaterial := generateResponse.Plaintext.value, wrappedMaterial := generateResponse.CiphertextBlob.value, wrapInfo := KmsWrapInfo(generateResponse.KeyId.value));
      return Success(output);
    }
  }

  class KmsWrapKeyMaterial extends MaterialWrapping.WrapMaterial<KmsWrapInfo> {
    const client: KMS.IKMSClient
    const awsKmsKey: AwsKmsIdentifierString
    const grantTokens: KMS.GrantTokenList

    constructor (client: KMS.IKMSClient, awsKmsKey: AwsKmsIdentifierString, grantTokens: KMS.GrantTokenList)
      requires client.ValidState()
      ensures this.client == client && this.awsKmsKey == awsKmsKey && this.grantTokens == grantTokens
      ensures Invariant()
      decreases client, awsKmsKey, grantTokens
    {
      this.client := client;
      this.awsKmsKey := awsKmsKey;
      this.grantTokens := grantTokens;
      Modifies := client.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      client.ValidState() &&
      client.Modifies == Modifies &&
      KMS.IsValid_KeyIdType(awsKmsKey)
    }

    predicate Ensures(input: MaterialWrapping.WrapInput, res: Result<MaterialWrapping.WrapOutput<KmsWrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.WrapInput, Result<MaterialWrapping.WrapOutput<KmsWrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      true &&
      ghost var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(input.encryptionContext); true && (res.Success? ==> Invariant() && KMS.IsValid_PlaintextType(input.plaintextMaterial) && KMS.IsValid_KeyIdType(awsKmsKey) && maybeStringifiedEncCtx.Success? && 0 < |client.History.Encrypt| && KMS.EncryptRequest(EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), KeyId := awsKmsKey, Plaintext := input.plaintextMaterial, EncryptionAlgorithm := None) == Last(client.History.Encrypt).input && Last(client.History.Encrypt).output.Success? && Last(client.History.Encrypt).output.value.CiphertextBlob.Some? && Last(client.History.Encrypt).output.value.CiphertextBlob == Some(res.value.wrappedMaterial) && Last(client.History.Encrypt).output.value.KeyId == Some(res.value.wrapInfo.kmsKeyArn) && ParseAwsKmsIdentifier(res.value.wrapInfo.kmsKeyArn).Success? && KMS.IsValid_CiphertextType(res.value.wrappedMaterial))
    }

    method Invoke(input: MaterialWrapping.WrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.WrapInput, Result<MaterialWrapping.WrapOutput<KmsWrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.WrapOutput<KmsWrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      decreases Modifies
    {
      var suite := input.algorithmSuite;
      var stringifiedEncCtx :- StringifyEncryptionContext(input.encryptionContext);
      :- Need(KMS.IsValid_PlaintextType(input.plaintextMaterial), Types.AwsCryptographicMaterialProvidersException(message := ""Invalid Plaintext on KMS Encrypt""));
      var encryptRequest := KMS.EncryptRequest(EncryptionContext := Some(stringifiedEncCtx), GrantTokens := Some(grantTokens), KeyId := awsKmsKey, Plaintext := input.plaintextMaterial, EncryptionAlgorithm := None);
      var maybeEncryptResponse := client.Encrypt(encryptRequest);
      var encryptResponse :- maybeEncryptResponse.MapFailure((e: Error) => Types.ComAmazonawsKms(ComAmazonawsKms := e));
      :- Need(encryptResponse.KeyId.Some? && ParseAwsKmsIdentifier(encryptResponse.KeyId.value).Success?, Types.AwsCryptographicMaterialProvidersException(message := ""Invalid response from AWS KMS Encrypt:: Invalid Key Id""));
      :- Need(encryptResponse.CiphertextBlob.Some?, Types.AwsCryptographicMaterialProvidersException(message := ""Invalid response from AWS KMS Encrypt: Invalid Ciphertext Blob""));
      var output := MaterialWrapping.WrapOutput(wrappedMaterial := encryptResponse.CiphertextBlob.value, wrapInfo := KmsWrapInfo(encryptResponse.KeyId.value));
      return Success(output);
    }
  }
}

module EdkWrapping {

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened Actions

  import opened Wrappers

  import opened MaterialWrapping

  import opened IntermediateKeyWrapping

  import Crypto = AwsCryptographyPrimitivesTypes

  import Types = AwsCryptographyMaterialProvidersTypes

  import Primitives = Aws.Cryptography.Primitives

  import Materials

  import AlgorithmSuites
  datatype WrapEdkMaterialOutput<T> = WrapOnlyEdkMaterialOutput(nameonly wrappedMaterial: seq<uint8>, nameonly symmetricSigningKey: Option<Types.Secret>, nameonly wrapInfo: T, ghost nameonly intermediateMaterial: Option<seq<uint8>>) | GenerateAndWrapEdkMaterialOutput(nameonly plaintextDataKey: seq<uint8>, nameonly wrappedMaterial: seq<uint8>, nameonly symmetricSigningKey: Option<Types.Secret>, nameonly wrapInfo: T, ghost nameonly intermediateMaterial: Option<seq<uint8>>)

  datatype UnwrapEdkMaterialOutput<T> = UnwrapEdkMaterialOutput(nameonly plaintextDataKey: seq<uint8>, nameonly symmetricSigningKey: Option<Types.Secret>, nameonly unwrapInfo: T, ghost nameonly intermediateMaterial: Option<seq<uint8>>)

  method WrapEdkMaterial<T>(nameonly encryptionMaterials: Types.EncryptionMaterials, nameonly wrap: MaterialWrapping.WrapMaterial<T>, nameonly generateAndWrap: MaterialWrapping.GenerateAndWrapMaterial<T>)
      returns (ret: Result<WrapEdkMaterialOutput<T>, Types.Error>)
    requires wrap.Invariant()
    requires generateAndWrap.Invariant()
    modifies wrap.Modifies + generateAndWrap.Modifies
    ensures ret.Success? && encryptionMaterials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? && encryptionMaterials.plaintextDataKey.Some? ==> ret.value.WrapOnlyEdkMaterialOutput? && var wrapRes: WrapOutput<T> := WrapOutput(wrappedMaterial := ret.value.wrappedMaterial, wrapInfo := ret.value.wrapInfo); true && wrap.Ensures(WrapInput(plaintextMaterial := encryptionMaterials.plaintextDataKey.value, algorithmSuite := encryptionMaterials.algorithmSuite, encryptionContext := encryptionMaterials.encryptionContext), Success(wrapRes), [])
    ensures ret.Success? && encryptionMaterials.algorithmSuite.edkWrapping.IntermediateKeyWrapping? && encryptionMaterials.plaintextDataKey.Some? ==> ret.value.WrapOnlyEdkMaterialOutput? && ret.value.intermediateMaterial.Some? && var encryptedPdkLen: nat := (AlgorithmSuites.GetEncryptKeyLength(encryptionMaterials.algorithmSuite) + AlgorithmSuites.GetEncryptTagLength(encryptionMaterials.algorithmSuite)) as nat; |ret.value.wrappedMaterial| >= encryptedPdkLen && generateAndWrap.Ensures(MaterialWrapping.GenerateAndWrapInput(algorithmSuite := encryptionMaterials.algorithmSuite, encryptionContext := encryptionMaterials.encryptionContext), Success(MaterialWrapping.GenerateAndWrapOutput(plaintextMaterial := ret.value.intermediateMaterial.value, wrappedMaterial := ret.value.wrappedMaterial[encryptedPdkLen..], wrapInfo := ret.value.wrapInfo)), [])
    ensures ret.Success? && encryptionMaterials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? && encryptionMaterials.plaintextDataKey.None? ==> ret.value.GenerateAndWrapEdkMaterialOutput? && var generateAndWrapRes: GenerateAndWrapOutput<T> := MaterialWrapping.GenerateAndWrapOutput(plaintextMaterial := ret.value.plaintextDataKey, wrappedMaterial := ret.value.wrappedMaterial, wrapInfo := ret.value.wrapInfo); generateAndWrap.Ensures(MaterialWrapping.GenerateAndWrapInput(algorithmSuite := encryptionMaterials.algorithmSuite, encryptionContext := encryptionMaterials.encryptionContext), Success(generateAndWrapRes), []) && |ret.value.plaintextDataKey| == AlgorithmSuites.GetEncryptKeyLength(encryptionMaterials.algorithmSuite) as nat
    ensures ret.Success? && encryptionMaterials.algorithmSuite.edkWrapping.IntermediateKeyWrapping? && encryptionMaterials.plaintextDataKey.None? ==> ret.value.GenerateAndWrapEdkMaterialOutput? && ret.value.intermediateMaterial.Some? && var encryptedPdkLen: nat := (AlgorithmSuites.GetEncryptKeyLength(encryptionMaterials.algorithmSuite) + AlgorithmSuites.GetEncryptTagLength(encryptionMaterials.algorithmSuite)) as nat; |ret.value.wrappedMaterial| >= encryptedPdkLen && generateAndWrap.Ensures(MaterialWrapping.GenerateAndWrapInput(algorithmSuite := encryptionMaterials.algorithmSuite, encryptionContext := encryptionMaterials.encryptionContext), Success(MaterialWrapping.GenerateAndWrapOutput(plaintextMaterial := ret.value.intermediateMaterial.value, wrappedMaterial := ret.value.wrappedMaterial[encryptedPdkLen..], wrapInfo := ret.value.wrapInfo)), [])
    decreases encryptionMaterials, wrap, generateAndWrap
  {
    :- Need(Materials.ValidEncryptionMaterials(encryptionMaterials), Types.AwsCryptographicMaterialProvidersException(message := ""Invalid materials for decryption.""));
    if encryptionMaterials.plaintextDataKey.Some? && encryptionMaterials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? {
      var directOutput :- wrap.Invoke(WrapInput(plaintextMaterial := encryptionMaterials.plaintextDataKey.value, algorithmSuite := encryptionMaterials.algorithmSuite, encryptionContext := encryptionMaterials.encryptionContext), []);
      return Success(WrapOnlyEdkMaterialOutput(wrappedMaterial := directOutput.wrappedMaterial, symmetricSigningKey := None, wrapInfo := directOutput.wrapInfo, intermediateMaterial := None));
    } else if encryptionMaterials.plaintextDataKey.Some? && encryptionMaterials.algorithmSuite.edkWrapping.IntermediateKeyWrapping? {
      var intermediateOutput :- IntermediateWrap(generateAndWrap := generateAndWrap, plaintextDataKey := encryptionMaterials.plaintextDataKey.value, algorithmSuite := encryptionMaterials.algorithmSuite, encryptionContext := encryptionMaterials.encryptionContext);
      return Success(WrapOnlyEdkMaterialOutput(wrappedMaterial := intermediateOutput.wrappedMaterial, symmetricSigningKey := Some(intermediateOutput.symmetricSigningKey), wrapInfo := intermediateOutput.wrapInfo, intermediateMaterial := Some(intermediateOutput.intermediateMaterial)));
    } else if encryptionMaterials.plaintextDataKey.None? && encryptionMaterials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? {
      var directOutput :- generateAndWrap.Invoke(MaterialWrapping.GenerateAndWrapInput(algorithmSuite := encryptionMaterials.algorithmSuite, encryptionContext := encryptionMaterials.encryptionContext), []);
      return Success(GenerateAndWrapEdkMaterialOutput(plaintextDataKey := directOutput.plaintextMaterial, wrappedMaterial := directOutput.wrappedMaterial, symmetricSigningKey := None, wrapInfo := directOutput.wrapInfo, intermediateMaterial := None));
    } else if encryptionMaterials.plaintextDataKey.None? && encryptionMaterials.algorithmSuite.edkWrapping.IntermediateKeyWrapping? {
      :- Need(encryptionMaterials.algorithmSuite.commitment.HKDF?, Types.AwsCryptographicMaterialProvidersException(message := ""Invalid algorithm suite: suites with intermediate key wrapping must use key commitment.""));
      var intermediateOutput :- IntermediateGenerateAndWrap(generateAndWrap := generateAndWrap, algorithmSuite := encryptionMaterials.algorithmSuite, encryptionContext := encryptionMaterials.encryptionContext);
      return Success(GenerateAndWrapEdkMaterialOutput(plaintextDataKey := intermediateOutput.plaintextDataKey, wrappedMaterial := intermediateOutput.wrappedMaterial, symmetricSigningKey := Some(intermediateOutput.symmetricSigningKey), wrapInfo := intermediateOutput.wrapInfo, intermediateMaterial := Some(intermediateOutput.intermediateMaterial)));
    } else {
      assert false;
    }
  }

  method UnwrapEdkMaterial<T>(wrappedMaterial: seq<uint8>, decryptionMaterials: Materials.DecryptionMaterialsPendingPlaintextDataKey, unwrap: UnwrapMaterial<T>)
      returns (ret: Result<UnwrapEdkMaterialOutput<T>, Types.Error>)
    requires unwrap.Invariant()
    modifies unwrap.Modifies
    ensures ret.Failure? && decryptionMaterials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> unwrap.Ensures(UnwrapInput(wrappedMaterial := wrappedMaterial, algorithmSuite := decryptionMaterials.algorithmSuite, encryptionContext := decryptionMaterials.encryptionContext), Failure(ret.error), [])
    ensures ret.Success? ==> true && var maybeProviderWrappedMaterial: Result<seq<uint8>, Types.Error> := GetProviderWrappedMaterial(wrappedMaterial, decryptionMaterials.algorithmSuite); maybeProviderWrappedMaterial.Success? && (decryptionMaterials.algorithmSuite.edkWrapping.IntermediateKeyWrapping? ==> ret.value.intermediateMaterial.Some?) && var unwrapRes: UnwrapOutput<T> := UnwrapOutput(unwrappedMaterial := if decryptionMaterials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? then ret.value.plaintextDataKey else ret.value.intermediateMaterial.value, unwrapInfo := ret.value.unwrapInfo); true && unwrap.Ensures(UnwrapInput(wrappedMaterial := maybeProviderWrappedMaterial.value, algorithmSuite := decryptionMaterials.algorithmSuite, encryptionContext := decryptionMaterials.encryptionContext), Success(unwrapRes), [])
    decreases wrappedMaterial, decryptionMaterials, unwrap
  {
    :- Need(Materials.ValidDecryptionMaterials(decryptionMaterials), Types.AwsCryptographicMaterialProvidersException(message := ""Invalid materials for decryption.""));
    if decryptionMaterials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? {
      var directOutput :- unwrap.Invoke(UnwrapInput(wrappedMaterial := wrappedMaterial, algorithmSuite := decryptionMaterials.algorithmSuite, encryptionContext := decryptionMaterials.encryptionContext), []);
      return Success(UnwrapEdkMaterialOutput(plaintextDataKey := directOutput.unwrappedMaterial, symmetricSigningKey := None, unwrapInfo := directOutput.unwrapInfo, intermediateMaterial := None));
    } else if decryptionMaterials.algorithmSuite.edkWrapping.IntermediateKeyWrapping? {
      :- Need(|wrappedMaterial| >= (decryptionMaterials.algorithmSuite.encrypt.AES_GCM.keyLength + decryptionMaterials.algorithmSuite.encrypt.AES_GCM.tagLength) as int, Types.AwsCryptographicMaterialProvidersException(message := ""Invalid material for Intermediate Unwrapping""));
      var intermediateOutput :- IntermediateUnwrap(unwrap := unwrap, wrappedMaterial := wrappedMaterial, algorithmSuite := decryptionMaterials.algorithmSuite, encryptionContext := decryptionMaterials.encryptionContext);
      return Success(UnwrapEdkMaterialOutput(plaintextDataKey := intermediateOutput.plaintextDataKey, symmetricSigningKey := Some(intermediateOutput.symmetricSigningKey), unwrapInfo := intermediateOutput.unwrapInfo, intermediateMaterial := Some(intermediateOutput.intermediateMaterial)));
    } else {
      assert false;
    }
  }

  function method GetProviderWrappedMaterial(material: seq<uint8>, algSuite: Types.AlgorithmSuiteInfo): (r: Result<seq<uint8>, Types.Error>)
    ensures r.Success? && algSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> r.value == material
    ensures r.Success? && algSuite.edkWrapping.IntermediateKeyWrapping? ==> var deserializedRes: Result<DeserializedIntermediateWrappedMaterial, Types.Error> := DeserializeIntermediateWrappedMaterial(material, algSuite); deserializedRes.Success? && r.value == deserializedRes.value.providerWrappedIkm
    decreases material, algSuite
  {
    if algSuite.edkWrapping.DIRECT_KEY_WRAPPING? then
      Success(material)
    else
      assert algSuite.edkWrapping.IntermediateKeyWrapping?; var deserializedWrappedRes: Result<DeserializedIntermediateWrappedMaterial, Types.Error> := DeserializeIntermediateWrappedMaterial(material, algSuite); if deserializedWrappedRes.Failure? then Failure(Types.AwsCryptographicMaterialProvidersException(message := ""Unable to deserialize Intermediate Key Wrapped material."")) else Success(deserializedWrappedRes.value.providerWrappedIkm)
  }
}

module MaterialWrapping {

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened Actions

  import opened Wrappers

  import Types = AwsCryptographyMaterialProvidersTypes

  import Primitives = Aws.Cryptography.Primitives

  import Materials

  import AlgorithmSuites
  datatype GenerateAndWrapInput = GenerateAndWrapInput(nameonly algorithmSuite: Types.AlgorithmSuiteInfo, nameonly encryptionContext: Types.EncryptionContext)

  datatype GenerateAndWrapOutput<T> = GenerateAndWrapOutput(nameonly plaintextMaterial: seq<uint8>, nameonly wrappedMaterial: seq<uint8>, nameonly wrapInfo: T)

  datatype WrapInput = WrapInput(nameonly plaintextMaterial: seq<uint8>, nameonly algorithmSuite: Types.AlgorithmSuiteInfo, nameonly encryptionContext: Types.EncryptionContext)

  datatype WrapOutput<T> = WrapOutput(nameonly wrappedMaterial: seq<uint8>, nameonly wrapInfo: T)

  datatype UnwrapInput = UnwrapInput(nameonly wrappedMaterial: seq<uint8>, nameonly algorithmSuite: Types.AlgorithmSuiteInfo, nameonly encryptionContext: Types.EncryptionContext)

  datatype UnwrapOutput<T> = UnwrapOutput(nameonly unwrappedMaterial: seq<uint8>, nameonly unwrapInfo: T)

  trait {:termination false} GenerateAndWrapMaterial<T> extends ActionWithResult<GenerateAndWrapInput, GenerateAndWrapOutput<T>, Types.Error> {
    method Invoke(input: GenerateAndWrapInput, ghost attemptsState: seq<ActionInvoke<GenerateAndWrapInput, Result<GenerateAndWrapOutput<T>, Types.Error>>>) returns (r: Result<GenerateAndWrapOutput<T>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, r, attemptsState)
      ensures r.Success? ==> |r.value.plaintextMaterial| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat
      decreases Modifies
  }

  trait {:termination false} WrapMaterial<T> extends ActionWithResult<WrapInput, WrapOutput<T>, Types.Error> {
    method Invoke(input: WrapInput, ghost attemptsState: seq<ActionInvoke<WrapInput, Result<WrapOutput<T>, Types.Error>>>) returns (r: Result<WrapOutput<T>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, r, attemptsState)
      decreases Modifies
  }

  trait {:termination false} UnwrapMaterial<T> extends ActionWithResult<UnwrapInput, UnwrapOutput<T>, Types.Error> {
    method Invoke(input: UnwrapInput, ghost attemptsState: seq<ActionInvoke<UnwrapInput, Result<UnwrapOutput<T>, Types.Error>>>) returns (r: Result<UnwrapOutput<T>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, r, attemptsState)
      ensures r.Success? ==> |r.value.unwrappedMaterial| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat
      decreases Modifies
  }
}

module IntermediateKeyWrapping {

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened Actions

  import opened Wrappers

  import opened MaterialWrapping

  import opened AlgorithmSuites

  import Crypto = AwsCryptographyPrimitivesTypes

  import Types = AwsCryptographyMaterialProvidersTypes

  import Primitives = Aws.Cryptography.Primitives

  import Materials

  import UTF8

  import HKDF

  import CanonicalEncryptionContext
  datatype IntermediateUnwrapOutput<T> = IntermediateUnwrapOutput(nameonly plaintextDataKey: seq<uint8>, nameonly symmetricSigningKey: seq<uint8>, nameonly unwrapInfo: T, ghost nameonly intermediateMaterial: seq<uint8>)

  datatype IntermediateGenerateAndWrapOutput<T> = IntermediateGenerateAndWrapOutput(nameonly plaintextDataKey: seq<uint8>, nameonly wrappedMaterial: seq<uint8>, nameonly symmetricSigningKey: seq<uint8>, nameonly wrapInfo: T, ghost nameonly intermediateMaterial: seq<uint8>)

  datatype IntermediateWrapOutput<T> = IntermediateWrapOutput(nameonly wrappedMaterial: seq<uint8>, nameonly symmetricSigningKey: seq<uint8>, nameonly wrapInfo: T, ghost nameonly intermediateMaterial: seq<uint8>)

  datatype DeserializedIntermediateWrappedMaterial = DeserializedIntermediateWrappedMaterial(nameonly encryptedPdk: seq<uint8>, nameonly providerWrappedIkm: seq<uint8>)

  datatype PdkEncryptionAndSymmetricSigningKeys = PdkEncryptionAndSymmetricSigningKeys(nameonly pdkEncryptionKey: seq<uint8>, nameonly symmetricSigningKey: seq<uint8>)

  const KEYWRAP_MAC_INFO := UTF8.EncodeAscii(""AWS_MPL_INTERMEDIATE_KEYWRAP_MAC"")
  const KEYWRAP_ENC_INFO := UTF8.EncodeAscii(""AWS_MPL_INTERMEDIATE_KEYWRAP_ENC"")

  method IntermediateUnwrap<T>(unwrap: UnwrapMaterial<T>, wrappedMaterial: seq<uint8>, algorithmSuite: Types.AlgorithmSuiteInfo, encryptionContext: Types.EncryptionContext)
      returns (res: Result<IntermediateUnwrapOutput<T>, Types.Error>)
    requires unwrap.Invariant()
    requires |wrappedMaterial| >= (AlgorithmSuites.GetEncryptKeyLength(algorithmSuite) + AlgorithmSuites.GetEncryptTagLength(algorithmSuite)) as nat
    requires algorithmSuite.commitment.HKDF?
    modifies unwrap.Modifies
    ensures res.Success? ==> |res.value.plaintextDataKey| == AlgorithmSuites.GetEncryptKeyLength(algorithmSuite) as nat
    ensures res.Success? ==> true && var maybeIntermediateWrappedMat: Result<DeserializedIntermediateWrappedMaterial, Types.Error> := DeserializeIntermediateWrappedMaterial(wrappedMaterial, algorithmSuite); maybeIntermediateWrappedMat.Success? && var unwrapRes: UnwrapOutput<T> := UnwrapOutput(unwrappedMaterial := res.value.intermediateMaterial, unwrapInfo := res.value.unwrapInfo); true && unwrap.Ensures(UnwrapInput(wrappedMaterial := maybeIntermediateWrappedMat.value.providerWrappedIkm, encryptionContext := encryptionContext, algorithmSuite := algorithmSuite), Success(unwrapRes), [])
    decreases unwrap, wrappedMaterial, algorithmSuite, encryptionContext
  {
    var maybeCrypto := Primitives.AtomicPrimitives();
    var cryptoPrimitives :- maybeCrypto.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
    var deserializedWrapped :- DeserializeIntermediateWrappedMaterial(wrappedMaterial, algorithmSuite);
    var DeserializedIntermediateWrappedMaterial(encryptedPdk, providerWrappedIkm) := deserializedWrapped;
    var unwrapOutput :- unwrap.Invoke(UnwrapInput(wrappedMaterial := providerWrappedIkm, encryptionContext := encryptionContext, algorithmSuite := algorithmSuite), []);
    var UnwrapOutput(intermediateMaterial, unwrapInfo) := unwrapOutput;
    var derivedKeys :- DeriveKeysFromIntermediateMaterial(intermediateMaterial, algorithmSuite, encryptionContext, cryptoPrimitives);
    var PdkEncryptionAndSymmetricSigningKeys(pdkEncryptionKey, symmetricSigningKey) := derivedKeys;
    var iv: seq<uint8> := seq(AlgorithmSuites.GetEncryptIvLength(algorithmSuite) as nat, (_ /* _v0 */: int) => 0);
    var tagIndex := |encryptedPdk| - AlgorithmSuites.GetEncryptTagLength(algorithmSuite) as nat;
    var aad :- CanonicalEncryptionContext.EncryptionContextToAAD(encryptionContext);
    var decInput := Crypto.AESDecryptInput(encAlg := algorithmSuite.encrypt.AES_GCM, iv := iv, key := pdkEncryptionKey, cipherTxt := encryptedPdk[..tagIndex], authTag := encryptedPdk[tagIndex..], aad := aad);
    var decOutR := cryptoPrimitives.AESDecrypt(decInput);
    var plaintextDataKey :- decOutR.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
    :- Need(|plaintextDataKey| == AlgorithmSuites.GetEncryptKeyLength(algorithmSuite) as nat, Types.AwsCryptographicMaterialProvidersException(message := ""Unexpected AES_GCM Decrypt length""));
    return Success(IntermediateUnwrapOutput(plaintextDataKey := plaintextDataKey, symmetricSigningKey := symmetricSigningKey, unwrapInfo := unwrapInfo, intermediateMaterial := intermediateMaterial));
  }

  method IntermediateWrap<T>(generateAndWrap: GenerateAndWrapMaterial<T>, plaintextDataKey: seq<uint8>, algorithmSuite: Types.AlgorithmSuiteInfo, encryptionContext: Types.EncryptionContext)
      returns (res: Result<IntermediateWrapOutput<T>, Types.Error>)
    requires generateAndWrap.Invariant()
    requires algorithmSuite.commitment.HKDF?
    requires |plaintextDataKey| == AlgorithmSuites.GetEncryptKeyLength(algorithmSuite) as nat
    modifies generateAndWrap.Modifies
    ensures res.Success? ==> true && var maybeIntermediateWrappedMat: Result<DeserializedIntermediateWrappedMaterial, Types.Error> := DeserializeIntermediateWrappedMaterial(res.value.wrappedMaterial, algorithmSuite); maybeIntermediateWrappedMat.Success? && generateAndWrap.Ensures(GenerateAndWrapInput(algorithmSuite := algorithmSuite, encryptionContext := encryptionContext), Success(GenerateAndWrapOutput(plaintextMaterial := res.value.intermediateMaterial, wrappedMaterial := maybeIntermediateWrappedMat.value.providerWrappedIkm, wrapInfo := res.value.wrapInfo)), []) && res.value.wrappedMaterial == maybeIntermediateWrappedMat.value.encryptedPdk + maybeIntermediateWrappedMat.value.providerWrappedIkm && |maybeIntermediateWrappedMat.value.encryptedPdk| == (AlgorithmSuites.GetEncryptKeyLength(algorithmSuite) + AlgorithmSuites.GetEncryptTagLength(algorithmSuite)) as nat
    decreases generateAndWrap, plaintextDataKey, algorithmSuite, encryptionContext
  {
    var maybeCrypto := Primitives.AtomicPrimitives();
    var cryptoPrimitives :- maybeCrypto.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
    var generateAndWrapOutput :- generateAndWrap.Invoke(GenerateAndWrapInput(algorithmSuite := algorithmSuite, encryptionContext := encryptionContext), []);
    var GenerateAndWrapOutput(intermediateMaterial, providerWrappedIkm, wrapInfo) := generateAndWrapOutput;
    var derivedKeys :- DeriveKeysFromIntermediateMaterial(intermediateMaterial, algorithmSuite, encryptionContext, cryptoPrimitives);
    var PdkEncryptionAndSymmetricSigningKeys(pdkEncryptionKey, symmetricSigningKey) := derivedKeys;
    var iv: seq<uint8> := seq(AlgorithmSuites.GetEncryptIvLength(algorithmSuite) as nat, (_ /* _v1 */: int) => 0);
    var aad :- CanonicalEncryptionContext.EncryptionContextToAAD(encryptionContext);
    var encInput := Crypto.AESEncryptInput(encAlg := algorithmSuite.encrypt.AES_GCM, iv := iv, key := pdkEncryptionKey, msg := plaintextDataKey, aad := aad);
    var encOutR := cryptoPrimitives.AESEncrypt(encInput);
    var encryptedPdk :- encOutR.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
    :- Need(|encryptedPdk.cipherText + encryptedPdk.authTag| == (AlgorithmSuites.GetEncryptKeyLength(algorithmSuite) + AlgorithmSuites.GetEncryptTagLength(algorithmSuite)) as nat, Types.AwsCryptographicMaterialProvidersException(message := ""Unexpected AES_GCM Encrypt length""));
    var serializedMaterial := encryptedPdk.cipherText + encryptedPdk.authTag + providerWrappedIkm;
    return Success(IntermediateWrapOutput(wrappedMaterial := serializedMaterial, symmetricSigningKey := symmetricSigningKey, wrapInfo := wrapInfo, intermediateMaterial := intermediateMaterial));
  }

  method IntermediateGenerateAndWrap<T>(generateAndWrap: GenerateAndWrapMaterial<T>, algorithmSuite: Types.AlgorithmSuiteInfo, encryptionContext: Types.EncryptionContext)
      returns (res: Result<IntermediateGenerateAndWrapOutput<T>, Types.Error>)
    requires generateAndWrap.Invariant()
    requires algorithmSuite.commitment.HKDF?
    modifies generateAndWrap.Modifies
    ensures res.Success? ==> true && var maybeIntermediateWrappedMat: Result<DeserializedIntermediateWrappedMaterial, Types.Error> := DeserializeIntermediateWrappedMaterial(res.value.wrappedMaterial, algorithmSuite); maybeIntermediateWrappedMat.Success? && generateAndWrap.Ensures(GenerateAndWrapInput(algorithmSuite := algorithmSuite, encryptionContext := encryptionContext), Success(GenerateAndWrapOutput(plaintextMaterial := res.value.intermediateMaterial, wrappedMaterial := maybeIntermediateWrappedMat.value.providerWrappedIkm, wrapInfo := res.value.wrapInfo)), [])
    decreases generateAndWrap, algorithmSuite, encryptionContext
  {
    var maybeCrypto := Primitives.AtomicPrimitives();
    var cryptoPrimitives :- maybeCrypto.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
    var generateBytesResult := cryptoPrimitives.GenerateRandomBytes(Crypto.GenerateRandomBytesInput(length := GetEncryptKeyLength(algorithmSuite)));
    var plaintextDataKey :- generateBytesResult.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
    var wrapOutput :- IntermediateWrap(generateAndWrap, plaintextDataKey, algorithmSuite, encryptionContext);
    return Success(IntermediateGenerateAndWrapOutput(plaintextDataKey := plaintextDataKey, wrappedMaterial := wrapOutput.wrappedMaterial, symmetricSigningKey := wrapOutput.symmetricSigningKey, wrapInfo := wrapOutput.wrapInfo, intermediateMaterial := wrapOutput.intermediateMaterial));
  }

  function method DeserializeIntermediateWrappedMaterial(material: seq<uint8>, algSuite: Types.AlgorithmSuiteInfo): (ret: Result<DeserializedIntermediateWrappedMaterial, Types.Error>)
    decreases material, algSuite
  {
    Need(|material| >= (AlgorithmSuites.GetEncryptKeyLength(algSuite) + AlgorithmSuites.GetEncryptTagLength(algSuite)) as nat, Types.AwsCryptographicMaterialProvidersException(message := ""Unable to deserialize Intermediate Key Wrapped material: too short."")); var encryptedPdkLen: BoundedInts.int32 := AlgorithmSuites.GetEncryptKeyLength(algSuite) + AlgorithmSuites.GetEncryptTagLength(algSuite); Success(DeserializedIntermediateWrappedMaterial(encryptedPdk := material[..encryptedPdkLen], providerWrappedIkm := material[encryptedPdkLen..]))
  }

  method DeriveKeysFromIntermediateMaterial(intermediateMaterial: seq<uint8>, algorithmSuite: Types.AlgorithmSuiteInfo, encryptionContext: Types.EncryptionContext, cryptoPrimitives: Primitives.AtomicPrimitivesClient)
      returns (res: Result<PdkEncryptionAndSymmetricSigningKeys, Types.Error>)
    requires cryptoPrimitives.ValidState()
    requires algorithmSuite.commitment.HKDF?
    modifies cryptoPrimitives.Modifies
    ensures cryptoPrimitives.ValidState()
    decreases intermediateMaterial, algorithmSuite, encryptionContext, cryptoPrimitives
  {
    var hkdfExtractInput := Crypto.HkdfExtractInput(digestAlgorithm := algorithmSuite.commitment.HKDF.hmac, salt := None, ikm := intermediateMaterial);
    var maybePseudoRandomKey := cryptoPrimitives.HkdfExtract(hkdfExtractInput);
    var pseudoRandomKey :- maybePseudoRandomKey.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
    var symmetricSigningKeyInput := Crypto.HkdfExpandInput(digestAlgorithm := algorithmSuite.commitment.HKDF.hmac, prk := pseudoRandomKey, info := KEYWRAP_MAC_INFO, expectedLength := algorithmSuite.commitment.HKDF.outputKeyLength);
    var pdkEncryptionKeyInput := symmetricSigningKeyInput.(info := KEYWRAP_ENC_INFO);
    var maybeSymmetricSigningKey := cryptoPrimitives.HkdfExpand(symmetricSigningKeyInput);
    var symmetricSigningKey :- maybeSymmetricSigningKey.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
    var maybePdkEncryptionKey := cryptoPrimitives.HkdfExpand(pdkEncryptionKeyInput);
    var pdkEncryptionKey :- maybePdkEncryptionKey.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
    return Success(PdkEncryptionAndSymmetricSigningKeys(pdkEncryptionKey := pdkEncryptionKey, symmetricSigningKey := symmetricSigningKey));
  }
}

module CanonicalEncryptionContext {

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import Types = AwsCryptographyMaterialProvidersTypes

  import opened Wrappers

  import Seq
  function method EncryptionContextToAAD(encryptionContext: Types.EncryptionContext): (res: Result<seq<uint8>, Types.Error>)
    decreases encryptionContext
  {
    Need(|encryptionContext| < UINT16_LIMIT, Types.AwsCryptographicMaterialProvidersException(message := ""Encryption Context is too large"")); var keys: seq<seq<uint8>> := SetToOrderedSequence(encryptionContext.Keys, UInt.UInt8Less); if |keys| == 0 then Success([]) else var KeyIntoPairBytes: seq<uint8> --> Result<seq<uint8>, Error> := (k: seq<uint8>) requires k in encryptionContext => var v: ValidUTF8Bytes := encryptionContext[k]; Need(HasUint16Len(k) && HasUint16Len(v), Types.AwsCryptographicMaterialProvidersException(message := ""Unable to serialize encryption context"")); Success(UInt16ToSeq(|k| as uint16) + k + UInt16ToSeq(|v| as uint16) + v); var pairsBytes: seq<seq<uint8>> :- Seq.MapWithResult(KeyIntoPairBytes, keys); var allBytes: seq<uint8> := UInt16ToSeq(|keys| as uint16) + Seq.Flatten(pairsBytes); Success(allBytes)
  }
}

module Constants {

  import UTF8

  import Types = AwsCryptographyMaterialProvidersTypes

  import AwsArnParsing
  type AwsKmsEncryptedDataKey = edk: Types.EncryptedDataKey
    | edk.keyProviderId == PROVIDER_ID && UTF8.ValidUTF8Seq(edk.keyProviderInfo)
    witness *

  datatype AwsKmsEdkHelper = AwsKmsEdkHelper(edk: AwsKmsEncryptedDataKey, arn: AwsArnParsing.AwsKmsArn)

  const PROVIDER_ID: UTF8.ValidUTF8Bytes := var s: seq<BoundedInts.uint8> := [97, 119, 115, 45, 107, 109, 115]; assert UTF8.ValidUTF8Range(s, 0, 7); s
  const PROVIDER_ID_HIERARCHY: UTF8.ValidUTF8Bytes := var s: seq<BoundedInts.uint8> := [97, 119, 115, 45, 107, 109, 115, 45, 104, 105, 101, 114, 97, 114, 99, 104, 121]; assert UTF8.ValidUTF8Range(s, 0, 17); s
  const RSA_PROVIDER_ID: UTF8.ValidUTF8Bytes := var s: seq<BoundedInts.uint8> := [97, 119, 115, 45, 107, 109, 115, 45, 114, 115, 97]; assert UTF8.ValidUTF8Range(s, 0, 11); s
}

module AwsKmsHierarchicalKeyring {

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened AwsArnParsing

  import opened AwsKmsUtils

  import opened Seq

  import opened Actions

  import opened Constants

  import opened A = AwsKmsMrkMatchForDecrypt

  import LocalCMC

  import SynchronizedLocalCMC

  import StormTracker

  import StormTrackingCMC

  import opened AlgorithmSuites

  import EdkWrapping

  import MaterialWrapping

  import CanonicalEncryptionContext

  import Keyring

  import Materials

  import Time

  import Random

  import Digest

  import Types = AwsCryptographyMaterialProvidersTypes

  import Crypto = AwsCryptographyPrimitivesTypes

  import KMS = ComAmazonawsKmsTypes

  import DDB = ComAmazonawsDynamodbTypes

  import KeyStore = AwsCryptographyKeyStoreTypes

  import UTF8

  import UUID

  import HKDF

  import HMAC

  import opened AESEncryption

  import Primitives = Aws.Cryptography.Primitives
  class AwsKmsHierarchicalKeyring extends Keyring.VerifiableInterface {
    const branchKeyId: Option<string>
    const branchKeyIdSupplier: Option<Types.IBranchKeyIdSupplier>
    const keyStore: KeyStore.IKeyStoreClient
    const ttlSeconds: Types.PositiveLong
    const cryptoPrimitives: Primitives.AtomicPrimitivesClient
    const cache: Types.ICryptographicMaterialsCache

    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      keyStore.ValidState() &&
      cryptoPrimitives.ValidState() &&
      (branchKeyIdSupplier.Some? ==>
        branchKeyIdSupplier.value.ValidState()) &&
      keyStore.Modifies <= Modifies &&
      cryptoPrimitives.Modifies <= Modifies &&
      (branchKeyIdSupplier.Some? ==>
        branchKeyIdSupplier.value.Modifies <= Modifies) &&
      History !in keyStore.Modifies &&
      History !in cryptoPrimitives.Modifies &&
      (branchKeyIdSupplier.Some? ==>
        History !in branchKeyIdSupplier.value.Modifies) &&
      (branchKeyIdSupplier.Some? || branchKeyId.Some?) &&
      (branchKeyIdSupplier.None? || branchKeyId.None?)
    }

    constructor (keyStore: KeyStore.IKeyStoreClient, branchKeyId: Option<string>, branchKeyIdSupplier: Option<Types.IBranchKeyIdSupplier>, ttlSeconds: Types.PositiveLong, cmc: Types.ICryptographicMaterialsCache, cryptoPrimitives: Primitives.AtomicPrimitivesClient)
      requires ttlSeconds >= 0
      requires keyStore.ValidState() && cryptoPrimitives.ValidState()
      requires branchKeyIdSupplier.Some? ==> branchKeyIdSupplier.value.ValidState()
      requires branchKeyIdSupplier.Some? || branchKeyId.Some?
      requires branchKeyIdSupplier.None? || branchKeyId.None?
      ensures this.keyStore == keyStore && this.branchKeyIdSupplier == branchKeyIdSupplier && this.ttlSeconds == ttlSeconds
      ensures ValidState() && fresh(this) && fresh(History) && var maybeSupplierModifies: set<object> := if branchKeyIdSupplier.Some? then branchKeyIdSupplier.value.Modifies else {}; true && fresh(Modifies - keyStore.Modifies - cryptoPrimitives.Modifies - maybeSupplierModifies)
      decreases keyStore, branchKeyId, branchKeyIdSupplier, ttlSeconds, cmc, cryptoPrimitives
    {
      this.keyStore := keyStore;
      this.branchKeyId := branchKeyId;
      this.branchKeyIdSupplier := branchKeyIdSupplier;
      this.ttlSeconds := ttlSeconds;
      this.cryptoPrimitives := cryptoPrimitives;
      this.cache := cmc;
      History := new Types.IKeyringCallHistory();
      ghost var maybeSupplierModifies := if branchKeyIdSupplier.Some? then branchKeyIdSupplier.value.Modifies else {};
      Modifies := {History} + keyStore.Modifies + cryptoPrimitives.Modifies + maybeSupplierModifies;
    }

    method GetBranchKeyId(context: Types.EncryptionContext) returns (ret: Result<string, Types.Error>)
      requires ValidState()
      modifies if branchKeyIdSupplier.Some? then branchKeyIdSupplier.value.Modifies else {}
      ensures ValidState()
      ensures branchKeyId.Some? ==> ret.Success? && ret.value == branchKeyId.value
      decreases context
    {
      if branchKeyId.Some? {
        return Success(branchKeyId.value);
      } else {
        var GetBranchKeyIdOut :- branchKeyIdSupplier.value.GetBranchKeyId(Types.GetBranchKeyIdInput(encryptionContext := context));
        return Success(GetBranchKeyIdOut.branchKeyId);
      }
    }

    predicate OnEncryptEnsuresPublicly(input: Types.OnEncryptInput, output: Result<Types.OnEncryptOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method {:vcs_split_on_every_assert} OnEncrypt'(input: Types.OnEncryptInput) returns (res: Result<Types.OnEncryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnEncryptEnsuresPublicly(input, res)
      ensures unchanged(History)
      ensures res.Success? ==> true && Materials.ValidEncryptionMaterialsTransition(input.materials, res.value.materials)
      decreases Modifies - {History}
    {
      var materials := input.materials;
      var suite := materials.algorithmSuite;
      var branchKeyIdForEncrypt :- GetBranchKeyId(materials.encryptionContext);
      var branchKeyIdUtf8 :- UTF8.Encode(branchKeyIdForEncrypt).MapFailure(WrapStringToError);
      var cacheId :- GetActiveCacheId(branchKeyIdForEncrypt, branchKeyIdUtf8, cryptoPrimitives);
      var hierarchicalMaterials :- GetActiveHierarchicalMaterials(branchKeyIdForEncrypt, cacheId, keyStore);
      var branchKey := hierarchicalMaterials.branchKey;
      var branchKeyVersion := hierarchicalMaterials.branchKeyVersion;
      var branchKeyVersionAsString :- UTF8.Decode(branchKeyVersion).MapFailure(WrapStringToError);
      var branchKeyVersionAsBytes :- UUID.ToByteArray(branchKeyVersionAsString).MapFailure(WrapStringToError);
      var kmsHierarchyGenerateAndWrap := new KmsHierarchyGenerateAndWrapKeyMaterial(hierarchicalMaterials.branchKey, branchKeyIdUtf8, branchKeyVersionAsBytes, cryptoPrimitives);
      var kmsHierarchyWrap := new KmsHierarchyWrapKeyMaterial(hierarchicalMaterials.branchKey, branchKeyIdUtf8, branchKeyVersionAsBytes, cryptoPrimitives);
      var wrapOutput :- EdkWrapping.WrapEdkMaterial<HierarchyWrapInfo>(encryptionMaterials := materials, wrap := kmsHierarchyWrap, generateAndWrap := kmsHierarchyGenerateAndWrap);
      var symmetricSigningKeyList := if wrapOutput.symmetricSigningKey.Some? then Some([wrapOutput.symmetricSigningKey.value]) else None;
      var edk := Types.EncryptedDataKey(keyProviderId := PROVIDER_ID_HIERARCHY, keyProviderInfo := branchKeyIdUtf8, ciphertext := wrapOutput.wrappedMaterial);
      if wrapOutput.GenerateAndWrapEdkMaterialOutput? {
        var result :- Materials.EncryptionMaterialAddDataKey(materials, wrapOutput.plaintextDataKey, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      } else if wrapOutput.WrapOnlyEdkMaterialOutput? {
        var result :- Materials.EncryptionMaterialAddEncryptedDataKeys(materials, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      }
    }

    predicate OnDecryptEnsuresPublicly(input: Types.OnDecryptInput, output: Result<Types.OnDecryptOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method OnDecrypt'(input: Types.OnDecryptInput) returns (res: Result<Types.OnDecryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnDecryptEnsuresPublicly(input, res)
      ensures unchanged(History)
      ensures res.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, res.value.materials)
      decreases Modifies - {History}
    {
      var materials := input.materials;
      var suite := input.materials.algorithmSuite;
      :- Need(Materials.DecryptionMaterialsWithoutPlaintextDataKey(materials), E(""Keyring received decryption materials that already contain a plaintext data key.""));
      var branchKeyIdForDecrypt :- GetBranchKeyId(materials.encryptionContext);
      var filter := new OnDecryptHierarchyEncryptedDataKeyFilter(branchKeyIdForDecrypt);
      var edksToAttempt :- FilterWithResult(filter, input.encryptedDataKeys);
      :- Need(0 < |edksToAttempt|, E(""Unable to decrypt data key: No Encrypted Data Keys found to match.""));
      var decryptClosure := new DecryptSingleEncryptedDataKey(materials, keyStore, cryptoPrimitives, branchKeyIdForDecrypt, ttlSeconds, cache);
      var outcome, attempts := ReduceToSuccess(decryptClosure, edksToAttempt);
      var SealedDecryptionMaterials :- outcome.MapFailure((errors: seq<Types.Error>) => Types.CollectionOfErrors(list := errors, message := ""No Configured KMS Key was able to decrypt the Data Key. The list of encountered Exceptions is available via `list`.""));
      assert decryptClosure.Ensures(Last(attempts).input, Success(SealedDecryptionMaterials), DropLast(attempts));
      return Success(Types.OnDecryptOutput(materials := SealedDecryptionMaterials));
    }

    method GetActiveCacheId(branchKeyId: string, branchKeyIdUtf8: seq<uint8>, cryptoPrimitives: Primitives.AtomicPrimitivesClient)
        returns (cacheId: Result<seq<uint8>, Types.Error>)
      requires cryptoPrimitives.ValidState()
      modifies cryptoPrimitives.Modifies
      ensures cryptoPrimitives.ValidState()
      ensures cacheId.Success? ==> |cacheId.value| == 32
      decreases branchKeyId, branchKeyIdUtf8, cryptoPrimitives
    {
      :- Need(UTF8.Decode(branchKeyIdUtf8).MapFailure(WrapStringToError).Success? && var branchKeyId: string := UTF8.Decode(branchKeyIdUtf8).MapFailure(WrapStringToError).value; true && 0 <= |branchKeyId| < UINT32_LIMIT, E(""Invalid Branch Key ID Length""));
      var branchKeyId := UTF8.Decode(branchKeyIdUtf8).value;
      var lenBranchKey := UInt.UInt32ToSeq(|branchKeyId| as uint32);
      var hashAlgorithm := Crypto.DigestAlgorithm.SHA_512;
      var maybeBranchKeyDigest := cryptoPrimitives.Digest(Crypto.DigestInput(digestAlgorithm := hashAlgorithm, message := branchKeyIdUtf8));
      var branchKeyDigest :- maybeBranchKeyDigest.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      var activeUtf8 :- UTF8.Encode(EXPRESSION_ATTRIBUTE_VALUE_STATUS_VALUE).MapFailure(WrapStringToError);
      var identifier := lenBranchKey + branchKeyDigest + [0] + activeUtf8;
      var maybeCacheIdDigest := cryptoPrimitives.Digest(Crypto.DigestInput(digestAlgorithm := hashAlgorithm, message := identifier));
      var cacheDigest :- maybeCacheIdDigest.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      :- Need(|cacheDigest| == Digest.Length(hashAlgorithm), Types.AwsCryptographicMaterialProvidersException(message := ""Digest generated a message not equal to the expected length.""));
      return Success(cacheDigest[0 .. 32]);
    }

    method GetActiveHierarchicalMaterials(branchKeyId: string, cacheId: seq<uint8>, keyStore: KeyStore.IKeyStoreClient)
        returns (material: Result<KeyStore.BranchKeyMaterials, Types.Error>)
      requires ValidState()
      requires keyStore.ValidState()
      modifies keyStore.Modifies
      ensures ValidState()
      ensures keyStore.ValidState()
      decreases branchKeyId, cacheId, keyStore
    {
      var getCacheInput := Types.GetCacheEntryInput(identifier := cacheId, bytesUsed := None);
      verifyValidStateCache(cache);
      var getCacheOutput := getEntry(cache, getCacheInput);
      if getCacheOutput.Failure? {
        var maybeGetActiveBranchKeyOutput := keyStore.GetActiveBranchKey(KeyStore.GetActiveBranchKeyInput(branchKeyIdentifier := branchKeyId));
        var getActiveBranchKeyOutput :- maybeGetActiveBranchKeyOutput.MapFailure((e: Error) => Types.AwsCryptographyKeyStore(AwsCryptographyKeyStore := e));
        var branchKeyMaterials := getActiveBranchKeyOutput.branchKeyMaterials;
        var now := Time.GetCurrent();
        :- Need(now as int + ttlSeconds as int < UInt.INT64_MAX_LIMIT, Types.AwsCryptographicMaterialProvidersException(message := ""INT64 Overflow when putting cache entry.""));
        var putCacheEntryInput := Types.PutCacheEntryInput(identifier := cacheId, materials := Types.Materials.BranchKey(branchKeyMaterials), creationTime := now, expiryTime := ttlSeconds + now, messagesUsed := None, bytesUsed := None);
        verifyValidStateCache(cache);
        var _ /* _v0 */ :- putEntry(cache, putCacheEntryInput);
        return Success(branchKeyMaterials);
      } else {
        :- Need(getCacheOutput.value.materials.BranchKey? && getCacheOutput.value.materials == Types.Materials.BranchKey(getCacheOutput.value.materials.BranchKey), E(""Invalid Material Type.""));
        return Success(getCacheOutput.value.materials.BranchKey);
      }
    }
  }

  class OnDecryptHierarchyEncryptedDataKeyFilter extends DeterministicActionWithResult<Types.EncryptedDataKey, bool, Types.Error> {
    const branchKeyId: string

    constructor (branchKeyId: string)
      decreases branchKeyId
    {
      this.branchKeyId := branchKeyId;
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<bool, Types.Error>)
      decreases edk, res
    {
      true &&
      (res.Success? &&
      res.value ==>
        edk.keyProviderId == PROVIDER_ID_HIERARCHY)
    }

    method Invoke(edk: Types.EncryptedDataKey) returns (res: Result<bool, Types.Error>)
      ensures Ensures(edk, res)
      decreases edk
    {
      var providerInfo := edk.keyProviderInfo;
      var providerId := edk.keyProviderId;
      if providerId != PROVIDER_ID_HIERARCHY {
        return Success(false);
      }
      if !UTF8.ValidUTF8Seq(providerInfo) {
        return Failure(E(""Invalid encoding, provider info is not UTF8.""));
      }
      var branchKeyId :- UTF8.Decode(providerInfo).MapFailure(WrapStringToError);
      return Success(this.branchKeyId == branchKeyId);
    }
  }

  class DecryptSingleEncryptedDataKey extends ActionWithResult<Types.EncryptedDataKey, Materials.SealedDecryptionMaterials, Types.Error> {
    const materials: Materials.DecryptionMaterialsPendingPlaintextDataKey
    const keyStore: KeyStore.IKeyStoreClient
    const cryptoPrimitives: Primitives.AtomicPrimitivesClient
    const branchKeyId: string
    const ttlSeconds: Types.PositiveLong
    const cache: Types.ICryptographicMaterialsCache

    constructor (materials: Materials.DecryptionMaterialsPendingPlaintextDataKey, keyStore: KeyStore.IKeyStoreClient, cryptoPrimitives: Primitives.AtomicPrimitivesClient, branchKeyId: string, ttlSeconds: Types.PositiveLong, cache: Types.ICryptographicMaterialsCache)
      requires keyStore.ValidState() && cryptoPrimitives.ValidState()
      ensures this.materials == materials && this.keyStore == keyStore && this.cryptoPrimitives == cryptoPrimitives && this.branchKeyId == branchKeyId && this.ttlSeconds == ttlSeconds && this.cache == cache
      ensures Invariant()
      decreases materials, keyStore, cryptoPrimitives, branchKeyId, ttlSeconds, cache
    {
      this.materials := materials;
      this.keyStore := keyStore;
      this.cryptoPrimitives := cryptoPrimitives;
      this.branchKeyId := branchKeyId;
      this.ttlSeconds := ttlSeconds;
      this.cache := cache;
      Modifies := keyStore.Modifies + cryptoPrimitives.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      keyStore.ValidState() &&
      cryptoPrimitives.ValidState() &&
      keyStore.Modifies + cryptoPrimitives.Modifies == Modifies
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<Materials.SealedDecryptionMaterials, Types.Error>, attemptsState: seq<ActionInvoke<Types.EncryptedDataKey, Result<Materials.SealedDecryptionMaterials, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        Invariant() &&
        Materials.DecryptionMaterialsTransitionIsValid(materials, res.value)
    }

    method Invoke(edk: Types.EncryptedDataKey, ghost attemptsState: seq<ActionInvoke<Types.EncryptedDataKey, Result<Materials.SealedDecryptionMaterials, Types.Error>>>) returns (res: Result<Materials.SealedDecryptionMaterials, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(edk, res, attemptsState)
      decreases Modifies
    {
      :- Need(UTF8.ValidUTF8Seq(edk.keyProviderInfo), Types.AwsCryptographicMaterialProvidersException(message := ""Received invalid EDK provider info for Hierarchical Keyring""));
      var suite := materials.algorithmSuite;
      var keyProviderId := edk.keyProviderId;
      var branchKeyIdUtf8 := edk.keyProviderInfo;
      var ciphertext := edk.ciphertext;
      var providerWrappedMaterial :- EdkWrapping.GetProviderWrappedMaterial(ciphertext, suite);
      :- Need(|providerWrappedMaterial| >= EDK_CIPHERTEXT_VERSION_INDEX as nat, Types.AwsCryptographicMaterialProvidersException(message := ""Received EDK Ciphertext of incorrect length.""));
      var branchKeyVersionUuid := providerWrappedMaterial[EDK_CIPHERTEXT_BRANCH_KEY_VERSION_INDEX .. EDK_CIPHERTEXT_VERSION_INDEX];
      var version :- UUID.FromByteArray(branchKeyVersionUuid).MapFailure(WrapStringToError);
      var cacheId :- GetVersionCacheId(branchKeyIdUtf8, version, cryptoPrimitives);
      var hierarchicalMaterials :- GetHierarchicalMaterialsVersion(branchKeyId, branchKeyIdUtf8, version, cacheId);
      var branchKey := hierarchicalMaterials.branchKey;
      var branchKeyVersion := hierarchicalMaterials.branchKeyVersion;
      var branchKeyVersionAsString :- UTF8.Decode(branchKeyVersion).MapFailure(WrapStringToError);
      var branchKeyVersionAsBytes :- UUID.ToByteArray(branchKeyVersionAsString).MapFailure(WrapStringToError);
      var maybeCrypto := Primitives.AtomicPrimitives();
      var crypto :- maybeCrypto.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
      var kmsHierarchyUnwrap := new KmsHierarchyUnwrapKeyMaterial(branchKey, branchKeyIdUtf8, branchKeyVersionAsBytes, crypto);
      var unwrapOutputRes := EdkWrapping.UnwrapEdkMaterial(edk.ciphertext, materials, kmsHierarchyUnwrap);
      var unwrapOutput :- unwrapOutputRes;
      var result :- Materials.DecryptionMaterialsAddDataKey(materials, unwrapOutput.plaintextDataKey, unwrapOutput.symmetricSigningKey);
      return Success(result);
    }

    method GetVersionCacheId(branchKeyIdUtf8: seq<uint8>, branchKeyVersion: string, cryptoPrimitives: Primitives.AtomicPrimitivesClient)
        returns (cacheId: Result<seq<uint8>, Types.Error>)
      ensures cacheId.Success? ==> |cacheId.value| == 32
      decreases branchKeyIdUtf8, branchKeyVersion, cryptoPrimitives
    {
      :- Need(UTF8.Decode(branchKeyIdUtf8).MapFailure(WrapStringToError).Success? && var branchKeyId: string := UTF8.Decode(branchKeyIdUtf8).MapFailure(WrapStringToError).value; true && 0 <= |branchKeyId| < UINT32_LIMIT, E(""Invalid Branch Key ID Length""));
      var branchKeyId := UTF8.Decode(branchKeyIdUtf8).value;
      var lenBranchKey := UInt.UInt32ToSeq(|branchKeyId| as uint32);
      :- Need(UTF8.IsASCIIString(branchKeyVersion), E(""Unable to represent as an ASCII string.""));
      var versionBytes := UTF8.EncodeAscii(branchKeyVersion);
      var identifier := lenBranchKey + branchKeyIdUtf8 + [0 as uint8] + versionBytes;
      var identifierDigestInput := Crypto.DigestInput(digestAlgorithm := Crypto.DigestAlgorithm.SHA_512, message := identifier);
      var maybeCacheDigest := Digest.Digest(identifierDigestInput);
      var cacheDigest :- maybeCacheDigest.MapFailure((e: Types.Error) => Types.AwsCryptographyPrimitives(e));
      return Success(cacheDigest[0 .. 32]);
    }

    method GetHierarchicalMaterialsVersion(branchKeyId: string, branchKeyIdUtf8: seq<uint8>, version: string, cacheId: seq<uint8>)
        returns (material: Result<KeyStore.BranchKeyMaterials, Types.Error>)
      requires Invariant()
      requires keyStore.ValidState()
      modifies keyStore.Modifies
      ensures keyStore.ValidState()
      decreases branchKeyId, branchKeyIdUtf8, version, cacheId
    {
      var getCacheInput := Types.GetCacheEntryInput(identifier := cacheId, bytesUsed := None);
      verifyValidStateCache(cache);
      var getCacheOutput := getEntry(cache, getCacheInput);
      if getCacheOutput.Failure? {
        var maybeGetBranchKeyVersionOutput := keyStore.GetBranchKeyVersion(KeyStore.GetBranchKeyVersionInput(branchKeyIdentifier := branchKeyId, branchKeyVersion := version));
        var getBranchKeyVersionOutput :- maybeGetBranchKeyVersionOutput.MapFailure((e: Error) => Types.AwsCryptographyKeyStore(AwsCryptographyKeyStore := e));
        var branchKeyMaterials := getBranchKeyVersionOutput.branchKeyMaterials;
        var now := Time.GetCurrent();
        :- Need(now as int + ttlSeconds as int < UInt.INT64_MAX_LIMIT, Types.AwsCryptographicMaterialProvidersException(message := ""INT64 Overflow when putting cache entry.""));
        var putCacheEntryInput := Types.PutCacheEntryInput(identifier := cacheId, materials := Types.Materials.BranchKey(branchKeyMaterials), creationTime := now, expiryTime := ttlSeconds + now, messagesUsed := None, bytesUsed := None);
        verifyValidStateCache(cache);
        var _ /* _v1 */ :- putEntry(cache, putCacheEntryInput);
        return Success(branchKeyMaterials);
      } else {
        :- Need(getCacheOutput.value.materials.BranchKey? && getCacheOutput.value.materials == Types.Materials.BranchKey(getCacheOutput.value.materials.BranchKey), E(""Invalid Material Type.""));
        return Success(getCacheOutput.value.materials.BranchKey);
      }
    }
  }

  datatype HierarchyUnwrapInfo = HierarchyUnwrapInfo

  datatype HierarchyWrapInfo = HierarchyWrapInfo

  class KmsHierarchyUnwrapKeyMaterial extends MaterialWrapping.UnwrapMaterial<HierarchyUnwrapInfo> {
    const branchKey: seq<uint8>
    const branchKeyIdUtf8: UTF8.ValidUTF8Bytes
    const branchKeyVersionAsBytes: seq<uint8>
    const crypto: Primitives.AtomicPrimitivesClient

    constructor (branchKey: seq<uint8>, branchKeyIdUtf8: UTF8.ValidUTF8Bytes, branchKeyVersionAsBytes: seq<uint8>, crypto: Primitives.AtomicPrimitivesClient)
      requires crypto.ValidState()
      ensures this.branchKey == branchKey && this.branchKeyIdUtf8 == branchKeyIdUtf8 && this.branchKeyVersionAsBytes == branchKeyVersionAsBytes && this.crypto == crypto
      ensures Invariant()
      decreases branchKey, branchKeyIdUtf8, branchKeyVersionAsBytes, crypto
    {
      this.branchKey := branchKey;
      this.branchKeyIdUtf8 := branchKeyIdUtf8;
      this.branchKeyVersionAsBytes := branchKeyVersionAsBytes;
      this.crypto := crypto;
      Modifies := crypto.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      crypto.ValidState() &&
      crypto.Modifies == Modifies
    }

    predicate Ensures(input: MaterialWrapping.UnwrapInput, res: Result<MaterialWrapping.UnwrapOutput<HierarchyUnwrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.UnwrapInput, Result<MaterialWrapping.UnwrapOutput<HierarchyUnwrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        Invariant() &&
        ghost var KeyLength: int32 := AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite); |input.wrappedMaterial| == EXPECTED_EDK_CIPHERTEXT_OVERHEAD as int + KeyLength as int && |crypto.History.AESDecrypt| > 0 && Seq.Last(crypto.History.AESDecrypt).output.Success? && ghost var AESDecryptInput: AESDecryptInput := Seq.Last(crypto.History.AESDecrypt).input; true && ghost var AESDecryptOutput: seq<uint8> := Seq.Last(crypto.History.AESDecrypt).output.value; true && ghost var wrappedMaterial: seq<uint8> := input.wrappedMaterial; true && ghost var aad: Types.EncryptionContext := input.encryptionContext; true && ghost var salt: seq<BoundedInts.uint8> := wrappedMaterial[0 .. H_WRAP_SALT_LEN]; true && ghost var iv: seq<BoundedInts.uint8> := wrappedMaterial[H_WRAP_SALT_LEN .. EDK_CIPHERTEXT_BRANCH_KEY_VERSION_INDEX]; true && ghost var branchKeyVersionUuid: seq<BoundedInts.uint8> := wrappedMaterial[EDK_CIPHERTEXT_BRANCH_KEY_VERSION_INDEX .. EDK_CIPHERTEXT_VERSION_INDEX]; true && ghost var wrappedKey: seq<BoundedInts.uint8> := wrappedMaterial[EDK_CIPHERTEXT_VERSION_INDEX .. EDK_CIPHERTEXT_VERSION_INDEX + KeyLength]; true && ghost var authTag: seq<BoundedInts.uint8> := wrappedMaterial[EDK_CIPHERTEXT_VERSION_INDEX + KeyLength..]; CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext).Success? && ghost var serializedEC: seq<uint8> := CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext).value; true && ghost var wrappingAad: seq<uint8> := WrappingAad(branchKeyIdUtf8, branchKeyVersionAsBytes, serializedEC); AESDecryptInput.encAlg == AES_256_ENC_ALG && AESDecryptInput.cipherTxt == wrappedKey && AESDecryptInput.authTag == authTag && AESDecryptInput.iv == iv && AESDecryptInput.aad == wrappingAad && AESDecryptOutput == res.value.unwrappedMaterial
    }

    method Invoke(input: MaterialWrapping.UnwrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.UnwrapInput, Result<MaterialWrapping.UnwrapOutput<HierarchyUnwrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.UnwrapOutput<HierarchyUnwrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      ensures res.Success? ==> |res.value.unwrappedMaterial| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat
      decreases Modifies
    {
      var suite := input.algorithmSuite;
      var wrappedMaterial := input.wrappedMaterial;
      var aad := input.encryptionContext;
      var KeyLength := AlgorithmSuites.GetEncryptKeyLength(suite);
      :- Need(|wrappedMaterial| == EXPECTED_EDK_CIPHERTEXT_OVERHEAD as int + KeyLength as int, Types.AwsCryptographicMaterialProvidersException(message := ""Received EDK Ciphertext of incorrect length2.""));
      var salt := wrappedMaterial[0 .. H_WRAP_SALT_LEN];
      var iv := wrappedMaterial[H_WRAP_SALT_LEN .. EDK_CIPHERTEXT_BRANCH_KEY_VERSION_INDEX];
      var branchKeyVersionUuid := wrappedMaterial[EDK_CIPHERTEXT_BRANCH_KEY_VERSION_INDEX .. EDK_CIPHERTEXT_VERSION_INDEX];
      var wrappedKey := wrappedMaterial[EDK_CIPHERTEXT_VERSION_INDEX .. EDK_CIPHERTEXT_VERSION_INDEX + KeyLength];
      var authTag := wrappedMaterial[EDK_CIPHERTEXT_VERSION_INDEX + KeyLength..];
      var serializedEC :- CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext);
      var wrappingAad := WrappingAad(branchKeyIdUtf8, branchKeyVersionAsBytes, serializedEC);
      var derivedBranchKey :- DeriveEncryptionKeyFromBranchKey(branchKey, salt, Some(PROVIDER_ID_HIERARCHY), crypto);
      var maybeUnwrappedPdk := crypto.AESDecrypt(Crypto.AESDecryptInput(encAlg := AES_256_ENC_ALG, key := derivedBranchKey, cipherTxt := wrappedKey, authTag := authTag, iv := iv, aad := wrappingAad));
      var unwrappedPdk :- maybeUnwrappedPdk.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      :- Need(|unwrappedPdk| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat, E(""Invalid Key Length""));
      var output := MaterialWrapping.UnwrapOutput(unwrappedMaterial := unwrappedPdk, unwrapInfo := HierarchyUnwrapInfo());
      return Success(output);
    }
  }

  class KmsHierarchyGenerateAndWrapKeyMaterial extends MaterialWrapping.GenerateAndWrapMaterial<HierarchyWrapInfo> {
    const branchKey: seq<uint8>
    const branchKeyIdUtf8: UTF8.ValidUTF8Bytes
    const branchKeyVersionAsBytes: seq<uint8>
    const crypto: Primitives.AtomicPrimitivesClient

    constructor (branchKey: seq<uint8>, branchKeyIdUtf8: UTF8.ValidUTF8Bytes, branchKeyVersionAsBytes: seq<uint8>, crypto: Primitives.AtomicPrimitivesClient)
      requires crypto.ValidState()
      ensures this.branchKey == branchKey && this.branchKeyIdUtf8 == branchKeyIdUtf8 && this.branchKeyVersionAsBytes == branchKeyVersionAsBytes && this.crypto == crypto
      ensures Invariant()
      decreases branchKey, branchKeyIdUtf8, branchKeyVersionAsBytes, crypto
    {
      this.branchKey := branchKey;
      this.branchKeyIdUtf8 := branchKeyIdUtf8;
      this.branchKeyVersionAsBytes := branchKeyVersionAsBytes;
      this.crypto := crypto;
      Modifies := crypto.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      crypto.ValidState() &&
      crypto.Modifies == Modifies
    }

    predicate Ensures(input: MaterialWrapping.GenerateAndWrapInput, res: Result<MaterialWrapping.GenerateAndWrapOutput<HierarchyWrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.GenerateAndWrapInput, Result<MaterialWrapping.GenerateAndWrapOutput<HierarchyWrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        true &&
        Invariant()
    }

    method Invoke(input: MaterialWrapping.GenerateAndWrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.GenerateAndWrapInput, Result<MaterialWrapping.GenerateAndWrapOutput<HierarchyWrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.GenerateAndWrapOutput<HierarchyWrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      ensures res.Success? ==> |res.value.plaintextMaterial| == input.algorithmSuite.encrypt.AES_GCM.keyLength as nat
      decreases Modifies
    {
      var suite := input.algorithmSuite;
      var pdkResult := crypto.GenerateRandomBytes(Crypto.GenerateRandomBytesInput(length := GetEncryptKeyLength(suite)));
      var pdk :- pdkResult.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      var wrap := new KmsHierarchyWrapKeyMaterial(branchKey, branchKeyIdUtf8, branchKeyVersionAsBytes, crypto);
      var wrapOutput: MaterialWrapping.WrapOutput<HierarchyWrapInfo> :- wrap.Invoke(MaterialWrapping.WrapInput(plaintextMaterial := pdk, algorithmSuite := input.algorithmSuite, encryptionContext := input.encryptionContext), []);
      var output := MaterialWrapping.GenerateAndWrapOutput(plaintextMaterial := pdk, wrappedMaterial := wrapOutput.wrappedMaterial, wrapInfo := HierarchyWrapInfo());
      return Success(output);
    }
  }

  class KmsHierarchyWrapKeyMaterial extends MaterialWrapping.WrapMaterial<HierarchyWrapInfo> {
    const branchKey: seq<uint8>
    const branchKeyIdUtf8: UTF8.ValidUTF8Bytes
    const branchKeyVersionAsBytes: seq<uint8>
    const crypto: Primitives.AtomicPrimitivesClient

    constructor (branchKey: seq<uint8>, branchKeyIdUtf8: UTF8.ValidUTF8Bytes, branchKeyVersionAsBytes: seq<uint8>, crypto: Primitives.AtomicPrimitivesClient)
      requires crypto.ValidState()
      ensures this.branchKey == branchKey && this.branchKeyIdUtf8 == branchKeyIdUtf8 && this.branchKeyVersionAsBytes == branchKeyVersionAsBytes && this.crypto == crypto
      ensures Invariant()
      decreases branchKey, branchKeyIdUtf8, branchKeyVersionAsBytes, crypto
    {
      this.branchKey := branchKey;
      this.branchKeyIdUtf8 := branchKeyIdUtf8;
      this.branchKeyVersionAsBytes := branchKeyVersionAsBytes;
      this.crypto := crypto;
      Modifies := crypto.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      crypto.ValidState() &&
      crypto.Modifies == Modifies
    }

    predicate Ensures(input: MaterialWrapping.WrapInput, res: Result<MaterialWrapping.WrapOutput<HierarchyWrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.WrapInput, Result<MaterialWrapping.WrapOutput<HierarchyWrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      true &&
      (res.Success? ==>
        Invariant() &&
        0 < |crypto.History.AESEncrypt| &&
        Seq.Last(crypto.History.AESEncrypt).output.Success? &&
        ghost var AESEncryptInput: AESEncryptInput := Seq.Last(crypto.History.AESEncrypt).input; true && ghost var AESEncryptOutput: AESEncryptOutput := Seq.Last(crypto.History.AESEncrypt).output.value; CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext).Success? && ghost var serializedEC: Result<seq<uint8>, Types.Error> := CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext); true && ghost var wrappingAad: seq<uint8> := WrappingAad(branchKeyIdUtf8, branchKeyVersionAsBytes, serializedEC.value); AESEncryptInput.encAlg == AES_256_ENC_ALG && AESEncryptInput.msg == input.plaintextMaterial && AESEncryptInput.aad == wrappingAad && |res.value.wrappedMaterial| > |AESEncryptOutput.cipherText| + |AESEncryptOutput.authTag| && res.value.wrapInfo == HierarchyWrapInfo())
    }

    method Invoke(input: MaterialWrapping.WrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.WrapInput, Result<MaterialWrapping.WrapOutput<HierarchyWrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.WrapOutput<HierarchyWrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      decreases Modifies
    {
      var suite := input.algorithmSuite;
      var maybeNonceSalt := crypto.GenerateRandomBytes(Crypto.GenerateRandomBytesInput(length := H_WRAP_SALT_LEN + H_WRAP_NONCE_LEN));
      var saltAndNonce :- maybeNonceSalt.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      assert |crypto.History.GenerateRandomBytes| == old(|crypto.History.GenerateRandomBytes|) + 1;
      assert |saltAndNonce| == (H_WRAP_NONCE_LEN + H_WRAP_SALT_LEN) as int;
      var salt := saltAndNonce[0 .. H_WRAP_SALT_LEN];
      var nonce := saltAndNonce[H_WRAP_SALT_LEN..];
      var serializedEC :- CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext);
      var wrappingAad := WrappingAad(branchKeyIdUtf8, branchKeyVersionAsBytes, serializedEC);
      var derivedBranchKey :- DeriveEncryptionKeyFromBranchKey(branchKey, salt, Some(PROVIDER_ID_HIERARCHY), crypto);
      var maybeWrappedPdk := crypto.AESEncrypt(Crypto.AESEncryptInput(encAlg := AES_256_ENC_ALG, iv := nonce, key := derivedBranchKey, msg := input.plaintextMaterial, aad := wrappingAad));
      var wrappedPdk :- maybeWrappedPdk.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      var output := MaterialWrapping.WrapOutput(wrappedMaterial := salt + nonce + branchKeyVersionAsBytes + wrappedPdk.cipherText + wrappedPdk.authTag, wrapInfo := HierarchyWrapInfo());
      return Success(output);
    }
  }

  const BRANCH_KEY_STORE_GSI := ""Active-Keys""
  const BRANCH_KEY_FIELD := ""enc""
  const VERSION_FIELD := ""version""
  const BRANCH_KEY_IDENTIFIER_FIELD := ""branch-key-id""
  const KEY_CONDITION_EXPRESSION := ""#status = :status and #branch_key_id = :branch_key_id""
  const EXPRESSION_ATTRIBUTE_NAMES := map[""#status"" := ""status"", ""#branch_key_id"" := ""branch-key-id""]
  const EXPRESSION_ATTRIBUTE_VALUE_STATUS_KEY := "":status""
  const EXPRESSION_ATTRIBUTE_VALUE_STATUS_VALUE := ""ACTIVE""
  const EXPRESSION_ATTRIBUTE_VALUE_BRANCH_KEY := "":branch_key_id""
  const H_WRAP_SALT_LEN: Types.PositiveInteger := 16
  const H_WRAP_NONCE_LEN: Types.PositiveInteger := 12
  const DERIVED_BRANCH_KEY_EXPECTED_LENGTH: Types.PositiveInteger := 32
  const AES_256_ENC_KEY_LENGTH: int32 := 32
  const AES_256_ENC_TAG_LENGTH: int32 := 16
  const AES_256_ENC_IV_LENGTH: int32 := 12
  const AES_256_ENC_ALG := Crypto.AES_GCM(keyLength := AES_256_ENC_KEY_LENGTH, tagLength := AES_256_ENC_TAG_LENGTH, ivLength := AES_256_ENC_IV_LENGTH)
  const EDK_CIPHERTEXT_VERSION_LENGTH: int32 := 16
  const EDK_CIPHERTEXT_BRANCH_KEY_VERSION_INDEX := H_WRAP_SALT_LEN + H_WRAP_NONCE_LEN
  const EDK_CIPHERTEXT_VERSION_INDEX := EDK_CIPHERTEXT_BRANCH_KEY_VERSION_INDEX + EDK_CIPHERTEXT_VERSION_LENGTH
  const EXPECTED_EDK_CIPHERTEXT_OVERHEAD := EDK_CIPHERTEXT_VERSION_INDEX + AES_256_ENC_TAG_LENGTH

  lemma {:axiom} verifyValidStateCache(cmc: Types.ICryptographicMaterialsCache)
    ensures cmc.ValidState()
    decreases cmc

  method getEntry(cmc: Types.ICryptographicMaterialsCache, input: Types.GetCacheEntryInput) returns (res: Result<Types.GetCacheEntryOutput, Types.Error>)
    requires cmc.ValidState()
    ensures cmc.ValidState()
    ensures cmc.GetCacheEntryEnsuresPublicly(input, res)
    ensures unchanged(cmc.History)
    decreases cmc, input
  {
    assume {:axiom} cmc.Modifies == {};
    res := cmc.GetCacheEntry(input);
  }

  method putEntry(cmc: Types.ICryptographicMaterialsCache, input: Types.PutCacheEntryInput) returns (res: Result<(), Types.Error>)
    requires cmc.ValidState()
    ensures cmc.ValidState()
    ensures cmc.PutCacheEntryEnsuresPublicly(input, res)
    ensures unchanged(cmc.History)
    decreases cmc, input
  {
    assume {:axiom} cmc.Modifies == {};
    res := cmc.PutCacheEntry(input);
  }

  method DeriveEncryptionKeyFromBranchKey(branchKey: seq<uint8>, salt: seq<uint8>, purpose: Option<seq<uint8>>, cryptoPrimitives: Primitives.AtomicPrimitivesClient)
      returns (output: Result<seq<uint8>, Types.Error>)
    requires cryptoPrimitives.ValidState()
    modifies cryptoPrimitives.Modifies
    ensures cryptoPrimitives.ValidState()
    ensures output.Success? ==> |output.value| == 32
    ensures |cryptoPrimitives.History.GenerateRandomBytes| == old(|cryptoPrimitives.History.GenerateRandomBytes|)
    ensures |cryptoPrimitives.History.KdfCounterMode| > 0
    decreases branchKey, salt, purpose, cryptoPrimitives
  {
    var maybeDerivedBranchKey := cryptoPrimitives.KdfCounterMode(Crypto.KdfCtrInput(digestAlgorithm := Crypto.DigestAlgorithm.SHA_256, ikm := branchKey, expectedLength := DERIVED_BRANCH_KEY_EXPECTED_LENGTH, purpose := purpose, nonce := Some(salt)));
    var derivedBranchKey :- maybeDerivedBranchKey.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
    output := Success(derivedBranchKey);
  }

  function method {:opaque} {:fuel 0, 0} WrappingAad(branchKeyId: seq<uint8>, branchKeyVersion: seq<uint8>, aad: seq<uint8>): (res: seq<uint8>)
    requires UTF8.ValidUTF8Seq(branchKeyId)
    ensures res == PROVIDER_ID_HIERARCHY + branchKeyId + branchKeyVersion + aad
    decreases branchKeyId, branchKeyVersion, aad
  {
    PROVIDER_ID_HIERARCHY + branchKeyId + branchKeyVersion + aad
  }

  function method SerializeEDKCiphertext(encOutput: Crypto.AESEncryptOutput): (ciphertext: seq<uint8>)
    decreases encOutput
  {
    encOutput.cipherText + encOutput.authTag
  }

  function method E(s: string): Types.Error
    decreases s
  {
    Types.AwsCryptographicMaterialProvidersException(message := s)
  }
}

module {:options ""/functionSyntax:4""} StormTracker {

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened DafnyLibraries

  import Types = AwsCryptographyMaterialProvidersTypes

  import LocalCMC

  import Time

  import SortedSets

  import Seq
  datatype CacheState = EmptyWait | EmptyFetch | Full(data: Types.GetCacheEntryOutput)

  class StormTracker {
    predicate ValidState()
      reads this, wrapped, wrapped.Modifies
      decreases wrapped.Modifies + {this, wrapped}
    {
      this !in wrapped.Modifies &&
      inFlight !in wrapped.Modifies &&
      wrapped.ValidState()
    }

    var wrapped: LocalCMC.LocalCMC
    var inFlight: MutableMap<seq<uint8>, Types.PositiveLong>
    var gracePeriod: Types.PositiveLong
    var graceInterval: Types.PositiveLong
    var fanOut: Types.PositiveLong
    var inFlightTTL: Types.PositiveLong
    var lastPrune: Types.PositiveLong
    var sleepMilli: Types.PositiveLong

    constructor (cache: Types.StormTrackingCache)
      ensures this.ValidState() && fresh(this.wrapped) && fresh(this.wrapped.Modifies) && fresh(this.inFlight)
      decreases cache
    {
      this.wrapped := new LocalCMC.LocalCMC(cache.entryCapacity as nat, cache.entryPruningTailSize.UnwrapOr(1) as nat);
      this.inFlight := new MutableMap<seq<uint8>, Types.PositiveLong>();
      this.gracePeriod := cache.gracePeriod as Types.PositiveLong;
      this.graceInterval := cache.graceInterval as Types.PositiveLong;
      this.fanOut := cache.fanOut as Types.PositiveLong;
      this.inFlightTTL := cache.inFlightTTL as Types.PositiveLong;
      this.sleepMilli := cache.sleepMilli as Types.PositiveLong;
      this.lastPrune := 0;
    }

    function method InFlightSize(): Types.PositiveLong
      reads this, this.inFlight
      decreases {this, this.inFlight}
    {
      var x: int := inFlight.Size();
      assert x >= 0;
      if x <= INT64_MAX_LIMIT then
        x as Types.PositiveLong
      else
        INT64_MAX_LIMIT as Types.PositiveLong
    }

    method FanOutReached(now: Types.PositiveLong) returns (res: bool)
      modifies this`lastPrune, inFlight
      decreases now
    {
      PruneInFlight(now);
      return fanOut <= InFlightSize();
    }

    function method AddLong(x: Types.PositiveLong, y: Types.PositiveLong): Types.PositiveLong
      decreases x, y
    {
      if x < INT64_MAX_LIMIT as Types.PositiveLong - y then
        x + y
      else
        INT64_MAX_LIMIT as Types.PositiveLong
    }

    method CheckInFlight(identifier: seq<uint8>, result: Types.GetCacheEntryOutput, now: Types.PositiveLong)
        returns (output: CacheState)
      modifies this`lastPrune, inFlight
      decreases identifier, result, now
    {
      var fanOutReached := FanOutReached(now);
      if fanOutReached {
        return Full(result);
      } else if result.expiryTime <= now {
        output := CheckNewEntry(identifier, now);
      } else if now < result.expiryTime - gracePeriod {
        return Full(result);
      } else {
        if inFlight.HasKey(identifier) {
          var entry := inFlight.Select(identifier);
          if AddLong(entry, graceInterval) > now {
            return Full(result);
          }
        }
        inFlight.Put(identifier, now);
        return EmptyFetch;
      }
    }

    method PruneInFlight(now: Types.PositiveLong)
      modifies this`lastPrune, inFlight
      decreases now
    {
      if fanOut > InFlightSize() {
        return;
      }
      if lastPrune == now {
        return;
      }
      lastPrune := now;
      var keySet := inFlight.Keys();
      var keys := SortedSets.ComputeSetToSequence(keySet);
      for i: int := 0 to |keys|
        invariant forall k: int {:trigger keys[k]} | i <= k < |keys| :: keys[k] in inFlight.Keys()
      {
        reveal Seq.HasNoDuplicates();
        var v := inFlight.Select(keys[i]);
        if now >= AddLong(v, inFlightTTL) {
          inFlight.Remove(keys[i]);
        }
      }
    }

    method CheckNewEntry(identifier: seq<uint8>, now: Types.PositiveLong) returns (output: CacheState)
      modifies this`lastPrune, inFlight
      decreases identifier, now
    {
      var fanOutReached := FanOutReached(now);
      if fanOutReached {
        return EmptyWait;
      } else if inFlight.HasKey(identifier) {
        var entry := inFlight.Select(identifier);
        if AddLong(entry, graceInterval) > now {
          return EmptyWait;
        }
      }
      inFlight.Put(identifier, now);
      return EmptyFetch;
    }

    method GetFromCacheWithTime(input: Types.GetCacheEntryInput, now: Types.PositiveLong) returns (output: Result<CacheState, Types.Error>)
      requires ValidState()
      modifies this`lastPrune, inFlight, wrapped.Modifies
      ensures ValidState()
      ensures inFlight == old(inFlight)
      ensures wrapped == old(wrapped)
      ensures wrapped.Modifies <= old(wrapped.Modifies)
      decreases input, now
    {
      var result := wrapped.GetCacheEntryWithTime(input, now);
      if result.Success? {
        var newResult := CheckInFlight(input.identifier, result.value, now);
        return Success(newResult);
      } else if result.error.EntryDoesNotExist? {
        var newResult := CheckNewEntry(input.identifier, now);
        return Success(newResult);
      } else {
        return Failure(result.error);
      }
    }

    method GetFromCache(input: Types.GetCacheEntryInput) returns (output: Result<CacheState, Types.Error>)
      requires ValidState()
      modifies this`lastPrune, inFlight, wrapped.Modifies
      ensures ValidState()
      ensures inFlight == old(inFlight)
      ensures wrapped == old(wrapped)
      ensures wrapped.Modifies <= old(wrapped.Modifies)
      decreases input
    {
      var now := Time.GetCurrent();
      output := GetFromCacheWithTime(input, now);
    }

    method GetCacheEntry(input: Types.GetCacheEntryInput) returns (output: Result<Types.GetCacheEntryOutput, Types.Error>)
      requires ValidState()
      modifies this`lastPrune, inFlight, wrapped.Modifies
      ensures ValidState()
      ensures inFlight == old(inFlight)
      ensures wrapped == old(wrapped)
      ensures wrapped.Modifies <= old(wrapped.Modifies)
      decreases input
    {
      var result := GetFromCache(input);
      if result.Failure? {
        return Failure(result.error);
      } else if result.value.Full? {
        return Success(result.value.data);
      } else {
        return Failure(Types.EntryDoesNotExist(message := ""Entry does not exist""));
      }
    }

    method PutCacheEntry(input: Types.PutCacheEntryInput) returns (output: Result<(), Types.Error>)
      requires ValidState()
      modifies inFlight, wrapped.Modifies
      ensures ValidState()
      ensures inFlight == old(inFlight)
      ensures wrapped == old(wrapped)
      ensures fresh(wrapped.Modifies - old(wrapped.Modifies))
      decreases input
    {
      inFlight.Remove(input.identifier);
      output := wrapped.PutCacheEntry'(input);
    }

    method DeleteCacheEntry(input: Types.DeleteCacheEntryInput) returns (output: Result<(), Types.Error>)
      requires ValidState()
      modifies inFlight, wrapped.Modifies
      ensures ValidState()
      ensures wrapped.Modifies <= old(wrapped.Modifies)
      decreases input
    {
      inFlight.Remove(input.identifier);
      output := wrapped.DeleteCacheEntry'(input);
    }

    method UpdateUsageMetadata(input: Types.UpdateUsageMetadataInput) returns (output: Result<(), Types.Error>)
      requires ValidState()
      modifies inFlight, wrapped.Modifies
      ensures ValidState()
      decreases input
    {
      output := wrapped.UpdateUsageMetadata'(input);
    }
  }

  function method DefaultStorm(): Types.StormTrackingCache
  {
    Types.StormTrackingCache(entryCapacity := 1000, entryPruningTailSize := Some(1), gracePeriod := 10, graceInterval := 1, fanOut := 20, inFlightTTL := 20, sleepMilli := 20)
  }
}

module {:options ""/functionSyntax:4""} LocalCMC {

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened DafnyLibraries

  import Time

  import Types = AwsCryptographyMaterialProvidersTypes

  import Seq
  datatype Ref<T> = Ptr(deref: T) | Null

  class CacheEntry {
    var prev: Ref<CacheEntry>
    var next: Ref<CacheEntry>
    const materials: Types.Materials
    const identifier: seq<uint8>
    const creationTime: Types.PositiveLong
    const expiryTime: Types.PositiveLong
    var messagesUsed: Types.PositiveInteger
    var bytesUsed: Types.PositiveInteger

    constructor (nameonly materials': Types.Materials, nameonly identifier': seq<uint8>, nameonly creationTime': Types.PositiveLong, nameonly expiryTime': Types.PositiveLong, nameonly messagesUsed': Types.PositiveInteger, nameonly bytesUsed': Types.PositiveInteger)
      ensures identifier == identifier' && materials == materials' && identifier == identifier' && creationTime == creationTime' && expiryTime == expiryTime' && messagesUsed == messagesUsed' && bytesUsed == bytesUsed'
      ensures prev == Null && next == Null
      ensures fresh(this)
      decreases materials', identifier', creationTime', expiryTime', messagesUsed', bytesUsed'
    {
      materials := materials';
      identifier := identifier';
      creationTime := creationTime';
      expiryTime := expiryTime';
      messagesUsed := messagesUsed';
      bytesUsed := bytesUsed';
      prev := NULL;
      next := NULL;
    }
  }

  class DoublyLinkedCacheEntryList {
    ghost var Items: seq<CacheEntry>

    predicate Invariant()
      reads this, Items
      decreases (set _s2s_0: CacheEntry | _s2s_0 in Items :: _s2s_0) + {this}
    {
      (0 == |Items| <==> head.Null? && tail.Null?) &&
      (0 < |Items| <==> head.Ptr? && tail.Ptr? && head.deref == Items[0] && tail.deref == Items[|Items| - 1]) &&
      (head.Ptr? <==> tail.Ptr?) &&
      (head.Ptr? ==>
        head.deref.prev.Null?) &&
      (tail.Ptr? ==>
        tail.deref.next.Null?) &&
      (forall v: CacheEntry? {:trigger multiset(Items)[v]} {:trigger v in Items} | v in Items :: 
        multiset(Items)[v] == 1) &&
      forall i: nat {:trigger Items[i]} | 0 <= i < |Items| :: 
        Prev?(i, Items[i], Items) &&
        Next?(i, Items[i], Items)
    }

    predicate Prev?(i: nat, c: CacheEntry, Items': seq<CacheEntry>)
      requires 0 <= i < |Items'|
      requires Items'[i] == c
      reads Items'
      decreases set _s2s_0: CacheEntry | _s2s_0 in Items' :: _s2s_0, i, c, Items'
    {
      if i == 0 then
        Items'[0].prev.Null?
      else
        Items'[i].prev.Ptr? && Items'[i].prev.deref == Items'[i - 1]
    }

    predicate Next?(i: nat, c: CacheEntry, Items': seq<CacheEntry>)
      requires 0 <= i < |Items'|
      requires Items'[i] == c
      reads Items'
      decreases set _s2s_0: CacheEntry | _s2s_0 in Items' :: _s2s_0, i, c, Items'
    {
      if i < |Items'| - 1 then
        Items'[i].next.Ptr? &&
        Items'[i].next.deref == Items'[i + 1]
      else
        assert i == |Items'| - 1; true && Items'[i].next.Null?
    }

    constructor ()
      ensures Items == []
      ensures Invariant()
    {
      head := Null;
      tail := Null;
      Items := [];
    }

    var head: Ref<CacheEntry>
    var tail: Ref<CacheEntry>

    method pushCell(toPush: CacheEntry)
      requires toPush !in Items
      requires toPush.next.Null? && toPush.prev.Null?
      requires Invariant()
      modifies this, Items, toPush
      ensures Invariant()
      ensures Items == [toPush] + old(Items)
      decreases toPush
    {
      Items := [toPush] + Items;
      var cRef := Ptr(toPush);
      if head.Ptr? {
        head.deref.prev := cRef;
        toPush.next := head;
        head := cRef;
      } else {
        head := cRef;
        tail := head;
      }
    }

    method moveToFront(c: CacheEntry)
      requires c in Items
      requires exists i: nat {:trigger Items[i]} | 0 <= i < |Items| :: c == Items[i]
      requires Invariant()
      modifies this, Items
      ensures Invariant()
      ensures head.Ptr? && head.deref == c
      ensures multiset(Items) == multiset(old(Items))
      decreases c
    {
      if head.deref != c {
        var toPush := Ptr(c);
        remove(c);
        assert head.deref in Items;
        Items := [toPush.deref] + Items;
        if head.Ptr? {
          head.deref.prev := toPush;
          toPush.deref.next := head;
          head := toPush;
        } else {
          head := toPush;
          tail := head;
        }
      }
      assert head.Ptr? <==> tail.Ptr?;
    }

    method {:vcs_split_on_every_assert} remove(toRemove: CacheEntry)
      requires Invariant()
      requires toRemove in Items
      modifies this, Items
      ensures Invariant()
      ensures multiset(Items) == multiset(old(Items)) - multiset{toRemove}
      ensures toRemove !in Items
      ensures toRemove.next.Null? && toRemove.prev.Null?
      ensures |Items| < |old(Items)|
      decreases toRemove
    {
      ghost var pos := IndexOfCacheEntry(Items, toRemove);
      Items := RemoveCacheEntry(Items, toRemove);
      if toRemove.prev.Null? {
        assert toRemove.prev.Null? ==> Ptr(toRemove) == head;
        assert pos == 0;
        head := toRemove.next;
      } else {
        assert toRemove != head.deref;
        assert 0 != pos;
        assert 0 < |Items|;
        assert Items[pos - 1] == toRemove.prev.deref;
        toRemove.prev.deref.next := toRemove.next;
      }
      if toRemove.next.Null? {
        assert toRemove.next.Null? ==> Ptr(toRemove) == tail;
        tail := toRemove.prev;
      } else {
        assert toRemove != tail.deref;
        assert 0 < |Items|;
        toRemove.next.deref.prev := toRemove.prev;
      }
      label AFTER:
      assert {:split_here} true;
      assert Items == old@AFTER(Items);
      assert toRemove !in Items;
      toRemove.next := NULL;
      toRemove.prev := NULL;
    }
  }

  class LocalCMC extends Types.ICryptographicMaterialsCache {
    predicate ValidState()
      reads this`Modifies, Modifies - {History}
      ensures ValidState() ==> History in Modifies
      decreases Modifies - {History} + {this}
    {
      History in Modifies &&
      this in Modifies &&
      queue in Modifies &&
      cache in Modifies &&
      (forall i: CacheEntry {:trigger i in Modifies} {:trigger i in queue.Items} | i in queue.Items :: 
        i in Modifies) &&
      Invariant()
    }

    predicate Invariant()
      reads this, queue, queue.Items, cache
      decreases (set _s2s_0: CacheEntry | _s2s_0 in queue.Items :: _s2s_0) + {this, queue, cache}
    {
      queue.Invariant() &&
      MutableMapIsInjective(cache) &&
      multiset(cache.Values()) == multiset(queue.Items) &&
      (forall c: CacheEntry {:trigger c.identifier} {:trigger c in queue.Items} | c in queue.Items :: 
        c.identifier in cache.Keys() &&
        cache.Select(c.identifier) == c) &&
      cache.Size() <= entryCapacity
    }

    var queue: DoublyLinkedCacheEntryList
    var cache: MutableMap<seq<uint8>, CacheEntry>
    const entryCapacity: nat
    const entryPruningTailSize: nat

    constructor (entryCapacity': nat, entryPruningTailSize': nat := 1)
      requires entryPruningTailSize' >= 1
      ensures entryCapacity == entryCapacity' && entryPruningTailSize == entryPruningTailSize' && ValidState() && fresh(this.Modifies)
      decreases entryCapacity', entryPruningTailSize'
    {
      entryCapacity := entryCapacity';
      entryPruningTailSize := entryPruningTailSize';
      cache := new MutableMap<seq<uint8>, CacheEntry>();
      queue := new DoublyLinkedCacheEntryList();
      History := new Types.ICryptographicMaterialsCacheCallHistory();
      Modifies := {History, queue, cache, this};
    }

    predicate GetCacheEntryEnsuresPublicly(input: Types.GetCacheEntryInput, output: Result<Types.GetCacheEntryOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method GetCacheEntry'(input: Types.GetCacheEntryInput) returns (output: Result<Types.GetCacheEntryOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures GetCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures Modifies <= old(Modifies)
      decreases Modifies - {History}
    {
      var now := Time.GetCurrent();
      output := GetCacheEntryWithTime(input, now);
    }

    method GetCacheEntryWithTime(input: Types.GetCacheEntryInput, now: Types.PositiveLong) returns (output: Result<Types.GetCacheEntryOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures GetCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures Modifies <= old(Modifies)
      decreases Modifies - {History}
    {
      if cache.HasKey(input.identifier) {
        var entry := cache.Select(input.identifier);
        if now <= entry.expiryTime {
          assert entry in multiset(queue.Items);
          queue.moveToFront(entry);
          output := Success(Types.GetCacheEntryOutput(materials := entry.materials, creationTime := entry.creationTime, expiryTime := entry.expiryTime, messagesUsed := entry.messagesUsed, bytesUsed := entry.bytesUsed));
          var _ /* _v0 */ :- pruning(now);
        } else {
          var _ /* _v1 */ :- DeleteCacheEntry'(Types.DeleteCacheEntryInput(identifier := input.identifier));
          output := Failure(Types.EntryDoesNotExist(message := ""Entry past TTL""));
        }
      } else {
        output := Failure(Types.EntryDoesNotExist(message := ""Entry does not exist""));
      }
    }

    predicate PutCacheEntryEnsuresPublicly(input: Types.PutCacheEntryInput, output: Result<(), Types.Error>)
      decreases input, output
    {
      true
    }

    method {:vcs_split_on_every_assert} PutCacheEntry'(input: Types.PutCacheEntryInput) returns (output: Result<(), Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures PutCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures fresh(Modifies - old(Modifies))
      decreases Modifies - {History}
    {
      if entryCapacity == 0 {
        return Success(());
      }
      if cache.HasKey(input.identifier) {
        var _ /* _v2 */ :- DeleteCacheEntry'(Types.DeleteCacheEntryInput(identifier := input.identifier));
      }
      assert input.identifier !in cache.Keys();
      assert 0 < entryCapacity;
      if entryCapacity == cache.Size() {
        assert 0 < |multiset(cache.Values())|;
        assert queue.tail.deref.identifier in cache.Keys();
        var _ /* _v3 */ :- DeleteCacheEntry'(Types.DeleteCacheEntryInput(identifier := queue.tail.deref.identifier));
      }
      label CAN_ADD:
      var cell := new CacheEntry(materials' := input.materials, identifier' := input.identifier, creationTime' := input.creationTime, expiryTime' := input.expiryTime, messagesUsed' := input.messagesUsed.UnwrapOr(0), bytesUsed' := input.bytesUsed.UnwrapOr(0));
      if cell in cache.Values() {
        assert cell in multiset(cache.Values());
      }
      queue.pushCell(cell);
      cache.Put(input.identifier, cell);
      Modifies := Modifies + {cell};
      output := Success(());
      forall k: seq<uint8>, k': seq<uint8> | k in cache.Keys() && k' in cache.Keys() && k != k'
        ensures cache.Select(k) != cache.Select(k')
      {
        if k != input.identifier && k' != input.identifier {
          assert k in old@CAN_ADD(cache.Keys());
          assert k' in old@CAN_ADD(cache.Keys());
          assert old@CAN_ADD(cache.Select(k)) != old@CAN_ADD(cache.Select(k'));
        }
      }
      assert Invariant();
    }

    predicate DeleteCacheEntryEnsuresPublicly(input: Types.DeleteCacheEntryInput, output: Result<(), Types.Error>)
      decreases input, output
    {
      true
    }

    method {:vcs_split_on_every_assert} DeleteCacheEntry'(input: Types.DeleteCacheEntryInput) returns (output: Result<(), Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures DeleteCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures input.identifier !in cache.Keys()
      ensures Modifies <= old(Modifies)
      ensures true && input.identifier in old(cache.Keys()) ==> true && old(cache.Select(input.identifier)) !in queue.Items && cache.Size() == old(cache.Size()) - 1 && old(cache.Keys()) - {input.identifier} == cache.Keys()
      decreases Modifies - {History}
    {
      if cache.HasKey(input.identifier) {
        assert input.identifier in cache.Keys();
        var cell := cache.Select(input.identifier);
        assert cell in multiset(queue.Items);
        label CAN_REMOVE:
        cache.Remove(input.identifier);
        assert cell !in cache.Values();
        assert MutableMapIsInjective(cache) by {
          assert forall k: seq<uint8> {:trigger cache.Select(k)} {:trigger old(cache.Select(k))} {:trigger k in cache.Keys()} | k in cache.Keys() :: old(allocated(cache.Select(k))) && unchanged(cache.Select(k));
          assert MutableMapIsInjective(old@CAN_REMOVE(cache));
          assert MutableMapContains(old@CAN_REMOVE(cache), cache);
          LemmaMutableMapContainsPreservesInjectivity(old@CAN_REMOVE(cache), cache);
        }
        assert |cache.Keys()| == |old@CAN_REMOVE(cache.Keys())| - 1;
        assert cache.Size() <= old@CAN_REMOVE(cache.Size()) <= entryCapacity;
        queue.remove(cell);
        assert multiset(cache.Values()) == multiset(queue.Items) by {
          ghost var cacheMultiset := multiset(cache.Values());
          ghost var queueMultiset := multiset(queue.Items);
          assert cacheMultiset[cell := 0] == queueMultiset[cell := 0];
          assert cell !in cacheMultiset;
          assert cell !in queueMultiset;
        }
        Modifies := Modifies - {cell};
      }
      output := Success(());
    }

    predicate UpdateUsageMetadataEnsuresPublicly(input: Types.UpdateUsageMetadataInput, output: Result<(), Types.Error>)
      decreases input, output
    {
      true
    }

    method UpdateUsageMetadata'(input: Types.UpdateUsageMetadataInput) returns (output: Result<(), Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures Modifies <= old(Modifies)
      decreases Modifies - {History}
    {
      if cache.HasKey(input.identifier) {
        var cell := cache.Select(input.identifier);
        assert cell in multiset(cache.Values());
        if cell.messagesUsed <= INT32_MAX_VALUE - 1 && cell.bytesUsed <= INT32_MAX_VALUE - input.bytesUsed {
          cell.messagesUsed, cell.bytesUsed := cell.messagesUsed + 1, cell.bytesUsed + input.bytesUsed;
        } else {
          var _ /* _v4 */ :- DeleteCacheEntry'(Types.DeleteCacheEntryInput(identifier := input.identifier));
        }
      }
      return Success(());
    }

    method pruning(now: Types.PositiveLong) returns (output: Result<(), Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures unchanged(History)
      ensures Modifies <= old(Modifies)
      decreases now
    {
      for i: int := 0 to entryPruningTailSize
        invariant ValidState()
        invariant Modifies <= old(Modifies)
      {
        if queue.tail.Ptr? {
          if queue.tail.deref.expiryTime < now {
            var _ /* _v5 */ :- DeleteCacheEntry'(Types.DeleteCacheEntryInput(identifier := queue.tail.deref.identifier));
          } else {
            return Success(());
          }
        } else {
          return Success(());
        }
      }
      return Success(());
    }
  }

  const NULL: Ref<CacheEntry> := Null
  const INT32_MAX_VALUE: int32 := 2040109465
  const INT64_MAX_VALUE: int64 := 8762203435012037017

  function {:opaque} {:fuel 0, 0} RemoveCacheEntry(s: seq<CacheEntry>, v: CacheEntry): (s': seq<CacheEntry>)
    requires multiset(s)[v] == 1
    ensures v !in s'
    ensures multiset(s') == multiset(s) - multiset{v}
    ensures ghost var pos: nat := IndexOfCacheEntry(s, v); (forall i: nat {:trigger s'[i]} {:trigger s[i]} | 0 <= i < pos :: s[i] == s'[i]) && (forall i: nat {:trigger s'[i]} | pos <= i < |s'| :: s[i + 1] == s'[i]) && s' == s[..pos] + s[pos + 1..]
    decreases s, v
  {
    ghost var pos: nat := IndexOfCacheEntry(s, v);
    assert s == s[..pos] + s[pos..];
    assert multiset(s[pos..])[v] == 1;
    assert s[pos..] == [s[pos]] + s[pos + 1..];
    s[..pos] + s[pos + 1..]
  }

  function IndexOfCacheEntry(s: seq<CacheEntry>, v: CacheEntry): (pos: nat)
    requires v in s
    ensures pos < |s| && s[pos] == v
    ensures v !in s[..pos]
    decreases s, v
  {
    if s[0] == v then
      0
    else
      1 + IndexOfCacheEntry(s[1..], v)
  }

  method RemoveValue<K, V>(k0: K, m: map<K, V>)
    requires k0 in m
    requires forall k: K, k': K {:trigger m[k'], m[k]} {:trigger m[k'], k in m} {:trigger m[k], k' in m} {:trigger k' in m, k in m} | k in m && k' in m && k != k' :: m[k] != m[k']
    ensures (m - {k0}).Values == m.Values - {m[k0]}
    decreases m
  {
    var m' := m - {k0};
    calc {
      m'.Values;
      set k: K {:trigger m'[k]} {:trigger k in m'} | k in m' :: m'[k];
      set k: K {:trigger m[k]} {:trigger k in m - {k0}} | k in m - {k0} :: m[k];
      m.Values - {m[k0]};
    }
  }

  predicate MutableMapIsInjective<K, V>(m: MutableMap<K, V>)
    reads m
    decreases {m}, m
  {
    forall k: K, k': K {:trigger m.Select(k'), m.Select(k)} {:trigger m.Select(k'), k in m.Keys()} {:trigger m.Select(k), k' in m.Keys()} {:trigger k' in m.Keys(), k in m.Keys()} | k in m.Keys() && k' in m.Keys() && k != k' :: 
      m.Select(k) != m.Select(k')
  }

  predicate MutableMapContains<K, V>(big: MutableMap<K, V>, small: MutableMap<K, V>)
    reads {big, small}
    decreases {big, small}, big, small
  {
    small.Keys() <= big.Keys() &&
    forall k: K {:trigger big.Select(k)} {:trigger small.Select(k)} {:trigger k in small.Keys()} | k in small.Keys() :: 
      small.Select(k) == big.Select(k)
  }

  lemma LemmaMutableMapContainsPreservesInjectivity<K, V>(big: MutableMap<K, V>, small: MutableMap<K, V>)
    requires MutableMapContains(big, small)
    requires MutableMapIsInjective(big)
    ensures MutableMapIsInjective(small)
    decreases big, small
  {
  }
}

module {:options ""/functionSyntax:4""} {:extern ""software.amazon.cryptography.internaldafny.StormTrackingCMC""} StormTrackingCMC {

  import opened Wrappers

  import Types = AwsCryptographyMaterialProvidersTypes

  import StormTracker
  class {:extern} StormTrackingCMC extends Types.ICryptographicMaterialsCache {
    predicate ValidState()
      reads this`Modifies, Modifies - {History}
      ensures ValidState() ==> History in Modifies
      decreases Modifies - {History} + {this}
    {
      History in Modifies
    }

    constructor {:extern} (wrapped: StormTracker.StormTracker)
      ensures ValidState() && fresh(this.Modifies)
      decreases wrapped

    predicate GetCacheEntryEnsuresPublicly(input: Types.GetCacheEntryInput, output: Result<Types.GetCacheEntryOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method {:extern ""GetCacheEntry""} GetCacheEntry'(input: Types.GetCacheEntryInput) returns (output: Result<Types.GetCacheEntryOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures GetCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}

    predicate PutCacheEntryEnsuresPublicly(input: Types.PutCacheEntryInput, output: Result<(), Types.Error>)
      decreases input, output
    {
      true
    }

    method {:extern ""PutCacheEntry""} PutCacheEntry'(input: Types.PutCacheEntryInput) returns (output: Result<(), Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures PutCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}

    predicate DeleteCacheEntryEnsuresPublicly(input: Types.DeleteCacheEntryInput, output: Result<(), Types.Error>)
      decreases input, output
    {
      true
    }

    method {:extern ""DeleteCacheEntry""} DeleteCacheEntry'(input: Types.DeleteCacheEntryInput) returns (output: Result<(), Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures DeleteCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures Modifies <= old(Modifies)
      decreases Modifies - {History}

    predicate UpdateUsageMetadataEnsuresPublicly(input: Types.UpdateUsageMetadataInput, output: Result<(), Types.Error>)
      decreases input, output
    {
      true
    }

    method {:extern ""UpdateUsageMetadata""} UpdateUsageMetadata'(input: Types.UpdateUsageMetadataInput) returns (output: Result<(), Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      decreases Modifies - {History}
  }
}

module {:options ""/functionSyntax:4""} {:extern ""software.amazon.cryptography.internaldafny.SynchronizedLocalCMC""} SynchronizedLocalCMC {

  import opened Wrappers

  import Types = AwsCryptographyMaterialProvidersTypes

  import LocalCMC
  class {:extern} SynchronizedLocalCMC extends Types.ICryptographicMaterialsCache {
    predicate ValidState()
      reads this`Modifies, Modifies - {History}
      ensures ValidState() ==> History in Modifies
      decreases Modifies - {History} + {this}
    {
      History in Modifies
    }

    constructor {:extern} (wrapped: LocalCMC.LocalCMC)
      ensures ValidState() && fresh(this.Modifies)
      decreases wrapped

    predicate GetCacheEntryEnsuresPublicly(input: Types.GetCacheEntryInput, output: Result<Types.GetCacheEntryOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method {:extern ""GetCacheEntry""} GetCacheEntry'(input: Types.GetCacheEntryInput) returns (output: Result<Types.GetCacheEntryOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures GetCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}

    predicate PutCacheEntryEnsuresPublicly(input: Types.PutCacheEntryInput, output: Result<(), Types.Error>)
      decreases input, output
    {
      true
    }

    method {:extern ""PutCacheEntry""} PutCacheEntry'(input: Types.PutCacheEntryInput) returns (output: Result<(), Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures PutCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}

    predicate DeleteCacheEntryEnsuresPublicly(input: Types.DeleteCacheEntryInput, output: Result<(), Types.Error>)
      decreases input, output
    {
      true
    }

    method {:extern ""DeleteCacheEntry""} DeleteCacheEntry'(input: Types.DeleteCacheEntryInput) returns (output: Result<(), Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures DeleteCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures Modifies <= old(Modifies)
      decreases Modifies - {History}

    predicate UpdateUsageMetadataEnsuresPublicly(input: Types.UpdateUsageMetadataInput, output: Result<(), Types.Error>)
      decreases input, output
    {
      true
    }

    method {:extern ""UpdateUsageMetadata""} UpdateUsageMetadata'(input: Types.UpdateUsageMetadataInput) returns (output: Result<(), Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      decreases Modifies - {History}
  }
}

module AwsKmsDiscoveryKeyring {

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened Actions

  import opened Constants

  import AlgorithmSuites

  import Keyring

  import Materials

  import opened AwsArnParsing

  import UTF8

  import Types = AwsCryptographyMaterialProvidersTypes

  import KMS = ComAmazonawsKmsTypes

  import opened AwsKmsUtils

  import opened AwsKmsKeyring

  import EdkWrapping

  import MaterialWrapping
  class AwsKmsDiscoveryKeyring extends Keyring.VerifiableInterface {
    const client: KMS.IKMSClient
    const discoveryFilter: Option<Types.DiscoveryFilter>
    const grantTokens: KMS.GrantTokenList

    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      client.ValidState() &&
      client.Modifies <= Modifies &&
      History !in client.Modifies
    }

    constructor (client: KMS.IKMSClient, discoveryFilter: Option<Types.DiscoveryFilter>, grantTokens: KMS.GrantTokenList)
      requires client.ValidState()
      ensures this.client == client && this.discoveryFilter == discoveryFilter && this.grantTokens == grantTokens
      ensures ValidState() && fresh(this) && fresh(History) && fresh(Modifies - client.Modifies)
      decreases client, discoveryFilter, grantTokens
    {
      this.client := client;
      this.discoveryFilter := discoveryFilter;
      this.grantTokens := grantTokens;
      History := new Types.IKeyringCallHistory();
      Modifies := {History} + client.Modifies;
    }

    predicate OnEncryptEnsuresPublicly(input: Types.OnEncryptInput, output: Result<Types.OnEncryptOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method OnEncrypt'(input: Types.OnEncryptInput) returns (output: Result<Types.OnEncryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnEncryptEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures output.Failure?
      decreases Modifies - {History}
    {
      return Failure(Types.AwsCryptographicMaterialProvidersException(message := ""Encryption is not supported with a Discovery Keyring.""));
    }

    predicate OnDecryptEnsuresPublicly(input: Types.OnDecryptInput, output: Result<Types.OnDecryptOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method OnDecrypt'(input: Types.OnDecryptInput) returns (res: Result<Types.OnDecryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnDecryptEnsuresPublicly(input, res)
      ensures unchanged(History)
      ensures res.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, res.value.materials)
      ensures input.materials.plaintextDataKey.Some? ==> true && res.Failure?
      ensures StringifyEncryptionContext(input.materials.encryptionContext).Failure? ==> res.Failure?
      ensures res.Success? ==> true && var stringifiedEncCtx: KMS.EncryptionContextType := StringifyEncryptionContext(input.materials.encryptionContext).Extract(); 0 < |client.History.Decrypt| && AlgorithmSuites.GetEncryptKeyLength(input.materials.algorithmSuite) as nat == |res.value.materials.plaintextDataKey.value| && var LastDecrypt: DafnyCallEvent<DecryptRequest, Result<DecryptResponse, Error>> := Seq.Last(client.History.Decrypt); LastDecrypt.output.Success? && exists edk: Types.EncryptedDataKey, awsKmsKey: string {:trigger Option<string>.Some(awsKmsKey), edk.keyProviderId} {:trigger Option<string>.Some(awsKmsKey), edk.ciphertext} {:trigger Option<string>.Some(awsKmsKey), edk in input.encryptedDataKeys} {:trigger _default.IsValid_KeyIdType(awsKmsKey), edk.keyProviderId} {:trigger _default.IsValid_KeyIdType(awsKmsKey), edk.ciphertext} {:trigger _default.IsValid_KeyIdType(awsKmsKey), edk in input.encryptedDataKeys} | true && edk in input.encryptedDataKeys :: true && var maybeProviderWrappedMaterial: Result<seq<uint8>, Types.Error> := EdkWrapping.GetProviderWrappedMaterial(edk.ciphertext, res.value.materials.algorithmSuite); maybeProviderWrappedMaterial.Success? && KMS.IsValid_CiphertextType(maybeProviderWrappedMaterial.value) && edk.keyProviderId == PROVIDER_ID && KMS.IsValid_KeyIdType(awsKmsKey) && var request: DecryptRequest := KMS.DecryptRequest(KeyId := Option.Some(awsKmsKey), CiphertextBlob := maybeProviderWrappedMaterial.value, EncryptionContext := Option.Some(stringifiedEncCtx), GrantTokens := Option.Some(grantTokens), EncryptionAlgorithm := Option.None()); Seq.Last(client.History.Decrypt).input == request && Seq.Last(client.History.Decrypt).output.value.Plaintext.Some? && (input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> Seq.Last(client.History.Decrypt).output.value.Plaintext == res.value.materials.plaintextDataKey) && Seq.Last(client.History.Decrypt).output.value.KeyId == Some(awsKmsKey)
      decreases Modifies - {History}
    {
      var materials := input.materials;
      var encryptedDataKeys := input.encryptedDataKeys;
      var suite := input.materials.algorithmSuite;
      :- Need(Materials.DecryptionMaterialsWithoutPlaintextDataKey(materials), Types.AwsCryptographicMaterialProvidersException(message := ""Keyring received decryption materials that already contain a plaintext data key.""));
      var edkFilter: AwsKmsEncryptedDataKeyFilter := new AwsKmsEncryptedDataKeyFilter(discoveryFilter);
      var matchingEdks :- Actions.FilterWithResult(edkFilter, encryptedDataKeys);
      var edkTransform: AwsKmsEncryptedDataKeyTransformer := new AwsKmsEncryptedDataKeyTransformer();
      var edksToAttempt, parts :- Actions.DeterministicFlatMapWithResult(edkTransform, matchingEdks);
      :- Need(0 < |edksToAttempt|, Types.AwsCryptographicMaterialProvidersException(message := ""Unable to decrypt data key: No Encrypted Data Keys found to match.""));
      forall helper: AwsKmsEdkHelper | helper in edksToAttempt
        ensures helper.edk in encryptedDataKeys
      {
        LemmaFlattenMembership(parts, edksToAttempt);
        assert helper.edk in encryptedDataKeys;
      }
      var decryptAction: AwsKmsEncryptedDataKeyDecryptor := new AwsKmsEncryptedDataKeyDecryptor(materials, client, grantTokens);
      var outcome, attempts := Actions.ReduceToSuccess(decryptAction, edksToAttempt);
      return match outcome { case Success(mat) => (assert exists helper: AwsKmsEdkHelper {:trigger decryptAction.Ensures(helper, Success(mat), attempts)} {:trigger helper.edk} {:trigger helper in edksToAttempt} | helper in edksToAttempt :: helper.edk in encryptedDataKeys && decryptAction.Ensures(helper, Success(mat), attempts); Success(Types.OnDecryptOutput(materials := mat))) case Failure(errors) => Failure(Types.CollectionOfErrors(list := errors, message := ""No Configured KMS Key was able to decrypt the Data Key. The list of encountered Exceptions is available via `list`."")) };
    }
  }

  class AwsKmsEncryptedDataKeyFilter extends DeterministicActionWithResult<Types.EncryptedDataKey, bool, Types.Error> {
    const discoveryFilter: Option<Types.DiscoveryFilter>

    constructor (discoveryFilter: Option<Types.DiscoveryFilter>)
      ensures true && this.discoveryFilter == discoveryFilter
      decreases discoveryFilter
    {
      this.discoveryFilter := discoveryFilter;
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<bool, Types.Error>)
      decreases edk, res
    {
      res.Success? &&
      res.value ==>
        UTF8.ValidUTF8Seq(edk.keyProviderInfo) &&
        ghost var keyId: Result<string, string> := UTF8.Decode(edk.keyProviderInfo); keyId.Success? && ghost var arn: Result<AwsKmsArn, string> := ParseAwsKmsArn(keyId.value); arn.Success? && edk.keyProviderId == PROVIDER_ID && arn.value.resource.resourceType == ""key"" && DiscoveryMatch(arn.value, discoveryFilter)
    }

    method Invoke(edk: Types.EncryptedDataKey) returns (output: Result<bool, Types.Error>)
      ensures Ensures(edk, output)
      decreases edk
    {
      :- Need(UTF8.ValidUTF8Seq(edk.keyProviderInfo), Types.AwsCryptographicMaterialProvidersException(message := ""Invalid AWS KMS encoding, provider info is not UTF8.""));
      var keyId :- UTF8.Decode(edk.keyProviderInfo).MapFailure(WrapStringToError);
      var arn :- ParseAwsKmsArn(keyId).MapFailure(WrapStringToError);
      :- Need(arn.resource.resourceType == ""key"", Types.AwsCryptographicMaterialProvidersException(message := ""Only AWS KMS Keys supported""));
      if edk.keyProviderId != PROVIDER_ID {
        return Success(false);
      }
      if !DiscoveryMatch(arn, discoveryFilter) {
        return Success(false);
      }
      return Success(true);
    }
  }

  class AwsKmsEncryptedDataKeyTransformer extends DeterministicActionWithResult<Types.EncryptedDataKey, seq<AwsKmsEdkHelper>, Types.Error> {
    constructor ()
    {
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<seq<AwsKmsEdkHelper>, Types.Error>)
      decreases edk, res
    {
      true &&
      res.Success? ==>
        |res.value| == 1 &&
        ghost var matchingEdk: AwsKmsEdkHelper := res.value[0]; UTF8.ValidUTF8Seq(edk.keyProviderInfo) && ghost var keyId: Result<string, string> := UTF8.Decode(edk.keyProviderInfo); keyId.Success? && ghost var arn: Result<AwsKmsArn, string> := ParseAwsKmsArn(keyId.value); arn.Success? && arn.value == matchingEdk.arn && matchingEdk.edk == edk
    }

    method Invoke(edk: Types.EncryptedDataKey) returns (res: Result<seq<AwsKmsEdkHelper>, Types.Error>)
      ensures Ensures(edk, res)
      decreases edk
    {
      :- Need(edk.keyProviderId == PROVIDER_ID, Types.AwsCryptographicMaterialProvidersException(message := ""Encrypted data key was not generated by KMS""));
      :- Need(UTF8.ValidUTF8Seq(edk.keyProviderInfo), Types.AwsCryptographicMaterialProvidersException(message := ""Invalid AWS KMS encoding, provider info is not UTF8.""));
      var keyId :- UTF8.Decode(edk.keyProviderInfo).MapFailure(WrapStringToError);
      var arn :- ParseAwsKmsArn(keyId).MapFailure(WrapStringToError);
      return Success([AwsKmsEdkHelper(edk, arn)]);
    }
  }

  class AwsKmsEncryptedDataKeyDecryptor extends ActionWithResult<AwsKmsEdkHelper, Materials.SealedDecryptionMaterials, Types.Error> {
    const materials: Materials.DecryptionMaterialsPendingPlaintextDataKey
    const client: KMS.IKMSClient
    const grantTokens: KMS.GrantTokenList

    constructor (materials: Materials.DecryptionMaterialsPendingPlaintextDataKey, client: KMS.IKMSClient, grantTokens: KMS.GrantTokenList)
      requires client.ValidState()
      ensures this.materials == materials && this.client == client && this.grantTokens == grantTokens
      ensures Invariant()
      decreases materials, client, grantTokens
    {
      this.materials := materials;
      this.client := client;
      this.grantTokens := grantTokens;
      Modifies := client.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      client.ValidState() &&
      client.Modifies == Modifies
    }

    predicate Ensures(helper: AwsKmsEdkHelper, res: Result<Materials.SealedDecryptionMaterials, Types.Error>, attemptsState: seq<ActionInvoke<AwsKmsEdkHelper, Result<Materials.SealedDecryptionMaterials, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      true &&
      res.Success? ==>
        Invariant() &&
        ghost var keyArn: string := helper.arn.ToString(); true && ghost var maybeProviderWrappedMaterial: Result<seq<uint8>, Types.Error> := EdkWrapping.GetProviderWrappedMaterial(helper.edk.ciphertext, materials.algorithmSuite); maybeProviderWrappedMaterial.Success? && KMS.IsValid_CiphertextType(maybeProviderWrappedMaterial.value) && KMS.IsValid_KeyIdType(keyArn) && ghost var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(materials.encryptionContext); maybeStringifiedEncCtx.Success? && Materials.DecryptionMaterialsTransitionIsValid(materials, res.value) && 0 < |client.History.Decrypt| && KMS.DecryptRequest(KeyId := Some(keyArn), CiphertextBlob := maybeProviderWrappedMaterial.value, EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), EncryptionAlgorithm := None) == Seq.Last(client.History.Decrypt).input && Seq.Last(client.History.Decrypt).output.Success? && Seq.Last(client.History.Decrypt).output.value.Plaintext.Some? && (materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> Seq.Last(client.History.Decrypt).output.value.Plaintext == res.value.plaintextDataKey) && Seq.Last(client.History.Decrypt).output.value.KeyId == Some(keyArn)
    }

    method Invoke(helper: AwsKmsEdkHelper, ghost attemptsState: seq<ActionInvoke<AwsKmsEdkHelper, Result<Materials.SealedDecryptionMaterials, Types.Error>>>) returns (res: Result<Materials.SealedDecryptionMaterials, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(helper, res, attemptsState)
      decreases Modifies
    {
      var awsKmsKey := helper.arn.ToString();
      var _ /* _v0 */ :- ValidateKmsKeyId(helper.arn.ToString());
      var kmsUnwrap := new KmsUnwrapKeyMaterial(client, awsKmsKey, grantTokens);
      var unwrapOutputRes := EdkWrapping.UnwrapEdkMaterial(helper.edk.ciphertext, materials, kmsUnwrap);
      var unwrapOutput :- unwrapOutputRes;
      var result :- Materials.DecryptionMaterialsAddDataKey(materials, unwrapOutput.plaintextDataKey, unwrapOutput.symmetricSigningKey);
      return Success(result);
    }
  }

  function method DiscoveryMatch(arn: AwsKmsArn, discoveryFilter: Option<Types.DiscoveryFilter>): (res: bool)
    ensures discoveryFilter.Some? && res ==> discoveryFilter.value.partition == arn.partition && discoveryFilter.value.accountIds <= [arn.account]
    decreases arn, discoveryFilter
  {
    true &&
    match discoveryFilter { case Some(filter) => filter.partition == arn.partition && filter.accountIds <= [arn.account] case None() => true }
  }

  lemma /*{:_induction parts}*/ LemmaFlattenMembership<T>(parts: seq<seq<T>>, flat: seq<T>)
    requires Seq.Flatten(parts) == flat
    ensures forall index: int {:trigger parts[index]} | 0 <= index < |parts| :: multiset(parts[index]) <= multiset(flat)
    ensures multiset(Seq.Flatten(parts)) == multiset(flat)
    ensures forall part: seq<T> {:trigger part in parts} | part in parts :: forall i: T {:trigger i in flat} {:trigger i in part} | i in part :: i in flat
    ensures forall i: T {:trigger i in flat} | i in flat :: exists part: seq<T> {:trigger i in part} {:trigger part in parts} | part in parts :: i in part
    decreases parts, flat
  {
  }
}

module DiscoveryMultiKeyring {

  import opened Wrappers

  import Seq

  import Types = AwsCryptographyMaterialProvidersTypes

  import KMS = Types.ComAmazonawsKmsTypes

  import MultiKeyring

  import AwsArnParsing

  import AwsKmsMrkAreUnique

  import AwsKmsDiscoveryKeyring

  import opened AwsKmsUtils

  import Kms = Com.Amazonaws.Kms
  method DiscoveryMultiKeyring(regions: seq<string>, discoveryFilter: Option<Types.DiscoveryFilter>, clientSupplier: Types.IClientSupplier, grantTokens: Option<KMS.GrantTokenList>)
      returns (output: Result<MultiKeyring.MultiKeyring, Types.Error>)
    requires clientSupplier.ValidState()
    modifies clientSupplier.Modifies
    ensures output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.History) && fresh(output.value.Modifies - clientSupplier.Modifies)
    ensures |regions| == 0 || (exists r: seq<char> {:trigger r in regions} | r in regions :: r == """") ==> output.Failure?
    ensures true && output.Success? ==> output.value.generatorKeyring.None? && |regions| == |output.value.childKeyrings| && forall i: int {:trigger output.value.childKeyrings[i]} | 0 <= i < |regions| :: var k: Types.IKeyring := output.value.childKeyrings[i]; k is AwsKmsDiscoveryKeyring.AwsKmsDiscoveryKeyring && var c: AwsKmsDiscoveryKeyring.AwsKmsDiscoveryKeyring := k as AwsKmsDiscoveryKeyring.AwsKmsDiscoveryKeyring; (discoveryFilter.Some? ==> c.discoveryFilter == discoveryFilter) && (grantTokens.Some? ==> c.grantTokens == grantTokens.value)
    decreases regions, discoveryFilter, clientSupplier, grantTokens
  {
    :- Need(|regions| > 0, Types.AwsCryptographicMaterialProvidersException(message := ""No regions passed.""));
    :- Need(Seq.IndexOfOption(regions, """").None?, Types.AwsCryptographicMaterialProvidersException(message := ""Empty string is not a valid region.""));
    var children: seq<AwsKmsDiscoveryKeyring.AwsKmsDiscoveryKeyring> := [];
    for i: int := 0 to |regions|
      invariant |regions[..i]| == |children|
      invariant fresh(MultiKeyring.GatherModifies(None, children) - clientSupplier.Modifies)
      invariant forall i: int {:trigger children[i]} | 0 <= i < |children| :: (discoveryFilter.Some? ==> children[i].discoveryFilter == discoveryFilter) && (grantTokens.Some? ==> children[i].grantTokens == grantTokens.value) && children[i].ValidState()
    {
      var region := regions[i];
      var client :- clientSupplier.GetClient(Types.GetClientInput(region := region));
      var keyring := new AwsKmsDiscoveryKeyring.AwsKmsDiscoveryKeyring(client, discoveryFilter, grantTokens.UnwrapOr([]));
      children := children + [keyring];
    }
    var keyring := new MultiKeyring.MultiKeyring(None(), children);
    return Success(keyring);
  }
}

module AwsKmsMrkKeyring {

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened AwsArnParsing

  import opened AwsKmsUtils

  import opened AwsKmsKeyring

  import Types = AwsCryptographyMaterialProvidersTypes

  import KMS = Types.ComAmazonawsKmsTypes

  import opened Seq

  import opened Actions

  import opened Constants

  import Keyring

  import Materials

  import AlgorithmSuites

  import UTF8

  import EdkWrapping

  import MaterialWrapping
  class AwsKmsMrkKeyring extends Keyring.VerifiableInterface {
    const client: KMS.IKMSClient
    const awsKmsKey: AwsKmsIdentifierString
    const awsKmsArn: AwsKmsIdentifier
    const grantTokens: KMS.GrantTokenList

    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      client.ValidState() &&
      client.Modifies <= Modifies &&
      History !in client.Modifies
    }

    constructor (client: KMS.IKMSClient, awsKmsKey: string, grantTokens: KMS.GrantTokenList)
      requires ParseAwsKmsIdentifier(awsKmsKey).Success?
      requires UTF8.IsASCIIString(awsKmsKey)
      requires 0 < |awsKmsKey| <= MAX_AWS_KMS_IDENTIFIER_LENGTH
      requires client.ValidState()
      ensures this.client == client && this.awsKmsKey == awsKmsKey && this.grantTokens == grantTokens
      ensures ValidState() && fresh(this) && fresh(History) && fresh(Modifies - client.Modifies)
      decreases client, awsKmsKey, grantTokens
    {
      var parsedAwsKmsId := ParseAwsKmsIdentifier(awsKmsKey);
      this.client := client;
      this.awsKmsKey := awsKmsKey;
      this.awsKmsArn := parsedAwsKmsId.value;
      this.grantTokens := grantTokens;
      History := new Types.IKeyringCallHistory();
      Modifies := {History} + client.Modifies;
    }

    predicate OnEncryptEnsuresPublicly(input: Types.OnEncryptInput, output: Result<Types.OnEncryptOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method {:vcs_split_on_every_assert} OnEncrypt'(input: Types.OnEncryptInput) returns (output: Result<Types.OnEncryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures unchanged(History)
      ensures OnEncryptEnsuresPublicly(input, output)
      ensures output.Success? ==> true && Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
      ensures StringifyEncryptionContext(input.materials.encryptionContext).Failure? ==> output.Failure?
      ensures !KMS.IsValid_KeyIdType(awsKmsKey) ==> output.Failure?
      ensures input.materials.plaintextDataKey.Some? && !KMS.IsValid_PlaintextType(input.materials.plaintextDataKey.value) ==> output.Failure?
      ensures output.Success? && input.materials.plaintextDataKey.None? && input.materials.algorithmSuite.edkWrapping.IntermediateKeyWrapping? ==> true && var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(input.materials.encryptionContext); maybeStringifiedEncCtx.Success? && 0 < |client.History.GenerateDataKey| && Last(client.History.GenerateDataKey).input == KMS.GenerateDataKeyRequest(EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), KeyId := awsKmsKey, NumberOfBytes := Some(AlgorithmSuites.GetEncryptKeyLength(input.materials.algorithmSuite)), KeySpec := None)
      ensures output.Success? && input.materials.plaintextDataKey.None? && input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> true && var suite: AlgorithmSuiteInfo := input.materials.algorithmSuite; true && var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(input.materials.encryptionContext); maybeStringifiedEncCtx.Success? && 0 < |client.History.GenerateDataKey| && Last(client.History.GenerateDataKey).input == KMS.GenerateDataKeyRequest(EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), KeyId := awsKmsKey, NumberOfBytes := Some(AlgorithmSuites.GetEncryptKeyLength(suite)), KeySpec := None)
      ensures output.Success? && input.materials.plaintextDataKey.None? && input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> Last(client.History.GenerateDataKey).output.Success? && var GenerateResponse: GenerateDataKeyResponse := Last(client.History.GenerateDataKey).output.value; GenerateResponse.CiphertextBlob.Some? && GenerateResponse.KeyId.Some? && UTF8.Encode(GenerateResponse.KeyId.value).Success? && |output.value.materials.encryptedDataKeys| == |input.materials.encryptedDataKeys| + 1 && KMS.IsValid_CiphertextType(Last(output.value.materials.encryptedDataKeys).ciphertext) && Last(output.value.materials.encryptedDataKeys).ciphertext == GenerateResponse.CiphertextBlob.value && Last(output.value.materials.encryptedDataKeys).keyProviderInfo == UTF8.Encode(GenerateResponse.KeyId.value).value && 0 < |client.History.GenerateDataKey| && exists returnedKeyId: KeyIdType, kmsPlaintext: Option<PlaintextType> {:trigger KMS.GenerateDataKeyResponse(KeyId := Some(returnedKeyId), CiphertextBlob := Some(Last(output.value.materials.encryptedDataKeys).ciphertext), Plaintext := kmsPlaintext)} :: true && Last(client.History.GenerateDataKey).output.value == KMS.GenerateDataKeyResponse(KeyId := Some(returnedKeyId), CiphertextBlob := Some(Last(output.value.materials.encryptedDataKeys).ciphertext), Plaintext := kmsPlaintext)
      ensures output.Success? && input.materials.plaintextDataKey.Some? && input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> KMS.IsValid_PlaintextType(input.materials.plaintextDataKey.value) && var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(input.materials.encryptionContext); maybeStringifiedEncCtx.Success? && 0 < |client.History.Encrypt| && Last(client.History.Encrypt).input == KMS.EncryptRequest(EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), KeyId := awsKmsKey, Plaintext := input.materials.plaintextDataKey.value, EncryptionAlgorithm := None)
      ensures input.materials.plaintextDataKey.Some? && output.Success? && input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> Last(client.History.Encrypt).output.Success? && var EncryptResponse: EncryptResponse := Last(client.History.Encrypt).output.value; EncryptResponse.CiphertextBlob.Some? && EncryptResponse.KeyId.Some? && UTF8.Encode(EncryptResponse.KeyId.value).Success? && |output.value.materials.encryptedDataKeys| == |input.materials.encryptedDataKeys| + 1 && Last(output.value.materials.encryptedDataKeys).ciphertext == EncryptResponse.CiphertextBlob.value && Last(output.value.materials.encryptedDataKeys).keyProviderInfo == UTF8.Encode(EncryptResponse.KeyId.value).value && KMS.IsValid_CiphertextType(Last(output.value.materials.encryptedDataKeys).ciphertext) && 0 < |client.History.Encrypt| && Last(client.History.Encrypt).output.Success? && exists returnedKeyId: Option<KeyIdType>, returnedEncryptionAlgorithm: Option<EncryptionAlgorithmSpec> {:trigger KMS.EncryptResponse(CiphertextBlob := Some(Last(output.value.materials.encryptedDataKeys).ciphertext), KeyId := returnedKeyId, EncryptionAlgorithm := returnedEncryptionAlgorithm)} :: true && Last(client.History.Encrypt).output.value == KMS.EncryptResponse(CiphertextBlob := Some(Last(output.value.materials.encryptedDataKeys).ciphertext), KeyId := returnedKeyId, EncryptionAlgorithm := returnedEncryptionAlgorithm)
      ensures input.materials.plaintextDataKey.Some? && input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? && StringifyEncryptionContext(input.materials.encryptionContext).Success? && |client.History.Encrypt| == |old(client.History.Encrypt)| + 1 && Last(client.History.Encrypt).output.Failure? ==> output.Failure?
      ensures input.materials.plaintextDataKey.None? && input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? && StringifyEncryptionContext(input.materials.encryptionContext).Success? && |client.History.GenerateDataKey| == |old(client.History.GenerateDataKey)| + 1 && Last(client.History.GenerateDataKey).output.Failure? ==> output.Failure?
      decreases Modifies - {History}
    {
      var materials := input.materials;
      var suite := input.materials.algorithmSuite;
      var stringifiedEncCtx :- StringifyEncryptionContext(input.materials.encryptionContext);
      var kmsGenerateAndWrap := new KmsGenerateAndWrapKeyMaterial(client, awsKmsKey, grantTokens);
      var kmsWrap := new KmsWrapKeyMaterial(client, awsKmsKey, grantTokens);
      var wrapOutput :- EdkWrapping.WrapEdkMaterial<KmsWrapInfo>(encryptionMaterials := materials, wrap := kmsWrap, generateAndWrap := kmsGenerateAndWrap);
      var kmsKeyArn := wrapOutput.wrapInfo.kmsKeyArn;
      var symmetricSigningKeyList := if wrapOutput.symmetricSigningKey.Some? then Some([wrapOutput.symmetricSigningKey.value]) else None;
      var providerInfo :- UTF8.Encode(kmsKeyArn).MapFailure(WrapStringToError);
      :- Need(|providerInfo| < UINT16_LIMIT, Types.AwsCryptographicMaterialProvidersException(message := ""Invalid response from AWS KMS GenerateDataKey: Key ID too long.""));
      var edk := Types.EncryptedDataKey(keyProviderId := PROVIDER_ID, keyProviderInfo := providerInfo, ciphertext := wrapOutput.wrappedMaterial);
      if wrapOutput.GenerateAndWrapEdkMaterialOutput? {
        assert |client.History.GenerateDataKey| > 0 && Last(client.History.GenerateDataKey).output.Success?;
        assert |kmsGenerateAndWrap.client.History.GenerateDataKey| > 0 && Last(kmsGenerateAndWrap.client.History.GenerateDataKey).output.Success?;
        assert Last(client.History.GenerateDataKey).output.value == Last(kmsGenerateAndWrap.client.History.GenerateDataKey).output.value;
        var result :- Materials.EncryptionMaterialAddDataKey(materials, wrapOutput.plaintextDataKey, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      } else if wrapOutput.WrapOnlyEdkMaterialOutput? {
        var result :- Materials.EncryptionMaterialAddEncryptedDataKeys(materials, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      }
    }

    predicate OnDecryptEnsuresPublicly(input: Types.OnDecryptInput, output: Result<Types.OnDecryptOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method OnDecrypt'(input: Types.OnDecryptInput) returns (output: Result<Types.OnDecryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures unchanged(History)
      ensures OnDecryptEnsuresPublicly(input, output)
      ensures output.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
      ensures input.materials.plaintextDataKey.None? && output.Success? ==> output.value.materials.plaintextDataKey.Some? && var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(input.materials.encryptionContext); maybeStringifiedEncCtx.Success? && 0 < |client.History.Decrypt| && var suite: AlgorithmSuiteInfo := input.materials.algorithmSuite; AlgorithmSuites.GetEncryptKeyLength(suite) as nat == |output.value.materials.plaintextDataKey.value| && var LastDecrypt: DafnyCallEvent<DecryptRequest, Result<DecryptResponse, Error>> := Last(client.History.Decrypt); LastDecrypt.output.Success? && exists edk: EncryptedDataKey {:trigger edk.keyProviderId} {:trigger edk.ciphertext} {:trigger edk in input.encryptedDataKeys} | edk in input.encryptedDataKeys :: true && var maybeWrappedMaterial: Result<seq<uint8>, Types.Error> := EdkWrapping.GetProviderWrappedMaterial(edk.ciphertext, input.materials.algorithmSuite); maybeWrappedMaterial.Success? && edk.keyProviderId == PROVIDER_ID && KMS.IsValid_CiphertextType(maybeWrappedMaterial.value) && KMS.DecryptRequest(KeyId := Some(awsKmsKey), CiphertextBlob := maybeWrappedMaterial.value, EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), EncryptionAlgorithm := None) == LastDecrypt.input && LastDecrypt.output.value.KeyId == Some(awsKmsKey) && (input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> LastDecrypt.output.value.Plaintext == output.value.materials.plaintextDataKey)
      decreases Modifies - {History}
    {
      var materials := input.materials;
      var suite := input.materials.algorithmSuite;
      :- Need(Materials.DecryptionMaterialsWithoutPlaintextDataKey(materials), Types.AwsCryptographicMaterialProvidersException(message := ""Keyring received decryption materials that already contain a plaintext data key.""));
      var filter := new AwsKmsUtils.OnDecryptMrkAwareEncryptedDataKeyFilter(awsKmsArn, PROVIDER_ID);
      var edksToAttempt :- FilterWithResult(filter, input.encryptedDataKeys);
      :- Need(0 < |edksToAttempt|, Types.AwsCryptographicMaterialProvidersException(message := ""Unable to decrypt data key: No Encrypted Data Keys found to match.""));
      var decryptClosure: DecryptSingleEncryptedDataKey := new DecryptSingleEncryptedDataKey(materials, client, awsKmsKey, grantTokens);
      var outcome, attempts := ReduceToSuccess(decryptClosure, edksToAttempt);
      var SealedDecryptionMaterials :- outcome.MapFailure((errors: seq<Types.Error>) => Types.CollectionOfErrors(list := errors, message := ""No Configured KMS Key was able to decrypt the Data Key. The list of encountered Exceptions is available via `list`.""));
      assert decryptClosure.Ensures(Last(attempts).input, Success(SealedDecryptionMaterials), DropLast(attempts));
      return Success(Types.OnDecryptOutput(materials := SealedDecryptionMaterials));
    }
  }

  class DecryptSingleEncryptedDataKey extends ActionWithResult<Types.EncryptedDataKey, Materials.SealedDecryptionMaterials, Types.Error> {
    const materials: Materials.DecryptionMaterialsPendingPlaintextDataKey
    const client: KMS.IKMSClient
    const awsKmsKey: AwsKmsIdentifierString
    const grantTokens: KMS.GrantTokenList

    constructor (materials: Materials.DecryptionMaterialsPendingPlaintextDataKey, client: KMS.IKMSClient, awsKmsKey: AwsKmsIdentifierString, grantTokens: KMS.GrantTokenList)
      requires client.ValidState()
      ensures this.materials == materials && this.client == client && this.awsKmsKey == awsKmsKey && this.grantTokens == grantTokens
      ensures Invariant()
      decreases materials, client, awsKmsKey, grantTokens
    {
      this.materials := materials;
      this.client := client;
      this.awsKmsKey := awsKmsKey;
      this.grantTokens := grantTokens;
      Modifies := client.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      client.ValidState() &&
      client.Modifies == Modifies
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<Materials.SealedDecryptionMaterials, Types.Error>, attempts: seq<ActionInvoke<Types.EncryptedDataKey, Result<Materials.SealedDecryptionMaterials, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      true &&
      (res.Success? ==>
        Invariant() &&
        ghost var maybeProviderWrappedMaterial: Result<seq<uint8>, Types.Error> := EdkWrapping.GetProviderWrappedMaterial(edk.ciphertext, materials.algorithmSuite); maybeProviderWrappedMaterial.Success? && KMS.IsValid_CiphertextType(maybeProviderWrappedMaterial.value) && Materials.DecryptionMaterialsTransitionIsValid(materials, res.value) && ghost var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(materials.encryptionContext); maybeStringifiedEncCtx.Success? && 0 < |client.History.Decrypt| && KMS.DecryptRequest(KeyId := Some(awsKmsKey), CiphertextBlob := maybeProviderWrappedMaterial.value, EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), EncryptionAlgorithm := None) == Last(client.History.Decrypt).input && Last(client.History.Decrypt).output.Success? && Last(client.History.Decrypt).output.value.Plaintext.Some? && (materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> Last(client.History.Decrypt).output.value.Plaintext == res.value.plaintextDataKey) && Last(client.History.Decrypt).output.value.KeyId == Some(awsKmsKey))
    }

    method Invoke(edk: Types.EncryptedDataKey, ghost attemptsState: seq<ActionInvoke<Types.EncryptedDataKey, Result<Materials.SealedDecryptionMaterials, Types.Error>>>) returns (res: Result<Materials.SealedDecryptionMaterials, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(edk, res, attemptsState)
      decreases Modifies
    {
      var kmsUnwrap := new KmsUnwrapKeyMaterial(client, awsKmsKey, grantTokens);
      var unwrapOutputRes := EdkWrapping.UnwrapEdkMaterial(edk.ciphertext, materials, kmsUnwrap);
      var unwrapOutput :- unwrapOutputRes;
      var result :- Materials.DecryptionMaterialsAddDataKey(materials, unwrapOutput.plaintextDataKey, unwrapOutput.symmetricSigningKey);
      return Success(result);
    }
  }
}

module MrkAwareStrictMultiKeyring {

  import opened Wrappers

  import Seq

  import Types = AwsCryptographyMaterialProvidersTypes

  import KMS = Types.ComAmazonawsKmsTypes

  import MultiKeyring

  import AwsArnParsing

  import AwsKmsMrkAreUnique

  import AwsKmsMrkKeyring

  import opened AwsKmsUtils
  method {:vcs_split_on_every_assert} MrkAwareStrictMultiKeyring(generator: Option<string>, awsKmsKeys: Option<seq<string>>, clientSupplier: Types.IClientSupplier, grantTokens: Option<KMS.GrantTokenList>)
      returns (output: Result<MultiKeyring.MultiKeyring, Types.Error>)
    requires clientSupplier.ValidState()
    modifies clientSupplier.Modifies
    ensures output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.History) && fresh(output.value.Modifies - clientSupplier.Modifies)
    ensures (generator.Some? && generator.value == """") || (awsKmsKeys.Some? && exists k: seq<char> {:trigger k in awsKmsKeys.value} | k in awsKmsKeys.value :: k == """") ==> output.Failure?
    ensures var allStrings: seq<seq<char>> := if generator.Some? then [generator.value] + awsKmsKeys.UnwrapOr([]) else awsKmsKeys.UnwrapOr([]); var allIdentifiers: Result<seq<AwsKmsIdentifier>, string> := Seq.MapWithResult(AwsArnParsing.IsAwsKmsIdentifierString, allStrings); allIdentifiers.Failure? || (allIdentifiers.Success? && AwsKmsMrkAreUnique.AwsKmsMrkAreUnique(allIdentifiers.value).Fail?) ==> output.Failure?
    ensures true && output.Success? ==> (generator.Some? ==> output.value.generatorKeyring.Some? && output.value.generatorKeyring.value is AwsKmsMrkKeyring.AwsKmsMrkKeyring && var g: AwsKmsMrkKeyring.AwsKmsMrkKeyring := output.value.generatorKeyring.value as AwsKmsMrkKeyring.AwsKmsMrkKeyring; g.awsKmsKey == generator.value && (grantTokens.Some? ==> g.grantTokens == grantTokens.value)) && (generator.None? ==> true && output.value.generatorKeyring.None?) && (awsKmsKeys.Some? ==> |awsKmsKeys.value| == |output.value.childKeyrings| && forall index: int {:trigger awsKmsKeys.value[index]} {:trigger output.value.childKeyrings[index]} | 0 <= index < |awsKmsKeys.value| :: var childKeyring: Types.IKeyring := output.value.childKeyrings[index]; childKeyring is AwsKmsMrkKeyring.AwsKmsMrkKeyring && var awsKmsChild: AwsKmsMrkKeyring.AwsKmsMrkKeyring := childKeyring as AwsKmsMrkKeyring.AwsKmsMrkKeyring; awsKmsChild.awsKmsKey == awsKmsKeys.value[index] && (grantTokens.Some? ==> awsKmsChild.grantTokens == grantTokens.value)) && (awsKmsKeys.None? ==> true && output.value.childKeyrings == [])
    decreases generator, awsKmsKeys, clientSupplier, grantTokens
  {
    var allStrings := match generator { case Some(g) => [g] + awsKmsKeys.UnwrapOr([]) case None() => awsKmsKeys.UnwrapOr([]) };
    assert generator.Some? ==> generator.value in allStrings;
    assert awsKmsKeys.Some? ==> forall k: seq<char> {:trigger k in allStrings} {:trigger k in awsKmsKeys.value} | k in awsKmsKeys.value :: k in allStrings;
    var allIdentifiers :- Seq.MapWithResult(AwsArnParsing.IsAwsKmsIdentifierString, allStrings).MapFailure(WrapStringToError);
    :- AwsKmsMrkAreUnique.AwsKmsMrkAreUnique(allIdentifiers);
    var generatorKeyring: Option<AwsKmsMrkKeyring.AwsKmsMrkKeyring>;
    match generator {
      case {:split false} Some(generatorIdentifier) =>
        var arn :- AwsArnParsing.IsAwsKmsIdentifierString(generatorIdentifier).MapFailure(WrapStringToError);
        var region := AwsArnParsing.GetRegion(arn);
        var client :- clientSupplier.GetClient(Types.GetClientInput(region := region.UnwrapOr("""")));
        var g := new AwsKmsMrkKeyring.AwsKmsMrkKeyring(client, generatorIdentifier, grantTokens.UnwrapOr([]));
        generatorKeyring := Some(g);
      case {:split false} None() =>
        generatorKeyring := None();
    }
    var children: seq<AwsKmsMrkKeyring.AwsKmsMrkKeyring> := [];
    match awsKmsKeys {
      case {:split false} Some(childIdentifiers) =>
        for index: int := 0 to |childIdentifiers|
          invariant |awsKmsKeys.value[..index]| == |children|
          invariant fresh(MultiKeyring.GatherModifies(generatorKeyring, children) - clientSupplier.Modifies)
          invariant forall i: int {:trigger awsKmsKeys.value[i]} {:trigger children[i]} | 0 <= i < |children| :: ChildLoopInvariant(children[i], awsKmsKeys.value[i], grantTokens)
        {
          var childIdentifier := childIdentifiers[index];
          var info :- AwsArnParsing.IsAwsKmsIdentifierString(childIdentifier).MapFailure(WrapStringToError);
          var region := AwsArnParsing.GetRegion(info);
          var client :- clientSupplier.GetClient(Types.GetClientInput(region := region.UnwrapOr("""")));
          var keyring := new AwsKmsMrkKeyring.AwsKmsMrkKeyring(client, childIdentifier, grantTokens.UnwrapOr([]));
          children := children + [keyring];
          assert forall i: int {:trigger awsKmsKeys.value[i]} {:trigger children[i]} | 0 <= i < |children| :: ChildLoopInvariant(children[i], awsKmsKeys.value[i], grantTokens) by {
            assert forall i: int {:trigger awsKmsKeys.value[i]} {:trigger children[i]} | 0 <= i < |children| - 1 :: ChildLoopInvariant(children[i], awsKmsKeys.value[i], grantTokens);
            assert ChildLoopInvariant(keyring, awsKmsKeys.value[index], grantTokens);
            assert children[|children| - 1] == keyring;
          }
        }
      case {:split false} None() =>
        children := [];
    }
    :- Need(generatorKeyring.Some? || |children| > 0, Types.AwsCryptographicMaterialProvidersException(message := ""generatorKeyring or child Keyrings needed to create a multi keyring""));
    var keyring := new MultiKeyring.MultiKeyring(generatorKeyring, children);
    return Success(keyring);
  }

  predicate ChildLoopInvariant(child: AwsKmsMrkKeyring.AwsKmsMrkKeyring, awsKmsKey: string, grantTokens: Option<KMS.GrantTokenList>)
    decreases child, awsKmsKey, grantTokens
  {
    child.awsKmsKey == awsKmsKey &&
    (grantTokens.Some? ==>
      child.grantTokens == grantTokens.value) &&
    child.ValidState()
  }
}

module AwsKmsMrkDiscoveryKeyring {

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened AwsArnParsing

  import opened Actions

  import opened Constants

  import AlgorithmSuites

  import Keyring

  import Materials

  import UTF8

  import Types = AwsCryptographyMaterialProvidersTypes

  import KMS = Types.ComAmazonawsKmsTypes

  import opened AwsKmsUtils

  import AwsKmsKeyring

  import EdkWrapping

  import MaterialWrapping
  class AwsKmsMrkDiscoveryKeyring extends Keyring.VerifiableInterface {
    const client: KMS.IKMSClient
    const discoveryFilter: Option<Types.DiscoveryFilter>
    const grantTokens: KMS.GrantTokenList
    const region: string

    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      client.ValidState() &&
      client.Modifies <= Modifies &&
      History !in client.Modifies
    }

    constructor (client: KMS.IKMSClient, region: string, discoveryFilter: Option<Types.DiscoveryFilter>, grantTokens: KMS.GrantTokenList)
      requires client.ValidState()
      ensures this.client == client && this.region == region && this.discoveryFilter == discoveryFilter && this.grantTokens == grantTokens
      ensures ValidState() && fresh(this) && fresh(History) && fresh(Modifies - client.Modifies)
      decreases client, region, discoveryFilter, grantTokens
    {
      this.client := client;
      this.region := region;
      this.discoveryFilter := discoveryFilter;
      this.grantTokens := grantTokens;
      History := new Types.IKeyringCallHistory();
      Modifies := {History} + client.Modifies;
    }

    predicate OnEncryptEnsuresPublicly(input: Types.OnEncryptInput, output: Result<Types.OnEncryptOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method OnEncrypt'(input: Types.OnEncryptInput) returns (output: Result<Types.OnEncryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnEncryptEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures output.Failure?
      decreases Modifies - {History}
    {
      return Failure(Types.AwsCryptographicMaterialProvidersException(message := ""Encryption is not supported with a Discovery Keyring.""));
    }

    predicate OnDecryptEnsuresPublicly(input: Types.OnDecryptInput, output: Result<Types.OnDecryptOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method {:vcs_split_on_every_assert} OnDecrypt'(input: Types.OnDecryptInput) returns (output: Result<Types.OnDecryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnDecryptEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures output.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
      ensures input.materials.plaintextDataKey.Some? ==> true && output.Failure?
      ensures StringifyEncryptionContext(input.materials.encryptionContext).Failure? ==> output.Failure?
      ensures true && output.Success? ==> Materials.DecryptionMaterialsWithPlaintextDataKey(output.value.materials) && var stringifiedEncCtx: KMS.EncryptionContextType := StringifyEncryptionContext(input.materials.encryptionContext).Extract(); output.value.materials.plaintextDataKey.Some? && 0 < |client.History.Decrypt| && var LastDecrypt: DafnyCallEvent<DecryptRequest, Result<DecryptResponse, Error>> := Seq.Last(client.History.Decrypt); LastDecrypt.output.Success? && exists edk: Types.EncryptedDataKey, awsKmsKey: string {:trigger Option<string>.Some(awsKmsKey), edk.keyProviderId} {:trigger Option<string>.Some(awsKmsKey), edk.ciphertext} {:trigger Option<string>.Some(awsKmsKey), edk in input.encryptedDataKeys} {:trigger _default.IsValid_KeyIdType(awsKmsKey), edk.keyProviderId} {:trigger _default.IsValid_KeyIdType(awsKmsKey), edk.ciphertext} {:trigger _default.IsValid_KeyIdType(awsKmsKey), edk in input.encryptedDataKeys} | true && edk in input.encryptedDataKeys :: true && var maybeProviderWrappedMaterial: Result<seq<uint8>, Types.Error> := EdkWrapping.GetProviderWrappedMaterial(edk.ciphertext, output.value.materials.algorithmSuite); maybeProviderWrappedMaterial.Success? && KMS.IsValid_CiphertextType(maybeProviderWrappedMaterial.value) && edk.keyProviderId == PROVIDER_ID && KMS.IsValid_KeyIdType(awsKmsKey) && var request: DecryptRequest := KMS.DecryptRequest(KeyId := Option.Some(awsKmsKey), CiphertextBlob := maybeProviderWrappedMaterial.value, EncryptionContext := Option.Some(stringifiedEncCtx), GrantTokens := Option.Some(grantTokens), EncryptionAlgorithm := Option.None()); Seq.Last(client.History.Decrypt).input == request && Seq.Last(client.History.Decrypt).output.value.Plaintext.Some? && (input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> Seq.Last(client.History.Decrypt).output.value.Plaintext == output.value.materials.plaintextDataKey)
      decreases Modifies - {History}
    {
      var materials := input.materials;
      var encryptedDataKeys := input.encryptedDataKeys;
      var suite := input.materials.algorithmSuite;
      :- Need(Materials.DecryptionMaterialsWithoutPlaintextDataKey(materials), Types.AwsCryptographicMaterialProvidersException(message := ""Keyring received decryption materials that already contain a plaintext data key.""));
      var edkFilterTransform: AwsKmsEncryptedDataKeyFilterTransform := new AwsKmsEncryptedDataKeyFilterTransform(region, discoveryFilter);
      var edksToAttempt, parts :- Actions.DeterministicFlatMapWithResult(edkFilterTransform, encryptedDataKeys);
      forall i: int | 0 <= i < |parts|
        ensures edkFilterTransform.Ensures(encryptedDataKeys[i], Success(parts[i])) && 1 >= |parts[i]| && |encryptedDataKeys| == |parts| && edksToAttempt == Seq.Flatten(parts) && |encryptedDataKeys| >= |edksToAttempt| && multiset(parts[i]) <= multiset(edksToAttempt) && multiset(edksToAttempt) <= multiset(Seq.Flatten(parts)) && forall helper: AwsKmsEdkHelper {:trigger helper.arn} {:trigger helper.edk} {:trigger helper in edksToAttempt} {:trigger helper in parts[i]} | helper in parts[i] :: helper in edksToAttempt && helper.edk == encryptedDataKeys[i] && helper.arn.resource.resourceType == ""key""
      {
        if |parts| < |edksToAttempt| {
          Seq.LemmaFlattenLengthLeMul(parts, 1);
          Seq.LemmaFlattenAndFlattenReverseAreEquivalent(parts);
          assert |parts| * 1 >= |Seq.Flatten(parts)|;
        }
        forall helper: AwsKmsEdkHelper | helper in parts[i]
          ensures helper in edksToAttempt && helper.edk == encryptedDataKeys[i] && helper.arn.resource.resourceType == ""key""
        {
          LemmaMultisetSubMembership(parts[i], edksToAttempt);
        }
      }
      forall helper: AwsKmsEdkHelper | helper in edksToAttempt
        ensures helper.edk in encryptedDataKeys && helper.arn.resource.resourceType == ""key""
      {
        LemmaFlattenMembership(parts, edksToAttempt);
        assert helper in Seq.Flatten(parts);
      }
      :- Need(0 < |edksToAttempt|, Types.AwsCryptographicMaterialProvidersException(message := ""Unable to decrypt data key: No Encrypted Data Keys found to match.""));
      var decryptAction: AwsKmsEncryptedDataKeyDecryptor := new AwsKmsEncryptedDataKeyDecryptor(materials, client, region, grantTokens);
      var outcome, attempts := Actions.ReduceToSuccess(decryptAction, edksToAttempt);
      return match outcome { case Success(mat) => (assert exists helper: AwsKmsEdkHelper {:trigger decryptAction.Ensures(helper, Success(mat), attempts)} {:trigger helper.arn} {:trigger helper.edk} {:trigger helper in edksToAttempt} | helper in edksToAttempt :: helper.edk in encryptedDataKeys && helper.arn.resource.resourceType == ""key"" && decryptAction.Ensures(helper, Success(mat), attempts); Success(Types.OnDecryptOutput(materials := mat))) case Failure(errors) => Failure(Types.CollectionOfErrors(list := errors, message := ""No Configured KMS Key was able to decrypt the Data Key. The list of encountered Exceptions is available via `list`."")) };
    }
  }

  class AwsKmsEncryptedDataKeyFilterTransform extends DeterministicActionWithResult<Types.EncryptedDataKey, seq<AwsKmsEdkHelper>, Types.Error> {
    const region: string
    const discoveryFilter: Option<Types.DiscoveryFilter>

    constructor (region: string, discoveryFilter: Option<Types.DiscoveryFilter>)
      ensures this.region == region && this.discoveryFilter == discoveryFilter
      decreases region, discoveryFilter
    {
      this.region := region;
      this.discoveryFilter := discoveryFilter;
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<seq<AwsKmsEdkHelper>, Types.Error>)
      decreases edk, res
    {
      true &&
      res.Success? ==>
        if |res.value| == 1 then true && ghost var h: AwsKmsEdkHelper := res.value[0]; h.edk.keyProviderId == PROVIDER_ID && UTF8.ValidUTF8Seq(h.edk.keyProviderInfo) && UTF8.Decode(h.edk.keyProviderInfo).Success? && ParseAwsKmsArn(UTF8.Decode(h.edk.keyProviderInfo).value).Success? && h.arn == ParseAwsKmsArn(UTF8.Decode(h.edk.keyProviderInfo).value).value && h.edk == edk && h.arn.resource.resourceType == ""key"" && DiscoveryMatch(h.arn, discoveryFilter, region) else true && |res.value| == 0
    }

    method Invoke(edk: Types.EncryptedDataKey) returns (res: Result<seq<AwsKmsEdkHelper>, Types.Error>)
      ensures Ensures(edk, res)
      decreases edk
    {
      if edk.keyProviderId != PROVIDER_ID {
        return Success([]);
      }
      :- Need(UTF8.ValidUTF8Seq(edk.keyProviderInfo), Types.AwsCryptographicMaterialProvidersException(message := ""Invalid AWS KMS encoding, provider info is not UTF8.""));
      var keyId :- UTF8.Decode(edk.keyProviderInfo).MapFailure((e: string) => Types.AwsCryptographicMaterialProvidersException(message := e));
      var arn :- ParseAwsKmsArn(keyId).MapFailure((e: string) => Types.AwsCryptographicMaterialProvidersException(message := e));
      :- Need(arn.resource.resourceType == ""key"", Types.AwsCryptographicMaterialProvidersException(message := ""Only AWS KMS Keys supported""));
      if !DiscoveryMatch(arn, discoveryFilter, region) {
        return Success([]);
      }
      return Success([AwsKmsEdkHelper(edk, arn)]);
    }
  }

  class AwsKmsEncryptedDataKeyDecryptor extends ActionWithResult<AwsKmsEdkHelper, Materials.SealedDecryptionMaterials, Types.Error> {
    const materials: Materials.DecryptionMaterialsPendingPlaintextDataKey
    const client: KMS.IKMSClient
    const region: string
    const grantTokens: KMS.GrantTokenList

    constructor (materials: Materials.DecryptionMaterialsPendingPlaintextDataKey, client: KMS.IKMSClient, region: string, grantTokens: KMS.GrantTokenList)
      requires client.ValidState()
      ensures this.materials == materials && this.client == client && this.region == region && this.grantTokens == grantTokens
      ensures Invariant()
      decreases materials, client, region, grantTokens
    {
      this.materials := materials;
      this.client := client;
      this.region := region;
      this.grantTokens := grantTokens;
      Modifies := client.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      client.ValidState() &&
      client.Modifies == Modifies
    }

    predicate Ensures(helper: AwsKmsEdkHelper, res: Result<Materials.SealedDecryptionMaterials, Types.Error>, attempts: seq<ActionInvoke<AwsKmsEdkHelper, Result<Materials.SealedDecryptionMaterials, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      true &&
      res.Success? ==>
        Invariant() &&
        Materials.DecryptionMaterialsTransitionIsValid(materials, res.value) &&
        ghost var keyArn: string := ToStringForRegion(helper.arn, region); true && ghost var maybeProviderWrappedMaterial: Result<seq<uint8>, Types.Error> := EdkWrapping.GetProviderWrappedMaterial(helper.edk.ciphertext, materials.algorithmSuite); maybeProviderWrappedMaterial.Success? && ghost var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(materials.encryptionContext); KMS.IsValid_CiphertextType(maybeProviderWrappedMaterial.value) && KMS.IsValid_KeyIdType(keyArn) && maybeStringifiedEncCtx.Success? && 0 < |client.History.Decrypt| && KMS.DecryptRequest(KeyId := Some(keyArn), CiphertextBlob := maybeProviderWrappedMaterial.value, EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), EncryptionAlgorithm := None) == Seq.Last(client.History.Decrypt).input && Seq.Last(client.History.Decrypt).output.Success? && (materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> Seq.Last(client.History.Decrypt).output.value.Plaintext == res.value.plaintextDataKey) && Seq.Last(client.History.Decrypt).output.value.KeyId == Some(keyArn) && Seq.Last(client.History.Decrypt).output.value.Plaintext.Some? && (materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> Seq.Last(client.History.Decrypt).output.value.Plaintext == res.value.plaintextDataKey)
    }

    method Invoke(helper: AwsKmsEdkHelper, ghost attemptsState: seq<ActionInvoke<AwsKmsEdkHelper, Result<Materials.SealedDecryptionMaterials, Types.Error>>>) returns (res: Result<Materials.SealedDecryptionMaterials, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(helper, res, attemptsState)
      decreases Modifies
    {
      var awsKmsKey := ToStringForRegion(helper.arn, region);
      var _ /* _v0 */ :- ValidateKmsKeyId(awsKmsKey);
      var kmsUnwrap := new AwsKmsKeyring.KmsUnwrapKeyMaterial(client, awsKmsKey, grantTokens);
      var unwrapOutputRes := EdkWrapping.UnwrapEdkMaterial(helper.edk.ciphertext, materials, kmsUnwrap);
      var unwrapOutput :- unwrapOutputRes;
      res := Materials.DecryptionMaterialsAddDataKey(materials, unwrapOutput.plaintextDataKey, unwrapOutput.symmetricSigningKey);
    }
  }

  function method ToStringForRegion(arn: AwsKmsArn, region: string): (res: string)
    decreases arn, region
  {
    if IsMultiRegionAwsKmsArn(arn) then
      arn.ToArnString(Some(region))
    else
      arn.ToString()
  }

  function method DiscoveryMatch(arn: AwsKmsArn, discoveryFilter: Option<Types.DiscoveryFilter>, region: string): (res: bool)
    ensures discoveryFilter.Some? && res ==> discoveryFilter.value.partition == arn.partition && arn.account in discoveryFilter.value.accountIds
    ensures !IsMultiRegionAwsKmsArn(arn) && res ==> arn.region == region
    decreases arn, discoveryFilter, region
  {
    match discoveryFilter { case Some(filter) => filter.partition == arn.partition && arn.account in filter.accountIds case None() => true } &&
    if !IsMultiRegionAwsKmsArn(arn) then region == arn.region else true
  }

  lemma LemmaMultisetSubMembership<T>(a: seq<T>, b: seq<T>)
    requires multiset(a) <= multiset(b)
    ensures forall i: T {:trigger i in b} {:trigger i in a} | i in a :: i in b
    decreases a, b
  {
  }

  lemma /*{:_induction parts}*/ LemmaFlattenMembership<T>(parts: seq<seq<T>>, flat: seq<T>)
    requires Seq.Flatten(parts) == flat
    ensures forall index: int {:trigger parts[index]} | 0 <= index < |parts| :: multiset(parts[index]) <= multiset(flat)
    ensures multiset(Seq.Flatten(parts)) == multiset(flat)
    ensures forall part: seq<T> {:trigger part in parts} | part in parts :: forall i: T {:trigger i in flat} {:trigger i in part} | i in part :: i in flat
    ensures forall i: T {:trigger i in flat} | i in flat :: exists part: seq<T> {:trigger i in part} {:trigger part in parts} | part in parts :: i in part
    decreases parts, flat
  {
  }
}

module MrkAwareDiscoveryMultiKeyring {

  import opened Wrappers

  import Seq

  import Types = AwsCryptographyMaterialProvidersTypes

  import KMS = Types.ComAmazonawsKmsTypes

  import MultiKeyring

  import AwsArnParsing

  import AwsKmsMrkAreUnique

  import AwsKmsMrkDiscoveryKeyring

  import opened AwsKmsUtils
  method MrkAwareDiscoveryMultiKeyring(regions: seq<string>, discoveryFilter: Option<Types.DiscoveryFilter>, clientSupplier: Types.IClientSupplier, grantTokens: Option<KMS.GrantTokenList>)
      returns (output: Result<MultiKeyring.MultiKeyring, Types.Error>)
    requires clientSupplier.ValidState()
    modifies clientSupplier.Modifies
    ensures output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.History) && fresh(output.value.Modifies - clientSupplier.Modifies)
    ensures |regions| == 0 || (exists r: seq<char> {:trigger r in regions} | r in regions :: r == """") ==> output.Failure?
    ensures true && output.Success? ==> output.value.generatorKeyring.None? && |regions| == |output.value.childKeyrings| && forall i: int {:trigger regions[i]} {:trigger output.value.childKeyrings[i]} | 0 <= i < |regions| :: var k: Types.IKeyring := output.value.childKeyrings[i]; k is AwsKmsMrkDiscoveryKeyring.AwsKmsMrkDiscoveryKeyring && var c: AwsKmsMrkDiscoveryKeyring.AwsKmsMrkDiscoveryKeyring := k as AwsKmsMrkDiscoveryKeyring.AwsKmsMrkDiscoveryKeyring; c.region == regions[i] && (discoveryFilter.Some? ==> c.discoveryFilter == discoveryFilter) && (grantTokens.Some? ==> c.grantTokens == grantTokens.value)
    decreases regions, discoveryFilter, clientSupplier, grantTokens
  {
    :- Need(|regions| > 0, Types.AwsCryptographicMaterialProvidersException(message := ""No regions passed.""));
    :- Need(Seq.IndexOfOption(regions, """").None?, Types.AwsCryptographicMaterialProvidersException(message := ""Empty string is not a valid region.""));
    var children: seq<AwsKmsMrkDiscoveryKeyring.AwsKmsMrkDiscoveryKeyring> := [];
    for i: int := 0 to |regions|
      invariant |regions[..i]| == |children|
      invariant fresh(MultiKeyring.GatherModifies(None, children) - clientSupplier.Modifies)
      invariant forall i: int {:trigger regions[i]} {:trigger children[i]} | 0 <= i < |children| :: children[i].region == regions[i] && (discoveryFilter.Some? ==> children[i].discoveryFilter == discoveryFilter) && (grantTokens.Some? ==> children[i].grantTokens == grantTokens.value) && children[i].ValidState()
    {
      var region := regions[i];
      var client :- clientSupplier.GetClient(Types.GetClientInput(region := region));
      var keyring := new AwsKmsMrkDiscoveryKeyring.AwsKmsMrkDiscoveryKeyring(client, region, discoveryFilter, grantTokens.UnwrapOr([]));
      children := children + [keyring];
    }
    var keyring := new MultiKeyring.MultiKeyring(None(), children);
    return Success(keyring);
  }
}

module AwsKmsRsaKeyring {

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened Actions

  import UTF8

  import Primitives = Aws.Cryptography.Primitives

  import Crypto = AwsCryptographyPrimitivesTypes

  import Keyring

  import Materials

  import Types = AwsCryptographyMaterialProvidersTypes

  import KMS = ComAmazonawsKmsTypes

  import CanonicalEncryptionContext

  import AwsArnParsing

  import opened Constants

  import AlgorithmSuites

  import Seq

  import MaterialWrapping

  import EdkWrapping

  import AwsKmsUtils
  class AwsKmsRsaKeyring extends Keyring.VerifiableInterface {
    const client: Option<KMS.IKMSClient>
    const grantTokens: KMS.GrantTokenList
    const awsKmsKey: AwsArnParsing.AwsKmsIdentifierString
    const awsKmsArn: AwsArnParsing.AwsKmsIdentifier
    const paddingScheme: KMS.EncryptionAlgorithmSpec
    const publicKey: Option<seq<uint8>>
    const cryptoPrimitives: Primitives.AtomicPrimitivesClient

    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      cryptoPrimitives.Modifies <= Modifies &&
      History !in cryptoPrimitives.Modifies &&
      cryptoPrimitives.ValidState() &&
      (client.Some? ==>
        client.value.ValidState() &&
        client.value.Modifies <= Modifies &&
        History !in client.value.Modifies) &&
      (paddingScheme.RSAES_OAEP_SHA_1? || paddingScheme.RSAES_OAEP_SHA_256?) &&
      UTF8.Encode(awsKmsKey).Success? &&
      (publicKey.Some? ==>
        ValidRSAKeyLength(publicKey.value))
    }

    predicate ValidRSAKeyLength(publicKey: seq<uint8>)
      decreases publicKey
    {
      ghost var rsaKeyLengthRes: Result<GetRSAKeyModulusLengthOutput, Error> := cryptoPrimitives.GetRSAKeyModulusLength(Crypto.GetRSAKeyModulusLengthInput(publicKey := publicKey));
      rsaKeyLengthRes.Success? &&
      rsaKeyLengthRes.value.length >= MIN_KMS_RSA_KEY_LEN
    }

    constructor (publicKey: Option<seq<uint8>>, awsKmsKey: AwsArnParsing.AwsKmsIdentifierString, paddingScheme: KMS.EncryptionAlgorithmSpec, client: Option<KMS.IKMSClient>, cryptoPrimitives: Primitives.AtomicPrimitivesClient, grantTokens: KMS.GrantTokenList)
      requires cryptoPrimitives.ValidState()
      requires client.Some? ==> client.value.ValidState()
      requires publicKey.Some? ==> true && var rsaKeyLengthRes: Result<GetRSAKeyModulusLengthOutput, Error> := cryptoPrimitives.GetRSAKeyModulusLength(Crypto.GetRSAKeyModulusLengthInput(publicKey := publicKey.value)); rsaKeyLengthRes.Success? && rsaKeyLengthRes.value.length >= MIN_KMS_RSA_KEY_LEN
      requires paddingScheme.RSAES_OAEP_SHA_1? || paddingScheme.RSAES_OAEP_SHA_256?
      ensures ValidState() && fresh(this) && fresh(History) && fresh(Modifies - (if client.Some? then client.value.Modifies else {}) - cryptoPrimitives.Modifies)
      decreases publicKey, awsKmsKey, paddingScheme, client, cryptoPrimitives, grantTokens
    {
      History := new Types.IKeyringCallHistory();
      Modifies := {History};
      if client.Some? {
        Modifies := Modifies + client.value.Modifies;
      }
      Modifies := Modifies + cryptoPrimitives.Modifies;
      var parsedAwsKmsId := AwsArnParsing.ParseAwsKmsIdentifier(awsKmsKey);
      this.publicKey := publicKey;
      this.awsKmsKey := awsKmsKey;
      this.awsKmsArn := parsedAwsKmsId.value;
      this.paddingScheme := paddingScheme;
      this.client := client;
      this.cryptoPrimitives := cryptoPrimitives;
      this.grantTokens := grantTokens;
    }

    predicate OnEncryptEnsuresPublicly(input: Types.OnEncryptInput, output: Result<Types.OnEncryptOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method OnEncrypt'(input: Types.OnEncryptInput) returns (res: Result<Types.OnEncryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnEncryptEnsuresPublicly(input, res)
      ensures unchanged(History)
      ensures res.Success? ==> true && Materials.ValidEncryptionMaterialsTransition(input.materials, res.value.materials)
      ensures publicKey.None? || |publicKey.Extract()| == 0 ==> res.Failure?
      ensures !input.materials.algorithmSuite.signature.None? ==> res.Failure?
      decreases Modifies - {History}
    {
      :- Need(this.publicKey.Some? && |this.publicKey.Extract()| > 0, Types.AwsCryptographicMaterialProvidersException(message := ""A AwsKmsRsaKeyring without a public key cannot provide OnEncrypt""));
      :- Need(input.materials.algorithmSuite.signature.None?, Types.AwsCryptographicMaterialProvidersException(message := ""AwsKmsRsaKeyring cannot be used with an Algorithm Suite with asymmetric signing."" + "" Please specify an algorithm suite without asymmetric signing.""));
      var wrap := new KmsRsaWrapKeyMaterial(publicKey.value, paddingScheme, cryptoPrimitives);
      var generateAndWrap := new KmsRsaGenerateAndWrapKeyMaterial(publicKey.value, paddingScheme, cryptoPrimitives);
      var wrapOutput :- EdkWrapping.WrapEdkMaterial<KmsRsaWrapInfo>(encryptionMaterials := input.materials, wrap := wrap, generateAndWrap := generateAndWrap);
      var symmetricSigningKeyList := if wrapOutput.symmetricSigningKey.Some? then Some([wrapOutput.symmetricSigningKey.value]) else None;
      var edk: Types.EncryptedDataKey := Types.EncryptedDataKey(keyProviderId := RSA_PROVIDER_ID, keyProviderInfo := UTF8.Encode(awsKmsKey).value, ciphertext := wrapOutput.wrappedMaterial);
      var returnMaterials;
      if wrapOutput.GenerateAndWrapEdkMaterialOutput? {
        returnMaterials :- Materials.EncryptionMaterialAddDataKey(input.materials, wrapOutput.plaintextDataKey, [edk], symmetricSigningKeyList);
      } else if wrapOutput.WrapOnlyEdkMaterialOutput? {
        returnMaterials :- Materials.EncryptionMaterialAddEncryptedDataKeys(input.materials, [edk], symmetricSigningKeyList);
      }
      return Success(Types.OnEncryptOutput(materials := returnMaterials));
    }

    predicate OnDecryptEnsuresPublicly(input: Types.OnDecryptInput, output: Result<Types.OnDecryptOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method OnDecrypt'(input: Types.OnDecryptInput) returns (res: Result<Types.OnDecryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnDecryptEnsuresPublicly(input, res)
      ensures unchanged(History)
      ensures res.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, res.value.materials)
      ensures client.None? ==> res.Failure?
      ensures !input.materials.algorithmSuite.signature.None? ==> res.Failure?
      decreases Modifies - {History}
    {
      :- Need(client.Some?, Types.AwsCryptographicMaterialProvidersException(message := ""An AwsKmsRsaKeyring without an AWS KMS client cannot provide OnDecrypt""));
      var materials := input.materials;
      :- Need(Materials.DecryptionMaterialsWithoutPlaintextDataKey(materials), Types.AwsCryptographicMaterialProvidersException(message := ""Keyring received decryption materials that already contain a plaintext data key.""));
      :- Need(input.materials.algorithmSuite.signature.None?, Types.AwsCryptographicMaterialProvidersException(message := ""AwsKmsRsaKeyring cannot be used with an Algorithm Suite with asymmetric signing."" + "" Please specify an algorithm suite without asymmetric signing.""));
      var filter := new AwsKmsUtils.OnDecryptMrkAwareEncryptedDataKeyFilter(awsKmsArn, RSA_PROVIDER_ID);
      var edksToAttempt :- FilterWithResult(filter, input.encryptedDataKeys);
      :- Need(0 < |edksToAttempt|, Types.AwsCryptographicMaterialProvidersException(message := ""Unable to decrypt data key: No Encrypted Data Keys found to match.""));
      var encryptionContextDigest :- EncryptionContextDigest(cryptoPrimitives, materials.encryptionContext);
      var decryptClosure := new DecryptSingleAWSRSAEncryptedDataKey(materials, client.value, awsKmsKey, paddingScheme, encryptionContextDigest, grantTokens);
      var outcome, attempts := ReduceToSuccess(decryptClosure, edksToAttempt);
      var SealedDecryptionMaterials :- outcome.MapFailure((errors: seq<Types.Error>) => Types.CollectionOfErrors(list := errors, message := ""No Configured KMS Key was able to decrypt the Data Key. The list of encountered Exceptions is available via `list`.""));
      assert decryptClosure.Ensures(Seq.Last(attempts).input, Success(SealedDecryptionMaterials), Seq.DropLast(attempts));
      return Success(Types.OnDecryptOutput(materials := SealedDecryptionMaterials));
    }
  }

  class DecryptSingleAWSRSAEncryptedDataKey extends ActionWithResult<Types.EncryptedDataKey, Materials.SealedDecryptionMaterials, Types.Error> {
    const materials: Materials.DecryptionMaterialsPendingPlaintextDataKey
    const client: KMS.IKMSClient
    const awsKmsKey: AwsArnParsing.AwsKmsIdentifierString
    const paddingScheme: KMS.EncryptionAlgorithmSpec
    const encryptionContextDigest: seq<uint8>
    const grantTokens: KMS.GrantTokenList

    constructor (materials: Materials.DecryptionMaterialsPendingPlaintextDataKey, client: KMS.IKMSClient, awsKmsKey: AwsArnParsing.AwsKmsIdentifierString, paddingScheme: KMS.EncryptionAlgorithmSpec, encryptionContextDigest: seq<uint8>, grantTokens: KMS.GrantTokenList)
      requires client.ValidState()
      ensures this.materials == materials && this.client == client && this.awsKmsKey == awsKmsKey && this.paddingScheme == paddingScheme && this.encryptionContextDigest == encryptionContextDigest && this.grantTokens == grantTokens
      ensures Invariant()
      decreases materials, client, awsKmsKey, paddingScheme, encryptionContextDigest, grantTokens
    {
      this.materials := materials;
      this.client := client;
      this.awsKmsKey := awsKmsKey;
      this.paddingScheme := paddingScheme;
      this.encryptionContextDigest := encryptionContextDigest;
      this.grantTokens := grantTokens;
      Modifies := client.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      client.ValidState() &&
      client.Modifies == Modifies
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<Materials.SealedDecryptionMaterials, Types.Error>, attemptsState: seq<ActionInvoke<Types.EncryptedDataKey, Result<Materials.SealedDecryptionMaterials, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        Invariant() &&
        ghost var maybeWrappedMaterial: Result<seq<uint8>, Types.Error> := EdkWrapping.GetProviderWrappedMaterial(edk.ciphertext, materials.algorithmSuite); maybeWrappedMaterial.Success? && KMS.IsValid_CiphertextType(maybeWrappedMaterial.value) && Materials.DecryptionMaterialsTransitionIsValid(materials, res.value) && 0 < |client.History.Decrypt| && KMS.DecryptRequest(KeyId := Some(awsKmsKey), CiphertextBlob := maybeWrappedMaterial.value, EncryptionContext := None, GrantTokens := Some(grantTokens), EncryptionAlgorithm := Some(paddingScheme)) == Seq.Last(client.History.Decrypt).input && Seq.Last(client.History.Decrypt).output.Success? && Seq.Last(client.History.Decrypt).output.value.Plaintext.Some? && (materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> Seq.Last(client.History.Decrypt).output.value.Plaintext.value == encryptionContextDigest + res.value.plaintextDataKey.value) && Seq.Last(client.History.Decrypt).output.value.KeyId == Some(awsKmsKey)
    }

    method Invoke(edk: Types.EncryptedDataKey, ghost attemptsState: seq<ActionInvoke<Types.EncryptedDataKey, Result<Materials.SealedDecryptionMaterials, Types.Error>>>) returns (res: Result<Materials.SealedDecryptionMaterials, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(edk, res, attemptsState)
      decreases Modifies
    {
      var unwrap := new KmsRsaUnwrapKeyMaterial(client, awsKmsKey, paddingScheme, encryptionContextDigest, grantTokens);
      var unwrapOutput :- EdkWrapping.UnwrapEdkMaterial(edk.ciphertext, materials, unwrap);
      var result :- Materials.DecryptionMaterialsAddDataKey(materials, unwrapOutput.plaintextDataKey, unwrapOutput.symmetricSigningKey);
      return Success(result);
    }
  }

  datatype KmsRsaUnwrapInfo = KmsRsaUnwrapInfo

  datatype KmsRsaWrapInfo = KmsRsaWrapInfo

  class KmsRsaGenerateAndWrapKeyMaterial extends MaterialWrapping.GenerateAndWrapMaterial<KmsRsaWrapInfo> {
    const publicKey: seq<uint8>
    const paddingScheme: KMS.EncryptionAlgorithmSpec
    const cryptoPrimitives: Primitives.AtomicPrimitivesClient

    constructor (publicKey: seq<uint8>, paddingScheme: KMS.EncryptionAlgorithmSpec, cryptoPrimitives: Primitives.AtomicPrimitivesClient)
      requires cryptoPrimitives.ValidState()
      requires paddingScheme.RSAES_OAEP_SHA_1? || paddingScheme.RSAES_OAEP_SHA_256?
      ensures this.publicKey == publicKey && this.cryptoPrimitives == cryptoPrimitives && this.paddingScheme == paddingScheme
      ensures Invariant()
      decreases publicKey, paddingScheme, cryptoPrimitives
    {
      this.publicKey := publicKey;
      this.cryptoPrimitives := cryptoPrimitives;
      this.paddingScheme := paddingScheme;
      Modifies := cryptoPrimitives.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      cryptoPrimitives.ValidState() &&
      Modifies == cryptoPrimitives.Modifies &&
      (paddingScheme.RSAES_OAEP_SHA_1? || paddingScheme.RSAES_OAEP_SHA_256?)
    }

    predicate Ensures(input: MaterialWrapping.GenerateAndWrapInput, res: Result<MaterialWrapping.GenerateAndWrapOutput<KmsRsaWrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.GenerateAndWrapInput, Result<MaterialWrapping.GenerateAndWrapOutput<KmsRsaWrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      true
    }

    method Invoke(input: MaterialWrapping.GenerateAndWrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.GenerateAndWrapInput, Result<MaterialWrapping.GenerateAndWrapOutput<KmsRsaWrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.GenerateAndWrapOutput<KmsRsaWrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      ensures res.Success? ==> |res.value.plaintextMaterial| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat
      decreases Modifies
    {
      var generateBytesResult := cryptoPrimitives.GenerateRandomBytes(Crypto.GenerateRandomBytesInput(length := AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite)));
      var plaintextMaterial :- generateBytesResult.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      var wrap := new KmsRsaWrapKeyMaterial(publicKey, paddingScheme, cryptoPrimitives);
      var wrapOutput: MaterialWrapping.WrapOutput<KmsRsaWrapInfo> :- wrap.Invoke(MaterialWrapping.WrapInput(plaintextMaterial := plaintextMaterial, algorithmSuite := input.algorithmSuite, encryptionContext := input.encryptionContext), []);
      var output := MaterialWrapping.GenerateAndWrapOutput(plaintextMaterial := plaintextMaterial, wrappedMaterial := wrapOutput.wrappedMaterial, wrapInfo := KmsRsaWrapInfo());
      return Success(output);
    }
  }

  class KmsRsaWrapKeyMaterial extends MaterialWrapping.WrapMaterial<KmsRsaWrapInfo> {
    const publicKey: seq<uint8>
    const paddingScheme: KMS.EncryptionAlgorithmSpec
    const cryptoPrimitives: Primitives.AtomicPrimitivesClient

    constructor (publicKey: seq<uint8>, paddingScheme: KMS.EncryptionAlgorithmSpec, cryptoPrimitives: Primitives.AtomicPrimitivesClient)
      requires cryptoPrimitives.ValidState()
      requires paddingScheme.RSAES_OAEP_SHA_1? || paddingScheme.RSAES_OAEP_SHA_256?
      ensures this.publicKey == publicKey && this.cryptoPrimitives == cryptoPrimitives && this.paddingScheme == paddingScheme
      ensures Invariant()
      decreases publicKey, paddingScheme, cryptoPrimitives
    {
      this.publicKey := publicKey;
      this.cryptoPrimitives := cryptoPrimitives;
      this.paddingScheme := paddingScheme;
      Modifies := cryptoPrimitives.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      cryptoPrimitives.ValidState() &&
      Modifies == cryptoPrimitives.Modifies &&
      (paddingScheme.RSAES_OAEP_SHA_1? || paddingScheme.RSAES_OAEP_SHA_256?)
    }

    predicate Ensures(input: MaterialWrapping.WrapInput, res: Result<MaterialWrapping.WrapOutput<KmsRsaWrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.WrapInput, Result<MaterialWrapping.WrapOutput<KmsRsaWrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      true
    }

    method Invoke(input: MaterialWrapping.WrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.WrapInput, Result<MaterialWrapping.WrapOutput<KmsRsaWrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.WrapOutput<KmsRsaWrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      decreases Modifies
    {
      var encryptionContextDigest :- EncryptionContextDigest(cryptoPrimitives, input.encryptionContext);
      var padding := match paddingScheme case RSAES_OAEP_SHA_1() => Crypto.OAEP_SHA1 case RSAES_OAEP_SHA_256() => Crypto.OAEP_SHA256;
      var RSAEncryptOutput := cryptoPrimitives.RSAEncrypt(Crypto.RSAEncryptInput(padding := padding, publicKey := publicKey, plaintext := encryptionContextDigest + input.plaintextMaterial));
      var ciphertext :- RSAEncryptOutput.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
      var output := MaterialWrapping.WrapOutput(wrappedMaterial := ciphertext, wrapInfo := KmsRsaWrapInfo());
      return Success(output);
    }
  }

  class KmsRsaUnwrapKeyMaterial extends MaterialWrapping.UnwrapMaterial<KmsRsaUnwrapInfo> {
    const client: KMS.IKMSClient
    const awsKmsKey: AwsArnParsing.AwsKmsIdentifierString
    const paddingScheme: KMS.EncryptionAlgorithmSpec
    const encryptionContextDigest: seq<uint8>
    const grantTokens: KMS.GrantTokenList

    constructor (client: KMS.IKMSClient, awsKmsKey: AwsArnParsing.AwsKmsIdentifierString, paddingScheme: KMS.EncryptionAlgorithmSpec, encryptionContextDigest: seq<uint8>, grantTokens: KMS.GrantTokenList)
      requires client.ValidState()
      ensures this.client == client && this.awsKmsKey == awsKmsKey && this.paddingScheme == paddingScheme && this.encryptionContextDigest == encryptionContextDigest && this.grantTokens == grantTokens
      ensures Invariant()
      decreases client, awsKmsKey, paddingScheme, encryptionContextDigest, grantTokens
    {
      this.client := client;
      this.awsKmsKey := awsKmsKey;
      this.paddingScheme := paddingScheme;
      this.encryptionContextDigest := encryptionContextDigest;
      this.grantTokens := grantTokens;
      Modifies := client.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      client.ValidState() &&
      client.Modifies == Modifies
    }

    predicate Ensures(input: MaterialWrapping.UnwrapInput, res: Result<MaterialWrapping.UnwrapOutput<KmsRsaUnwrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.UnwrapInput, Result<MaterialWrapping.UnwrapOutput<KmsRsaUnwrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        Invariant() &&
        KMS.IsValid_CiphertextType(input.wrappedMaterial) &&
        0 < |client.History.Decrypt| &&
        KMS.DecryptRequest(KeyId := Some(awsKmsKey), CiphertextBlob := input.wrappedMaterial, EncryptionContext := None, GrantTokens := Some(grantTokens), EncryptionAlgorithm := Some(paddingScheme)) == Seq.Last(client.History.Decrypt).input &&
        Seq.Last(client.History.Decrypt).output.Success? &&
        Seq.Last(client.History.Decrypt).output.value.Plaintext.Some? &&
        Seq.Last(client.History.Decrypt).output.value.Plaintext.value == encryptionContextDigest + res.value.unwrappedMaterial &&
        Seq.Last(client.History.Decrypt).output.value.KeyId == Some(awsKmsKey)
    }

    method Invoke(input: MaterialWrapping.UnwrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.UnwrapInput, Result<MaterialWrapping.UnwrapOutput<KmsRsaUnwrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.UnwrapOutput<KmsRsaUnwrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      ensures res.Success? ==> |res.value.unwrappedMaterial| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat
      decreases Modifies
    {
      :- Need(KMS.IsValid_CiphertextType(input.wrappedMaterial), Types.AwsCryptographicMaterialProvidersException(message := ""Ciphertext length invalid""));
      var decryptRequest := KMS.DecryptRequest(KeyId := Some(awsKmsKey), CiphertextBlob := input.wrappedMaterial, EncryptionContext := None, GrantTokens := Some(grantTokens), EncryptionAlgorithm := Some(paddingScheme));
      var maybeDecryptResponse := client.Decrypt(decryptRequest);
      var decryptResponse :- maybeDecryptResponse.MapFailure((e: Error) => Types.ComAmazonawsKms(ComAmazonawsKms := e));
      :- Need(decryptResponse.KeyId.Some? && decryptResponse.KeyId.value == awsKmsKey && decryptResponse.Plaintext.Some?, Types.AwsCryptographicMaterialProvidersException(message := ""Invalid response from KMS Decrypt""));
      :- Need(encryptionContextDigest <= decryptResponse.Plaintext.value && AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat + |encryptionContextDigest| == |decryptResponse.Plaintext.value|, Types.AwsCryptographicMaterialProvidersException(message := ""Encryption context digest does not match expected value.""));
      var output := MaterialWrapping.UnwrapOutput(unwrappedMaterial := decryptResponse.Plaintext.value[|encryptionContextDigest|..], unwrapInfo := KmsRsaUnwrapInfo());
      return Success(output);
    }
  }

  const MIN_KMS_RSA_KEY_LEN: Crypto.RSAModulusLengthBits := 2048

  method EncryptionContextDigest(cryptoPrimitives: Primitives.AtomicPrimitivesClient, encryptionContext: Types.EncryptionContext) returns (output: Result<seq<uint8>, Types.Error>)
    requires cryptoPrimitives.ValidState()
    modifies cryptoPrimitives.Modifies
    ensures cryptoPrimitives.ValidState()
    decreases cryptoPrimitives, encryptionContext
  {
    var canonicalEC :- CanonicalEncryptionContext.EncryptionContextToAAD(encryptionContext);
    var DigestInput := Crypto.DigestInput(digestAlgorithm := Crypto.SHA_384, message := canonicalEC);
    var maybeDigest := cryptoPrimitives.Digest(DigestInput);
    var digest :- maybeDigest.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
    return Success(digest);
  }
}

module RawAESKeyring {

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened String = StandardLibrary.String

  import opened Actions

  import opened Wrappers

  import Types = AwsCryptographyMaterialProvidersTypes

  import Crypto = AwsCryptographyPrimitivesTypes

  import Keyring

  import Materials

  import CanonicalEncryptionContext

  import opened AlgorithmSuites

  import UTF8

  import Seq

  import MaterialWrapping

  import EdkWrapping

  import Primitives = Aws.Cryptography.Primitives
  class RawAESKeyring extends Keyring.VerifiableInterface, Types.IKeyring {
    const cryptoPrimitives: Primitives.AtomicPrimitivesClient

    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      cryptoPrimitives.Modifies <= Modifies &&
      History !in cryptoPrimitives.Modifies &&
      cryptoPrimitives.ValidState() &&
      |wrappingKey| == wrappingAlgorithm.keyLength as nat
    }

    const keyNamespace: UTF8.ValidUTF8Bytes
    const keyName: UTF8.ValidUTF8Bytes
    const wrappingKey: seq<uint8>
    const wrappingAlgorithm: Crypto.AES_GCM

    constructor (namespace: UTF8.ValidUTF8Bytes, name: UTF8.ValidUTF8Bytes, key: seq<uint8>, wrappingAlgorithm: Crypto.AES_GCM, cryptoPrimitives: Primitives.AtomicPrimitivesClient)
      requires |namespace| < UINT16_LIMIT
      requires |name| < UINT16_LIMIT
      requires |key| == 16 || |key| == 24 || |key| == 32
      requires |key| == wrappingAlgorithm.keyLength as int
      requires cryptoPrimitives.ValidState()
      ensures keyNamespace == namespace
      ensures keyName == name
      ensures wrappingKey == key
      ensures this.wrappingAlgorithm == wrappingAlgorithm
      ensures this.cryptoPrimitives == cryptoPrimitives
      ensures ValidState() && fresh(History) && fresh(Modifies - cryptoPrimitives.Modifies)
      decreases namespace, name, key, wrappingAlgorithm, cryptoPrimitives
    {
      keyNamespace := namespace;
      keyName := name;
      wrappingKey := key;
      this.wrappingAlgorithm := wrappingAlgorithm;
      this.cryptoPrimitives := cryptoPrimitives;
      History := new Types.IKeyringCallHistory();
      Modifies := {History} + cryptoPrimitives.Modifies;
    }

    predicate OnEncryptEnsuresPublicly(input: Types.OnEncryptInput, output: Result<Types.OnEncryptOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method {:vcs_split_on_every_assert} OnEncrypt'(input: Types.OnEncryptInput) returns (output: Result<Types.OnEncryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnEncryptEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures output.Success? ==> true && Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
      ensures output.Success? ==> CanonicalEncryptionContext.EncryptionContextToAAD(input.materials.encryptionContext).Success? && 1 <= |cryptoPrimitives.History.GenerateRandomBytes| && Seq.Last(cryptoPrimitives.History.GenerateRandomBytes).output.Success?
      ensures output.Success? ==> true && var iv: seq<uint8> := Seq.Last(cryptoPrimitives.History.GenerateRandomBytes).output.value; |iv| == wrappingAlgorithm.ivLength as nat && 1 <= |cryptoPrimitives.History.AESEncrypt| && var AESEncryptInput: AESEncryptInput := Seq.Last(cryptoPrimitives.History.AESEncrypt).input; AESEncryptInput.encAlg == wrappingAlgorithm && AESEncryptInput.key == wrappingKey && AESEncryptInput.iv == iv && AESEncryptInput.aad == CanonicalEncryptionContext.EncryptionContextToAAD(input.materials.encryptionContext).value && |output.value.materials.encryptedDataKeys| == |input.materials.encryptedDataKeys| + 1 && var edk: EncryptedDataKey := Seq.Last(output.value.materials.encryptedDataKeys); Seq.Last(cryptoPrimitives.History.AESEncrypt).output.Success? && var AESEncryptOutput: AESEncryptOutput := Seq.Last(cryptoPrimitives.History.AESEncrypt).output.value; true && edk.keyProviderInfo == SerializeProviderInfo(iv)
      ensures CanonicalEncryptionContext.EncryptionContextToAAD(input.materials.encryptionContext).Failure? ==> output.Failure?
      decreases Modifies - {History}
    {
      var materials := input.materials;
      var suite := materials.algorithmSuite;
      var wrap := new AesWrapKeyMaterial(wrappingKey, wrappingAlgorithm, cryptoPrimitives);
      var generateAndWrap := new AesGenerateAndWrapKeyMaterial(wrap);
      var wrapOutput :- EdkWrapping.WrapEdkMaterial<AesWrapInfo>(encryptionMaterials := materials, wrap := wrap, generateAndWrap := generateAndWrap);
      var symmetricSigningKeyList := if wrapOutput.symmetricSigningKey.Some? then Some([wrapOutput.symmetricSigningKey.value]) else None;
      var edk: Types.EncryptedDataKey := Types.EncryptedDataKey(keyProviderId := keyNamespace, keyProviderInfo := SerializeProviderInfo(wrapOutput.wrapInfo.iv), ciphertext := wrapOutput.wrappedMaterial);
      if wrapOutput.GenerateAndWrapEdkMaterialOutput? {
        var result :- Materials.EncryptionMaterialAddDataKey(materials, wrapOutput.plaintextDataKey, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      } else if wrapOutput.WrapOnlyEdkMaterialOutput? {
        var result :- Materials.EncryptionMaterialAddEncryptedDataKeys(materials, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      }
    }

    predicate OnDecryptEnsuresPublicly(input: Types.OnDecryptInput, output: Result<Types.OnDecryptOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method {:vcs_split_on_every_assert} OnDecrypt'(input: Types.OnDecryptInput) returns (output: Result<Types.OnDecryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnDecryptEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures output.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
      ensures true && output.Success? ==> CanonicalEncryptionContext.EncryptionContextToAAD(input.materials.encryptionContext).Success? && input.materials.plaintextDataKey.None? && output.value.materials.plaintextDataKey.Some? && 0 < |cryptoPrimitives.History.AESDecrypt| && Seq.Last(cryptoPrimitives.History.AESDecrypt).output.Success? && var AESDecryptRequest: AESDecryptInput := Seq.Last(cryptoPrimitives.History.AESDecrypt).input; AESDecryptRequest.encAlg == wrappingAlgorithm && AESDecryptRequest.key == wrappingKey && (exists edk: EncryptedDataKey {:trigger edk.ciphertext} {:trigger edk.keyProviderInfo} {:trigger edk in input.encryptedDataKeys} | edk in input.encryptedDataKeys :: ValidProviderInfo(edk.keyProviderInfo) && wrappingAlgorithm.tagLength as nat <= |edk.ciphertext| && AESDecryptRequest.iv == GetIvFromProvInfo(edk.keyProviderInfo)) && AESDecryptRequest.aad == CanonicalEncryptionContext.EncryptionContextToAAD(input.materials.encryptionContext).value
      ensures CanonicalEncryptionContext.EncryptionContextToAAD(input.materials.encryptionContext).Failure? ==> output.Failure?
      decreases Modifies - {History}
    {
      var materials := input.materials;
      :- Need(Materials.DecryptionMaterialsWithoutPlaintextDataKey(materials), Types.AwsCryptographicMaterialProvidersException(message := ""Keyring received decryption materials that already contain a plaintext data key.""));
      var aad :- CanonicalEncryptionContext.EncryptionContextToAAD(input.materials.encryptionContext);
      :- Need(|wrappingKey| == wrappingAlgorithm.keyLength as int, Types.AwsCryptographicMaterialProvidersException(message := ""The wrapping key does not match the wrapping algorithm""));
      var errors: seq<Types.Error> := [];
      for i: int := 0 to |input.encryptedDataKeys|
        invariant |errors| == i
        invariant unchanged(History)
      {
        if ShouldDecryptEDK(input.encryptedDataKeys[i]) {
          var edk := input.encryptedDataKeys[i];
          var iv := GetIvFromProvInfo(edk.keyProviderInfo);
          var unwrap := new AesUnwrapKeyMaterial(wrappingKey, wrappingAlgorithm, iv, cryptoPrimitives);
          var unwrapOutput := EdkWrapping.UnwrapEdkMaterial(edk.ciphertext, materials, unwrap);
          if unwrapOutput.Success? {
            var result :- Materials.DecryptionMaterialsAddDataKey(materials, unwrapOutput.value.plaintextDataKey, unwrapOutput.value.symmetricSigningKey);
            var value := Types.OnDecryptOutput(materials := result);
            return Success(value);
          } else {
            errors := errors + [unwrapOutput.error];
          }
        } else {
          errors := errors + [Types.AwsCryptographicMaterialProvidersException(message := ""EncrypedDataKey "" + Base10Int2String(i) + "" did not match AESKeyring. "")];
        }
      }
      return Failure(Types.CollectionOfErrors(list := errors, message := ""Raw AES Keyring was unable to decrypt any encrypted data key. The list of encountered Exceptions is avaible via `list`.""));
    }

    function method SerializeProviderInfo(iv: seq<uint8>): seq<uint8>
      requires |iv| == wrappingAlgorithm.ivLength as int
      decreases iv
    {
      keyName + UInt32ToSeq((wrappingAlgorithm.tagLength * 8) as uint32) + UInt32ToSeq(wrappingAlgorithm.ivLength as uint32) + iv
    }

    predicate method ShouldDecryptEDK(edk: Types.EncryptedDataKey)
      decreases edk
    {
      edk.keyProviderId == keyNamespace &&
      ValidProviderInfo(edk.keyProviderInfo)
    }

    predicate method ValidProviderInfo(info: seq<uint8>)
      decreases info
    {
      |info| == |keyName| + AUTH_TAG_LEN_LEN + IV_LEN_LEN + wrappingAlgorithm.ivLength as int &&
      info[0 .. |keyName|] == keyName &&
      SeqToUInt32(info[|keyName| .. |keyName| + AUTH_TAG_LEN_LEN]) == 128 &&
      SeqToUInt32(info[|keyName| .. |keyName| + AUTH_TAG_LEN_LEN]) == wrappingAlgorithm.tagLength as uint32 * 8 &&
      SeqToUInt32(info[|keyName| + AUTH_TAG_LEN_LEN .. |keyName| + AUTH_TAG_LEN_LEN + IV_LEN_LEN]) == wrappingAlgorithm.ivLength as uint32 &&
      SeqToUInt32(info[|keyName| + AUTH_TAG_LEN_LEN .. |keyName| + AUTH_TAG_LEN_LEN + IV_LEN_LEN]) == 12
    }

    function method GetIvFromProvInfo(info: seq<uint8>): seq<uint8>
      requires ValidProviderInfo(info)
      decreases info
    {
      info[|keyName| + AUTH_TAG_LEN_LEN + IV_LEN_LEN..]
    }
  }

  datatype AesUnwrapInfo = AesUnwrapInfo

  datatype AesWrapInfo = AesWrapInfo(iv: seq<uint8>)

  class AesGenerateAndWrapKeyMaterial extends MaterialWrapping.GenerateAndWrapMaterial<AesWrapInfo> {
    const wrap: AesWrapKeyMaterial

    constructor (wrap: AesWrapKeyMaterial)
      requires wrap.Invariant()
      ensures this.wrap == wrap
      ensures Invariant()
      decreases wrap
    {
      this.wrap := wrap;
      Modifies := wrap.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      Modifies == wrap.Modifies &&
      wrap.Invariant()
    }

    predicate Ensures(input: MaterialWrapping.GenerateAndWrapInput, res: Result<MaterialWrapping.GenerateAndWrapOutput<AesWrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.GenerateAndWrapInput, Result<MaterialWrapping.GenerateAndWrapOutput<AesWrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        Invariant() &&
        2 <= |wrap.cryptoPrimitives.History.GenerateRandomBytes| &&
        Seq.Last(Seq.DropLast(wrap.cryptoPrimitives.History.GenerateRandomBytes)).output.Success? &&
        ghost var plaintextMaterial: seq<uint8> := Seq.Last(Seq.DropLast(wrap.cryptoPrimitives.History.GenerateRandomBytes)).output.value; res.value.plaintextMaterial == plaintextMaterial && wrap.Ensures(MaterialWrapping.WrapInput(plaintextMaterial := plaintextMaterial, algorithmSuite := input.algorithmSuite, encryptionContext := input.encryptionContext), Success(MaterialWrapping.WrapOutput(wrappedMaterial := res.value.wrappedMaterial, wrapInfo := res.value.wrapInfo)), []) && |res.value.plaintextMaterial| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat
    }

    method Invoke(input: MaterialWrapping.GenerateAndWrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.GenerateAndWrapInput, Result<MaterialWrapping.GenerateAndWrapOutput<AesWrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.GenerateAndWrapOutput<AesWrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      decreases Modifies
    {
      var generateBytesResult := wrap.cryptoPrimitives.GenerateRandomBytes(Crypto.GenerateRandomBytesInput(length := AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite)));
      var plaintextMaterial :- generateBytesResult.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      ghost var oldGenerateRandomBytes := wrap.cryptoPrimitives.History.GenerateRandomBytes;
      var wrapOutput: MaterialWrapping.WrapOutput<AesWrapInfo> :- wrap.Invoke(MaterialWrapping.WrapInput(plaintextMaterial := plaintextMaterial, algorithmSuite := input.algorithmSuite, encryptionContext := input.encryptionContext), []);
      res := Success(MaterialWrapping.GenerateAndWrapOutput(plaintextMaterial := plaintextMaterial, wrappedMaterial := wrapOutput.wrappedMaterial, wrapInfo := wrapOutput.wrapInfo));
      wrap.cryptoPrimitives.History.GenerateRandomBytes := oldGenerateRandomBytes + [Seq.Last(wrap.cryptoPrimitives.History.GenerateRandomBytes)];
    }
  }

  class AesWrapKeyMaterial extends MaterialWrapping.WrapMaterial<AesWrapInfo> {
    const wrappingKey: seq<uint8>
    const wrappingAlgorithm: Crypto.AES_GCM
    const cryptoPrimitives: Primitives.AtomicPrimitivesClient

    constructor (wrappingKey: seq<uint8>, wrappingAlgorithm: Crypto.AES_GCM, cryptoPrimitives: Primitives.AtomicPrimitivesClient)
      requires cryptoPrimitives.ValidState()
      ensures this.wrappingKey == wrappingKey && this.wrappingAlgorithm == wrappingAlgorithm && this.cryptoPrimitives == cryptoPrimitives
      ensures Invariant()
      decreases wrappingKey, wrappingAlgorithm, cryptoPrimitives
    {
      this.wrappingKey := wrappingKey;
      this.wrappingAlgorithm := wrappingAlgorithm;
      this.cryptoPrimitives := cryptoPrimitives;
      Modifies := cryptoPrimitives.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      cryptoPrimitives.ValidState() &&
      Modifies == cryptoPrimitives.Modifies
    }

    predicate Ensures(input: MaterialWrapping.WrapInput, res: Result<MaterialWrapping.WrapOutput<AesWrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.WrapInput, Result<MaterialWrapping.WrapOutput<AesWrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      true &&
      (res.Success? ==>
        Invariant() &&
        CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext).Success? &&
        0 < |cryptoPrimitives.History.GenerateRandomBytes| &&
        0 < |cryptoPrimitives.History.AESEncrypt| &&
        Seq.Last(cryptoPrimitives.History.GenerateRandomBytes).output.Success? &&
        Seq.Last(cryptoPrimitives.History.AESEncrypt).output.Success? &&
        ghost var iv: seq<uint8> := Seq.Last(cryptoPrimitives.History.GenerateRandomBytes).output.value; true && ghost var AESEncryptInput: AESEncryptInput := Seq.Last(cryptoPrimitives.History.AESEncrypt).input; true && ghost var AESEncryptOutput: AESEncryptOutput := Seq.Last(cryptoPrimitives.History.AESEncrypt).output.value; |iv| == wrappingAlgorithm.ivLength as nat && AESEncryptInput.encAlg == wrappingAlgorithm && AESEncryptInput.key == wrappingKey && AESEncryptInput.iv == iv && AESEncryptInput.aad == CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext).value && res.value.wrappedMaterial == SerializeEDKCiphertext(AESEncryptOutput) && res.value.wrapInfo.iv == iv)
    }

    method Invoke(input: MaterialWrapping.WrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.WrapInput, Result<MaterialWrapping.WrapOutput<AesWrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.WrapOutput<AesWrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      decreases Modifies
    {
      var aad :- CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext);
      var randomIvResult := cryptoPrimitives.GenerateRandomBytes(Crypto.GenerateRandomBytesInput(length := wrappingAlgorithm.ivLength));
      var iv :- randomIvResult.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      var aesEncryptResult := cryptoPrimitives.AESEncrypt(Crypto.AESEncryptInput(encAlg := wrappingAlgorithm, iv := iv, key := wrappingKey, msg := input.plaintextMaterial, aad := aad));
      var wrappedMaterialResult :- aesEncryptResult.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      var wrappedMaterial := SerializeEDKCiphertext(wrappedMaterialResult);
      return Success(MaterialWrapping.WrapOutput(wrappedMaterial := wrappedMaterial, wrapInfo := AesWrapInfo(iv)));
    }
  }

  class AesUnwrapKeyMaterial extends MaterialWrapping.UnwrapMaterial<AesUnwrapInfo> {
    const wrappingKey: seq<uint8>
    const wrappingAlgorithm: Crypto.AES_GCM
    const iv: seq<uint8>
    const cryptoPrimitives: Primitives.AtomicPrimitivesClient

    constructor (wrappingKey: seq<uint8>, wrappingAlgorithm: Crypto.AES_GCM, iv: seq<uint8>, cryptoPrimitives: Primitives.AtomicPrimitivesClient)
      requires cryptoPrimitives.ValidState()
      requires |iv| == wrappingAlgorithm.ivLength as nat
      ensures this.wrappingKey == wrappingKey && this.iv == iv && this.wrappingAlgorithm == wrappingAlgorithm && this.cryptoPrimitives == cryptoPrimitives
      ensures Invariant()
      decreases wrappingKey, wrappingAlgorithm, iv, cryptoPrimitives
    {
      this.wrappingKey := wrappingKey;
      this.iv := iv;
      this.wrappingAlgorithm := wrappingAlgorithm;
      this.cryptoPrimitives := cryptoPrimitives;
      Modifies := cryptoPrimitives.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      cryptoPrimitives.ValidState() &&
      Modifies == cryptoPrimitives.Modifies &&
      |iv| == wrappingAlgorithm.ivLength as nat
    }

    predicate Ensures(input: MaterialWrapping.UnwrapInput, res: Result<MaterialWrapping.UnwrapOutput<AesUnwrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.UnwrapInput, Result<MaterialWrapping.UnwrapOutput<AesUnwrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        Invariant() &&
        |res.value.unwrappedMaterial| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat &&
        CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext).Success? &&
        wrappingAlgorithm.tagLength as nat <= |input.wrappedMaterial| &&
        ghost var encryptionOutput: Crypto.AESEncryptOutput := DeserializeEDKCiphertext(input.wrappedMaterial, wrappingAlgorithm.tagLength as nat); 0 < |cryptoPrimitives.History.AESDecrypt| && Seq.Last(cryptoPrimitives.History.AESDecrypt).output.Success? && ghost var AESDecryptInput: AESDecryptInput := Seq.Last(cryptoPrimitives.History.AESDecrypt).input; AESDecryptInput.encAlg == wrappingAlgorithm && AESDecryptInput.key == wrappingKey && AESDecryptInput.cipherTxt == encryptionOutput.cipherText && AESDecryptInput.authTag == encryptionOutput.authTag && AESDecryptInput.iv == iv && AESDecryptInput.aad == CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext).value && res.value.unwrappedMaterial == Seq.Last(cryptoPrimitives.History.AESDecrypt).output.value
    }

    method Invoke(input: MaterialWrapping.UnwrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.UnwrapInput, Result<MaterialWrapping.UnwrapOutput<AesUnwrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.UnwrapOutput<AesUnwrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      decreases Modifies
    {
      var aad :- CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext);
      :- Need(wrappingAlgorithm.tagLength as nat <= |input.wrappedMaterial|, Types.AwsCryptographicMaterialProvidersException(message := ""Insufficient data to decrypt.""));
      var encryptionOutput := DeserializeEDKCiphertext(input.wrappedMaterial, wrappingAlgorithm.tagLength as nat);
      var maybePtKey := cryptoPrimitives.AESDecrypt(Crypto.AESDecryptInput(encAlg := wrappingAlgorithm, key := wrappingKey, cipherTxt := encryptionOutput.cipherText, authTag := encryptionOutput.authTag, iv := iv, aad := aad));
      var ptKey :- maybePtKey.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      :- Need(GetEncryptKeyLength(input.algorithmSuite) as nat == |ptKey|, Types.AwsCryptographicMaterialProvidersException(message := ""Plaintext Data Key is not the expected length""));
      return Success(MaterialWrapping.UnwrapOutput(unwrappedMaterial := ptKey, unwrapInfo := AesUnwrapInfo));
    }
  }

  const AUTH_TAG_LEN_LEN := 4
  const IV_LEN_LEN := 4

  function method DeserializeEDKCiphertext(ciphertext: seq<uint8>, tagLen: nat): (encOutput: Crypto.AESEncryptOutput)
    requires tagLen <= |ciphertext|
    ensures |encOutput.authTag| == tagLen
    ensures SerializeEDKCiphertext(encOutput) == ciphertext
    decreases ciphertext, tagLen
  {
    var encryptedKeyLength: int := |ciphertext| - tagLen as int;
    Crypto.AESEncryptOutput(cipherText := ciphertext[..encryptedKeyLength], authTag := ciphertext[encryptedKeyLength..])
  }

  function method SerializeEDKCiphertext(encOutput: Crypto.AESEncryptOutput): (ciphertext: seq<uint8>)
    decreases encOutput
  {
    encOutput.cipherText + encOutput.authTag
  }

  lemma EDKSerializeDeserialize(encOutput: Crypto.AESEncryptOutput)
    ensures DeserializeEDKCiphertext(SerializeEDKCiphertext(encOutput), |encOutput.authTag|) == encOutput
    decreases encOutput
  {
  }

  lemma EDKDeserializeSerialze(ciphertext: seq<uint8>, tagLen: nat)
    requires tagLen <= |ciphertext|
    ensures SerializeEDKCiphertext(DeserializeEDKCiphertext(ciphertext, tagLen)) == ciphertext
    decreases ciphertext, tagLen
  {
  }
}

module RawRSAKeyring {

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened String = StandardLibrary.String

  import opened Actions

  import opened Wrappers

  import Types = AwsCryptographyMaterialProvidersTypes

  import Crypto = AwsCryptographyPrimitivesTypes

  import Primitives = Aws.Cryptography.Primitives

  import Keyring

  import Materials

  import opened AlgorithmSuites

  import Random

  import RSAEncryption

  import UTF8

  import opened Seq

  import MaterialWrapping

  import EdkWrapping
  class RawRSAKeyring extends Keyring.VerifiableInterface, Types.IKeyring {
    const cryptoPrimitives: Primitives.AtomicPrimitivesClient

    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      cryptoPrimitives.Modifies <= Modifies &&
      History !in cryptoPrimitives.Modifies &&
      cryptoPrimitives.ValidState()
    }

    const keyNamespace: UTF8.ValidUTF8Bytes
    const keyName: UTF8.ValidUTF8Bytes
    const publicKey: Option<seq<uint8>>
    const privateKey: Option<seq<uint8>>
    const paddingScheme: Crypto.RSAPaddingMode

    constructor (namespace: UTF8.ValidUTF8Bytes, name: UTF8.ValidUTF8Bytes, publicKey: Option<seq<uint8>>, privateKey: Option<seq<uint8>>, paddingScheme: Crypto.RSAPaddingMode, cryptoPrimitives: Primitives.AtomicPrimitivesClient)
      requires |namespace| < UINT16_LIMIT
      requires |name| < UINT16_LIMIT
      requires cryptoPrimitives.ValidState()
      ensures this.keyNamespace == namespace
      ensures this.keyName == name
      ensures this.paddingScheme == paddingScheme
      ensures this.publicKey == publicKey
      ensures this.privateKey == privateKey
      ensures ValidState() && fresh(History) && fresh(Modifies - cryptoPrimitives.Modifies)
      decreases namespace, name, publicKey, privateKey, paddingScheme, cryptoPrimitives
    {
      this.keyNamespace := namespace;
      this.keyName := name;
      this.paddingScheme := paddingScheme;
      this.publicKey := publicKey;
      this.privateKey := privateKey;
      this.cryptoPrimitives := cryptoPrimitives;
      History := new Types.IKeyringCallHistory();
      Modifies := {History} + cryptoPrimitives.Modifies;
    }

    predicate OnEncryptEnsuresPublicly(input: Types.OnEncryptInput, output: Result<Types.OnEncryptOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method OnEncrypt'(input: Types.OnEncryptInput) returns (output: Result<Types.OnEncryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnEncryptEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures output.Success? ==> true && Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
      ensures this.publicKey.None? || |this.publicKey.Extract()| == 0 ==> output.Failure?
      ensures input.materials.plaintextDataKey.None? && output.Success? ==> output.value.materials.plaintextDataKey.Some?
      ensures true && output.Success? ==> |output.value.materials.encryptedDataKeys| == |input.materials.encryptedDataKeys| + 1
      ensures this.privateKey.Some? && this.publicKey.None? ==> output.Failure?
      decreases Modifies - {History}
    {
      :- Need(this.publicKey.Some? && |this.publicKey.Extract()| > 0, Types.AwsCryptographicMaterialProvidersException(message := ""A RawRSAKeyring without a public key cannot provide OnEncrypt""));
      var materials := input.materials;
      var suite := materials.algorithmSuite;
      var wrap := new RsaWrapKeyMaterial(publicKey.value, paddingScheme, cryptoPrimitives);
      var generateAndWrap := new RsaGenerateAndWrapKeyMaterial(publicKey.value, paddingScheme, cryptoPrimitives);
      var wrapOutput :- EdkWrapping.WrapEdkMaterial<RsaWrapInfo>(encryptionMaterials := materials, wrap := wrap, generateAndWrap := generateAndWrap);
      var symmetricSigningKeyList := if wrapOutput.symmetricSigningKey.Some? then Some([wrapOutput.symmetricSigningKey.value]) else None;
      var edk: Types.EncryptedDataKey := Types.EncryptedDataKey(keyProviderId := this.keyNamespace, keyProviderInfo := this.keyName, ciphertext := wrapOutput.wrappedMaterial);
      if wrapOutput.GenerateAndWrapEdkMaterialOutput? {
        var result :- Materials.EncryptionMaterialAddDataKey(materials, wrapOutput.plaintextDataKey, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      } else if wrapOutput.WrapOnlyEdkMaterialOutput? {
        var result :- Materials.EncryptionMaterialAddEncryptedDataKeys(materials, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      }
    }

    predicate OnDecryptEnsuresPublicly(input: Types.OnDecryptInput, output: Result<Types.OnDecryptOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method OnDecrypt'(input: Types.OnDecryptInput) returns (output: Result<Types.OnDecryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnDecryptEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures output.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
      ensures privateKey.None? || |privateKey.Extract()| == 0 ==> output.Failure?
      ensures input.materials.plaintextDataKey.Some? ==> output.Failure?
      decreases Modifies - {History}
    {
      :- Need(this.privateKey.Some? && |this.privateKey.Extract()| > 0, Types.AwsCryptographicMaterialProvidersException(message := ""A RawRSAKeyring without a private key cannot provide OnEncrypt""));
      var materials := input.materials;
      :- Need(Materials.DecryptionMaterialsWithoutPlaintextDataKey(materials), Types.AwsCryptographicMaterialProvidersException(message := ""Keyring received decryption materials that already contain a plaintext data key.""));
      var errors: seq<Types.Error> := [];
      for i: int := 0 to |input.encryptedDataKeys|
        invariant |errors| == i
      {
        if ShouldDecryptEDK(input.encryptedDataKeys[i]) {
          var edk := input.encryptedDataKeys[i];
          var unwrap := new RsaUnwrapKeyMaterial(privateKey.Extract(), paddingScheme, cryptoPrimitives);
          var unwrapOutput := EdkWrapping.UnwrapEdkMaterial(edk.ciphertext, materials, unwrap);
          if unwrapOutput.Success? {
            var returnMaterials :- Materials.DecryptionMaterialsAddDataKey(materials, unwrapOutput.value.plaintextDataKey, unwrapOutput.value.symmetricSigningKey);
            return Success(Types.OnDecryptOutput(materials := returnMaterials));
          } else {
            errors := errors + [unwrapOutput.error];
          }
        } else {
          errors := errors + [Types.AwsCryptographicMaterialProvidersException(message := ""EncryptedDataKey "" + Base10Int2String(i) + "" did not match RSAKeyring. "")];
        }
      }
      return Failure(Types.CollectionOfErrors(list := errors, message := ""Raw RSA Key was unable to decrypt any encrypted data key. The list of encountered Exceptions is avaible via `list`.""));
    }

    predicate method ShouldDecryptEDK(edk: Types.EncryptedDataKey)
      ensures edk.keyProviderInfo == this.keyName && edk.keyProviderId == this.keyNamespace && |edk.ciphertext| > 0 ==> true
      decreases edk
    {
      UTF8.ValidUTF8Seq(edk.keyProviderInfo) &&
      edk.keyProviderInfo == this.keyName &&
      edk.keyProviderId == this.keyNamespace &&
      |edk.ciphertext| > 0
    }
  }

  datatype RsaUnwrapInfo = RsaUnwrapInfo

  datatype RsaWrapInfo = RsaWrapInfo

  class RsaGenerateAndWrapKeyMaterial extends MaterialWrapping.GenerateAndWrapMaterial<RsaWrapInfo> {
    const publicKey: seq<uint8>
    const paddingScheme: Crypto.RSAPaddingMode
    const cryptoPrimitives: Primitives.AtomicPrimitivesClient

    constructor (publicKey: seq<uint8>, paddingScheme: Crypto.RSAPaddingMode, cryptoPrimitives: Primitives.AtomicPrimitivesClient)
      requires cryptoPrimitives.ValidState()
      ensures this.publicKey == publicKey && this.paddingScheme == paddingScheme && this.cryptoPrimitives == cryptoPrimitives
      ensures Invariant()
      decreases publicKey, paddingScheme, cryptoPrimitives
    {
      this.publicKey := publicKey;
      this.paddingScheme := paddingScheme;
      this.cryptoPrimitives := cryptoPrimitives;
      Modifies := cryptoPrimitives.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      cryptoPrimitives.ValidState() &&
      Modifies == cryptoPrimitives.Modifies
    }

    predicate Ensures(input: MaterialWrapping.GenerateAndWrapInput, res: Result<MaterialWrapping.GenerateAndWrapOutput<RsaWrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.GenerateAndWrapInput, Result<MaterialWrapping.GenerateAndWrapOutput<RsaWrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        true &&
        Invariant()
    }

    method Invoke(input: MaterialWrapping.GenerateAndWrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.GenerateAndWrapInput, Result<MaterialWrapping.GenerateAndWrapOutput<RsaWrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.GenerateAndWrapOutput<RsaWrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      ensures res.Success? ==> |res.value.plaintextMaterial| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat
      decreases Modifies
    {
      var generateBytesResult := cryptoPrimitives.GenerateRandomBytes(Crypto.GenerateRandomBytesInput(length := AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite)));
      var plaintextMaterial :- generateBytesResult.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      var wrap := new RsaWrapKeyMaterial(publicKey, paddingScheme, cryptoPrimitives);
      var wrapOutput: MaterialWrapping.WrapOutput<RsaWrapInfo> :- wrap.Invoke(MaterialWrapping.WrapInput(plaintextMaterial := plaintextMaterial, algorithmSuite := input.algorithmSuite, encryptionContext := input.encryptionContext), []);
      var output := MaterialWrapping.GenerateAndWrapOutput(plaintextMaterial := plaintextMaterial, wrappedMaterial := wrapOutput.wrappedMaterial, wrapInfo := RsaWrapInfo());
      return Success(output);
    }
  }

  class RsaWrapKeyMaterial extends MaterialWrapping.WrapMaterial<RsaWrapInfo> {
    const publicKey: seq<uint8>
    const paddingScheme: Crypto.RSAPaddingMode
    const cryptoPrimitives: Primitives.AtomicPrimitivesClient

    constructor (publicKey: seq<uint8>, paddingScheme: Crypto.RSAPaddingMode, cryptoPrimitives: Primitives.AtomicPrimitivesClient)
      requires cryptoPrimitives.ValidState()
      ensures this.publicKey == publicKey && this.paddingScheme == paddingScheme && this.cryptoPrimitives == cryptoPrimitives
      ensures Invariant()
      decreases publicKey, paddingScheme, cryptoPrimitives
    {
      this.publicKey := publicKey;
      this.paddingScheme := paddingScheme;
      this.cryptoPrimitives := cryptoPrimitives;
      Modifies := cryptoPrimitives.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      cryptoPrimitives.ValidState() &&
      Modifies == cryptoPrimitives.Modifies
    }

    predicate Ensures(input: MaterialWrapping.WrapInput, res: Result<MaterialWrapping.WrapOutput<RsaWrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.WrapInput, Result<MaterialWrapping.WrapOutput<RsaWrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      true &&
      (res.Success? ==>
        Invariant() &&
        0 < |cryptoPrimitives.History.RSAEncrypt| &&
        Seq.Last(cryptoPrimitives.History.RSAEncrypt).output.Success? &&
        ghost var RsaEncryptInput: RSAEncryptInput := Seq.Last(cryptoPrimitives.History.RSAEncrypt).input; true && ghost var RsaEncryptOutput: Result<seq<uint8>, Error> := Seq.Last(cryptoPrimitives.History.RSAEncrypt).output; RsaEncryptInput.padding == paddingScheme && RsaEncryptInput.publicKey == publicKey && RsaEncryptInput.plaintext == input.plaintextMaterial && RsaEncryptOutput.value == res.value.wrappedMaterial)
    }

    method Invoke(input: MaterialWrapping.WrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.WrapInput, Result<MaterialWrapping.WrapOutput<RsaWrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.WrapOutput<RsaWrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      decreases Modifies
    {
      var RSAEncryptOutput := cryptoPrimitives.RSAEncrypt(Crypto.RSAEncryptInput(padding := paddingScheme, publicKey := publicKey, plaintext := input.plaintextMaterial));
      var ciphertext :- RSAEncryptOutput.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
      var output := MaterialWrapping.WrapOutput(wrappedMaterial := ciphertext, wrapInfo := RsaWrapInfo());
      return Success(output);
    }
  }

  class RsaUnwrapKeyMaterial extends MaterialWrapping.UnwrapMaterial<RsaUnwrapInfo> {
    const privateKey: seq<uint8>
    const paddingScheme: Crypto.RSAPaddingMode
    const cryptoPrimitives: Primitives.AtomicPrimitivesClient

    constructor (privateKey: seq<uint8>, paddingScheme: Crypto.RSAPaddingMode, cryptoPrimitives: Primitives.AtomicPrimitivesClient)
      requires cryptoPrimitives.ValidState()
      ensures this.privateKey == privateKey && this.paddingScheme == paddingScheme && this.cryptoPrimitives == cryptoPrimitives
      ensures Invariant()
      decreases privateKey, paddingScheme, cryptoPrimitives
    {
      this.privateKey := privateKey;
      this.paddingScheme := paddingScheme;
      this.cryptoPrimitives := cryptoPrimitives;
      Modifies := cryptoPrimitives.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      cryptoPrimitives.ValidState() &&
      Modifies == cryptoPrimitives.Modifies
    }

    predicate Ensures(input: MaterialWrapping.UnwrapInput, res: Result<MaterialWrapping.UnwrapOutput<RsaUnwrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.UnwrapInput, Result<MaterialWrapping.UnwrapOutput<RsaUnwrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        Invariant() &&
        |cryptoPrimitives.History.RSADecrypt| > 0 &&
        Last(cryptoPrimitives.History.RSADecrypt).output.Success? &&
        ghost var decryptInput: RSADecryptInput := Last(cryptoPrimitives.History.RSADecrypt).input; true && ghost var decryptOutput: seq<uint8> := Last(cryptoPrimitives.History.RSADecrypt).output.value; decryptInput.padding == paddingScheme && decryptInput.privateKey == privateKey && decryptInput.cipherText == input.wrappedMaterial && decryptOutput == res.value.unwrappedMaterial
    }

    method Invoke(input: MaterialWrapping.UnwrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.UnwrapInput, Result<MaterialWrapping.UnwrapOutput<RsaUnwrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.UnwrapOutput<RsaUnwrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      ensures res.Success? ==> |res.value.unwrappedMaterial| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat
      decreases Modifies
    {
      var suite := input.algorithmSuite;
      var wrappedMaterial := input.wrappedMaterial;
      var aad := input.encryptionContext;
      var maybeDecryptResult := cryptoPrimitives.RSADecrypt(Crypto.RSADecryptInput(padding := paddingScheme, privateKey := privateKey, cipherText := wrappedMaterial));
      var decryptResult :- maybeDecryptResult.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      :- Need(|decryptResult| == AlgorithmSuites.GetEncryptKeyLength(suite) as nat, Types.AwsCryptographicMaterialProvidersException(message := ""Invalid plaintext length.""));
      assert |cryptoPrimitives.History.RSADecrypt| > 0;
      var output := MaterialWrapping.UnwrapOutput(unwrappedMaterial := decryptResult, unwrapInfo := RsaUnwrapInfo());
      return Success(output);
    }
  }
}

module DefaultCMM {

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import AlgorithmSuites

  import Materials

  import CMM

  import Signature

  import Base64

  import UTF8

  import Types = AwsCryptographyMaterialProvidersTypes

  import Crypto = AwsCryptographyPrimitivesTypes

  import Primitives = Aws.Cryptography.Primitives

  import Defaults

  import Commitment

  import Seq
  class DefaultCMM extends CMM.VerifiableInterface {
    const cryptoPrimitives: Primitives.AtomicPrimitivesClient

    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      keyring.ValidState() &&
      cryptoPrimitives.ValidState() &&
      keyring.Modifies <= Modifies &&
      cryptoPrimitives.Modifies <= Modifies &&
      History !in keyring.Modifies &&
      History !in cryptoPrimitives.Modifies
    }

    const keyring: Types.IKeyring

    constructor OfKeyring(k: Types.IKeyring, c: Primitives.AtomicPrimitivesClient)
      requires k.ValidState() && c.ValidState()
      ensures keyring == k && cryptoPrimitives == c
      ensures ValidState() && fresh(this) && fresh(History) && fresh(Modifies - cryptoPrimitives.Modifies - keyring.Modifies)
      ensures Modifies == {History} + keyring.Modifies + cryptoPrimitives.Modifies
      decreases k, c
    {
      keyring := k;
      cryptoPrimitives := c;
      History := new Types.ICryptographicMaterialsManagerCallHistory();
      Modifies := {History} + c.Modifies + k.Modifies;
    }

    predicate GetEncryptionMaterialsEnsuresPublicly(input: Types.GetEncryptionMaterialsInput, output: Result<Types.GetEncryptionMaterialsOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method GetEncryptionMaterials'(input: Types.GetEncryptionMaterialsInput) returns (output: Result<Types.GetEncryptionMaterialsOutput, Types.Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures true && ValidState()
      ensures GetEncryptionMaterialsEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures output.Success? ==> true && Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.encryptionMaterials)
      ensures output.Success? ==> true && CMM.RequiredEncryptionContextKeys?(input.requiredEncryptionContextKeys, output.value.encryptionMaterials)
      ensures output.Success? ==> true && (output.value.encryptionMaterials.algorithmSuite.signature.ECDSA? <==> Materials.EC_PUBLIC_KEY_FIELD in output.value.encryptionMaterials.encryptionContext && output.value.encryptionMaterials.signingKey.Some?)
      ensures Materials.EC_PUBLIC_KEY_FIELD in input.encryptionContext ==> output.Failure?
      ensures true && output.Success? ==> if input.algorithmSuiteId.Some? then output.value.encryptionMaterials.algorithmSuite.id == input.algorithmSuiteId.value else input.algorithmSuiteId.None? && output.value.encryptionMaterials.algorithmSuite.id == Defaults.GetAlgorithmSuiteForCommitmentPolicy(input.commitmentPolicy)
      ensures true && output.Success? ==> |keyring.History.OnEncrypt| == |old(keyring.History.OnEncrypt)| + 1 && Seq.Last(keyring.History.OnEncrypt).output.Success? && Seq.Last(keyring.History.OnEncrypt).output.value.materials.plaintextDataKey == output.value.encryptionMaterials.plaintextDataKey && Seq.Last(keyring.History.OnEncrypt).output.value.materials.encryptedDataKeys == output.value.encryptionMaterials.encryptedDataKeys
      ensures input.algorithmSuiteId.Some? && Commitment.ValidateCommitmentPolicyOnEncrypt(input.algorithmSuiteId.value, input.commitmentPolicy).Fail? ==> output.Failure?
      decreases Modifies - {History}
    {
      :- Need(Materials.EC_PUBLIC_KEY_FIELD !in input.encryptionContext, Types.AwsCryptographicMaterialProvidersException(message := ""Reserved Field found in EncryptionContext keys.""));
      var algorithmId := if input.algorithmSuiteId.Some? then input.algorithmSuiteId.value else Defaults.GetAlgorithmSuiteForCommitmentPolicy(input.commitmentPolicy);
      :- Commitment.ValidateCommitmentPolicyOnEncrypt(algorithmId, input.commitmentPolicy);
      var suite := AlgorithmSuites.GetSuite(algorithmId);
      var signingKey: Option<seq<uint8>>;
      var verificationKey: Option<seq<uint8>>;
      if suite.signature.ECDSA? {
        var maybeECDSAPair := cryptoPrimitives.GenerateECDSASignatureKey(Crypto.GenerateECDSASignatureKeyInput(signatureAlgorithm := suite.signature.ECDSA.curve));
        var pair :- maybeECDSAPair.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
        signingKey := Some(pair.signingKey);
        verificationKey := Some(pair.verificationKey);
      } else {
        assert suite.signature.None?;
        signingKey := None;
        verificationKey := None;
      }
      var materials :- Materials.InitializeEncryptionMaterials(Types.InitializeEncryptionMaterialsInput(algorithmSuiteId := algorithmId, encryptionContext := input.encryptionContext, signingKey := signingKey, verificationKey := verificationKey, requiredEncryptionContextKeys := input.requiredEncryptionContextKeys.UnwrapOr([])));
      var result :- keyring.OnEncrypt(Types.OnEncryptInput(materials := materials));
      var encryptionMaterialsOutput := Types.GetEncryptionMaterialsOutput(encryptionMaterials := result.materials);
      :- Need(Materials.EncryptionMaterialsHasPlaintextDataKey(encryptionMaterialsOutput.encryptionMaterials), Types.AwsCryptographicMaterialProvidersException(message := ""Could not retrieve materials required for encryption""));
      :- Need(Materials.ValidEncryptionMaterialsTransition(materials, encryptionMaterialsOutput.encryptionMaterials), Types.AwsCryptographicMaterialProvidersException(message := ""Keyring returned an invalid response""));
      output := Success(encryptionMaterialsOutput);
    }

    predicate DecryptMaterialsEnsuresPublicly(input: Types.DecryptMaterialsInput, output: Result<Types.DecryptMaterialsOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method DecryptMaterials'(input: Types.DecryptMaterialsInput) returns (output: Result<Types.DecryptMaterialsOutput, Types.Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures true && ValidState()
      ensures DecryptMaterialsEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures output.Success? ==> true && Materials.DecryptionMaterialsWithPlaintextDataKey(output.value.decryptionMaterials)
      ensures (output.Success? ==> CMM.ReproducedEncryptionContext?(input)) && (!CMM.ReproducedEncryptionContext?(input) ==> output.Failure?)
      ensures output.Success? ==> CMM.EncryptionContextComplete(input, output.value.decryptionMaterials)
      ensures (AlgorithmSuites.GetSuite(input.algorithmSuiteId).signature.None? <==> Materials.EC_PUBLIC_KEY_FIELD in input.encryptionContext + input.reproducedEncryptionContext.UnwrapOr(map[])) ==> output.Failure?
      ensures Commitment.ValidateCommitmentPolicyOnDecrypt(input.algorithmSuiteId, input.commitmentPolicy).Fail? ==> output.Failure?
      ensures output.Success? && AlgorithmSuites.GetSuite(input.algorithmSuiteId).signature.ECDSA? ==> Materials.DecodeVerificationKey(input.encryptionContext + input.reproducedEncryptionContext.UnwrapOr(map[])).Success? && output.value.decryptionMaterials.verificationKey.Some? && output.value.decryptionMaterials.verificationKey == Some(Materials.DecodeVerificationKey(input.encryptionContext + input.reproducedEncryptionContext.UnwrapOr(map[])).value.value)
      ensures output.Success? ==> input.algorithmSuiteId == output.value.decryptionMaterials.algorithmSuite.id && (output.value.decryptionMaterials.algorithmSuite.signature.ECDSA? ==> output.value.decryptionMaterials.verificationKey.Some?) && (0 < |output.value.decryptionMaterials.requiredEncryptionContextKeys| ==> input.reproducedEncryptionContext.Some?) && forall key: ValidUTF8Bytes {:trigger key in input.reproducedEncryptionContext.value} {:trigger key in input.encryptionContext} {:trigger key in output.value.decryptionMaterials.requiredEncryptionContextKeys} | key in output.value.decryptionMaterials.requiredEncryptionContextKeys :: key !in input.encryptionContext && key in input.reproducedEncryptionContext.value
      ensures true && output.Success? ==> |keyring.History.OnDecrypt| == |old(keyring.History.OnDecrypt)| + 1 && Seq.Last(keyring.History.OnDecrypt).output.Success? && Seq.Last(keyring.History.OnDecrypt).output.value.materials.plaintextDataKey == output.value.decryptionMaterials.plaintextDataKey
      decreases Modifies - {History}
    {
      :- Commitment.ValidateCommitmentPolicyOnDecrypt(input.algorithmSuiteId, input.commitmentPolicy);
      var requiredEncryptionContextKeys := [];
      if input.reproducedEncryptionContext.Some? {
        var keysSet := input.reproducedEncryptionContext.value.Keys;
        while keysSet != {}
          invariant forall key: seq<BoundedInts.uint8> {:trigger input.encryptionContext[key]} {:trigger input.reproducedEncryptionContext.value[key]} {:trigger key in keysSet} {:trigger key in input.encryptionContext} {:trigger key in input.reproducedEncryptionContext.value} | key in input.reproducedEncryptionContext.value && key in input.encryptionContext && key !in keysSet :: input.reproducedEncryptionContext.value[key] == input.encryptionContext[key]
          invariant forall key: ValidUTF8Bytes {:trigger key in input.encryptionContext} {:trigger key in requiredEncryptionContextKeys} | key in requiredEncryptionContextKeys :: key !in input.encryptionContext
          decreases keysSet
        {
          var key :| key in keysSet;
          if key in input.encryptionContext {
            :- Need(input.reproducedEncryptionContext.value[key] == input.encryptionContext[key], Types.AwsCryptographicMaterialProvidersException(message := ""Encryption context does not match reproduced encryption context.""));
          } else {
            requiredEncryptionContextKeys := requiredEncryptionContextKeys + [key];
          }
          keysSet := keysSet - {key};
        }
      }
      var materials :- Materials.InitializeDecryptionMaterials(Types.InitializeDecryptionMaterialsInput(algorithmSuiteId := input.algorithmSuiteId, encryptionContext := input.encryptionContext + input.reproducedEncryptionContext.UnwrapOr(map[]), requiredEncryptionContextKeys := requiredEncryptionContextKeys));
      var result :- keyring.OnDecrypt(Types.OnDecryptInput(materials := materials, encryptedDataKeys := input.encryptedDataKeys));
      :- Need(Materials.DecryptionMaterialsTransitionIsValid(materials, result.materials), Types.AwsCryptographicMaterialProvidersException(message := ""Keyring.OnDecrypt failed to decrypt the plaintext data key.""));
      return Success(Types.DecryptMaterialsOutput(decryptionMaterials := result.materials));
    }
  }
}

module {:options ""/functionSyntax:4""} CMM {

  import opened Wrappers

  import Types = AwsCryptographyMaterialProvidersTypes

  import Materials
  trait {:termination false} VerifiableInterface extends Types.ICryptographicMaterialsManager {
    method GetEncryptionMaterials'(input: Types.GetEncryptionMaterialsInput) returns (output: Result<Types.GetEncryptionMaterialsOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures GetEncryptionMaterialsEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures output.Success? ==> true && Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.encryptionMaterials)
      ensures output.Success? ==> true && RequiredEncryptionContextKeys?(input.requiredEncryptionContextKeys, output.value.encryptionMaterials)
      decreases Modifies - {History}

    method DecryptMaterials'(input: Types.DecryptMaterialsInput) returns (output: Result<Types.DecryptMaterialsOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures DecryptMaterialsEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures output.Success? ==> true && Materials.DecryptionMaterialsWithPlaintextDataKey(output.value.decryptionMaterials)
      ensures (output.Success? ==> ReproducedEncryptionContext?(input)) && (!ReproducedEncryptionContext?(input) ==> output.Failure?)
      ensures output.Success? ==> EncryptionContextComplete(input, output.value.decryptionMaterials)
      decreases Modifies - {History}
  }

  predicate method RequiredEncryptionContextKeys?(requiredEncryptionContextKeys: Option<Types.EncryptionContextKeys>, encryptionMaterials: Types.EncryptionMaterials)
    decreases requiredEncryptionContextKeys, encryptionMaterials
  {
    forall k: ValidUTF8Bytes {:trigger k in encryptionMaterials.requiredEncryptionContextKeys} {:trigger k in requiredEncryptionContextKeys.UnwrapOr([])} | k in requiredEncryptionContextKeys.UnwrapOr([]) :: 
      k in encryptionMaterials.requiredEncryptionContextKeys
  }

  predicate method EncryptionContextComplete(input: Types.DecryptMaterialsInput, decryptionMaterials: Types.DecryptionMaterials)
    decreases input, decryptionMaterials
  {
    var reproducedEncryptionContext: EncryptionContext := input.reproducedEncryptionContext.UnwrapOr(map[]);
    forall k: seq<BoundedInts.uint8> {:trigger reproducedEncryptionContext[k]} {:trigger decryptionMaterials.encryptionContext[k]} {:trigger k in decryptionMaterials.encryptionContext} {:trigger k in reproducedEncryptionContext.Keys} | k in reproducedEncryptionContext.Keys :: 
      k in decryptionMaterials.encryptionContext &&
      decryptionMaterials.encryptionContext[k] == reproducedEncryptionContext[k]
  }

  predicate method ReproducedEncryptionContext?(input: Types.DecryptMaterialsInput)
    decreases input
  {
    var reproducedEncryptionContext: EncryptionContext := input.reproducedEncryptionContext.UnwrapOr(map[]);
    forall k: seq<BoundedInts.uint8> {:trigger reproducedEncryptionContext[k]} {:trigger input.encryptionContext[k]} {:trigger k in input.encryptionContext} {:trigger k in reproducedEncryptionContext.Keys} | k in reproducedEncryptionContext.Keys && k in input.encryptionContext :: 
      input.encryptionContext[k] == reproducedEncryptionContext[k]
  }
}

module Defaults {

  import opened AwsCryptographyMaterialProvidersTypes
  function method GetAlgorithmSuiteForCommitmentPolicy(commitmentPolicy: CommitmentPolicy): (output: AlgorithmSuiteId)
    ensures commitmentPolicy == CommitmentPolicy.ESDK(FORBID_ENCRYPT_ALLOW_DECRYPT) ==> output == AlgorithmSuiteId.ESDK(ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384)
    ensures commitmentPolicy == CommitmentPolicy.ESDK(REQUIRE_ENCRYPT_ALLOW_DECRYPT) || commitmentPolicy == CommitmentPolicy.ESDK(ESDKCommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT) ==> output == AlgorithmSuiteId.ESDK(ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384)
    ensures commitmentPolicy == CommitmentPolicy.DBE(DBECommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT) ==> output == AlgorithmSuiteId.DBE(ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384_SYMSIG_HMAC_SHA384)
    decreases commitmentPolicy
  {
    match commitmentPolicy
    case ESDK(c) =>
      (match c
      case FORBID_ENCRYPT_ALLOW_DECRYPT() =>
        AlgorithmSuiteId.ESDK(ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384)
      case _ /* _v0 */ =>
        AlgorithmSuiteId.ESDK(ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384))
    case DBE(_ /* _v1 */) =>
      AlgorithmSuiteId.DBE(ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384_SYMSIG_HMAC_SHA384)
  }
}

module Commitment {

  import opened Wrappers

  import opened AwsCryptographyMaterialProvidersTypes

  import AlgorithmSuites
  function method ValidateCommitmentPolicyOnEncrypt(algorithm: AlgorithmSuiteId, commitmentPolicy: CommitmentPolicy): (res: Outcome<Error>)
    ensures commitmentPolicy == CommitmentPolicy.ESDK(FORBID_ENCRYPT_ALLOW_DECRYPT) && (var suite: AlgorithmSuite := AlgorithmSuites.GetSuite(algorithm); true && !suite.commitment.None?) ==> res.Fail?
    ensures (commitmentPolicy == CommitmentPolicy.ESDK(REQUIRE_ENCRYPT_ALLOW_DECRYPT) || commitmentPolicy == CommitmentPolicy.ESDK(ESDKCommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT) || commitmentPolicy == CommitmentPolicy.DBE(DBECommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT)) && (var suite: AlgorithmSuite := AlgorithmSuites.GetSuite(algorithm); true && suite.commitment.None?) ==> res.Fail?
    ensures (commitmentPolicy == CommitmentPolicy.ESDK(REQUIRE_ENCRYPT_ALLOW_DECRYPT) || commitmentPolicy == CommitmentPolicy.ESDK(ESDKCommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT) || commitmentPolicy == CommitmentPolicy.DBE(DBECommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT)) && (var suite: AlgorithmSuite := AlgorithmSuites.GetSuite(algorithm); true && !suite.commitment.None?) ==> res.Pass?
    ensures commitmentPolicy == CommitmentPolicy.ESDK(FORBID_ENCRYPT_ALLOW_DECRYPT) && (var suite: AlgorithmSuite := AlgorithmSuites.GetSuite(algorithm); true && suite.commitment.None?) ==> res.Pass?
    decreases algorithm, commitmentPolicy
  {
    var suite: AlgorithmSuite := AlgorithmSuites.GetSuite(algorithm);
    if commitmentPolicy == CommitmentPolicy.ESDK(FORBID_ENCRYPT_ALLOW_DECRYPT) && !suite.commitment.None? then
      Fail(InvalidAlgorithmSuiteInfoOnEncrypt(message := ""Configuration conflict. Commitment policy requires only non-committing algorithm suites""))
    else if (commitmentPolicy == CommitmentPolicy.ESDK(REQUIRE_ENCRYPT_ALLOW_DECRYPT) || commitmentPolicy == CommitmentPolicy.ESDK(ESDKCommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT) || commitmentPolicy == CommitmentPolicy.DBE(DBECommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT)) && suite.commitment.None? then
      Fail(InvalidAlgorithmSuiteInfoOnEncrypt(message := ""Configuration conflict. Commitment policy requires only committing algorithm suites""))
    else
      Pass
  }

  function method ValidateCommitmentPolicyOnDecrypt(algorithm: AlgorithmSuiteId, commitmentPolicy: CommitmentPolicy): (res: Outcome<Error>)
    ensures (commitmentPolicy == CommitmentPolicy.ESDK(ESDKCommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT) || commitmentPolicy == CommitmentPolicy.DBE(DBECommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT)) && (var suite: AlgorithmSuite := AlgorithmSuites.GetSuite(algorithm); true && suite.commitment.None?) ==> res.Fail?
    ensures (commitmentPolicy == CommitmentPolicy.ESDK(ESDKCommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT) || commitmentPolicy == CommitmentPolicy.DBE(DBECommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT)) && (var suite: AlgorithmSuite := AlgorithmSuites.GetSuite(algorithm); true && !suite.commitment.None?) ==> res.Pass?
    ensures true && (commitmentPolicy == CommitmentPolicy.ESDK(FORBID_ENCRYPT_ALLOW_DECRYPT) || commitmentPolicy == CommitmentPolicy.ESDK(REQUIRE_ENCRYPT_ALLOW_DECRYPT)) ==> res.Pass?
    decreases algorithm, commitmentPolicy
  {
    var suite: AlgorithmSuite := AlgorithmSuites.GetSuite(algorithm);
    if true && (commitmentPolicy == CommitmentPolicy.ESDK(ESDKCommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT) || commitmentPolicy == CommitmentPolicy.DBE(DBECommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT)) && suite.commitment.None? then
      Fail(InvalidAlgorithmSuiteInfoOnDecrypt(message := ""Configuration conflict. Commitment policy requires only committing algorithm suites""))
    else
      Pass
  }
}

module DefaultClientSupplier {

  import ComAmazonawsKmsTypes

  import Kms = Com.Amazonaws.Kms

  import opened AwsCryptographyMaterialProvidersTypes

  import opened Wrappers
  class DefaultClientSupplier extends IClientSupplier {
    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      true &&
      History in Modifies
    }

    constructor ()
      ensures ValidState() && fresh(History) && fresh(Modifies)
    {
      History := new IClientSupplierCallHistory();
      Modifies := {History};
    }

    predicate GetClientEnsuresPublicly(input: GetClientInput, output: Result<ComAmazonawsKmsTypes.IKMSClient, Error>)
      decreases input, output
    {
      true
    }

    method GetClient'(input: GetClientInput) returns (output: Result<ComAmazonawsKmsTypes.IKMSClient, Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! Modifies && fresh(output.value) && fresh(output.value.Modifies))
      ensures GetClientEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}
    {
      var maybeClient := Kms.KMSClientForRegion(input.region);
      return maybeClient.MapFailure((e: Error) => ComAmazonawsKms(e));
    }
  }
}

module RequiredEncryptionContextCMM {

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import Materials

  import CMM

  import UTF8

  import Types = AwsCryptographyMaterialProvidersTypes

  import Seq
  class RequiredEncryptionContextCMM extends CMM.VerifiableInterface {
    const underlyingCMM: Types.ICryptographicMaterialsManager
    const requiredEncryptionContextKeys: seq<UTF8.ValidUTF8Bytes>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      underlyingCMM.ValidState() &&
      underlyingCMM.Modifies <= Modifies &&
      History !in underlyingCMM.Modifies
    }

    constructor (inputCMM: Types.ICryptographicMaterialsManager, inputKeys: set<UTF8.ValidUTF8Bytes>)
      requires inputCMM.ValidState()
      requires 0 < |inputKeys|
      ensures |inputKeys| == |requiredEncryptionContextKeys| && forall k: UTF8.ValidUTF8Bytes {:trigger k in inputKeys} {:trigger k in requiredEncryptionContextKeys} | k in requiredEncryptionContextKeys :: k in inputKeys
      ensures ValidState() && fresh(this) && fresh(History) && fresh(Modifies - underlyingCMM.Modifies) && underlyingCMM == inputCMM
      ensures Modifies == {History} + underlyingCMM.Modifies
      decreases inputCMM, inputKeys
    {
      var keySet := inputKeys;
      var keySeq := [];
      while keySet != {}
        invariant |keySeq| + |keySet| == |inputKeys|
        invariant forall k: UTF8.ValidUTF8Bytes {:trigger k in inputKeys} {:trigger k in keySeq} | k in keySeq :: k in inputKeys
        decreases keySet
      {
        var key :| key in keySet;
        keySeq := keySeq + [key];
        keySet := keySet - {key};
      }
      underlyingCMM := inputCMM;
      requiredEncryptionContextKeys := keySeq;
      History := new Types.ICryptographicMaterialsManagerCallHistory();
      Modifies := {History} + inputCMM.Modifies;
    }

    predicate GetEncryptionMaterialsEnsuresPublicly(input: Types.GetEncryptionMaterialsInput, output: Result<Types.GetEncryptionMaterialsOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method GetEncryptionMaterials'(input: Types.GetEncryptionMaterialsInput) returns (output: Result<Types.GetEncryptionMaterialsOutput, Types.Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures true && ValidState()
      ensures GetEncryptionMaterialsEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures output.Success? ==> true && Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.encryptionMaterials)
      ensures output.Success? ==> true && CMM.RequiredEncryptionContextKeys?(input.requiredEncryptionContextKeys, output.value.encryptionMaterials)
      ensures !(forall k: UTF8.ValidUTF8Bytes {:trigger k in input.encryptionContext} {:trigger k in requiredEncryptionContextKeys} | k in requiredEncryptionContextKeys :: k in input.encryptionContext) ==> output.Failure?
      ensures true && output.Success? ==> |underlyingCMM.History.GetEncryptionMaterials| == |old(underlyingCMM.History.GetEncryptionMaterials)| + 1 && Seq.Last(underlyingCMM.History.GetEncryptionMaterials).output.Success? && output == Seq.Last(underlyingCMM.History.GetEncryptionMaterials).output
      ensures true && output.Success? ==> Seq.Last(underlyingCMM.History.GetEncryptionMaterials).input.requiredEncryptionContextKeys.Some? && var keys: EncryptionContextKeys := Seq.Last(underlyingCMM.History.GetEncryptionMaterials).input.requiredEncryptionContextKeys.value; true && forall k: UTF8.ValidUTF8Bytes {:trigger k in keys} {:trigger k in requiredEncryptionContextKeys} | k in requiredEncryptionContextKeys :: k in keys
      ensures true && output.Success? ==> true && forall k: UTF8.ValidUTF8Bytes {:trigger k in output.value.encryptionMaterials.requiredEncryptionContextKeys} {:trigger k in requiredEncryptionContextKeys} | k in requiredEncryptionContextKeys :: k in output.value.encryptionMaterials.requiredEncryptionContextKeys
      decreases Modifies - {History}
    {
      :- Need(forall k: UTF8.ValidUTF8Bytes {:trigger k in input.encryptionContext} {:trigger k in requiredEncryptionContextKeys} | k in requiredEncryptionContextKeys :: k in input.encryptionContext, Types.AwsCryptographicMaterialProvidersException(message := ""Encryption context does not contain required keys.""));
      var result :- underlyingCMM.GetEncryptionMaterials(input.(requiredEncryptionContextKeys := Some(input.requiredEncryptionContextKeys.UnwrapOr([]) + requiredEncryptionContextKeys)));
      :- Need(forall k: UTF8.ValidUTF8Bytes {:trigger k in result.encryptionMaterials.requiredEncryptionContextKeys} {:trigger k in requiredEncryptionContextKeys} | k in requiredEncryptionContextKeys :: k in result.encryptionMaterials.requiredEncryptionContextKeys, Types.AwsCryptographicMaterialProvidersException(message := ""Expected encryption context keys do not exist in keys to only authenticate.""));
      :- Need(Materials.EncryptionMaterialsHasPlaintextDataKey(result.encryptionMaterials), Types.AwsCryptographicMaterialProvidersException(message := ""Could not retrieve materials required for encryption""));
      :- Need(CMM.RequiredEncryptionContextKeys?(input.requiredEncryptionContextKeys, result.encryptionMaterials), Types.AwsCryptographicMaterialProvidersException(message := ""Keyring returned an invalid response""));
      output := Success(result);
    }

    predicate DecryptMaterialsEnsuresPublicly(input: Types.DecryptMaterialsInput, output: Result<Types.DecryptMaterialsOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method DecryptMaterials'(input: Types.DecryptMaterialsInput) returns (output: Result<Types.DecryptMaterialsOutput, Types.Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures true && ValidState()
      ensures DecryptMaterialsEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures output.Success? ==> true && Materials.DecryptionMaterialsWithPlaintextDataKey(output.value.decryptionMaterials)
      ensures (output.Success? ==> CMM.ReproducedEncryptionContext?(input)) && (!CMM.ReproducedEncryptionContext?(input) ==> output.Failure?)
      ensures output.Success? ==> CMM.EncryptionContextComplete(input, output.value.decryptionMaterials)
      ensures true && (output.Success? ==> input.reproducedEncryptionContext.Some? && forall k: UTF8.ValidUTF8Bytes {:trigger k in input.reproducedEncryptionContext.value} {:trigger k in requiredEncryptionContextKeys} | k in requiredEncryptionContextKeys :: k in input.reproducedEncryptionContext.value)
      ensures input.reproducedEncryptionContext.None? ==> output.Failure?
      ensures input.reproducedEncryptionContext.Some? && !(forall k: UTF8.ValidUTF8Bytes {:trigger k in input.reproducedEncryptionContext.value} {:trigger k in requiredEncryptionContextKeys} | k in requiredEncryptionContextKeys :: k in input.reproducedEncryptionContext.value) ==> output.Failure?
      ensures output.Success? ==> |underlyingCMM.History.DecryptMaterials| == |old(underlyingCMM.History.DecryptMaterials)| + 1 && Seq.Last(underlyingCMM.History.DecryptMaterials).output == output && Seq.Last(underlyingCMM.History.DecryptMaterials).input == input
      ensures |underlyingCMM.History.DecryptMaterials| == |old(underlyingCMM.History.DecryptMaterials)| + 1 && Seq.Last(underlyingCMM.History.DecryptMaterials).output.Success? && !(forall k: UTF8.ValidUTF8Bytes {:trigger k in Seq.Last(underlyingCMM.History.DecryptMaterials).output.value.decryptionMaterials.encryptionContext} {:trigger k in requiredEncryptionContextKeys} | k in requiredEncryptionContextKeys :: k in Seq.Last(underlyingCMM.History.DecryptMaterials).output.value.decryptionMaterials.encryptionContext) ==> output.Failure?
      decreases Modifies - {History}
    {
      :- Need(input.reproducedEncryptionContext.Some?, Types.AwsCryptographicMaterialProvidersException(message := ""No reproduced encryption context on decrypt.""));
      :- Need(CMM.ReproducedEncryptionContext?(input), Types.AwsCryptographicMaterialProvidersException(message := ""Encryption context does not match reproduced encryption context.""));
      :- Need(forall k: UTF8.ValidUTF8Bytes {:trigger k in input.reproducedEncryptionContext.value} {:trigger k in requiredEncryptionContextKeys} | k in requiredEncryptionContextKeys :: k in input.reproducedEncryptionContext.value, Types.AwsCryptographicMaterialProvidersException(message := ""Reproduced encryption context missing required keys.""));
      var result :- underlyingCMM.DecryptMaterials(input);
      :- Need(forall k: UTF8.ValidUTF8Bytes {:trigger k in result.decryptionMaterials.encryptionContext} {:trigger k in requiredEncryptionContextKeys} | k in requiredEncryptionContextKeys :: k in result.decryptionMaterials.encryptionContext, Types.AwsCryptographicMaterialProvidersException(message := ""Final encryption context missing required keys.""));
      :- Need(CMM.EncryptionContextComplete(input, result.decryptionMaterials), Types.AwsCryptographicMaterialProvidersException(message := ""Reproduced encryption context missing from encryption context.""));
      :- Need(Materials.DecryptionMaterialsWithPlaintextDataKey(result.decryptionMaterials), Types.AwsCryptographicMaterialProvidersException(message := ""Keyring.OnDecrypt failed to decrypt the plaintext data key.""));
      return Success(result);
    }
  }
}

module Aws {

  module Cryptography {

      }
}

module Com {

  module Amazonaws {

    
      }
}

module JSON {

  
  
  
  
  
  
  
  module Utils {

    
    
    
    
    
    
    module Views {

      
          }
  }

  module ZeroCopy {

    
    
      }

  module ConcreteSyntax {

    
      }
}
")]

namespace Dafny {
  internal class ArrayHelpers {
    public static T[] InitNewArray1<T>(T z, BigInteger size0) {
      int s0 = (int)size0;
      T[] a = new T[s0];
      for (int i0 = 0; i0 < s0; i0++) {
        a[i0] = z;
      }
      return a;
    }
  }
} // end of namespace Dafny
internal static class FuncExtensions {
  public static Func<U, UResult> DowncastClone<T, TResult, U, UResult>(this Func<T, TResult> F, Func<U, T> ArgConv, Func<TResult, UResult> ResConv) {
    return arg => ResConv(F(ArgConv(arg)));
  }
  public static Func<UResult> DowncastClone<TResult, UResult>(this Func<TResult> F, Func<TResult, UResult> ResConv) {
    return () => ResConv(F());
  }
  public static Func<U1, U2, UResult> DowncastClone<T1, T2, TResult, U1, U2, UResult>(this Func<T1, T2, TResult> F, Func<U1, T1> ArgConv1, Func<U2, T2> ArgConv2, Func<TResult, UResult> ResConv) {
    return (arg1, arg2) => ResConv(F(ArgConv1(arg1), ArgConv2(arg2)));
  }
  public static Func<U1, U2, U3, UResult> DowncastClone<T1, T2, T3, TResult, U1, U2, U3, UResult>(this Func<T1, T2, T3, TResult> F, Func<U1, T1> ArgConv1, Func<U2, T2> ArgConv2, Func<U3, T3> ArgConv3, Func<TResult, UResult> ResConv) {
    return (arg1, arg2, arg3) => ResConv(F(ArgConv1(arg1), ArgConv2(arg2), ArgConv3(arg3)));
  }
  public static Func<U1, U2, U3, U4, UResult> DowncastClone<T1, T2, T3, T4, TResult, U1, U2, U3, U4, UResult>(this Func<T1, T2, T3, T4, TResult> F, Func<U1, T1> ArgConv1, Func<U2, T2> ArgConv2, Func<U3, T3> ArgConv3, Func<U4, T4> ArgConv4, Func<TResult, UResult> ResConv) {
    return (arg1, arg2, arg3, arg4) => ResConv(F(ArgConv1(arg1), ArgConv2(arg2), ArgConv3(arg3), ArgConv4(arg4)));
  }
  public static Func<U1, U2, U3, U4, U5, UResult> DowncastClone<T1, T2, T3, T4, T5, TResult, U1, U2, U3, U4, U5, UResult>(this Func<T1, T2, T3, T4, T5, TResult> F, Func<U1, T1> ArgConv1, Func<U2, T2> ArgConv2, Func<U3, T3> ArgConv3, Func<U4, T4> ArgConv4, Func<U5, T5> ArgConv5, Func<TResult, UResult> ResConv) {
    return (arg1, arg2, arg3, arg4, arg5) => ResConv(F(ArgConv1(arg1), ArgConv2(arg2), ArgConv3(arg3), ArgConv4(arg4), ArgConv5(arg5)));
  }
  public static Func<U1, U2, U3, U4, U5, U6, U7, UResult> DowncastClone<T1, T2, T3, T4, T5, T6, T7, TResult, U1, U2, U3, U4, U5, U6, U7, UResult>(this Func<T1, T2, T3, T4, T5, T6, T7, TResult> F, Func<U1, T1> ArgConv1, Func<U2, T2> ArgConv2, Func<U3, T3> ArgConv3, Func<U4, T4> ArgConv4, Func<U5, T5> ArgConv5, Func<U6, T6> ArgConv6, Func<U7, T7> ArgConv7, Func<TResult, UResult> ResConv) {
    return (arg1, arg2, arg3, arg4, arg5, arg6, arg7) => ResConv(F(ArgConv1(arg1), ArgConv2(arg2), ArgConv3(arg3), ArgConv4(arg4), ArgConv5(arg5), ArgConv6(arg6), ArgConv7(arg7)));
  }
  public static Func<U1, U2, U3, U4, U5, U6, UResult> DowncastClone<T1, T2, T3, T4, T5, T6, TResult, U1, U2, U3, U4, U5, U6, UResult>(this Func<T1, T2, T3, T4, T5, T6, TResult> F, Func<U1, T1> ArgConv1, Func<U2, T2> ArgConv2, Func<U3, T3> ArgConv3, Func<U4, T4> ArgConv4, Func<U5, T5> ArgConv5, Func<U6, T6> ArgConv6, Func<TResult, UResult> ResConv) {
    return (arg1, arg2, arg3, arg4, arg5, arg6) => ResConv(F(ArgConv1(arg1), ArgConv2(arg2), ArgConv3(arg3), ArgConv4(arg4), ArgConv5(arg5), ArgConv6(arg6)));
  }
}
namespace _System {

  public partial class nat {
    private static readonly Dafny.TypeDescriptor<BigInteger> _TYPE = new Dafny.TypeDescriptor<BigInteger>(BigInteger.Zero);
    public static Dafny.TypeDescriptor<BigInteger> _TypeDescriptor() {
      return _TYPE;
    }
  }
} // end of namespace _System
namespace software.amazon.cryptography.keystore.internaldafny.types {

  public interface _IDafnyCallEvent<I, O> {
    bool is_DafnyCallEvent { get; }
    I dtor_input { get; }
    O dtor_output { get; }
    _IDafnyCallEvent<__I, __O> DowncastClone<__I, __O>(Func<I, __I> converter0, Func<O, __O> converter1);
  }
  public class DafnyCallEvent<I, O> : _IDafnyCallEvent<I, O> {
    public readonly I _input;
    public readonly O _output;
    public DafnyCallEvent(I input, O output) {
      this._input = input;
      this._output = output;
    }
    public _IDafnyCallEvent<__I, __O> DowncastClone<__I, __O>(Func<I, __I> converter0, Func<O, __O> converter1) {
      if (this is _IDafnyCallEvent<__I, __O> dt) { return dt; }
      return new DafnyCallEvent<__I, __O>(converter0(_input), converter1(_output));
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.keystore.internaldafny.types.DafnyCallEvent<I, O>;
      return oth != null && object.Equals(this._input, oth._input) && object.Equals(this._output, oth._output);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._input));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._output));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.keystore.internaldafny.types_Compile.DafnyCallEvent.DafnyCallEvent";
      s += "(";
      s += Dafny.Helpers.ToString(this._input);
      s += ", ";
      s += Dafny.Helpers.ToString(this._output);
      s += ")";
      return s;
    }
    public static software.amazon.cryptography.keystore.internaldafny.types._IDafnyCallEvent<I, O> Default(I _default_I, O _default_O) {
      return create(_default_I, _default_O);
    }
    public static Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IDafnyCallEvent<I, O>> _TypeDescriptor(Dafny.TypeDescriptor<I> _td_I, Dafny.TypeDescriptor<O> _td_O) {
      return new Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IDafnyCallEvent<I, O>>(software.amazon.cryptography.keystore.internaldafny.types.DafnyCallEvent<I, O>.Default(_td_I.Default(), _td_O.Default()));
    }
    public static _IDafnyCallEvent<I, O> create(I input, O output) {
      return new DafnyCallEvent<I, O>(input, output);
    }
    public static _IDafnyCallEvent<I, O> create_DafnyCallEvent(I input, O output) {
      return create(input, output);
    }
    public bool is_DafnyCallEvent { get { return true; } }
    public I dtor_input {
      get {
        return this._input;
      }
    }
    public O dtor_output {
      get {
        return this._output;
      }
    }
  }

  public interface _IBeaconKeyMaterials {
    bool is_BeaconKeyMaterials { get; }
    Dafny.ISequence<char> dtor_beaconKeyIdentifier { get; }
    Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_beaconKey { get; }
    Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>> dtor_hmacKeys { get; }
    _IBeaconKeyMaterials DowncastClone();
  }
  public class BeaconKeyMaterials : _IBeaconKeyMaterials {
    public readonly Dafny.ISequence<char> _beaconKeyIdentifier;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _encryptionContext;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<byte>> _beaconKey;
    public readonly Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>> _hmacKeys;
    public BeaconKeyMaterials(Dafny.ISequence<char> beaconKeyIdentifier, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Wrappers_Compile._IOption<Dafny.ISequence<byte>> beaconKey, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>> hmacKeys) {
      this._beaconKeyIdentifier = beaconKeyIdentifier;
      this._encryptionContext = encryptionContext;
      this._beaconKey = beaconKey;
      this._hmacKeys = hmacKeys;
    }
    public _IBeaconKeyMaterials DowncastClone() {
      if (this is _IBeaconKeyMaterials dt) { return dt; }
      return new BeaconKeyMaterials(_beaconKeyIdentifier, _encryptionContext, _beaconKey, _hmacKeys);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.keystore.internaldafny.types.BeaconKeyMaterials;
      return oth != null && object.Equals(this._beaconKeyIdentifier, oth._beaconKeyIdentifier) && object.Equals(this._encryptionContext, oth._encryptionContext) && object.Equals(this._beaconKey, oth._beaconKey) && object.Equals(this._hmacKeys, oth._hmacKeys);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._beaconKeyIdentifier));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._beaconKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._hmacKeys));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.keystore.internaldafny.types_Compile.BeaconKeyMaterials.BeaconKeyMaterials";
      s += "(";
      s += Dafny.Helpers.ToString(this._beaconKeyIdentifier);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this._beaconKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this._hmacKeys);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default(), Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>>.Default());
    public static software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials>(software.amazon.cryptography.keystore.internaldafny.types.BeaconKeyMaterials.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IBeaconKeyMaterials create(Dafny.ISequence<char> beaconKeyIdentifier, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Wrappers_Compile._IOption<Dafny.ISequence<byte>> beaconKey, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>> hmacKeys) {
      return new BeaconKeyMaterials(beaconKeyIdentifier, encryptionContext, beaconKey, hmacKeys);
    }
    public static _IBeaconKeyMaterials create_BeaconKeyMaterials(Dafny.ISequence<char> beaconKeyIdentifier, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Wrappers_Compile._IOption<Dafny.ISequence<byte>> beaconKey, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>> hmacKeys) {
      return create(beaconKeyIdentifier, encryptionContext, beaconKey, hmacKeys);
    }
    public bool is_BeaconKeyMaterials { get { return true; } }
    public Dafny.ISequence<char> dtor_beaconKeyIdentifier {
      get {
        return this._beaconKeyIdentifier;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this._encryptionContext;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_beaconKey {
      get {
        return this._beaconKey;
      }
    }
    public Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>> dtor_hmacKeys {
      get {
        return this._hmacKeys;
      }
    }
  }

  public interface _IBranchKeyMaterials {
    bool is_BranchKeyMaterials { get; }
    Dafny.ISequence<char> dtor_branchKeyIdentifier { get; }
    Dafny.ISequence<byte> dtor_branchKeyVersion { get; }
    Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext { get; }
    Dafny.ISequence<byte> dtor_branchKey { get; }
    _IBranchKeyMaterials DowncastClone();
  }
  public class BranchKeyMaterials : _IBranchKeyMaterials {
    public readonly Dafny.ISequence<char> _branchKeyIdentifier;
    public readonly Dafny.ISequence<byte> _branchKeyVersion;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _encryptionContext;
    public readonly Dafny.ISequence<byte> _branchKey;
    public BranchKeyMaterials(Dafny.ISequence<char> branchKeyIdentifier, Dafny.ISequence<byte> branchKeyVersion, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<byte> branchKey) {
      this._branchKeyIdentifier = branchKeyIdentifier;
      this._branchKeyVersion = branchKeyVersion;
      this._encryptionContext = encryptionContext;
      this._branchKey = branchKey;
    }
    public _IBranchKeyMaterials DowncastClone() {
      if (this is _IBranchKeyMaterials dt) { return dt; }
      return new BranchKeyMaterials(_branchKeyIdentifier, _branchKeyVersion, _encryptionContext, _branchKey);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.keystore.internaldafny.types.BranchKeyMaterials;
      return oth != null && object.Equals(this._branchKeyIdentifier, oth._branchKeyIdentifier) && object.Equals(this._branchKeyVersion, oth._branchKeyVersion) && object.Equals(this._encryptionContext, oth._encryptionContext) && object.Equals(this._branchKey, oth._branchKey);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._branchKeyIdentifier));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._branchKeyVersion));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._branchKey));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.keystore.internaldafny.types_Compile.BranchKeyMaterials.BranchKeyMaterials";
      s += "(";
      s += Dafny.Helpers.ToString(this._branchKeyIdentifier);
      s += ", ";
      s += Dafny.Helpers.ToString(this._branchKeyVersion);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this._branchKey);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials theDefault = create(Dafny.Sequence<char>.Empty, UTF8.ValidUTF8Bytes.Default(), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Dafny.Sequence<byte>.Empty);
    public static software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials>(software.amazon.cryptography.keystore.internaldafny.types.BranchKeyMaterials.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IBranchKeyMaterials create(Dafny.ISequence<char> branchKeyIdentifier, Dafny.ISequence<byte> branchKeyVersion, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<byte> branchKey) {
      return new BranchKeyMaterials(branchKeyIdentifier, branchKeyVersion, encryptionContext, branchKey);
    }
    public static _IBranchKeyMaterials create_BranchKeyMaterials(Dafny.ISequence<char> branchKeyIdentifier, Dafny.ISequence<byte> branchKeyVersion, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<byte> branchKey) {
      return create(branchKeyIdentifier, branchKeyVersion, encryptionContext, branchKey);
    }
    public bool is_BranchKeyMaterials { get { return true; } }
    public Dafny.ISequence<char> dtor_branchKeyIdentifier {
      get {
        return this._branchKeyIdentifier;
      }
    }
    public Dafny.ISequence<byte> dtor_branchKeyVersion {
      get {
        return this._branchKeyVersion;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this._encryptionContext;
      }
    }
    public Dafny.ISequence<byte> dtor_branchKey {
      get {
        return this._branchKey;
      }
    }
  }

  public interface _ICreateKeyInput {
    bool is_CreateKeyInput { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_branchKeyIdentifier { get; }
    Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> dtor_encryptionContext { get; }
    _ICreateKeyInput DowncastClone();
  }
  public class CreateKeyInput : _ICreateKeyInput {
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<char>> _branchKeyIdentifier;
    public readonly Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> _encryptionContext;
    public CreateKeyInput(Wrappers_Compile._IOption<Dafny.ISequence<char>> branchKeyIdentifier, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> encryptionContext) {
      this._branchKeyIdentifier = branchKeyIdentifier;
      this._encryptionContext = encryptionContext;
    }
    public _ICreateKeyInput DowncastClone() {
      if (this is _ICreateKeyInput dt) { return dt; }
      return new CreateKeyInput(_branchKeyIdentifier, _encryptionContext);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.keystore.internaldafny.types.CreateKeyInput;
      return oth != null && object.Equals(this._branchKeyIdentifier, oth._branchKeyIdentifier) && object.Equals(this._encryptionContext, oth._encryptionContext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._branchKeyIdentifier));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptionContext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.keystore.internaldafny.types_Compile.CreateKeyInput.CreateKeyInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._branchKeyIdentifier);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptionContext);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyInput theDefault = create(Wrappers_Compile.Option<Dafny.ISequence<char>>.Default(), Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>.Default());
    public static software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyInput>(software.amazon.cryptography.keystore.internaldafny.types.CreateKeyInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICreateKeyInput create(Wrappers_Compile._IOption<Dafny.ISequence<char>> branchKeyIdentifier, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> encryptionContext) {
      return new CreateKeyInput(branchKeyIdentifier, encryptionContext);
    }
    public static _ICreateKeyInput create_CreateKeyInput(Wrappers_Compile._IOption<Dafny.ISequence<char>> branchKeyIdentifier, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> encryptionContext) {
      return create(branchKeyIdentifier, encryptionContext);
    }
    public bool is_CreateKeyInput { get { return true; } }
    public Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_branchKeyIdentifier {
      get {
        return this._branchKeyIdentifier;
      }
    }
    public Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> dtor_encryptionContext {
      get {
        return this._encryptionContext;
      }
    }
  }

  public interface _ICreateKeyOutput {
    bool is_CreateKeyOutput { get; }
    Dafny.ISequence<char> dtor_branchKeyIdentifier { get; }
    _ICreateKeyOutput DowncastClone();
  }
  public class CreateKeyOutput : _ICreateKeyOutput {
    public readonly Dafny.ISequence<char> _branchKeyIdentifier;
    public CreateKeyOutput(Dafny.ISequence<char> branchKeyIdentifier) {
      this._branchKeyIdentifier = branchKeyIdentifier;
    }
    public _ICreateKeyOutput DowncastClone() {
      if (this is _ICreateKeyOutput dt) { return dt; }
      return new CreateKeyOutput(_branchKeyIdentifier);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.keystore.internaldafny.types.CreateKeyOutput;
      return oth != null && object.Equals(this._branchKeyIdentifier, oth._branchKeyIdentifier);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._branchKeyIdentifier));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.keystore.internaldafny.types_Compile.CreateKeyOutput.CreateKeyOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._branchKeyIdentifier);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput theDefault = create(Dafny.Sequence<char>.Empty);
    public static software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput>(software.amazon.cryptography.keystore.internaldafny.types.CreateKeyOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICreateKeyOutput create(Dafny.ISequence<char> branchKeyIdentifier) {
      return new CreateKeyOutput(branchKeyIdentifier);
    }
    public static _ICreateKeyOutput create_CreateKeyOutput(Dafny.ISequence<char> branchKeyIdentifier) {
      return create(branchKeyIdentifier);
    }
    public bool is_CreateKeyOutput { get { return true; } }
    public Dafny.ISequence<char> dtor_branchKeyIdentifier {
      get {
        return this._branchKeyIdentifier;
      }
    }
  }

  public interface _ICreateKeyStoreInput {
    bool is_CreateKeyStoreInput { get; }
    _ICreateKeyStoreInput DowncastClone();
  }
  public class CreateKeyStoreInput : _ICreateKeyStoreInput {
    public CreateKeyStoreInput() {
    }
    public _ICreateKeyStoreInput DowncastClone() {
      if (this is _ICreateKeyStoreInput dt) { return dt; }
      return new CreateKeyStoreInput();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.keystore.internaldafny.types.CreateKeyStoreInput;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.keystore.internaldafny.types_Compile.CreateKeyStoreInput.CreateKeyStoreInput";
      return s;
    }
    private static readonly software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreInput theDefault = create();
    public static software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreInput>(software.amazon.cryptography.keystore.internaldafny.types.CreateKeyStoreInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICreateKeyStoreInput create() {
      return new CreateKeyStoreInput();
    }
    public static _ICreateKeyStoreInput create_CreateKeyStoreInput() {
      return create();
    }
    public bool is_CreateKeyStoreInput { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_ICreateKeyStoreInput> AllSingletonConstructors {
      get {
        yield return CreateKeyStoreInput.create();
      }
    }
  }

  public interface _ICreateKeyStoreOutput {
    bool is_CreateKeyStoreOutput { get; }
    Dafny.ISequence<char> dtor_tableArn { get; }
    _ICreateKeyStoreOutput DowncastClone();
  }
  public class CreateKeyStoreOutput : _ICreateKeyStoreOutput {
    public readonly Dafny.ISequence<char> _tableArn;
    public CreateKeyStoreOutput(Dafny.ISequence<char> tableArn) {
      this._tableArn = tableArn;
    }
    public _ICreateKeyStoreOutput DowncastClone() {
      if (this is _ICreateKeyStoreOutput dt) { return dt; }
      return new CreateKeyStoreOutput(_tableArn);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.keystore.internaldafny.types.CreateKeyStoreOutput;
      return oth != null && object.Equals(this._tableArn, oth._tableArn);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._tableArn));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.keystore.internaldafny.types_Compile.CreateKeyStoreOutput.CreateKeyStoreOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._tableArn);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreOutput theDefault = create(Dafny.Sequence<char>.Empty);
    public static software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreOutput>(software.amazon.cryptography.keystore.internaldafny.types.CreateKeyStoreOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICreateKeyStoreOutput create(Dafny.ISequence<char> tableArn) {
      return new CreateKeyStoreOutput(tableArn);
    }
    public static _ICreateKeyStoreOutput create_CreateKeyStoreOutput(Dafny.ISequence<char> tableArn) {
      return create(tableArn);
    }
    public bool is_CreateKeyStoreOutput { get { return true; } }
    public Dafny.ISequence<char> dtor_tableArn {
      get {
        return this._tableArn;
      }
    }
  }

  public interface _IGetActiveBranchKeyInput {
    bool is_GetActiveBranchKeyInput { get; }
    Dafny.ISequence<char> dtor_branchKeyIdentifier { get; }
    _IGetActiveBranchKeyInput DowncastClone();
  }
  public class GetActiveBranchKeyInput : _IGetActiveBranchKeyInput {
    public readonly Dafny.ISequence<char> _branchKeyIdentifier;
    public GetActiveBranchKeyInput(Dafny.ISequence<char> branchKeyIdentifier) {
      this._branchKeyIdentifier = branchKeyIdentifier;
    }
    public _IGetActiveBranchKeyInput DowncastClone() {
      if (this is _IGetActiveBranchKeyInput dt) { return dt; }
      return new GetActiveBranchKeyInput(_branchKeyIdentifier);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.keystore.internaldafny.types.GetActiveBranchKeyInput;
      return oth != null && object.Equals(this._branchKeyIdentifier, oth._branchKeyIdentifier);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._branchKeyIdentifier));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.keystore.internaldafny.types_Compile.GetActiveBranchKeyInput.GetActiveBranchKeyInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._branchKeyIdentifier);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyInput theDefault = create(Dafny.Sequence<char>.Empty);
    public static software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyInput>(software.amazon.cryptography.keystore.internaldafny.types.GetActiveBranchKeyInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetActiveBranchKeyInput create(Dafny.ISequence<char> branchKeyIdentifier) {
      return new GetActiveBranchKeyInput(branchKeyIdentifier);
    }
    public static _IGetActiveBranchKeyInput create_GetActiveBranchKeyInput(Dafny.ISequence<char> branchKeyIdentifier) {
      return create(branchKeyIdentifier);
    }
    public bool is_GetActiveBranchKeyInput { get { return true; } }
    public Dafny.ISequence<char> dtor_branchKeyIdentifier {
      get {
        return this._branchKeyIdentifier;
      }
    }
  }

  public interface _IGetActiveBranchKeyOutput {
    bool is_GetActiveBranchKeyOutput { get; }
    software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials dtor_branchKeyMaterials { get; }
    _IGetActiveBranchKeyOutput DowncastClone();
  }
  public class GetActiveBranchKeyOutput : _IGetActiveBranchKeyOutput {
    public readonly software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials _branchKeyMaterials;
    public GetActiveBranchKeyOutput(software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials branchKeyMaterials) {
      this._branchKeyMaterials = branchKeyMaterials;
    }
    public _IGetActiveBranchKeyOutput DowncastClone() {
      if (this is _IGetActiveBranchKeyOutput dt) { return dt; }
      return new GetActiveBranchKeyOutput(_branchKeyMaterials);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.keystore.internaldafny.types.GetActiveBranchKeyOutput;
      return oth != null && object.Equals(this._branchKeyMaterials, oth._branchKeyMaterials);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._branchKeyMaterials));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.keystore.internaldafny.types_Compile.GetActiveBranchKeyOutput.GetActiveBranchKeyOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._branchKeyMaterials);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput theDefault = create(software.amazon.cryptography.keystore.internaldafny.types.BranchKeyMaterials.Default());
    public static software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput>(software.amazon.cryptography.keystore.internaldafny.types.GetActiveBranchKeyOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetActiveBranchKeyOutput create(software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials branchKeyMaterials) {
      return new GetActiveBranchKeyOutput(branchKeyMaterials);
    }
    public static _IGetActiveBranchKeyOutput create_GetActiveBranchKeyOutput(software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials branchKeyMaterials) {
      return create(branchKeyMaterials);
    }
    public bool is_GetActiveBranchKeyOutput { get { return true; } }
    public software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials dtor_branchKeyMaterials {
      get {
        return this._branchKeyMaterials;
      }
    }
  }

  public interface _IGetBeaconKeyInput {
    bool is_GetBeaconKeyInput { get; }
    Dafny.ISequence<char> dtor_branchKeyIdentifier { get; }
    _IGetBeaconKeyInput DowncastClone();
  }
  public class GetBeaconKeyInput : _IGetBeaconKeyInput {
    public readonly Dafny.ISequence<char> _branchKeyIdentifier;
    public GetBeaconKeyInput(Dafny.ISequence<char> branchKeyIdentifier) {
      this._branchKeyIdentifier = branchKeyIdentifier;
    }
    public _IGetBeaconKeyInput DowncastClone() {
      if (this is _IGetBeaconKeyInput dt) { return dt; }
      return new GetBeaconKeyInput(_branchKeyIdentifier);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.keystore.internaldafny.types.GetBeaconKeyInput;
      return oth != null && object.Equals(this._branchKeyIdentifier, oth._branchKeyIdentifier);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._branchKeyIdentifier));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.keystore.internaldafny.types_Compile.GetBeaconKeyInput.GetBeaconKeyInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._branchKeyIdentifier);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyInput theDefault = create(Dafny.Sequence<char>.Empty);
    public static software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyInput>(software.amazon.cryptography.keystore.internaldafny.types.GetBeaconKeyInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetBeaconKeyInput create(Dafny.ISequence<char> branchKeyIdentifier) {
      return new GetBeaconKeyInput(branchKeyIdentifier);
    }
    public static _IGetBeaconKeyInput create_GetBeaconKeyInput(Dafny.ISequence<char> branchKeyIdentifier) {
      return create(branchKeyIdentifier);
    }
    public bool is_GetBeaconKeyInput { get { return true; } }
    public Dafny.ISequence<char> dtor_branchKeyIdentifier {
      get {
        return this._branchKeyIdentifier;
      }
    }
  }

  public interface _IGetBeaconKeyOutput {
    bool is_GetBeaconKeyOutput { get; }
    software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials dtor_beaconKeyMaterials { get; }
    _IGetBeaconKeyOutput DowncastClone();
  }
  public class GetBeaconKeyOutput : _IGetBeaconKeyOutput {
    public readonly software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials _beaconKeyMaterials;
    public GetBeaconKeyOutput(software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials beaconKeyMaterials) {
      this._beaconKeyMaterials = beaconKeyMaterials;
    }
    public _IGetBeaconKeyOutput DowncastClone() {
      if (this is _IGetBeaconKeyOutput dt) { return dt; }
      return new GetBeaconKeyOutput(_beaconKeyMaterials);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.keystore.internaldafny.types.GetBeaconKeyOutput;
      return oth != null && object.Equals(this._beaconKeyMaterials, oth._beaconKeyMaterials);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._beaconKeyMaterials));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.keystore.internaldafny.types_Compile.GetBeaconKeyOutput.GetBeaconKeyOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._beaconKeyMaterials);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput theDefault = create(software.amazon.cryptography.keystore.internaldafny.types.BeaconKeyMaterials.Default());
    public static software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput>(software.amazon.cryptography.keystore.internaldafny.types.GetBeaconKeyOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetBeaconKeyOutput create(software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials beaconKeyMaterials) {
      return new GetBeaconKeyOutput(beaconKeyMaterials);
    }
    public static _IGetBeaconKeyOutput create_GetBeaconKeyOutput(software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials beaconKeyMaterials) {
      return create(beaconKeyMaterials);
    }
    public bool is_GetBeaconKeyOutput { get { return true; } }
    public software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials dtor_beaconKeyMaterials {
      get {
        return this._beaconKeyMaterials;
      }
    }
  }

  public interface _IGetBranchKeyVersionInput {
    bool is_GetBranchKeyVersionInput { get; }
    Dafny.ISequence<char> dtor_branchKeyIdentifier { get; }
    Dafny.ISequence<char> dtor_branchKeyVersion { get; }
    _IGetBranchKeyVersionInput DowncastClone();
  }
  public class GetBranchKeyVersionInput : _IGetBranchKeyVersionInput {
    public readonly Dafny.ISequence<char> _branchKeyIdentifier;
    public readonly Dafny.ISequence<char> _branchKeyVersion;
    public GetBranchKeyVersionInput(Dafny.ISequence<char> branchKeyIdentifier, Dafny.ISequence<char> branchKeyVersion) {
      this._branchKeyIdentifier = branchKeyIdentifier;
      this._branchKeyVersion = branchKeyVersion;
    }
    public _IGetBranchKeyVersionInput DowncastClone() {
      if (this is _IGetBranchKeyVersionInput dt) { return dt; }
      return new GetBranchKeyVersionInput(_branchKeyIdentifier, _branchKeyVersion);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.keystore.internaldafny.types.GetBranchKeyVersionInput;
      return oth != null && object.Equals(this._branchKeyIdentifier, oth._branchKeyIdentifier) && object.Equals(this._branchKeyVersion, oth._branchKeyVersion);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._branchKeyIdentifier));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._branchKeyVersion));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.keystore.internaldafny.types_Compile.GetBranchKeyVersionInput.GetBranchKeyVersionInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._branchKeyIdentifier);
      s += ", ";
      s += Dafny.Helpers.ToString(this._branchKeyVersion);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionInput theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty);
    public static software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionInput>(software.amazon.cryptography.keystore.internaldafny.types.GetBranchKeyVersionInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetBranchKeyVersionInput create(Dafny.ISequence<char> branchKeyIdentifier, Dafny.ISequence<char> branchKeyVersion) {
      return new GetBranchKeyVersionInput(branchKeyIdentifier, branchKeyVersion);
    }
    public static _IGetBranchKeyVersionInput create_GetBranchKeyVersionInput(Dafny.ISequence<char> branchKeyIdentifier, Dafny.ISequence<char> branchKeyVersion) {
      return create(branchKeyIdentifier, branchKeyVersion);
    }
    public bool is_GetBranchKeyVersionInput { get { return true; } }
    public Dafny.ISequence<char> dtor_branchKeyIdentifier {
      get {
        return this._branchKeyIdentifier;
      }
    }
    public Dafny.ISequence<char> dtor_branchKeyVersion {
      get {
        return this._branchKeyVersion;
      }
    }
  }

  public interface _IGetBranchKeyVersionOutput {
    bool is_GetBranchKeyVersionOutput { get; }
    software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials dtor_branchKeyMaterials { get; }
    _IGetBranchKeyVersionOutput DowncastClone();
  }
  public class GetBranchKeyVersionOutput : _IGetBranchKeyVersionOutput {
    public readonly software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials _branchKeyMaterials;
    public GetBranchKeyVersionOutput(software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials branchKeyMaterials) {
      this._branchKeyMaterials = branchKeyMaterials;
    }
    public _IGetBranchKeyVersionOutput DowncastClone() {
      if (this is _IGetBranchKeyVersionOutput dt) { return dt; }
      return new GetBranchKeyVersionOutput(_branchKeyMaterials);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.keystore.internaldafny.types.GetBranchKeyVersionOutput;
      return oth != null && object.Equals(this._branchKeyMaterials, oth._branchKeyMaterials);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._branchKeyMaterials));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.keystore.internaldafny.types_Compile.GetBranchKeyVersionOutput.GetBranchKeyVersionOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._branchKeyMaterials);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput theDefault = create(software.amazon.cryptography.keystore.internaldafny.types.BranchKeyMaterials.Default());
    public static software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput>(software.amazon.cryptography.keystore.internaldafny.types.GetBranchKeyVersionOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetBranchKeyVersionOutput create(software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials branchKeyMaterials) {
      return new GetBranchKeyVersionOutput(branchKeyMaterials);
    }
    public static _IGetBranchKeyVersionOutput create_GetBranchKeyVersionOutput(software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials branchKeyMaterials) {
      return create(branchKeyMaterials);
    }
    public bool is_GetBranchKeyVersionOutput { get { return true; } }
    public software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials dtor_branchKeyMaterials {
      get {
        return this._branchKeyMaterials;
      }
    }
  }

  public interface _IGetKeyStoreInfoOutput {
    bool is_GetKeyStoreInfoOutput { get; }
    Dafny.ISequence<char> dtor_keyStoreId { get; }
    Dafny.ISequence<char> dtor_keyStoreName { get; }
    Dafny.ISequence<char> dtor_logicalKeyStoreName { get; }
    Dafny.ISequence<Dafny.ISequence<char>> dtor_grantTokens { get; }
    software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration dtor_kmsConfiguration { get; }
    _IGetKeyStoreInfoOutput DowncastClone();
  }
  public class GetKeyStoreInfoOutput : _IGetKeyStoreInfoOutput {
    public readonly Dafny.ISequence<char> _keyStoreId;
    public readonly Dafny.ISequence<char> _keyStoreName;
    public readonly Dafny.ISequence<char> _logicalKeyStoreName;
    public readonly Dafny.ISequence<Dafny.ISequence<char>> _grantTokens;
    public readonly software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration _kmsConfiguration;
    public GetKeyStoreInfoOutput(Dafny.ISequence<char> keyStoreId, Dafny.ISequence<char> keyStoreName, Dafny.ISequence<char> logicalKeyStoreName, Dafny.ISequence<Dafny.ISequence<char>> grantTokens, software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration kmsConfiguration) {
      this._keyStoreId = keyStoreId;
      this._keyStoreName = keyStoreName;
      this._logicalKeyStoreName = logicalKeyStoreName;
      this._grantTokens = grantTokens;
      this._kmsConfiguration = kmsConfiguration;
    }
    public _IGetKeyStoreInfoOutput DowncastClone() {
      if (this is _IGetKeyStoreInfoOutput dt) { return dt; }
      return new GetKeyStoreInfoOutput(_keyStoreId, _keyStoreName, _logicalKeyStoreName, _grantTokens, _kmsConfiguration);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.keystore.internaldafny.types.GetKeyStoreInfoOutput;
      return oth != null && object.Equals(this._keyStoreId, oth._keyStoreId) && object.Equals(this._keyStoreName, oth._keyStoreName) && object.Equals(this._logicalKeyStoreName, oth._logicalKeyStoreName) && object.Equals(this._grantTokens, oth._grantTokens) && object.Equals(this._kmsConfiguration, oth._kmsConfiguration);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keyStoreId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keyStoreName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._logicalKeyStoreName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._grantTokens));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._kmsConfiguration));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.keystore.internaldafny.types_Compile.GetKeyStoreInfoOutput.GetKeyStoreInfoOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._keyStoreId);
      s += ", ";
      s += Dafny.Helpers.ToString(this._keyStoreName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._logicalKeyStoreName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._grantTokens);
      s += ", ";
      s += Dafny.Helpers.ToString(this._kmsConfiguration);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.keystore.internaldafny.types._IGetKeyStoreInfoOutput theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, Dafny.Sequence<Dafny.ISequence<char>>.Empty, software.amazon.cryptography.keystore.internaldafny.types.KMSConfiguration.Default());
    public static software.amazon.cryptography.keystore.internaldafny.types._IGetKeyStoreInfoOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IGetKeyStoreInfoOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IGetKeyStoreInfoOutput>(software.amazon.cryptography.keystore.internaldafny.types.GetKeyStoreInfoOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IGetKeyStoreInfoOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetKeyStoreInfoOutput create(Dafny.ISequence<char> keyStoreId, Dafny.ISequence<char> keyStoreName, Dafny.ISequence<char> logicalKeyStoreName, Dafny.ISequence<Dafny.ISequence<char>> grantTokens, software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration kmsConfiguration) {
      return new GetKeyStoreInfoOutput(keyStoreId, keyStoreName, logicalKeyStoreName, grantTokens, kmsConfiguration);
    }
    public static _IGetKeyStoreInfoOutput create_GetKeyStoreInfoOutput(Dafny.ISequence<char> keyStoreId, Dafny.ISequence<char> keyStoreName, Dafny.ISequence<char> logicalKeyStoreName, Dafny.ISequence<Dafny.ISequence<char>> grantTokens, software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration kmsConfiguration) {
      return create(keyStoreId, keyStoreName, logicalKeyStoreName, grantTokens, kmsConfiguration);
    }
    public bool is_GetKeyStoreInfoOutput { get { return true; } }
    public Dafny.ISequence<char> dtor_keyStoreId {
      get {
        return this._keyStoreId;
      }
    }
    public Dafny.ISequence<char> dtor_keyStoreName {
      get {
        return this._keyStoreName;
      }
    }
    public Dafny.ISequence<char> dtor_logicalKeyStoreName {
      get {
        return this._logicalKeyStoreName;
      }
    }
    public Dafny.ISequence<Dafny.ISequence<char>> dtor_grantTokens {
      get {
        return this._grantTokens;
      }
    }
    public software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration dtor_kmsConfiguration {
      get {
        return this._kmsConfiguration;
      }
    }
  }

  public partial class IKeyStoreClientCallHistory {
    public IKeyStoreClientCallHistory() {
    }
  }

  public interface IKeyStoreClient {
    Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetKeyStoreInfoOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> GetKeyStoreInfo();
    Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> CreateKeyStore(software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> CreateKey(software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> VersionKey(software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> GetActiveBranchKey(software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> GetBranchKeyVersion(software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> GetBeaconKey(software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyInput input);
  }
  public class _Companion_IKeyStoreClient {
  }

  public interface _IKeyStoreConfig {
    bool is_KeyStoreConfig { get; }
    Dafny.ISequence<char> dtor_ddbTableName { get; }
    software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration dtor_kmsConfiguration { get; }
    Dafny.ISequence<char> dtor_logicalKeyStoreName { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_id { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient> dtor_ddbClient { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient> dtor_kmsClient { get; }
    _IKeyStoreConfig DowncastClone();
  }
  public class KeyStoreConfig : _IKeyStoreConfig {
    public readonly Dafny.ISequence<char> _ddbTableName;
    public readonly software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration _kmsConfiguration;
    public readonly Dafny.ISequence<char> _logicalKeyStoreName;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<char>> _id;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> _grantTokens;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient> _ddbClient;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient> _kmsClient;
    public KeyStoreConfig(Dafny.ISequence<char> ddbTableName, software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration kmsConfiguration, Dafny.ISequence<char> logicalKeyStoreName, Wrappers_Compile._IOption<Dafny.ISequence<char>> id, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens, Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient> ddbClient, Wrappers_Compile._IOption<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient> kmsClient) {
      this._ddbTableName = ddbTableName;
      this._kmsConfiguration = kmsConfiguration;
      this._logicalKeyStoreName = logicalKeyStoreName;
      this._id = id;
      this._grantTokens = grantTokens;
      this._ddbClient = ddbClient;
      this._kmsClient = kmsClient;
    }
    public _IKeyStoreConfig DowncastClone() {
      if (this is _IKeyStoreConfig dt) { return dt; }
      return new KeyStoreConfig(_ddbTableName, _kmsConfiguration, _logicalKeyStoreName, _id, _grantTokens, _ddbClient, _kmsClient);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.keystore.internaldafny.types.KeyStoreConfig;
      return oth != null && object.Equals(this._ddbTableName, oth._ddbTableName) && object.Equals(this._kmsConfiguration, oth._kmsConfiguration) && object.Equals(this._logicalKeyStoreName, oth._logicalKeyStoreName) && object.Equals(this._id, oth._id) && object.Equals(this._grantTokens, oth._grantTokens) && object.Equals(this._ddbClient, oth._ddbClient) && object.Equals(this._kmsClient, oth._kmsClient);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._ddbTableName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._kmsConfiguration));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._logicalKeyStoreName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._id));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._grantTokens));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._ddbClient));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._kmsClient));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.keystore.internaldafny.types_Compile.KeyStoreConfig.KeyStoreConfig";
      s += "(";
      s += Dafny.Helpers.ToString(this._ddbTableName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._kmsConfiguration);
      s += ", ";
      s += Dafny.Helpers.ToString(this._logicalKeyStoreName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._id);
      s += ", ";
      s += Dafny.Helpers.ToString(this._grantTokens);
      s += ", ";
      s += Dafny.Helpers.ToString(this._ddbClient);
      s += ", ";
      s += Dafny.Helpers.ToString(this._kmsClient);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.keystore.internaldafny.types._IKeyStoreConfig theDefault = create(Dafny.Sequence<char>.Empty, software.amazon.cryptography.keystore.internaldafny.types.KMSConfiguration.Default(), Dafny.Sequence<char>.Empty, Wrappers_Compile.Option<Dafny.ISequence<char>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.Default(), Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient>.Default(), Wrappers_Compile.Option<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient>.Default());
    public static software.amazon.cryptography.keystore.internaldafny.types._IKeyStoreConfig Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IKeyStoreConfig> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IKeyStoreConfig>(software.amazon.cryptography.keystore.internaldafny.types.KeyStoreConfig.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IKeyStoreConfig> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IKeyStoreConfig create(Dafny.ISequence<char> ddbTableName, software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration kmsConfiguration, Dafny.ISequence<char> logicalKeyStoreName, Wrappers_Compile._IOption<Dafny.ISequence<char>> id, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens, Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient> ddbClient, Wrappers_Compile._IOption<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient> kmsClient) {
      return new KeyStoreConfig(ddbTableName, kmsConfiguration, logicalKeyStoreName, id, grantTokens, ddbClient, kmsClient);
    }
    public static _IKeyStoreConfig create_KeyStoreConfig(Dafny.ISequence<char> ddbTableName, software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration kmsConfiguration, Dafny.ISequence<char> logicalKeyStoreName, Wrappers_Compile._IOption<Dafny.ISequence<char>> id, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens, Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient> ddbClient, Wrappers_Compile._IOption<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient> kmsClient) {
      return create(ddbTableName, kmsConfiguration, logicalKeyStoreName, id, grantTokens, ddbClient, kmsClient);
    }
    public bool is_KeyStoreConfig { get { return true; } }
    public Dafny.ISequence<char> dtor_ddbTableName {
      get {
        return this._ddbTableName;
      }
    }
    public software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration dtor_kmsConfiguration {
      get {
        return this._kmsConfiguration;
      }
    }
    public Dafny.ISequence<char> dtor_logicalKeyStoreName {
      get {
        return this._logicalKeyStoreName;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_id {
      get {
        return this._id;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens {
      get {
        return this._grantTokens;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient> dtor_ddbClient {
      get {
        return this._ddbClient;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient> dtor_kmsClient {
      get {
        return this._kmsClient;
      }
    }
  }

  public interface _IKMSConfiguration {
    bool is_kmsKeyArn { get; }
    Dafny.ISequence<char> dtor_kmsKeyArn { get; }
    _IKMSConfiguration DowncastClone();
  }
  public class KMSConfiguration : _IKMSConfiguration {
    public readonly Dafny.ISequence<char> _kmsKeyArn;
    public KMSConfiguration(Dafny.ISequence<char> kmsKeyArn) {
      this._kmsKeyArn = kmsKeyArn;
    }
    public _IKMSConfiguration DowncastClone() {
      if (this is _IKMSConfiguration dt) { return dt; }
      return new KMSConfiguration(_kmsKeyArn);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.keystore.internaldafny.types.KMSConfiguration;
      return oth != null && object.Equals(this._kmsKeyArn, oth._kmsKeyArn);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._kmsKeyArn));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.keystore.internaldafny.types_Compile.KMSConfiguration.kmsKeyArn";
      s += "(";
      s += Dafny.Helpers.ToString(this._kmsKeyArn);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration theDefault = create(Dafny.Sequence<char>.Empty);
    public static software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration>(software.amazon.cryptography.keystore.internaldafny.types.KMSConfiguration.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IKMSConfiguration create(Dafny.ISequence<char> kmsKeyArn) {
      return new KMSConfiguration(kmsKeyArn);
    }
    public static _IKMSConfiguration create_kmsKeyArn(Dafny.ISequence<char> kmsKeyArn) {
      return create(kmsKeyArn);
    }
    public bool is_kmsKeyArn { get { return true; } }
    public Dafny.ISequence<char> dtor_kmsKeyArn {
      get {
        return this._kmsKeyArn;
      }
    }
  }

  public interface _IVersionKeyInput {
    bool is_VersionKeyInput { get; }
    Dafny.ISequence<char> dtor_branchKeyIdentifier { get; }
    _IVersionKeyInput DowncastClone();
  }
  public class VersionKeyInput : _IVersionKeyInput {
    public readonly Dafny.ISequence<char> _branchKeyIdentifier;
    public VersionKeyInput(Dafny.ISequence<char> branchKeyIdentifier) {
      this._branchKeyIdentifier = branchKeyIdentifier;
    }
    public _IVersionKeyInput DowncastClone() {
      if (this is _IVersionKeyInput dt) { return dt; }
      return new VersionKeyInput(_branchKeyIdentifier);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.keystore.internaldafny.types.VersionKeyInput;
      return oth != null && object.Equals(this._branchKeyIdentifier, oth._branchKeyIdentifier);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._branchKeyIdentifier));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.keystore.internaldafny.types_Compile.VersionKeyInput.VersionKeyInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._branchKeyIdentifier);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyInput theDefault = create(Dafny.Sequence<char>.Empty);
    public static software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyInput>(software.amazon.cryptography.keystore.internaldafny.types.VersionKeyInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IVersionKeyInput create(Dafny.ISequence<char> branchKeyIdentifier) {
      return new VersionKeyInput(branchKeyIdentifier);
    }
    public static _IVersionKeyInput create_VersionKeyInput(Dafny.ISequence<char> branchKeyIdentifier) {
      return create(branchKeyIdentifier);
    }
    public bool is_VersionKeyInput { get { return true; } }
    public Dafny.ISequence<char> dtor_branchKeyIdentifier {
      get {
        return this._branchKeyIdentifier;
      }
    }
  }

  public interface _IVersionKeyOutput {
    bool is_VersionKeyOutput { get; }
    _IVersionKeyOutput DowncastClone();
  }
  public class VersionKeyOutput : _IVersionKeyOutput {
    public VersionKeyOutput() {
    }
    public _IVersionKeyOutput DowncastClone() {
      if (this is _IVersionKeyOutput dt) { return dt; }
      return new VersionKeyOutput();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.keystore.internaldafny.types.VersionKeyOutput;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.keystore.internaldafny.types_Compile.VersionKeyOutput.VersionKeyOutput";
      return s;
    }
    private static readonly software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput theDefault = create();
    public static software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput>(software.amazon.cryptography.keystore.internaldafny.types.VersionKeyOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IVersionKeyOutput create() {
      return new VersionKeyOutput();
    }
    public static _IVersionKeyOutput create_VersionKeyOutput() {
      return create();
    }
    public bool is_VersionKeyOutput { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_IVersionKeyOutput> AllSingletonConstructors {
      get {
        yield return VersionKeyOutput.create();
      }
    }
  }

  public interface _IError {
    bool is_KeyStoreException { get; }
    bool is_ComAmazonawsDynamodb { get; }
    bool is_ComAmazonawsKms { get; }
    bool is_CollectionOfErrors { get; }
    bool is_Opaque { get; }
    Dafny.ISequence<char> dtor_message { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IError dtor_ComAmazonawsDynamodb { get; }
    software.amazon.cryptography.services.kms.internaldafny.types._IError dtor_ComAmazonawsKms { get; }
    Dafny.ISequence<software.amazon.cryptography.keystore.internaldafny.types._IError> dtor_list { get; }
    object dtor_obj { get; }
    _IError DowncastClone();
  }
  public abstract class Error : _IError {
    public Error() { }
    private static readonly software.amazon.cryptography.keystore.internaldafny.types._IError theDefault = create_KeyStoreException(Dafny.Sequence<char>.Empty);
    public static software.amazon.cryptography.keystore.internaldafny.types._IError Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IError> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IError>(software.amazon.cryptography.keystore.internaldafny.types.Error.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IError> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IError create_KeyStoreException(Dafny.ISequence<char> message) {
      return new Error_KeyStoreException(message);
    }
    public static _IError create_ComAmazonawsDynamodb(software.amazon.cryptography.services.dynamodb.internaldafny.types._IError ComAmazonawsDynamodb) {
      return new Error_ComAmazonawsDynamodb(ComAmazonawsDynamodb);
    }
    public static _IError create_ComAmazonawsKms(software.amazon.cryptography.services.kms.internaldafny.types._IError ComAmazonawsKms) {
      return new Error_ComAmazonawsKms(ComAmazonawsKms);
    }
    public static _IError create_CollectionOfErrors(Dafny.ISequence<software.amazon.cryptography.keystore.internaldafny.types._IError> list, Dafny.ISequence<char> message) {
      return new Error_CollectionOfErrors(list, message);
    }
    public static _IError create_Opaque(object obj) {
      return new Error_Opaque(obj);
    }
    public bool is_KeyStoreException { get { return this is Error_KeyStoreException; } }
    public bool is_ComAmazonawsDynamodb { get { return this is Error_ComAmazonawsDynamodb; } }
    public bool is_ComAmazonawsKms { get { return this is Error_ComAmazonawsKms; } }
    public bool is_CollectionOfErrors { get { return this is Error_CollectionOfErrors; } }
    public bool is_Opaque { get { return this is Error_Opaque; } }
    public Dafny.ISequence<char> dtor_message {
      get {
        var d = this;
        if (d is Error_KeyStoreException) { return ((Error_KeyStoreException)d)._message; }
        return ((Error_CollectionOfErrors)d)._message;
      }
    }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IError dtor_ComAmazonawsDynamodb {
      get {
        var d = this;
        return ((Error_ComAmazonawsDynamodb)d)._ComAmazonawsDynamodb;
      }
    }
    public software.amazon.cryptography.services.kms.internaldafny.types._IError dtor_ComAmazonawsKms {
      get {
        var d = this;
        return ((Error_ComAmazonawsKms)d)._ComAmazonawsKms;
      }
    }
    public Dafny.ISequence<software.amazon.cryptography.keystore.internaldafny.types._IError> dtor_list {
      get {
        var d = this;
        return ((Error_CollectionOfErrors)d)._list;
      }
    }
    public object dtor_obj {
      get {
        var d = this;
        return ((Error_Opaque)d)._obj;
      }
    }
    public abstract _IError DowncastClone();
  }
  public class Error_KeyStoreException : Error {
    public readonly Dafny.ISequence<char> _message;
    public Error_KeyStoreException(Dafny.ISequence<char> message) {
      this._message = message;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_KeyStoreException(_message);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.keystore.internaldafny.types.Error_KeyStoreException;
      return oth != null && object.Equals(this._message, oth._message);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._message));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.keystore.internaldafny.types_Compile.Error.KeyStoreException";
      s += "(";
      s += Dafny.Helpers.ToString(this._message);
      s += ")";
      return s;
    }
  }
  public class Error_ComAmazonawsDynamodb : Error {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IError _ComAmazonawsDynamodb;
    public Error_ComAmazonawsDynamodb(software.amazon.cryptography.services.dynamodb.internaldafny.types._IError ComAmazonawsDynamodb) {
      this._ComAmazonawsDynamodb = ComAmazonawsDynamodb;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_ComAmazonawsDynamodb(_ComAmazonawsDynamodb);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.keystore.internaldafny.types.Error_ComAmazonawsDynamodb;
      return oth != null && object.Equals(this._ComAmazonawsDynamodb, oth._ComAmazonawsDynamodb);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._ComAmazonawsDynamodb));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.keystore.internaldafny.types_Compile.Error.ComAmazonawsDynamodb";
      s += "(";
      s += Dafny.Helpers.ToString(this._ComAmazonawsDynamodb);
      s += ")";
      return s;
    }
  }
  public class Error_ComAmazonawsKms : Error {
    public readonly software.amazon.cryptography.services.kms.internaldafny.types._IError _ComAmazonawsKms;
    public Error_ComAmazonawsKms(software.amazon.cryptography.services.kms.internaldafny.types._IError ComAmazonawsKms) {
      this._ComAmazonawsKms = ComAmazonawsKms;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_ComAmazonawsKms(_ComAmazonawsKms);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.keystore.internaldafny.types.Error_ComAmazonawsKms;
      return oth != null && object.Equals(this._ComAmazonawsKms, oth._ComAmazonawsKms);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._ComAmazonawsKms));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.keystore.internaldafny.types_Compile.Error.ComAmazonawsKms";
      s += "(";
      s += Dafny.Helpers.ToString(this._ComAmazonawsKms);
      s += ")";
      return s;
    }
  }
  public class Error_CollectionOfErrors : Error {
    public readonly Dafny.ISequence<software.amazon.cryptography.keystore.internaldafny.types._IError> _list;
    public readonly Dafny.ISequence<char> _message;
    public Error_CollectionOfErrors(Dafny.ISequence<software.amazon.cryptography.keystore.internaldafny.types._IError> list, Dafny.ISequence<char> message) {
      this._list = list;
      this._message = message;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_CollectionOfErrors(_list, _message);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.keystore.internaldafny.types.Error_CollectionOfErrors;
      return oth != null && object.Equals(this._list, oth._list) && object.Equals(this._message, oth._message);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._list));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._message));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.keystore.internaldafny.types_Compile.Error.CollectionOfErrors";
      s += "(";
      s += Dafny.Helpers.ToString(this._list);
      s += ", ";
      s += Dafny.Helpers.ToString(this._message);
      s += ")";
      return s;
    }
  }
  public class Error_Opaque : Error {
    public readonly object _obj;
    public Error_Opaque(object obj) {
      this._obj = obj;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_Opaque(_obj);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.keystore.internaldafny.types.Error_Opaque;
      return oth != null && this._obj == oth._obj;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 4;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._obj));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.keystore.internaldafny.types_Compile.Error.Opaque";
      s += "(";
      s += Dafny.Helpers.ToString(this._obj);
      s += ")";
      return s;
    }
  }

  public partial class OpaqueError {
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IError> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IError>(software.amazon.cryptography.keystore.internaldafny.types.Error.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types._IError> _TypeDescriptor() {
      return _TYPE;
    }
  }

} // end of namespace software.amazon.cryptography.keystore.internaldafny.types
namespace software.amazon.cryptography.materialproviders.internaldafny.types {

  public interface _IDafnyCallEvent<I, O> {
    bool is_DafnyCallEvent { get; }
    I dtor_input { get; }
    O dtor_output { get; }
    _IDafnyCallEvent<__I, __O> DowncastClone<__I, __O>(Func<I, __I> converter0, Func<O, __O> converter1);
  }
  public class DafnyCallEvent<I, O> : _IDafnyCallEvent<I, O> {
    public readonly I _input;
    public readonly O _output;
    public DafnyCallEvent(I input, O output) {
      this._input = input;
      this._output = output;
    }
    public _IDafnyCallEvent<__I, __O> DowncastClone<__I, __O>(Func<I, __I> converter0, Func<O, __O> converter1) {
      if (this is _IDafnyCallEvent<__I, __O> dt) { return dt; }
      return new DafnyCallEvent<__I, __O>(converter0(_input), converter1(_output));
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.DafnyCallEvent<I, O>;
      return oth != null && object.Equals(this._input, oth._input) && object.Equals(this._output, oth._output);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._input));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._output));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.DafnyCallEvent.DafnyCallEvent";
      s += "(";
      s += Dafny.Helpers.ToString(this._input);
      s += ", ";
      s += Dafny.Helpers.ToString(this._output);
      s += ")";
      return s;
    }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IDafnyCallEvent<I, O> Default(I _default_I, O _default_O) {
      return create(_default_I, _default_O);
    }
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDafnyCallEvent<I, O>> _TypeDescriptor(Dafny.TypeDescriptor<I> _td_I, Dafny.TypeDescriptor<O> _td_O) {
      return new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDafnyCallEvent<I, O>>(software.amazon.cryptography.materialproviders.internaldafny.types.DafnyCallEvent<I, O>.Default(_td_I.Default(), _td_O.Default()));
    }
    public static _IDafnyCallEvent<I, O> create(I input, O output) {
      return new DafnyCallEvent<I, O>(input, output);
    }
    public static _IDafnyCallEvent<I, O> create_DafnyCallEvent(I input, O output) {
      return create(input, output);
    }
    public bool is_DafnyCallEvent { get { return true; } }
    public I dtor_input {
      get {
        return this._input;
      }
    }
    public O dtor_output {
      get {
        return this._output;
      }
    }
  }

  public interface _IAesWrappingAlg {
    bool is_ALG__AES128__GCM__IV12__TAG16 { get; }
    bool is_ALG__AES192__GCM__IV12__TAG16 { get; }
    bool is_ALG__AES256__GCM__IV12__TAG16 { get; }
    _IAesWrappingAlg DowncastClone();
  }
  public abstract class AesWrappingAlg : _IAesWrappingAlg {
    public AesWrappingAlg() { }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IAesWrappingAlg theDefault = create_ALG__AES128__GCM__IV12__TAG16();
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IAesWrappingAlg Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IAesWrappingAlg> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IAesWrappingAlg>(software.amazon.cryptography.materialproviders.internaldafny.types.AesWrappingAlg.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IAesWrappingAlg> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IAesWrappingAlg create_ALG__AES128__GCM__IV12__TAG16() {
      return new AesWrappingAlg_ALG__AES128__GCM__IV12__TAG16();
    }
    public static _IAesWrappingAlg create_ALG__AES192__GCM__IV12__TAG16() {
      return new AesWrappingAlg_ALG__AES192__GCM__IV12__TAG16();
    }
    public static _IAesWrappingAlg create_ALG__AES256__GCM__IV12__TAG16() {
      return new AesWrappingAlg_ALG__AES256__GCM__IV12__TAG16();
    }
    public bool is_ALG__AES128__GCM__IV12__TAG16 { get { return this is AesWrappingAlg_ALG__AES128__GCM__IV12__TAG16; } }
    public bool is_ALG__AES192__GCM__IV12__TAG16 { get { return this is AesWrappingAlg_ALG__AES192__GCM__IV12__TAG16; } }
    public bool is_ALG__AES256__GCM__IV12__TAG16 { get { return this is AesWrappingAlg_ALG__AES256__GCM__IV12__TAG16; } }
    public static System.Collections.Generic.IEnumerable<_IAesWrappingAlg> AllSingletonConstructors {
      get {
        yield return AesWrappingAlg.create_ALG__AES128__GCM__IV12__TAG16();
        yield return AesWrappingAlg.create_ALG__AES192__GCM__IV12__TAG16();
        yield return AesWrappingAlg.create_ALG__AES256__GCM__IV12__TAG16();
      }
    }
    public abstract _IAesWrappingAlg DowncastClone();
  }
  public class AesWrappingAlg_ALG__AES128__GCM__IV12__TAG16 : AesWrappingAlg {
    public AesWrappingAlg_ALG__AES128__GCM__IV12__TAG16() {
    }
    public override _IAesWrappingAlg DowncastClone() {
      if (this is _IAesWrappingAlg dt) { return dt; }
      return new AesWrappingAlg_ALG__AES128__GCM__IV12__TAG16();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.AesWrappingAlg_ALG__AES128__GCM__IV12__TAG16;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.AesWrappingAlg.ALG_AES128_GCM_IV12_TAG16";
      return s;
    }
  }
  public class AesWrappingAlg_ALG__AES192__GCM__IV12__TAG16 : AesWrappingAlg {
    public AesWrappingAlg_ALG__AES192__GCM__IV12__TAG16() {
    }
    public override _IAesWrappingAlg DowncastClone() {
      if (this is _IAesWrappingAlg dt) { return dt; }
      return new AesWrappingAlg_ALG__AES192__GCM__IV12__TAG16();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.AesWrappingAlg_ALG__AES192__GCM__IV12__TAG16;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.AesWrappingAlg.ALG_AES192_GCM_IV12_TAG16";
      return s;
    }
  }
  public class AesWrappingAlg_ALG__AES256__GCM__IV12__TAG16 : AesWrappingAlg {
    public AesWrappingAlg_ALG__AES256__GCM__IV12__TAG16() {
    }
    public override _IAesWrappingAlg DowncastClone() {
      if (this is _IAesWrappingAlg dt) { return dt; }
      return new AesWrappingAlg_ALG__AES256__GCM__IV12__TAG16();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.AesWrappingAlg_ALG__AES256__GCM__IV12__TAG16;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.AesWrappingAlg.ALG_AES256_GCM_IV12_TAG16";
      return s;
    }
  }

  public interface _IAlgorithmSuiteId {
    bool is_ESDK { get; }
    bool is_DBE { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId dtor_ESDK { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId dtor_DBE { get; }
    _IAlgorithmSuiteId DowncastClone();
  }
  public abstract class AlgorithmSuiteId : _IAlgorithmSuiteId {
    public AlgorithmSuiteId() { }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId theDefault = create_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId>(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IAlgorithmSuiteId create_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId ESDK) {
      return new AlgorithmSuiteId_ESDK(ESDK);
    }
    public static _IAlgorithmSuiteId create_DBE(software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId DBE) {
      return new AlgorithmSuiteId_DBE(DBE);
    }
    public bool is_ESDK { get { return this is AlgorithmSuiteId_ESDK; } }
    public bool is_DBE { get { return this is AlgorithmSuiteId_DBE; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId dtor_ESDK {
      get {
        var d = this;
        return ((AlgorithmSuiteId_ESDK)d)._ESDK;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId dtor_DBE {
      get {
        var d = this;
        return ((AlgorithmSuiteId_DBE)d)._DBE;
      }
    }
    public abstract _IAlgorithmSuiteId DowncastClone();
  }
  public class AlgorithmSuiteId_ESDK : AlgorithmSuiteId {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId _ESDK;
    public AlgorithmSuiteId_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId ESDK) {
      this._ESDK = ESDK;
    }
    public override _IAlgorithmSuiteId DowncastClone() {
      if (this is _IAlgorithmSuiteId dt) { return dt; }
      return new AlgorithmSuiteId_ESDK(_ESDK);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId_ESDK;
      return oth != null && object.Equals(this._ESDK, oth._ESDK);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._ESDK));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.AlgorithmSuiteId.ESDK";
      s += "(";
      s += Dafny.Helpers.ToString(this._ESDK);
      s += ")";
      return s;
    }
  }
  public class AlgorithmSuiteId_DBE : AlgorithmSuiteId {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId _DBE;
    public AlgorithmSuiteId_DBE(software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId DBE) {
      this._DBE = DBE;
    }
    public override _IAlgorithmSuiteId DowncastClone() {
      if (this is _IAlgorithmSuiteId dt) { return dt; }
      return new AlgorithmSuiteId_DBE(_DBE);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId_DBE;
      return oth != null && object.Equals(this._DBE, oth._DBE);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._DBE));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.AlgorithmSuiteId.DBE";
      s += "(";
      s += Dafny.Helpers.ToString(this._DBE);
      s += ")";
      return s;
    }
  }

  public interface _IAlgorithmSuiteInfo {
    bool is_AlgorithmSuiteInfo { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId dtor_id { get; }
    Dafny.ISequence<byte> dtor_binaryId { get; }
    int dtor_messageVersion { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt dtor_encrypt { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm dtor_kdf { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm dtor_commitment { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._ISignatureAlgorithm dtor_signature { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._ISymmetricSignatureAlgorithm dtor_symmetricSignature { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IEdkWrappingAlgorithm dtor_edkWrapping { get; }
    _IAlgorithmSuiteInfo DowncastClone();
  }
  public class AlgorithmSuiteInfo : _IAlgorithmSuiteInfo {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId _id;
    public readonly Dafny.ISequence<byte> _binaryId;
    public readonly int _messageVersion;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt _encrypt;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm _kdf;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm _commitment;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._ISignatureAlgorithm _signature;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._ISymmetricSignatureAlgorithm _symmetricSignature;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IEdkWrappingAlgorithm _edkWrapping;
    public AlgorithmSuiteInfo(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId id, Dafny.ISequence<byte> binaryId, int messageVersion, software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt encrypt, software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm kdf, software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm commitment, software.amazon.cryptography.materialproviders.internaldafny.types._ISignatureAlgorithm signature, software.amazon.cryptography.materialproviders.internaldafny.types._ISymmetricSignatureAlgorithm symmetricSignature, software.amazon.cryptography.materialproviders.internaldafny.types._IEdkWrappingAlgorithm edkWrapping) {
      this._id = id;
      this._binaryId = binaryId;
      this._messageVersion = messageVersion;
      this._encrypt = encrypt;
      this._kdf = kdf;
      this._commitment = commitment;
      this._signature = signature;
      this._symmetricSignature = symmetricSignature;
      this._edkWrapping = edkWrapping;
    }
    public _IAlgorithmSuiteInfo DowncastClone() {
      if (this is _IAlgorithmSuiteInfo dt) { return dt; }
      return new AlgorithmSuiteInfo(_id, _binaryId, _messageVersion, _encrypt, _kdf, _commitment, _signature, _symmetricSignature, _edkWrapping);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteInfo;
      return oth != null && object.Equals(this._id, oth._id) && object.Equals(this._binaryId, oth._binaryId) && this._messageVersion == oth._messageVersion && object.Equals(this._encrypt, oth._encrypt) && object.Equals(this._kdf, oth._kdf) && object.Equals(this._commitment, oth._commitment) && object.Equals(this._signature, oth._signature) && object.Equals(this._symmetricSignature, oth._symmetricSignature) && object.Equals(this._edkWrapping, oth._edkWrapping);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._id));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._binaryId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._messageVersion));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encrypt));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._kdf));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._commitment));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._signature));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._symmetricSignature));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._edkWrapping));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.AlgorithmSuiteInfo.AlgorithmSuiteInfo";
      s += "(";
      s += Dafny.Helpers.ToString(this._id);
      s += ", ";
      s += Dafny.Helpers.ToString(this._binaryId);
      s += ", ";
      s += Dafny.Helpers.ToString(this._messageVersion);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encrypt);
      s += ", ";
      s += Dafny.Helpers.ToString(this._kdf);
      s += ", ";
      s += Dafny.Helpers.ToString(this._commitment);
      s += ", ";
      s += Dafny.Helpers.ToString(this._signature);
      s += ", ";
      s += Dafny.Helpers.ToString(this._symmetricSignature);
      s += ", ";
      s += Dafny.Helpers.ToString(this._edkWrapping);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo theDefault = create(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.Default(), Dafny.Sequence<byte>.Empty, 0, software.amazon.cryptography.materialproviders.internaldafny.types.Encrypt.Default(), software.amazon.cryptography.materialproviders.internaldafny.types.DerivationAlgorithm.Default(), software.amazon.cryptography.materialproviders.internaldafny.types.DerivationAlgorithm.Default(), software.amazon.cryptography.materialproviders.internaldafny.types.SignatureAlgorithm.Default(), software.amazon.cryptography.materialproviders.internaldafny.types.SymmetricSignatureAlgorithm.Default(), software.amazon.cryptography.materialproviders.internaldafny.types.EdkWrappingAlgorithm.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteInfo.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IAlgorithmSuiteInfo create(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId id, Dafny.ISequence<byte> binaryId, int messageVersion, software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt encrypt, software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm kdf, software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm commitment, software.amazon.cryptography.materialproviders.internaldafny.types._ISignatureAlgorithm signature, software.amazon.cryptography.materialproviders.internaldafny.types._ISymmetricSignatureAlgorithm symmetricSignature, software.amazon.cryptography.materialproviders.internaldafny.types._IEdkWrappingAlgorithm edkWrapping) {
      return new AlgorithmSuiteInfo(id, binaryId, messageVersion, encrypt, kdf, commitment, signature, symmetricSignature, edkWrapping);
    }
    public static _IAlgorithmSuiteInfo create_AlgorithmSuiteInfo(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId id, Dafny.ISequence<byte> binaryId, int messageVersion, software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt encrypt, software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm kdf, software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm commitment, software.amazon.cryptography.materialproviders.internaldafny.types._ISignatureAlgorithm signature, software.amazon.cryptography.materialproviders.internaldafny.types._ISymmetricSignatureAlgorithm symmetricSignature, software.amazon.cryptography.materialproviders.internaldafny.types._IEdkWrappingAlgorithm edkWrapping) {
      return create(id, binaryId, messageVersion, encrypt, kdf, commitment, signature, symmetricSignature, edkWrapping);
    }
    public bool is_AlgorithmSuiteInfo { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId dtor_id {
      get {
        return this._id;
      }
    }
    public Dafny.ISequence<byte> dtor_binaryId {
      get {
        return this._binaryId;
      }
    }
    public int dtor_messageVersion {
      get {
        return this._messageVersion;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt dtor_encrypt {
      get {
        return this._encrypt;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm dtor_kdf {
      get {
        return this._kdf;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm dtor_commitment {
      get {
        return this._commitment;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._ISignatureAlgorithm dtor_signature {
      get {
        return this._signature;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._ISymmetricSignatureAlgorithm dtor_symmetricSignature {
      get {
        return this._symmetricSignature;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IEdkWrappingAlgorithm dtor_edkWrapping {
      get {
        return this._edkWrapping;
      }
    }
  }

  public partial class IAwsCryptographicMaterialProvidersClientCallHistory {
    public IAwsCryptographicMaterialProvidersClientCallHistory() {
    }
  }

  public interface IAwsCryptographicMaterialProvidersClient {
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsKeyringInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsDiscoveryKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsDiscoveryKeyringInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsMultiKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMultiKeyringInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsDiscoveryMultiKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsDiscoveryMultiKeyringInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsMrkKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkKeyringInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsMrkMultiKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkMultiKeyringInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsMrkDiscoveryKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkDiscoveryKeyringInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsMrkDiscoveryMultiKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkDiscoveryMultiKeyringInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsHierarchicalKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsHierarchicalKeyringInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateMultiKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateMultiKeyringInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateRawAesKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRawAesKeyringInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateRawRsaKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRawRsaKeyringInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsRsaKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsRsaKeyringInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateDefaultCryptographicMaterialsManager(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateDefaultCryptographicMaterialsManagerInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateRequiredEncryptionContextCMM(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRequiredEncryptionContextCMMInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateCryptographicMaterialsCache(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateCryptographicMaterialsCacheInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateDefaultClientSupplier(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateDefaultClientSupplierInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> InitializeEncryptionMaterials(software.amazon.cryptography.materialproviders.internaldafny.types._IInitializeEncryptionMaterialsInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> InitializeDecryptionMaterials(software.amazon.cryptography.materialproviders.internaldafny.types._IInitializeDecryptionMaterialsInput input);
    Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> ValidEncryptionMaterialsTransition(software.amazon.cryptography.materialproviders.internaldafny.types._IValidEncryptionMaterialsTransitionInput input);
    Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> ValidDecryptionMaterialsTransition(software.amazon.cryptography.materialproviders.internaldafny.types._IValidDecryptionMaterialsTransitionInput input);
    Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> EncryptionMaterialsHasPlaintextDataKey(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials input);
    Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> DecryptionMaterialsWithPlaintextDataKey(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetAlgorithmSuiteInfo(Dafny.ISequence<byte> input);
    Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> ValidAlgorithmSuiteInfo(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo input);
    Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> ValidateCommitmentPolicyOnEncrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IValidateCommitmentPolicyOnEncryptInput input);
    Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> ValidateCommitmentPolicyOnDecrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IValidateCommitmentPolicyOnDecryptInput input);
  }
  public class _Companion_IAwsCryptographicMaterialProvidersClient {
  }

  public partial class IBranchKeyIdSupplierCallHistory {
    public IBranchKeyIdSupplierCallHistory() {
    }
  }

  public interface IBranchKeyIdSupplier {
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetBranchKeyId(software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetBranchKeyId_k(software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdInput input);
  }
  public class _Companion_IBranchKeyIdSupplier {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetBranchKeyId(software.amazon.cryptography.materialproviders.internaldafny.types.IBranchKeyIdSupplier _this, software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(software.amazon.cryptography.materialproviders.internaldafny.types.GetBranchKeyIdOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out0;
      _out0 = (_this).GetBranchKeyId_k(input);
      output = _out0;
      return output;
    }
  }

  public interface _ICacheType {
    bool is_Default { get; }
    bool is_No { get; }
    bool is_SingleThreaded { get; }
    bool is_MultiThreaded { get; }
    bool is_StormTracking { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IDefaultCache dtor_Default { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._INoCache dtor_No { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._ISingleThreadedCache dtor_SingleThreaded { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IMultiThreadedCache dtor_MultiThreaded { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IStormTrackingCache dtor_StormTracking { get; }
    _ICacheType DowncastClone();
  }
  public abstract class CacheType : _ICacheType {
    public CacheType() { }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType theDefault = create_Default(software.amazon.cryptography.materialproviders.internaldafny.types.DefaultCache.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType>(software.amazon.cryptography.materialproviders.internaldafny.types.CacheType.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICacheType create_Default(software.amazon.cryptography.materialproviders.internaldafny.types._IDefaultCache Default) {
      return new CacheType_Default(Default);
    }
    public static _ICacheType create_No(software.amazon.cryptography.materialproviders.internaldafny.types._INoCache No) {
      return new CacheType_No(No);
    }
    public static _ICacheType create_SingleThreaded(software.amazon.cryptography.materialproviders.internaldafny.types._ISingleThreadedCache SingleThreaded) {
      return new CacheType_SingleThreaded(SingleThreaded);
    }
    public static _ICacheType create_MultiThreaded(software.amazon.cryptography.materialproviders.internaldafny.types._IMultiThreadedCache MultiThreaded) {
      return new CacheType_MultiThreaded(MultiThreaded);
    }
    public static _ICacheType create_StormTracking(software.amazon.cryptography.materialproviders.internaldafny.types._IStormTrackingCache StormTracking) {
      return new CacheType_StormTracking(StormTracking);
    }
    public bool is_Default { get { return this is CacheType_Default; } }
    public bool is_No { get { return this is CacheType_No; } }
    public bool is_SingleThreaded { get { return this is CacheType_SingleThreaded; } }
    public bool is_MultiThreaded { get { return this is CacheType_MultiThreaded; } }
    public bool is_StormTracking { get { return this is CacheType_StormTracking; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDefaultCache dtor_Default {
      get {
        var d = this;
        return ((CacheType_Default)d)._Default;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._INoCache dtor_No {
      get {
        var d = this;
        return ((CacheType_No)d)._No;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._ISingleThreadedCache dtor_SingleThreaded {
      get {
        var d = this;
        return ((CacheType_SingleThreaded)d)._SingleThreaded;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IMultiThreadedCache dtor_MultiThreaded {
      get {
        var d = this;
        return ((CacheType_MultiThreaded)d)._MultiThreaded;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IStormTrackingCache dtor_StormTracking {
      get {
        var d = this;
        return ((CacheType_StormTracking)d)._StormTracking;
      }
    }
    public abstract _ICacheType DowncastClone();
  }
  public class CacheType_Default : CacheType {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDefaultCache _Default;
    public CacheType_Default(software.amazon.cryptography.materialproviders.internaldafny.types._IDefaultCache Default) {
      this._Default = Default;
    }
    public override _ICacheType DowncastClone() {
      if (this is _ICacheType dt) { return dt; }
      return new CacheType_Default(_Default);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CacheType_Default;
      return oth != null && object.Equals(this._Default, oth._Default);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._Default));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CacheType.Default";
      s += "(";
      s += Dafny.Helpers.ToString(this._Default);
      s += ")";
      return s;
    }
  }
  public class CacheType_No : CacheType {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._INoCache _No;
    public CacheType_No(software.amazon.cryptography.materialproviders.internaldafny.types._INoCache No) {
      this._No = No;
    }
    public override _ICacheType DowncastClone() {
      if (this is _ICacheType dt) { return dt; }
      return new CacheType_No(_No);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CacheType_No;
      return oth != null && object.Equals(this._No, oth._No);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._No));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CacheType.No";
      s += "(";
      s += Dafny.Helpers.ToString(this._No);
      s += ")";
      return s;
    }
  }
  public class CacheType_SingleThreaded : CacheType {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._ISingleThreadedCache _SingleThreaded;
    public CacheType_SingleThreaded(software.amazon.cryptography.materialproviders.internaldafny.types._ISingleThreadedCache SingleThreaded) {
      this._SingleThreaded = SingleThreaded;
    }
    public override _ICacheType DowncastClone() {
      if (this is _ICacheType dt) { return dt; }
      return new CacheType_SingleThreaded(_SingleThreaded);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CacheType_SingleThreaded;
      return oth != null && object.Equals(this._SingleThreaded, oth._SingleThreaded);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._SingleThreaded));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CacheType.SingleThreaded";
      s += "(";
      s += Dafny.Helpers.ToString(this._SingleThreaded);
      s += ")";
      return s;
    }
  }
  public class CacheType_MultiThreaded : CacheType {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IMultiThreadedCache _MultiThreaded;
    public CacheType_MultiThreaded(software.amazon.cryptography.materialproviders.internaldafny.types._IMultiThreadedCache MultiThreaded) {
      this._MultiThreaded = MultiThreaded;
    }
    public override _ICacheType DowncastClone() {
      if (this is _ICacheType dt) { return dt; }
      return new CacheType_MultiThreaded(_MultiThreaded);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CacheType_MultiThreaded;
      return oth != null && object.Equals(this._MultiThreaded, oth._MultiThreaded);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._MultiThreaded));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CacheType.MultiThreaded";
      s += "(";
      s += Dafny.Helpers.ToString(this._MultiThreaded);
      s += ")";
      return s;
    }
  }
  public class CacheType_StormTracking : CacheType {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IStormTrackingCache _StormTracking;
    public CacheType_StormTracking(software.amazon.cryptography.materialproviders.internaldafny.types._IStormTrackingCache StormTracking) {
      this._StormTracking = StormTracking;
    }
    public override _ICacheType DowncastClone() {
      if (this is _ICacheType dt) { return dt; }
      return new CacheType_StormTracking(_StormTracking);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CacheType_StormTracking;
      return oth != null && object.Equals(this._StormTracking, oth._StormTracking);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 4;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._StormTracking));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CacheType.StormTracking";
      s += "(";
      s += Dafny.Helpers.ToString(this._StormTracking);
      s += ")";
      return s;
    }
  }

  public partial class IClientSupplierCallHistory {
    public IClientSupplierCallHistory() {
    }
  }

  public interface IClientSupplier {
    Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetClient(software.amazon.cryptography.materialproviders.internaldafny.types._IGetClientInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetClient_k(software.amazon.cryptography.materialproviders.internaldafny.types._IGetClientInput input);
  }
  public class _Companion_IClientSupplier {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetClient(software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier _this, software.amazon.cryptography.materialproviders.internaldafny.types._IGetClientInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out1;
      _out1 = (_this).GetClient_k(input);
      output = _out1;
      return output;
    }
  }

  public interface _ICommitmentPolicy {
    bool is_ESDK { get; }
    bool is_DBE { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IESDKCommitmentPolicy dtor_ESDK { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IDBECommitmentPolicy dtor_DBE { get; }
    _ICommitmentPolicy DowncastClone();
  }
  public abstract class CommitmentPolicy : _ICommitmentPolicy {
    public CommitmentPolicy() { }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy theDefault = create_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKCommitmentPolicy.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy>(software.amazon.cryptography.materialproviders.internaldafny.types.CommitmentPolicy.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICommitmentPolicy create_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types._IESDKCommitmentPolicy ESDK) {
      return new CommitmentPolicy_ESDK(ESDK);
    }
    public static _ICommitmentPolicy create_DBE(software.amazon.cryptography.materialproviders.internaldafny.types._IDBECommitmentPolicy DBE) {
      return new CommitmentPolicy_DBE(DBE);
    }
    public bool is_ESDK { get { return this is CommitmentPolicy_ESDK; } }
    public bool is_DBE { get { return this is CommitmentPolicy_DBE; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IESDKCommitmentPolicy dtor_ESDK {
      get {
        var d = this;
        return ((CommitmentPolicy_ESDK)d)._ESDK;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDBECommitmentPolicy dtor_DBE {
      get {
        var d = this;
        return ((CommitmentPolicy_DBE)d)._DBE;
      }
    }
    public abstract _ICommitmentPolicy DowncastClone();
  }
  public class CommitmentPolicy_ESDK : CommitmentPolicy {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IESDKCommitmentPolicy _ESDK;
    public CommitmentPolicy_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types._IESDKCommitmentPolicy ESDK) {
      this._ESDK = ESDK;
    }
    public override _ICommitmentPolicy DowncastClone() {
      if (this is _ICommitmentPolicy dt) { return dt; }
      return new CommitmentPolicy_ESDK(_ESDK);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CommitmentPolicy_ESDK;
      return oth != null && object.Equals(this._ESDK, oth._ESDK);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._ESDK));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CommitmentPolicy.ESDK";
      s += "(";
      s += Dafny.Helpers.ToString(this._ESDK);
      s += ")";
      return s;
    }
  }
  public class CommitmentPolicy_DBE : CommitmentPolicy {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDBECommitmentPolicy _DBE;
    public CommitmentPolicy_DBE(software.amazon.cryptography.materialproviders.internaldafny.types._IDBECommitmentPolicy DBE) {
      this._DBE = DBE;
    }
    public override _ICommitmentPolicy DowncastClone() {
      if (this is _ICommitmentPolicy dt) { return dt; }
      return new CommitmentPolicy_DBE(_DBE);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CommitmentPolicy_DBE;
      return oth != null && object.Equals(this._DBE, oth._DBE);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._DBE));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CommitmentPolicy.DBE";
      s += "(";
      s += Dafny.Helpers.ToString(this._DBE);
      s += ")";
      return s;
    }
  }

  public partial class CountingNumber {
    private static readonly Dafny.TypeDescriptor<int> _TYPE = new Dafny.TypeDescriptor<int>(0);
    public static Dafny.TypeDescriptor<int> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public interface _ICreateAwsKmsDiscoveryKeyringInput {
    bool is_CreateAwsKmsDiscoveryKeyringInput { get; }
    software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient dtor_kmsClient { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> dtor_discoveryFilter { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens { get; }
    _ICreateAwsKmsDiscoveryKeyringInput DowncastClone();
  }
  public class CreateAwsKmsDiscoveryKeyringInput : _ICreateAwsKmsDiscoveryKeyringInput {
    public readonly software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _kmsClient;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> _discoveryFilter;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> _grantTokens;
    public CreateAwsKmsDiscoveryKeyringInput(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient kmsClient, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      this._kmsClient = kmsClient;
      this._discoveryFilter = discoveryFilter;
      this._grantTokens = grantTokens;
    }
    public _ICreateAwsKmsDiscoveryKeyringInput DowncastClone() {
      if (this is _ICreateAwsKmsDiscoveryKeyringInput dt) { return dt; }
      return new CreateAwsKmsDiscoveryKeyringInput(_kmsClient, _discoveryFilter, _grantTokens);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CreateAwsKmsDiscoveryKeyringInput;
      return oth != null && this._kmsClient == oth._kmsClient && object.Equals(this._discoveryFilter, oth._discoveryFilter) && object.Equals(this._grantTokens, oth._grantTokens);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._kmsClient));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._discoveryFilter));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._grantTokens));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CreateAwsKmsDiscoveryKeyringInput.CreateAwsKmsDiscoveryKeyringInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._kmsClient);
      s += ", ";
      s += Dafny.Helpers.ToString(this._discoveryFilter);
      s += ", ";
      s += Dafny.Helpers.ToString(this._grantTokens);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsDiscoveryKeyringInput theDefault = create(default(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter>.Default(), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsDiscoveryKeyringInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsDiscoveryKeyringInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsDiscoveryKeyringInput>(software.amazon.cryptography.materialproviders.internaldafny.types.CreateAwsKmsDiscoveryKeyringInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsDiscoveryKeyringInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICreateAwsKmsDiscoveryKeyringInput create(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient kmsClient, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      return new CreateAwsKmsDiscoveryKeyringInput(kmsClient, discoveryFilter, grantTokens);
    }
    public static _ICreateAwsKmsDiscoveryKeyringInput create_CreateAwsKmsDiscoveryKeyringInput(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient kmsClient, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      return create(kmsClient, discoveryFilter, grantTokens);
    }
    public bool is_CreateAwsKmsDiscoveryKeyringInput { get { return true; } }
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient dtor_kmsClient {
      get {
        return this._kmsClient;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> dtor_discoveryFilter {
      get {
        return this._discoveryFilter;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens {
      get {
        return this._grantTokens;
      }
    }
  }

  public interface _ICreateAwsKmsDiscoveryMultiKeyringInput {
    bool is_CreateAwsKmsDiscoveryMultiKeyringInput { get; }
    Dafny.ISequence<Dafny.ISequence<char>> dtor_regions { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> dtor_discoveryFilter { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> dtor_clientSupplier { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens { get; }
    _ICreateAwsKmsDiscoveryMultiKeyringInput DowncastClone();
  }
  public class CreateAwsKmsDiscoveryMultiKeyringInput : _ICreateAwsKmsDiscoveryMultiKeyringInput {
    public readonly Dafny.ISequence<Dafny.ISequence<char>> _regions;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> _discoveryFilter;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> _clientSupplier;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> _grantTokens;
    public CreateAwsKmsDiscoveryMultiKeyringInput(Dafny.ISequence<Dafny.ISequence<char>> regions, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> clientSupplier, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      this._regions = regions;
      this._discoveryFilter = discoveryFilter;
      this._clientSupplier = clientSupplier;
      this._grantTokens = grantTokens;
    }
    public _ICreateAwsKmsDiscoveryMultiKeyringInput DowncastClone() {
      if (this is _ICreateAwsKmsDiscoveryMultiKeyringInput dt) { return dt; }
      return new CreateAwsKmsDiscoveryMultiKeyringInput(_regions, _discoveryFilter, _clientSupplier, _grantTokens);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CreateAwsKmsDiscoveryMultiKeyringInput;
      return oth != null && object.Equals(this._regions, oth._regions) && object.Equals(this._discoveryFilter, oth._discoveryFilter) && object.Equals(this._clientSupplier, oth._clientSupplier) && object.Equals(this._grantTokens, oth._grantTokens);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._regions));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._discoveryFilter));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._clientSupplier));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._grantTokens));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CreateAwsKmsDiscoveryMultiKeyringInput.CreateAwsKmsDiscoveryMultiKeyringInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._regions);
      s += ", ";
      s += Dafny.Helpers.ToString(this._discoveryFilter);
      s += ", ";
      s += Dafny.Helpers.ToString(this._clientSupplier);
      s += ", ";
      s += Dafny.Helpers.ToString(this._grantTokens);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsDiscoveryMultiKeyringInput theDefault = create(Dafny.Sequence<Dafny.ISequence<char>>.Empty, Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter>.Default(), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier>.Default(), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsDiscoveryMultiKeyringInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsDiscoveryMultiKeyringInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsDiscoveryMultiKeyringInput>(software.amazon.cryptography.materialproviders.internaldafny.types.CreateAwsKmsDiscoveryMultiKeyringInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsDiscoveryMultiKeyringInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICreateAwsKmsDiscoveryMultiKeyringInput create(Dafny.ISequence<Dafny.ISequence<char>> regions, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> clientSupplier, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      return new CreateAwsKmsDiscoveryMultiKeyringInput(regions, discoveryFilter, clientSupplier, grantTokens);
    }
    public static _ICreateAwsKmsDiscoveryMultiKeyringInput create_CreateAwsKmsDiscoveryMultiKeyringInput(Dafny.ISequence<Dafny.ISequence<char>> regions, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> clientSupplier, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      return create(regions, discoveryFilter, clientSupplier, grantTokens);
    }
    public bool is_CreateAwsKmsDiscoveryMultiKeyringInput { get { return true; } }
    public Dafny.ISequence<Dafny.ISequence<char>> dtor_regions {
      get {
        return this._regions;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> dtor_discoveryFilter {
      get {
        return this._discoveryFilter;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> dtor_clientSupplier {
      get {
        return this._clientSupplier;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens {
      get {
        return this._grantTokens;
      }
    }
  }

  public interface _ICreateAwsKmsHierarchicalKeyringInput {
    bool is_CreateAwsKmsHierarchicalKeyringInput { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_branchKeyId { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IBranchKeyIdSupplier> dtor_branchKeyIdSupplier { get; }
    software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient dtor_keyStore { get; }
    long dtor_ttlSeconds { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType> dtor_cache { get; }
    _ICreateAwsKmsHierarchicalKeyringInput DowncastClone();
  }
  public class CreateAwsKmsHierarchicalKeyringInput : _ICreateAwsKmsHierarchicalKeyringInput {
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<char>> _branchKeyId;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IBranchKeyIdSupplier> _branchKeyIdSupplier;
    public readonly software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient _keyStore;
    public readonly long _ttlSeconds;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType> _cache;
    public CreateAwsKmsHierarchicalKeyringInput(Wrappers_Compile._IOption<Dafny.ISequence<char>> branchKeyId, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IBranchKeyIdSupplier> branchKeyIdSupplier, software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient keyStore, long ttlSeconds, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType> cache) {
      this._branchKeyId = branchKeyId;
      this._branchKeyIdSupplier = branchKeyIdSupplier;
      this._keyStore = keyStore;
      this._ttlSeconds = ttlSeconds;
      this._cache = cache;
    }
    public _ICreateAwsKmsHierarchicalKeyringInput DowncastClone() {
      if (this is _ICreateAwsKmsHierarchicalKeyringInput dt) { return dt; }
      return new CreateAwsKmsHierarchicalKeyringInput(_branchKeyId, _branchKeyIdSupplier, _keyStore, _ttlSeconds, _cache);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CreateAwsKmsHierarchicalKeyringInput;
      return oth != null && object.Equals(this._branchKeyId, oth._branchKeyId) && object.Equals(this._branchKeyIdSupplier, oth._branchKeyIdSupplier) && this._keyStore == oth._keyStore && this._ttlSeconds == oth._ttlSeconds && object.Equals(this._cache, oth._cache);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._branchKeyId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._branchKeyIdSupplier));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keyStore));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._ttlSeconds));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._cache));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CreateAwsKmsHierarchicalKeyringInput.CreateAwsKmsHierarchicalKeyringInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._branchKeyId);
      s += ", ";
      s += Dafny.Helpers.ToString(this._branchKeyIdSupplier);
      s += ", ";
      s += Dafny.Helpers.ToString(this._keyStore);
      s += ", ";
      s += Dafny.Helpers.ToString(this._ttlSeconds);
      s += ", ";
      s += Dafny.Helpers.ToString(this._cache);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsHierarchicalKeyringInput theDefault = create(Wrappers_Compile.Option<Dafny.ISequence<char>>.Default(), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.IBranchKeyIdSupplier>.Default(), default(software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient), 0, Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType>.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsHierarchicalKeyringInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsHierarchicalKeyringInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsHierarchicalKeyringInput>(software.amazon.cryptography.materialproviders.internaldafny.types.CreateAwsKmsHierarchicalKeyringInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsHierarchicalKeyringInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICreateAwsKmsHierarchicalKeyringInput create(Wrappers_Compile._IOption<Dafny.ISequence<char>> branchKeyId, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IBranchKeyIdSupplier> branchKeyIdSupplier, software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient keyStore, long ttlSeconds, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType> cache) {
      return new CreateAwsKmsHierarchicalKeyringInput(branchKeyId, branchKeyIdSupplier, keyStore, ttlSeconds, cache);
    }
    public static _ICreateAwsKmsHierarchicalKeyringInput create_CreateAwsKmsHierarchicalKeyringInput(Wrappers_Compile._IOption<Dafny.ISequence<char>> branchKeyId, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IBranchKeyIdSupplier> branchKeyIdSupplier, software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient keyStore, long ttlSeconds, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType> cache) {
      return create(branchKeyId, branchKeyIdSupplier, keyStore, ttlSeconds, cache);
    }
    public bool is_CreateAwsKmsHierarchicalKeyringInput { get { return true; } }
    public Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_branchKeyId {
      get {
        return this._branchKeyId;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IBranchKeyIdSupplier> dtor_branchKeyIdSupplier {
      get {
        return this._branchKeyIdSupplier;
      }
    }
    public software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient dtor_keyStore {
      get {
        return this._keyStore;
      }
    }
    public long dtor_ttlSeconds {
      get {
        return this._ttlSeconds;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType> dtor_cache {
      get {
        return this._cache;
      }
    }
  }

  public interface _ICreateAwsKmsKeyringInput {
    bool is_CreateAwsKmsKeyringInput { get; }
    Dafny.ISequence<char> dtor_kmsKeyId { get; }
    software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient dtor_kmsClient { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens { get; }
    _ICreateAwsKmsKeyringInput DowncastClone();
  }
  public class CreateAwsKmsKeyringInput : _ICreateAwsKmsKeyringInput {
    public readonly Dafny.ISequence<char> _kmsKeyId;
    public readonly software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _kmsClient;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> _grantTokens;
    public CreateAwsKmsKeyringInput(Dafny.ISequence<char> kmsKeyId, software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient kmsClient, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      this._kmsKeyId = kmsKeyId;
      this._kmsClient = kmsClient;
      this._grantTokens = grantTokens;
    }
    public _ICreateAwsKmsKeyringInput DowncastClone() {
      if (this is _ICreateAwsKmsKeyringInput dt) { return dt; }
      return new CreateAwsKmsKeyringInput(_kmsKeyId, _kmsClient, _grantTokens);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CreateAwsKmsKeyringInput;
      return oth != null && object.Equals(this._kmsKeyId, oth._kmsKeyId) && this._kmsClient == oth._kmsClient && object.Equals(this._grantTokens, oth._grantTokens);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._kmsKeyId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._kmsClient));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._grantTokens));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CreateAwsKmsKeyringInput.CreateAwsKmsKeyringInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._kmsKeyId);
      s += ", ";
      s += Dafny.Helpers.ToString(this._kmsClient);
      s += ", ";
      s += Dafny.Helpers.ToString(this._grantTokens);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsKeyringInput theDefault = create(Dafny.Sequence<char>.Empty, default(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsKeyringInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsKeyringInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsKeyringInput>(software.amazon.cryptography.materialproviders.internaldafny.types.CreateAwsKmsKeyringInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsKeyringInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICreateAwsKmsKeyringInput create(Dafny.ISequence<char> kmsKeyId, software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient kmsClient, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      return new CreateAwsKmsKeyringInput(kmsKeyId, kmsClient, grantTokens);
    }
    public static _ICreateAwsKmsKeyringInput create_CreateAwsKmsKeyringInput(Dafny.ISequence<char> kmsKeyId, software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient kmsClient, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      return create(kmsKeyId, kmsClient, grantTokens);
    }
    public bool is_CreateAwsKmsKeyringInput { get { return true; } }
    public Dafny.ISequence<char> dtor_kmsKeyId {
      get {
        return this._kmsKeyId;
      }
    }
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient dtor_kmsClient {
      get {
        return this._kmsClient;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens {
      get {
        return this._grantTokens;
      }
    }
  }

  public interface _ICreateAwsKmsMrkDiscoveryKeyringInput {
    bool is_CreateAwsKmsMrkDiscoveryKeyringInput { get; }
    software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient dtor_kmsClient { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> dtor_discoveryFilter { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens { get; }
    Dafny.ISequence<char> dtor_region { get; }
    _ICreateAwsKmsMrkDiscoveryKeyringInput DowncastClone();
  }
  public class CreateAwsKmsMrkDiscoveryKeyringInput : _ICreateAwsKmsMrkDiscoveryKeyringInput {
    public readonly software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _kmsClient;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> _discoveryFilter;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> _grantTokens;
    public readonly Dafny.ISequence<char> _region;
    public CreateAwsKmsMrkDiscoveryKeyringInput(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient kmsClient, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens, Dafny.ISequence<char> region) {
      this._kmsClient = kmsClient;
      this._discoveryFilter = discoveryFilter;
      this._grantTokens = grantTokens;
      this._region = region;
    }
    public _ICreateAwsKmsMrkDiscoveryKeyringInput DowncastClone() {
      if (this is _ICreateAwsKmsMrkDiscoveryKeyringInput dt) { return dt; }
      return new CreateAwsKmsMrkDiscoveryKeyringInput(_kmsClient, _discoveryFilter, _grantTokens, _region);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CreateAwsKmsMrkDiscoveryKeyringInput;
      return oth != null && this._kmsClient == oth._kmsClient && object.Equals(this._discoveryFilter, oth._discoveryFilter) && object.Equals(this._grantTokens, oth._grantTokens) && object.Equals(this._region, oth._region);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._kmsClient));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._discoveryFilter));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._grantTokens));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._region));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CreateAwsKmsMrkDiscoveryKeyringInput.CreateAwsKmsMrkDiscoveryKeyringInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._kmsClient);
      s += ", ";
      s += Dafny.Helpers.ToString(this._discoveryFilter);
      s += ", ";
      s += Dafny.Helpers.ToString(this._grantTokens);
      s += ", ";
      s += Dafny.Helpers.ToString(this._region);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkDiscoveryKeyringInput theDefault = create(default(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter>.Default(), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.Default(), Dafny.Sequence<char>.Empty);
    public static software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkDiscoveryKeyringInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkDiscoveryKeyringInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkDiscoveryKeyringInput>(software.amazon.cryptography.materialproviders.internaldafny.types.CreateAwsKmsMrkDiscoveryKeyringInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkDiscoveryKeyringInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICreateAwsKmsMrkDiscoveryKeyringInput create(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient kmsClient, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens, Dafny.ISequence<char> region) {
      return new CreateAwsKmsMrkDiscoveryKeyringInput(kmsClient, discoveryFilter, grantTokens, region);
    }
    public static _ICreateAwsKmsMrkDiscoveryKeyringInput create_CreateAwsKmsMrkDiscoveryKeyringInput(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient kmsClient, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens, Dafny.ISequence<char> region) {
      return create(kmsClient, discoveryFilter, grantTokens, region);
    }
    public bool is_CreateAwsKmsMrkDiscoveryKeyringInput { get { return true; } }
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient dtor_kmsClient {
      get {
        return this._kmsClient;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> dtor_discoveryFilter {
      get {
        return this._discoveryFilter;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens {
      get {
        return this._grantTokens;
      }
    }
    public Dafny.ISequence<char> dtor_region {
      get {
        return this._region;
      }
    }
  }

  public interface _ICreateAwsKmsMrkDiscoveryMultiKeyringInput {
    bool is_CreateAwsKmsMrkDiscoveryMultiKeyringInput { get; }
    Dafny.ISequence<Dafny.ISequence<char>> dtor_regions { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> dtor_discoveryFilter { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> dtor_clientSupplier { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens { get; }
    _ICreateAwsKmsMrkDiscoveryMultiKeyringInput DowncastClone();
  }
  public class CreateAwsKmsMrkDiscoveryMultiKeyringInput : _ICreateAwsKmsMrkDiscoveryMultiKeyringInput {
    public readonly Dafny.ISequence<Dafny.ISequence<char>> _regions;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> _discoveryFilter;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> _clientSupplier;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> _grantTokens;
    public CreateAwsKmsMrkDiscoveryMultiKeyringInput(Dafny.ISequence<Dafny.ISequence<char>> regions, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> clientSupplier, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      this._regions = regions;
      this._discoveryFilter = discoveryFilter;
      this._clientSupplier = clientSupplier;
      this._grantTokens = grantTokens;
    }
    public _ICreateAwsKmsMrkDiscoveryMultiKeyringInput DowncastClone() {
      if (this is _ICreateAwsKmsMrkDiscoveryMultiKeyringInput dt) { return dt; }
      return new CreateAwsKmsMrkDiscoveryMultiKeyringInput(_regions, _discoveryFilter, _clientSupplier, _grantTokens);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CreateAwsKmsMrkDiscoveryMultiKeyringInput;
      return oth != null && object.Equals(this._regions, oth._regions) && object.Equals(this._discoveryFilter, oth._discoveryFilter) && object.Equals(this._clientSupplier, oth._clientSupplier) && object.Equals(this._grantTokens, oth._grantTokens);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._regions));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._discoveryFilter));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._clientSupplier));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._grantTokens));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CreateAwsKmsMrkDiscoveryMultiKeyringInput.CreateAwsKmsMrkDiscoveryMultiKeyringInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._regions);
      s += ", ";
      s += Dafny.Helpers.ToString(this._discoveryFilter);
      s += ", ";
      s += Dafny.Helpers.ToString(this._clientSupplier);
      s += ", ";
      s += Dafny.Helpers.ToString(this._grantTokens);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkDiscoveryMultiKeyringInput theDefault = create(Dafny.Sequence<Dafny.ISequence<char>>.Empty, Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter>.Default(), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier>.Default(), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkDiscoveryMultiKeyringInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkDiscoveryMultiKeyringInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkDiscoveryMultiKeyringInput>(software.amazon.cryptography.materialproviders.internaldafny.types.CreateAwsKmsMrkDiscoveryMultiKeyringInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkDiscoveryMultiKeyringInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICreateAwsKmsMrkDiscoveryMultiKeyringInput create(Dafny.ISequence<Dafny.ISequence<char>> regions, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> clientSupplier, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      return new CreateAwsKmsMrkDiscoveryMultiKeyringInput(regions, discoveryFilter, clientSupplier, grantTokens);
    }
    public static _ICreateAwsKmsMrkDiscoveryMultiKeyringInput create_CreateAwsKmsMrkDiscoveryMultiKeyringInput(Dafny.ISequence<Dafny.ISequence<char>> regions, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> clientSupplier, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      return create(regions, discoveryFilter, clientSupplier, grantTokens);
    }
    public bool is_CreateAwsKmsMrkDiscoveryMultiKeyringInput { get { return true; } }
    public Dafny.ISequence<Dafny.ISequence<char>> dtor_regions {
      get {
        return this._regions;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> dtor_discoveryFilter {
      get {
        return this._discoveryFilter;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> dtor_clientSupplier {
      get {
        return this._clientSupplier;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens {
      get {
        return this._grantTokens;
      }
    }
  }

  public interface _ICreateAwsKmsMrkKeyringInput {
    bool is_CreateAwsKmsMrkKeyringInput { get; }
    Dafny.ISequence<char> dtor_kmsKeyId { get; }
    software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient dtor_kmsClient { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens { get; }
    _ICreateAwsKmsMrkKeyringInput DowncastClone();
  }
  public class CreateAwsKmsMrkKeyringInput : _ICreateAwsKmsMrkKeyringInput {
    public readonly Dafny.ISequence<char> _kmsKeyId;
    public readonly software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _kmsClient;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> _grantTokens;
    public CreateAwsKmsMrkKeyringInput(Dafny.ISequence<char> kmsKeyId, software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient kmsClient, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      this._kmsKeyId = kmsKeyId;
      this._kmsClient = kmsClient;
      this._grantTokens = grantTokens;
    }
    public _ICreateAwsKmsMrkKeyringInput DowncastClone() {
      if (this is _ICreateAwsKmsMrkKeyringInput dt) { return dt; }
      return new CreateAwsKmsMrkKeyringInput(_kmsKeyId, _kmsClient, _grantTokens);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CreateAwsKmsMrkKeyringInput;
      return oth != null && object.Equals(this._kmsKeyId, oth._kmsKeyId) && this._kmsClient == oth._kmsClient && object.Equals(this._grantTokens, oth._grantTokens);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._kmsKeyId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._kmsClient));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._grantTokens));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CreateAwsKmsMrkKeyringInput.CreateAwsKmsMrkKeyringInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._kmsKeyId);
      s += ", ";
      s += Dafny.Helpers.ToString(this._kmsClient);
      s += ", ";
      s += Dafny.Helpers.ToString(this._grantTokens);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkKeyringInput theDefault = create(Dafny.Sequence<char>.Empty, default(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkKeyringInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkKeyringInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkKeyringInput>(software.amazon.cryptography.materialproviders.internaldafny.types.CreateAwsKmsMrkKeyringInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkKeyringInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICreateAwsKmsMrkKeyringInput create(Dafny.ISequence<char> kmsKeyId, software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient kmsClient, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      return new CreateAwsKmsMrkKeyringInput(kmsKeyId, kmsClient, grantTokens);
    }
    public static _ICreateAwsKmsMrkKeyringInput create_CreateAwsKmsMrkKeyringInput(Dafny.ISequence<char> kmsKeyId, software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient kmsClient, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      return create(kmsKeyId, kmsClient, grantTokens);
    }
    public bool is_CreateAwsKmsMrkKeyringInput { get { return true; } }
    public Dafny.ISequence<char> dtor_kmsKeyId {
      get {
        return this._kmsKeyId;
      }
    }
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient dtor_kmsClient {
      get {
        return this._kmsClient;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens {
      get {
        return this._grantTokens;
      }
    }
  }

  public interface _ICreateAwsKmsMrkMultiKeyringInput {
    bool is_CreateAwsKmsMrkMultiKeyringInput { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_generator { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_kmsKeyIds { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> dtor_clientSupplier { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens { get; }
    _ICreateAwsKmsMrkMultiKeyringInput DowncastClone();
  }
  public class CreateAwsKmsMrkMultiKeyringInput : _ICreateAwsKmsMrkMultiKeyringInput {
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<char>> _generator;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> _kmsKeyIds;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> _clientSupplier;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> _grantTokens;
    public CreateAwsKmsMrkMultiKeyringInput(Wrappers_Compile._IOption<Dafny.ISequence<char>> generator, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> kmsKeyIds, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> clientSupplier, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      this._generator = generator;
      this._kmsKeyIds = kmsKeyIds;
      this._clientSupplier = clientSupplier;
      this._grantTokens = grantTokens;
    }
    public _ICreateAwsKmsMrkMultiKeyringInput DowncastClone() {
      if (this is _ICreateAwsKmsMrkMultiKeyringInput dt) { return dt; }
      return new CreateAwsKmsMrkMultiKeyringInput(_generator, _kmsKeyIds, _clientSupplier, _grantTokens);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CreateAwsKmsMrkMultiKeyringInput;
      return oth != null && object.Equals(this._generator, oth._generator) && object.Equals(this._kmsKeyIds, oth._kmsKeyIds) && object.Equals(this._clientSupplier, oth._clientSupplier) && object.Equals(this._grantTokens, oth._grantTokens);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._generator));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._kmsKeyIds));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._clientSupplier));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._grantTokens));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CreateAwsKmsMrkMultiKeyringInput.CreateAwsKmsMrkMultiKeyringInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._generator);
      s += ", ";
      s += Dafny.Helpers.ToString(this._kmsKeyIds);
      s += ", ";
      s += Dafny.Helpers.ToString(this._clientSupplier);
      s += ", ";
      s += Dafny.Helpers.ToString(this._grantTokens);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkMultiKeyringInput theDefault = create(Wrappers_Compile.Option<Dafny.ISequence<char>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.Default(), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier>.Default(), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkMultiKeyringInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkMultiKeyringInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkMultiKeyringInput>(software.amazon.cryptography.materialproviders.internaldafny.types.CreateAwsKmsMrkMultiKeyringInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkMultiKeyringInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICreateAwsKmsMrkMultiKeyringInput create(Wrappers_Compile._IOption<Dafny.ISequence<char>> generator, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> kmsKeyIds, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> clientSupplier, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      return new CreateAwsKmsMrkMultiKeyringInput(generator, kmsKeyIds, clientSupplier, grantTokens);
    }
    public static _ICreateAwsKmsMrkMultiKeyringInput create_CreateAwsKmsMrkMultiKeyringInput(Wrappers_Compile._IOption<Dafny.ISequence<char>> generator, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> kmsKeyIds, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> clientSupplier, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      return create(generator, kmsKeyIds, clientSupplier, grantTokens);
    }
    public bool is_CreateAwsKmsMrkMultiKeyringInput { get { return true; } }
    public Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_generator {
      get {
        return this._generator;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_kmsKeyIds {
      get {
        return this._kmsKeyIds;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> dtor_clientSupplier {
      get {
        return this._clientSupplier;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens {
      get {
        return this._grantTokens;
      }
    }
  }

  public interface _ICreateAwsKmsMultiKeyringInput {
    bool is_CreateAwsKmsMultiKeyringInput { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_generator { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_kmsKeyIds { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> dtor_clientSupplier { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens { get; }
    _ICreateAwsKmsMultiKeyringInput DowncastClone();
  }
  public class CreateAwsKmsMultiKeyringInput : _ICreateAwsKmsMultiKeyringInput {
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<char>> _generator;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> _kmsKeyIds;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> _clientSupplier;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> _grantTokens;
    public CreateAwsKmsMultiKeyringInput(Wrappers_Compile._IOption<Dafny.ISequence<char>> generator, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> kmsKeyIds, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> clientSupplier, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      this._generator = generator;
      this._kmsKeyIds = kmsKeyIds;
      this._clientSupplier = clientSupplier;
      this._grantTokens = grantTokens;
    }
    public _ICreateAwsKmsMultiKeyringInput DowncastClone() {
      if (this is _ICreateAwsKmsMultiKeyringInput dt) { return dt; }
      return new CreateAwsKmsMultiKeyringInput(_generator, _kmsKeyIds, _clientSupplier, _grantTokens);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CreateAwsKmsMultiKeyringInput;
      return oth != null && object.Equals(this._generator, oth._generator) && object.Equals(this._kmsKeyIds, oth._kmsKeyIds) && object.Equals(this._clientSupplier, oth._clientSupplier) && object.Equals(this._grantTokens, oth._grantTokens);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._generator));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._kmsKeyIds));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._clientSupplier));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._grantTokens));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CreateAwsKmsMultiKeyringInput.CreateAwsKmsMultiKeyringInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._generator);
      s += ", ";
      s += Dafny.Helpers.ToString(this._kmsKeyIds);
      s += ", ";
      s += Dafny.Helpers.ToString(this._clientSupplier);
      s += ", ";
      s += Dafny.Helpers.ToString(this._grantTokens);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMultiKeyringInput theDefault = create(Wrappers_Compile.Option<Dafny.ISequence<char>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.Default(), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier>.Default(), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMultiKeyringInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMultiKeyringInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMultiKeyringInput>(software.amazon.cryptography.materialproviders.internaldafny.types.CreateAwsKmsMultiKeyringInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMultiKeyringInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICreateAwsKmsMultiKeyringInput create(Wrappers_Compile._IOption<Dafny.ISequence<char>> generator, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> kmsKeyIds, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> clientSupplier, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      return new CreateAwsKmsMultiKeyringInput(generator, kmsKeyIds, clientSupplier, grantTokens);
    }
    public static _ICreateAwsKmsMultiKeyringInput create_CreateAwsKmsMultiKeyringInput(Wrappers_Compile._IOption<Dafny.ISequence<char>> generator, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> kmsKeyIds, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> clientSupplier, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      return create(generator, kmsKeyIds, clientSupplier, grantTokens);
    }
    public bool is_CreateAwsKmsMultiKeyringInput { get { return true; } }
    public Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_generator {
      get {
        return this._generator;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_kmsKeyIds {
      get {
        return this._kmsKeyIds;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier> dtor_clientSupplier {
      get {
        return this._clientSupplier;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens {
      get {
        return this._grantTokens;
      }
    }
  }

  public interface _ICreateAwsKmsRsaKeyringInput {
    bool is_CreateAwsKmsRsaKeyringInput { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_publicKey { get; }
    Dafny.ISequence<char> dtor_kmsKeyId { get; }
    software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec dtor_encryptionAlgorithm { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient> dtor_kmsClient { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens { get; }
    _ICreateAwsKmsRsaKeyringInput DowncastClone();
  }
  public class CreateAwsKmsRsaKeyringInput : _ICreateAwsKmsRsaKeyringInput {
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<byte>> _publicKey;
    public readonly Dafny.ISequence<char> _kmsKeyId;
    public readonly software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec _encryptionAlgorithm;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient> _kmsClient;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> _grantTokens;
    public CreateAwsKmsRsaKeyringInput(Wrappers_Compile._IOption<Dafny.ISequence<byte>> publicKey, Dafny.ISequence<char> kmsKeyId, software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec encryptionAlgorithm, Wrappers_Compile._IOption<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient> kmsClient, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      this._publicKey = publicKey;
      this._kmsKeyId = kmsKeyId;
      this._encryptionAlgorithm = encryptionAlgorithm;
      this._kmsClient = kmsClient;
      this._grantTokens = grantTokens;
    }
    public _ICreateAwsKmsRsaKeyringInput DowncastClone() {
      if (this is _ICreateAwsKmsRsaKeyringInput dt) { return dt; }
      return new CreateAwsKmsRsaKeyringInput(_publicKey, _kmsKeyId, _encryptionAlgorithm, _kmsClient, _grantTokens);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CreateAwsKmsRsaKeyringInput;
      return oth != null && object.Equals(this._publicKey, oth._publicKey) && object.Equals(this._kmsKeyId, oth._kmsKeyId) && object.Equals(this._encryptionAlgorithm, oth._encryptionAlgorithm) && object.Equals(this._kmsClient, oth._kmsClient) && object.Equals(this._grantTokens, oth._grantTokens);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._publicKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._kmsKeyId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptionAlgorithm));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._kmsClient));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._grantTokens));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CreateAwsKmsRsaKeyringInput.CreateAwsKmsRsaKeyringInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._publicKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this._kmsKeyId);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptionAlgorithm);
      s += ", ";
      s += Dafny.Helpers.ToString(this._kmsClient);
      s += ", ";
      s += Dafny.Helpers.ToString(this._grantTokens);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsRsaKeyringInput theDefault = create(Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default(), Dafny.Sequence<char>.Empty, software.amazon.cryptography.services.kms.internaldafny.types.EncryptionAlgorithmSpec.Default(), Wrappers_Compile.Option<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient>.Default(), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsRsaKeyringInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsRsaKeyringInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsRsaKeyringInput>(software.amazon.cryptography.materialproviders.internaldafny.types.CreateAwsKmsRsaKeyringInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsRsaKeyringInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICreateAwsKmsRsaKeyringInput create(Wrappers_Compile._IOption<Dafny.ISequence<byte>> publicKey, Dafny.ISequence<char> kmsKeyId, software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec encryptionAlgorithm, Wrappers_Compile._IOption<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient> kmsClient, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      return new CreateAwsKmsRsaKeyringInput(publicKey, kmsKeyId, encryptionAlgorithm, kmsClient, grantTokens);
    }
    public static _ICreateAwsKmsRsaKeyringInput create_CreateAwsKmsRsaKeyringInput(Wrappers_Compile._IOption<Dafny.ISequence<byte>> publicKey, Dafny.ISequence<char> kmsKeyId, software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec encryptionAlgorithm, Wrappers_Compile._IOption<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient> kmsClient, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      return create(publicKey, kmsKeyId, encryptionAlgorithm, kmsClient, grantTokens);
    }
    public bool is_CreateAwsKmsRsaKeyringInput { get { return true; } }
    public Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_publicKey {
      get {
        return this._publicKey;
      }
    }
    public Dafny.ISequence<char> dtor_kmsKeyId {
      get {
        return this._kmsKeyId;
      }
    }
    public software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec dtor_encryptionAlgorithm {
      get {
        return this._encryptionAlgorithm;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient> dtor_kmsClient {
      get {
        return this._kmsClient;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_grantTokens {
      get {
        return this._grantTokens;
      }
    }
  }

  public interface _ICreateCryptographicMaterialsCacheInput {
    bool is_CreateCryptographicMaterialsCacheInput { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType dtor_cache { get; }
    _ICreateCryptographicMaterialsCacheInput DowncastClone();
  }
  public class CreateCryptographicMaterialsCacheInput : _ICreateCryptographicMaterialsCacheInput {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType _cache;
    public CreateCryptographicMaterialsCacheInput(software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType cache) {
      this._cache = cache;
    }
    public _ICreateCryptographicMaterialsCacheInput DowncastClone() {
      if (this is _ICreateCryptographicMaterialsCacheInput dt) { return dt; }
      return new CreateCryptographicMaterialsCacheInput(_cache);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CreateCryptographicMaterialsCacheInput;
      return oth != null && object.Equals(this._cache, oth._cache);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._cache));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CreateCryptographicMaterialsCacheInput.CreateCryptographicMaterialsCacheInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._cache);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICreateCryptographicMaterialsCacheInput theDefault = create(software.amazon.cryptography.materialproviders.internaldafny.types.CacheType.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._ICreateCryptographicMaterialsCacheInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateCryptographicMaterialsCacheInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateCryptographicMaterialsCacheInput>(software.amazon.cryptography.materialproviders.internaldafny.types.CreateCryptographicMaterialsCacheInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateCryptographicMaterialsCacheInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICreateCryptographicMaterialsCacheInput create(software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType cache) {
      return new CreateCryptographicMaterialsCacheInput(cache);
    }
    public static _ICreateCryptographicMaterialsCacheInput create_CreateCryptographicMaterialsCacheInput(software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType cache) {
      return create(cache);
    }
    public bool is_CreateCryptographicMaterialsCacheInput { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType dtor_cache {
      get {
        return this._cache;
      }
    }
  }

  public interface _ICreateDefaultClientSupplierInput {
    bool is_CreateDefaultClientSupplierInput { get; }
    _ICreateDefaultClientSupplierInput DowncastClone();
  }
  public class CreateDefaultClientSupplierInput : _ICreateDefaultClientSupplierInput {
    public CreateDefaultClientSupplierInput() {
    }
    public _ICreateDefaultClientSupplierInput DowncastClone() {
      if (this is _ICreateDefaultClientSupplierInput dt) { return dt; }
      return new CreateDefaultClientSupplierInput();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CreateDefaultClientSupplierInput;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CreateDefaultClientSupplierInput.CreateDefaultClientSupplierInput";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICreateDefaultClientSupplierInput theDefault = create();
    public static software.amazon.cryptography.materialproviders.internaldafny.types._ICreateDefaultClientSupplierInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateDefaultClientSupplierInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateDefaultClientSupplierInput>(software.amazon.cryptography.materialproviders.internaldafny.types.CreateDefaultClientSupplierInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateDefaultClientSupplierInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICreateDefaultClientSupplierInput create() {
      return new CreateDefaultClientSupplierInput();
    }
    public static _ICreateDefaultClientSupplierInput create_CreateDefaultClientSupplierInput() {
      return create();
    }
    public bool is_CreateDefaultClientSupplierInput { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_ICreateDefaultClientSupplierInput> AllSingletonConstructors {
      get {
        yield return CreateDefaultClientSupplierInput.create();
      }
    }
  }

  public interface _ICreateDefaultCryptographicMaterialsManagerInput {
    bool is_CreateDefaultCryptographicMaterialsManagerInput { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring dtor_keyring { get; }
    _ICreateDefaultCryptographicMaterialsManagerInput DowncastClone();
  }
  public class CreateDefaultCryptographicMaterialsManagerInput : _ICreateDefaultCryptographicMaterialsManagerInput {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring _keyring;
    public CreateDefaultCryptographicMaterialsManagerInput(software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring keyring) {
      this._keyring = keyring;
    }
    public _ICreateDefaultCryptographicMaterialsManagerInput DowncastClone() {
      if (this is _ICreateDefaultCryptographicMaterialsManagerInput dt) { return dt; }
      return new CreateDefaultCryptographicMaterialsManagerInput(_keyring);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CreateDefaultCryptographicMaterialsManagerInput;
      return oth != null && this._keyring == oth._keyring;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keyring));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CreateDefaultCryptographicMaterialsManagerInput.CreateDefaultCryptographicMaterialsManagerInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._keyring);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICreateDefaultCryptographicMaterialsManagerInput theDefault = create(default(software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring));
    public static software.amazon.cryptography.materialproviders.internaldafny.types._ICreateDefaultCryptographicMaterialsManagerInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateDefaultCryptographicMaterialsManagerInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateDefaultCryptographicMaterialsManagerInput>(software.amazon.cryptography.materialproviders.internaldafny.types.CreateDefaultCryptographicMaterialsManagerInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateDefaultCryptographicMaterialsManagerInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICreateDefaultCryptographicMaterialsManagerInput create(software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring keyring) {
      return new CreateDefaultCryptographicMaterialsManagerInput(keyring);
    }
    public static _ICreateDefaultCryptographicMaterialsManagerInput create_CreateDefaultCryptographicMaterialsManagerInput(software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring keyring) {
      return create(keyring);
    }
    public bool is_CreateDefaultCryptographicMaterialsManagerInput { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring dtor_keyring {
      get {
        return this._keyring;
      }
    }
  }

  public interface _ICreateMultiKeyringInput {
    bool is_CreateMultiKeyringInput { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> dtor_generator { get; }
    Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> dtor_childKeyrings { get; }
    _ICreateMultiKeyringInput DowncastClone();
  }
  public class CreateMultiKeyringInput : _ICreateMultiKeyringInput {
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> _generator;
    public readonly Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> _childKeyrings;
    public CreateMultiKeyringInput(Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> generator, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> childKeyrings) {
      this._generator = generator;
      this._childKeyrings = childKeyrings;
    }
    public _ICreateMultiKeyringInput DowncastClone() {
      if (this is _ICreateMultiKeyringInput dt) { return dt; }
      return new CreateMultiKeyringInput(_generator, _childKeyrings);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CreateMultiKeyringInput;
      return oth != null && object.Equals(this._generator, oth._generator) && object.Equals(this._childKeyrings, oth._childKeyrings);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._generator));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._childKeyrings));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CreateMultiKeyringInput.CreateMultiKeyringInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._generator);
      s += ", ";
      s += Dafny.Helpers.ToString(this._childKeyrings);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICreateMultiKeyringInput theDefault = create(Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>.Default(), Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>.Empty);
    public static software.amazon.cryptography.materialproviders.internaldafny.types._ICreateMultiKeyringInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateMultiKeyringInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateMultiKeyringInput>(software.amazon.cryptography.materialproviders.internaldafny.types.CreateMultiKeyringInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateMultiKeyringInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICreateMultiKeyringInput create(Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> generator, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> childKeyrings) {
      return new CreateMultiKeyringInput(generator, childKeyrings);
    }
    public static _ICreateMultiKeyringInput create_CreateMultiKeyringInput(Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> generator, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> childKeyrings) {
      return create(generator, childKeyrings);
    }
    public bool is_CreateMultiKeyringInput { get { return true; } }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> dtor_generator {
      get {
        return this._generator;
      }
    }
    public Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> dtor_childKeyrings {
      get {
        return this._childKeyrings;
      }
    }
  }

  public interface _ICreateRawAesKeyringInput {
    bool is_CreateRawAesKeyringInput { get; }
    Dafny.ISequence<char> dtor_keyNamespace { get; }
    Dafny.ISequence<char> dtor_keyName { get; }
    Dafny.ISequence<byte> dtor_wrappingKey { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IAesWrappingAlg dtor_wrappingAlg { get; }
    _ICreateRawAesKeyringInput DowncastClone();
  }
  public class CreateRawAesKeyringInput : _ICreateRawAesKeyringInput {
    public readonly Dafny.ISequence<char> _keyNamespace;
    public readonly Dafny.ISequence<char> _keyName;
    public readonly Dafny.ISequence<byte> _wrappingKey;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IAesWrappingAlg _wrappingAlg;
    public CreateRawAesKeyringInput(Dafny.ISequence<char> keyNamespace, Dafny.ISequence<char> keyName, Dafny.ISequence<byte> wrappingKey, software.amazon.cryptography.materialproviders.internaldafny.types._IAesWrappingAlg wrappingAlg) {
      this._keyNamespace = keyNamespace;
      this._keyName = keyName;
      this._wrappingKey = wrappingKey;
      this._wrappingAlg = wrappingAlg;
    }
    public _ICreateRawAesKeyringInput DowncastClone() {
      if (this is _ICreateRawAesKeyringInput dt) { return dt; }
      return new CreateRawAesKeyringInput(_keyNamespace, _keyName, _wrappingKey, _wrappingAlg);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CreateRawAesKeyringInput;
      return oth != null && object.Equals(this._keyNamespace, oth._keyNamespace) && object.Equals(this._keyName, oth._keyName) && object.Equals(this._wrappingKey, oth._wrappingKey) && object.Equals(this._wrappingAlg, oth._wrappingAlg);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keyNamespace));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keyName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._wrappingKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._wrappingAlg));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CreateRawAesKeyringInput.CreateRawAesKeyringInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._keyNamespace);
      s += ", ";
      s += Dafny.Helpers.ToString(this._keyName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._wrappingKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this._wrappingAlg);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRawAesKeyringInput theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, Dafny.Sequence<byte>.Empty, software.amazon.cryptography.materialproviders.internaldafny.types.AesWrappingAlg.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRawAesKeyringInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRawAesKeyringInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRawAesKeyringInput>(software.amazon.cryptography.materialproviders.internaldafny.types.CreateRawAesKeyringInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRawAesKeyringInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICreateRawAesKeyringInput create(Dafny.ISequence<char> keyNamespace, Dafny.ISequence<char> keyName, Dafny.ISequence<byte> wrappingKey, software.amazon.cryptography.materialproviders.internaldafny.types._IAesWrappingAlg wrappingAlg) {
      return new CreateRawAesKeyringInput(keyNamespace, keyName, wrappingKey, wrappingAlg);
    }
    public static _ICreateRawAesKeyringInput create_CreateRawAesKeyringInput(Dafny.ISequence<char> keyNamespace, Dafny.ISequence<char> keyName, Dafny.ISequence<byte> wrappingKey, software.amazon.cryptography.materialproviders.internaldafny.types._IAesWrappingAlg wrappingAlg) {
      return create(keyNamespace, keyName, wrappingKey, wrappingAlg);
    }
    public bool is_CreateRawAesKeyringInput { get { return true; } }
    public Dafny.ISequence<char> dtor_keyNamespace {
      get {
        return this._keyNamespace;
      }
    }
    public Dafny.ISequence<char> dtor_keyName {
      get {
        return this._keyName;
      }
    }
    public Dafny.ISequence<byte> dtor_wrappingKey {
      get {
        return this._wrappingKey;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IAesWrappingAlg dtor_wrappingAlg {
      get {
        return this._wrappingAlg;
      }
    }
  }

  public interface _ICreateRawRsaKeyringInput {
    bool is_CreateRawRsaKeyringInput { get; }
    Dafny.ISequence<char> dtor_keyNamespace { get; }
    Dafny.ISequence<char> dtor_keyName { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IPaddingScheme dtor_paddingScheme { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_publicKey { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_privateKey { get; }
    _ICreateRawRsaKeyringInput DowncastClone();
  }
  public class CreateRawRsaKeyringInput : _ICreateRawRsaKeyringInput {
    public readonly Dafny.ISequence<char> _keyNamespace;
    public readonly Dafny.ISequence<char> _keyName;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IPaddingScheme _paddingScheme;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<byte>> _publicKey;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<byte>> _privateKey;
    public CreateRawRsaKeyringInput(Dafny.ISequence<char> keyNamespace, Dafny.ISequence<char> keyName, software.amazon.cryptography.materialproviders.internaldafny.types._IPaddingScheme paddingScheme, Wrappers_Compile._IOption<Dafny.ISequence<byte>> publicKey, Wrappers_Compile._IOption<Dafny.ISequence<byte>> privateKey) {
      this._keyNamespace = keyNamespace;
      this._keyName = keyName;
      this._paddingScheme = paddingScheme;
      this._publicKey = publicKey;
      this._privateKey = privateKey;
    }
    public _ICreateRawRsaKeyringInput DowncastClone() {
      if (this is _ICreateRawRsaKeyringInput dt) { return dt; }
      return new CreateRawRsaKeyringInput(_keyNamespace, _keyName, _paddingScheme, _publicKey, _privateKey);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CreateRawRsaKeyringInput;
      return oth != null && object.Equals(this._keyNamespace, oth._keyNamespace) && object.Equals(this._keyName, oth._keyName) && object.Equals(this._paddingScheme, oth._paddingScheme) && object.Equals(this._publicKey, oth._publicKey) && object.Equals(this._privateKey, oth._privateKey);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keyNamespace));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keyName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._paddingScheme));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._publicKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._privateKey));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CreateRawRsaKeyringInput.CreateRawRsaKeyringInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._keyNamespace);
      s += ", ";
      s += Dafny.Helpers.ToString(this._keyName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._paddingScheme);
      s += ", ";
      s += Dafny.Helpers.ToString(this._publicKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this._privateKey);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRawRsaKeyringInput theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, software.amazon.cryptography.materialproviders.internaldafny.types.PaddingScheme.Default(), Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRawRsaKeyringInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRawRsaKeyringInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRawRsaKeyringInput>(software.amazon.cryptography.materialproviders.internaldafny.types.CreateRawRsaKeyringInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRawRsaKeyringInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICreateRawRsaKeyringInput create(Dafny.ISequence<char> keyNamespace, Dafny.ISequence<char> keyName, software.amazon.cryptography.materialproviders.internaldafny.types._IPaddingScheme paddingScheme, Wrappers_Compile._IOption<Dafny.ISequence<byte>> publicKey, Wrappers_Compile._IOption<Dafny.ISequence<byte>> privateKey) {
      return new CreateRawRsaKeyringInput(keyNamespace, keyName, paddingScheme, publicKey, privateKey);
    }
    public static _ICreateRawRsaKeyringInput create_CreateRawRsaKeyringInput(Dafny.ISequence<char> keyNamespace, Dafny.ISequence<char> keyName, software.amazon.cryptography.materialproviders.internaldafny.types._IPaddingScheme paddingScheme, Wrappers_Compile._IOption<Dafny.ISequence<byte>> publicKey, Wrappers_Compile._IOption<Dafny.ISequence<byte>> privateKey) {
      return create(keyNamespace, keyName, paddingScheme, publicKey, privateKey);
    }
    public bool is_CreateRawRsaKeyringInput { get { return true; } }
    public Dafny.ISequence<char> dtor_keyNamespace {
      get {
        return this._keyNamespace;
      }
    }
    public Dafny.ISequence<char> dtor_keyName {
      get {
        return this._keyName;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IPaddingScheme dtor_paddingScheme {
      get {
        return this._paddingScheme;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_publicKey {
      get {
        return this._publicKey;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_privateKey {
      get {
        return this._privateKey;
      }
    }
  }

  public interface _ICreateRequiredEncryptionContextCMMInput {
    bool is_CreateRequiredEncryptionContextCMMInput { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager> dtor_underlyingCMM { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> dtor_keyring { get; }
    Dafny.ISequence<Dafny.ISequence<byte>> dtor_requiredEncryptionContextKeys { get; }
    _ICreateRequiredEncryptionContextCMMInput DowncastClone();
  }
  public class CreateRequiredEncryptionContextCMMInput : _ICreateRequiredEncryptionContextCMMInput {
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager> _underlyingCMM;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> _keyring;
    public readonly Dafny.ISequence<Dafny.ISequence<byte>> _requiredEncryptionContextKeys;
    public CreateRequiredEncryptionContextCMMInput(Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager> underlyingCMM, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> keyring, Dafny.ISequence<Dafny.ISequence<byte>> requiredEncryptionContextKeys) {
      this._underlyingCMM = underlyingCMM;
      this._keyring = keyring;
      this._requiredEncryptionContextKeys = requiredEncryptionContextKeys;
    }
    public _ICreateRequiredEncryptionContextCMMInput DowncastClone() {
      if (this is _ICreateRequiredEncryptionContextCMMInput dt) { return dt; }
      return new CreateRequiredEncryptionContextCMMInput(_underlyingCMM, _keyring, _requiredEncryptionContextKeys);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.CreateRequiredEncryptionContextCMMInput;
      return oth != null && object.Equals(this._underlyingCMM, oth._underlyingCMM) && object.Equals(this._keyring, oth._keyring) && object.Equals(this._requiredEncryptionContextKeys, oth._requiredEncryptionContextKeys);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._underlyingCMM));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keyring));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._requiredEncryptionContextKeys));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.CreateRequiredEncryptionContextCMMInput.CreateRequiredEncryptionContextCMMInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._underlyingCMM);
      s += ", ";
      s += Dafny.Helpers.ToString(this._keyring);
      s += ", ";
      s += Dafny.Helpers.ToString(this._requiredEncryptionContextKeys);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRequiredEncryptionContextCMMInput theDefault = create(Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager>.Default(), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>.Default(), Dafny.Sequence<Dafny.ISequence<byte>>.Empty);
    public static software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRequiredEncryptionContextCMMInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRequiredEncryptionContextCMMInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRequiredEncryptionContextCMMInput>(software.amazon.cryptography.materialproviders.internaldafny.types.CreateRequiredEncryptionContextCMMInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRequiredEncryptionContextCMMInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICreateRequiredEncryptionContextCMMInput create(Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager> underlyingCMM, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> keyring, Dafny.ISequence<Dafny.ISequence<byte>> requiredEncryptionContextKeys) {
      return new CreateRequiredEncryptionContextCMMInput(underlyingCMM, keyring, requiredEncryptionContextKeys);
    }
    public static _ICreateRequiredEncryptionContextCMMInput create_CreateRequiredEncryptionContextCMMInput(Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager> underlyingCMM, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> keyring, Dafny.ISequence<Dafny.ISequence<byte>> requiredEncryptionContextKeys) {
      return create(underlyingCMM, keyring, requiredEncryptionContextKeys);
    }
    public bool is_CreateRequiredEncryptionContextCMMInput { get { return true; } }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager> dtor_underlyingCMM {
      get {
        return this._underlyingCMM;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> dtor_keyring {
      get {
        return this._keyring;
      }
    }
    public Dafny.ISequence<Dafny.ISequence<byte>> dtor_requiredEncryptionContextKeys {
      get {
        return this._requiredEncryptionContextKeys;
      }
    }
  }

  public partial class ICryptographicMaterialsCacheCallHistory {
    public ICryptographicMaterialsCacheCallHistory() {
    }
  }

  public interface ICryptographicMaterialsCache {
    Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> PutCacheEntry(software.amazon.cryptography.materialproviders.internaldafny.types._IPutCacheEntryInput input);
    Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> PutCacheEntry_k(software.amazon.cryptography.materialproviders.internaldafny.types._IPutCacheEntryInput input);
    Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> UpdateUsageMetadata(software.amazon.cryptography.materialproviders.internaldafny.types._IUpdateUsageMetadataInput input);
    Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> UpdateUsageMetadata_k(software.amazon.cryptography.materialproviders.internaldafny.types._IUpdateUsageMetadataInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetCacheEntry(software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetCacheEntry_k(software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryInput input);
    Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> DeleteCacheEntry(software.amazon.cryptography.materialproviders.internaldafny.types._IDeleteCacheEntryInput input);
    Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> DeleteCacheEntry_k(software.amazon.cryptography.materialproviders.internaldafny.types._IDeleteCacheEntryInput input);
  }
  public class _Companion_ICryptographicMaterialsCache {
    public static Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> PutCacheEntry(software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache _this, software.amazon.cryptography.materialproviders.internaldafny.types._IPutCacheEntryInput input)
    {
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out2;
      _out2 = (_this).PutCacheEntry_k(input);
      output = _out2;
      return output;
    }
    public static Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> UpdateUsageMetadata(software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache _this, software.amazon.cryptography.materialproviders.internaldafny.types._IUpdateUsageMetadataInput input)
    {
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out3;
      _out3 = (_this).UpdateUsageMetadata_k(input);
      output = _out3;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetCacheEntry(software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache _this, software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out4;
      _out4 = (_this).GetCacheEntry_k(input);
      output = _out4;
      return output;
    }
    public static Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> DeleteCacheEntry(software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache _this, software.amazon.cryptography.materialproviders.internaldafny.types._IDeleteCacheEntryInput input)
    {
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out5;
      _out5 = (_this).DeleteCacheEntry_k(input);
      output = _out5;
      return output;
    }
  }

  public partial class ICryptographicMaterialsManagerCallHistory {
    public ICryptographicMaterialsManagerCallHistory() {
    }
  }

  public interface ICryptographicMaterialsManager {
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetEncryptionMaterials(software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetEncryptionMaterials_k(software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> DecryptMaterials(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> DecryptMaterials_k(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsInput input);
  }
  public class _Companion_ICryptographicMaterialsManager {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetEncryptionMaterials(software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager _this, software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out6;
      _out6 = (_this).GetEncryptionMaterials_k(input);
      output = _out6;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> DecryptMaterials(software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager _this, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out7;
      _out7 = (_this).DecryptMaterials_k(input);
      output = _out7;
      return output;
    }
  }

  public interface _IDBEAlgorithmSuiteId {
    bool is_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__SYMSIG__HMAC__SHA384 { get; }
    bool is_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384__SYMSIG__HMAC__SHA384 { get; }
    _IDBEAlgorithmSuiteId DowncastClone();
  }
  public abstract class DBEAlgorithmSuiteId : _IDBEAlgorithmSuiteId {
    public DBEAlgorithmSuiteId() { }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId theDefault = create_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__SYMSIG__HMAC__SHA384();
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId>(software.amazon.cryptography.materialproviders.internaldafny.types.DBEAlgorithmSuiteId.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDBEAlgorithmSuiteId create_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__SYMSIG__HMAC__SHA384() {
      return new DBEAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__SYMSIG__HMAC__SHA384();
    }
    public static _IDBEAlgorithmSuiteId create_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384__SYMSIG__HMAC__SHA384() {
      return new DBEAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384__SYMSIG__HMAC__SHA384();
    }
    public bool is_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__SYMSIG__HMAC__SHA384 { get { return this is DBEAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__SYMSIG__HMAC__SHA384; } }
    public bool is_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384__SYMSIG__HMAC__SHA384 { get { return this is DBEAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384__SYMSIG__HMAC__SHA384; } }
    public static System.Collections.Generic.IEnumerable<_IDBEAlgorithmSuiteId> AllSingletonConstructors {
      get {
        yield return DBEAlgorithmSuiteId.create_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__SYMSIG__HMAC__SHA384();
        yield return DBEAlgorithmSuiteId.create_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384__SYMSIG__HMAC__SHA384();
      }
    }
    public abstract _IDBEAlgorithmSuiteId DowncastClone();
  }
  public class DBEAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__SYMSIG__HMAC__SHA384 : DBEAlgorithmSuiteId {
    public DBEAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__SYMSIG__HMAC__SHA384() {
    }
    public override _IDBEAlgorithmSuiteId DowncastClone() {
      if (this is _IDBEAlgorithmSuiteId dt) { return dt; }
      return new DBEAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__SYMSIG__HMAC__SHA384();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.DBEAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__SYMSIG__HMAC__SHA384;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.DBEAlgorithmSuiteId.ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_SYMSIG_HMAC_SHA384";
      return s;
    }
  }
  public class DBEAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384__SYMSIG__HMAC__SHA384 : DBEAlgorithmSuiteId {
    public DBEAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384__SYMSIG__HMAC__SHA384() {
    }
    public override _IDBEAlgorithmSuiteId DowncastClone() {
      if (this is _IDBEAlgorithmSuiteId dt) { return dt; }
      return new DBEAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384__SYMSIG__HMAC__SHA384();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.DBEAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384__SYMSIG__HMAC__SHA384;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.DBEAlgorithmSuiteId.ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384_SYMSIG_HMAC_SHA384";
      return s;
    }
  }

  public interface _IDBECommitmentPolicy {
    bool is_REQUIRE__ENCRYPT__REQUIRE__DECRYPT { get; }
    _IDBECommitmentPolicy DowncastClone();
  }
  public class DBECommitmentPolicy : _IDBECommitmentPolicy {
    public DBECommitmentPolicy() {
    }
    public _IDBECommitmentPolicy DowncastClone() {
      if (this is _IDBECommitmentPolicy dt) { return dt; }
      return new DBECommitmentPolicy();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.DBECommitmentPolicy;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.DBECommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDBECommitmentPolicy theDefault = create();
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IDBECommitmentPolicy Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDBECommitmentPolicy> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDBECommitmentPolicy>(software.amazon.cryptography.materialproviders.internaldafny.types.DBECommitmentPolicy.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDBECommitmentPolicy> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDBECommitmentPolicy create() {
      return new DBECommitmentPolicy();
    }
    public static _IDBECommitmentPolicy create_REQUIRE__ENCRYPT__REQUIRE__DECRYPT() {
      return create();
    }
    public bool is_REQUIRE__ENCRYPT__REQUIRE__DECRYPT { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_IDBECommitmentPolicy> AllSingletonConstructors {
      get {
        yield return DBECommitmentPolicy.create();
      }
    }
  }

  public interface _IDecryptionMaterials {
    bool is_DecryptionMaterials { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo dtor_algorithmSuite { get; }
    Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext { get; }
    Dafny.ISequence<Dafny.ISequence<byte>> dtor_requiredEncryptionContextKeys { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_plaintextDataKey { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_verificationKey { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_symmetricSigningKey { get; }
    _IDecryptionMaterials DowncastClone();
  }
  public class DecryptionMaterials : _IDecryptionMaterials {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _algorithmSuite;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _encryptionContext;
    public readonly Dafny.ISequence<Dafny.ISequence<byte>> _requiredEncryptionContextKeys;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<byte>> _plaintextDataKey;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<byte>> _verificationKey;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<byte>> _symmetricSigningKey;
    public DecryptionMaterials(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo algorithmSuite, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<Dafny.ISequence<byte>> requiredEncryptionContextKeys, Wrappers_Compile._IOption<Dafny.ISequence<byte>> plaintextDataKey, Wrappers_Compile._IOption<Dafny.ISequence<byte>> verificationKey, Wrappers_Compile._IOption<Dafny.ISequence<byte>> symmetricSigningKey) {
      this._algorithmSuite = algorithmSuite;
      this._encryptionContext = encryptionContext;
      this._requiredEncryptionContextKeys = requiredEncryptionContextKeys;
      this._plaintextDataKey = plaintextDataKey;
      this._verificationKey = verificationKey;
      this._symmetricSigningKey = symmetricSigningKey;
    }
    public _IDecryptionMaterials DowncastClone() {
      if (this is _IDecryptionMaterials dt) { return dt; }
      return new DecryptionMaterials(_algorithmSuite, _encryptionContext, _requiredEncryptionContextKeys, _plaintextDataKey, _verificationKey, _symmetricSigningKey);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.DecryptionMaterials;
      return oth != null && object.Equals(this._algorithmSuite, oth._algorithmSuite) && object.Equals(this._encryptionContext, oth._encryptionContext) && object.Equals(this._requiredEncryptionContextKeys, oth._requiredEncryptionContextKeys) && object.Equals(this._plaintextDataKey, oth._plaintextDataKey) && object.Equals(this._verificationKey, oth._verificationKey) && object.Equals(this._symmetricSigningKey, oth._symmetricSigningKey);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._algorithmSuite));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._requiredEncryptionContextKeys));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._plaintextDataKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._verificationKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._symmetricSigningKey));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.DecryptionMaterials.DecryptionMaterials";
      s += "(";
      s += Dafny.Helpers.ToString(this._algorithmSuite);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this._requiredEncryptionContextKeys);
      s += ", ";
      s += Dafny.Helpers.ToString(this._plaintextDataKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this._verificationKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this._symmetricSigningKey);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials theDefault = create(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteInfo.Default(), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Dafny.Sequence<Dafny.ISequence<byte>>.Empty, Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>(software.amazon.cryptography.materialproviders.internaldafny.types.DecryptionMaterials.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDecryptionMaterials create(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo algorithmSuite, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<Dafny.ISequence<byte>> requiredEncryptionContextKeys, Wrappers_Compile._IOption<Dafny.ISequence<byte>> plaintextDataKey, Wrappers_Compile._IOption<Dafny.ISequence<byte>> verificationKey, Wrappers_Compile._IOption<Dafny.ISequence<byte>> symmetricSigningKey) {
      return new DecryptionMaterials(algorithmSuite, encryptionContext, requiredEncryptionContextKeys, plaintextDataKey, verificationKey, symmetricSigningKey);
    }
    public static _IDecryptionMaterials create_DecryptionMaterials(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo algorithmSuite, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<Dafny.ISequence<byte>> requiredEncryptionContextKeys, Wrappers_Compile._IOption<Dafny.ISequence<byte>> plaintextDataKey, Wrappers_Compile._IOption<Dafny.ISequence<byte>> verificationKey, Wrappers_Compile._IOption<Dafny.ISequence<byte>> symmetricSigningKey) {
      return create(algorithmSuite, encryptionContext, requiredEncryptionContextKeys, plaintextDataKey, verificationKey, symmetricSigningKey);
    }
    public bool is_DecryptionMaterials { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo dtor_algorithmSuite {
      get {
        return this._algorithmSuite;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this._encryptionContext;
      }
    }
    public Dafny.ISequence<Dafny.ISequence<byte>> dtor_requiredEncryptionContextKeys {
      get {
        return this._requiredEncryptionContextKeys;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_plaintextDataKey {
      get {
        return this._plaintextDataKey;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_verificationKey {
      get {
        return this._verificationKey;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_symmetricSigningKey {
      get {
        return this._symmetricSigningKey;
      }
    }
  }

  public interface _IDecryptMaterialsInput {
    bool is_DecryptMaterialsInput { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId dtor_algorithmSuiteId { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy dtor_commitmentPolicy { get; }
    Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> dtor_encryptedDataKeys { get; }
    Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext { get; }
    Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> dtor_reproducedEncryptionContext { get; }
    _IDecryptMaterialsInput DowncastClone();
  }
  public class DecryptMaterialsInput : _IDecryptMaterialsInput {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId _algorithmSuiteId;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy _commitmentPolicy;
    public readonly Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _encryptedDataKeys;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _encryptionContext;
    public readonly Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> _reproducedEncryptionContext;
    public DecryptMaterialsInput(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId algorithmSuiteId, software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy commitmentPolicy, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> encryptedDataKeys, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> reproducedEncryptionContext) {
      this._algorithmSuiteId = algorithmSuiteId;
      this._commitmentPolicy = commitmentPolicy;
      this._encryptedDataKeys = encryptedDataKeys;
      this._encryptionContext = encryptionContext;
      this._reproducedEncryptionContext = reproducedEncryptionContext;
    }
    public _IDecryptMaterialsInput DowncastClone() {
      if (this is _IDecryptMaterialsInput dt) { return dt; }
      return new DecryptMaterialsInput(_algorithmSuiteId, _commitmentPolicy, _encryptedDataKeys, _encryptionContext, _reproducedEncryptionContext);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.DecryptMaterialsInput;
      return oth != null && object.Equals(this._algorithmSuiteId, oth._algorithmSuiteId) && object.Equals(this._commitmentPolicy, oth._commitmentPolicy) && object.Equals(this._encryptedDataKeys, oth._encryptedDataKeys) && object.Equals(this._encryptionContext, oth._encryptionContext) && object.Equals(this._reproducedEncryptionContext, oth._reproducedEncryptionContext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._algorithmSuiteId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._commitmentPolicy));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptedDataKeys));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._reproducedEncryptionContext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.DecryptMaterialsInput.DecryptMaterialsInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._algorithmSuiteId);
      s += ", ";
      s += Dafny.Helpers.ToString(this._commitmentPolicy);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptedDataKeys);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this._reproducedEncryptionContext);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsInput theDefault = create(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.Default(), software.amazon.cryptography.materialproviders.internaldafny.types.CommitmentPolicy.Default(), Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.Empty, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsInput>(software.amazon.cryptography.materialproviders.internaldafny.types.DecryptMaterialsInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDecryptMaterialsInput create(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId algorithmSuiteId, software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy commitmentPolicy, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> encryptedDataKeys, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> reproducedEncryptionContext) {
      return new DecryptMaterialsInput(algorithmSuiteId, commitmentPolicy, encryptedDataKeys, encryptionContext, reproducedEncryptionContext);
    }
    public static _IDecryptMaterialsInput create_DecryptMaterialsInput(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId algorithmSuiteId, software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy commitmentPolicy, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> encryptedDataKeys, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> reproducedEncryptionContext) {
      return create(algorithmSuiteId, commitmentPolicy, encryptedDataKeys, encryptionContext, reproducedEncryptionContext);
    }
    public bool is_DecryptMaterialsInput { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId dtor_algorithmSuiteId {
      get {
        return this._algorithmSuiteId;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy dtor_commitmentPolicy {
      get {
        return this._commitmentPolicy;
      }
    }
    public Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> dtor_encryptedDataKeys {
      get {
        return this._encryptedDataKeys;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this._encryptionContext;
      }
    }
    public Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> dtor_reproducedEncryptionContext {
      get {
        return this._reproducedEncryptionContext;
      }
    }
  }

  public interface _IDecryptMaterialsOutput {
    bool is_DecryptMaterialsOutput { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials dtor_decryptionMaterials { get; }
    _IDecryptMaterialsOutput DowncastClone();
  }
  public class DecryptMaterialsOutput : _IDecryptMaterialsOutput {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _decryptionMaterials;
    public DecryptMaterialsOutput(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials decryptionMaterials) {
      this._decryptionMaterials = decryptionMaterials;
    }
    public _IDecryptMaterialsOutput DowncastClone() {
      if (this is _IDecryptMaterialsOutput dt) { return dt; }
      return new DecryptMaterialsOutput(_decryptionMaterials);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.DecryptMaterialsOutput;
      return oth != null && object.Equals(this._decryptionMaterials, oth._decryptionMaterials);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._decryptionMaterials));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.DecryptMaterialsOutput.DecryptMaterialsOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._decryptionMaterials);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput theDefault = create(software.amazon.cryptography.materialproviders.internaldafny.types.DecryptionMaterials.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput>(software.amazon.cryptography.materialproviders.internaldafny.types.DecryptMaterialsOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDecryptMaterialsOutput create(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials decryptionMaterials) {
      return new DecryptMaterialsOutput(decryptionMaterials);
    }
    public static _IDecryptMaterialsOutput create_DecryptMaterialsOutput(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials decryptionMaterials) {
      return create(decryptionMaterials);
    }
    public bool is_DecryptMaterialsOutput { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials dtor_decryptionMaterials {
      get {
        return this._decryptionMaterials;
      }
    }
  }

  public interface _IDefaultCache {
    bool is_DefaultCache { get; }
    int dtor_entryCapacity { get; }
    _IDefaultCache DowncastClone();
  }
  public class DefaultCache : _IDefaultCache {
    public readonly int _entryCapacity;
    public DefaultCache(int entryCapacity) {
      this._entryCapacity = entryCapacity;
    }
    public _IDefaultCache DowncastClone() {
      if (this is _IDefaultCache dt) { return dt; }
      return new DefaultCache(_entryCapacity);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.DefaultCache;
      return oth != null && this._entryCapacity == oth._entryCapacity;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._entryCapacity));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.DefaultCache.DefaultCache";
      s += "(";
      s += Dafny.Helpers.ToString(this._entryCapacity);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDefaultCache theDefault = create(0);
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IDefaultCache Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDefaultCache> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDefaultCache>(software.amazon.cryptography.materialproviders.internaldafny.types.DefaultCache.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDefaultCache> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDefaultCache create(int entryCapacity) {
      return new DefaultCache(entryCapacity);
    }
    public static _IDefaultCache create_DefaultCache(int entryCapacity) {
      return create(entryCapacity);
    }
    public bool is_DefaultCache { get { return true; } }
    public int dtor_entryCapacity {
      get {
        return this._entryCapacity;
      }
    }
  }

  public interface _IDeleteCacheEntryInput {
    bool is_DeleteCacheEntryInput { get; }
    Dafny.ISequence<byte> dtor_identifier { get; }
    _IDeleteCacheEntryInput DowncastClone();
  }
  public class DeleteCacheEntryInput : _IDeleteCacheEntryInput {
    public readonly Dafny.ISequence<byte> _identifier;
    public DeleteCacheEntryInput(Dafny.ISequence<byte> identifier) {
      this._identifier = identifier;
    }
    public _IDeleteCacheEntryInput DowncastClone() {
      if (this is _IDeleteCacheEntryInput dt) { return dt; }
      return new DeleteCacheEntryInput(_identifier);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.DeleteCacheEntryInput;
      return oth != null && object.Equals(this._identifier, oth._identifier);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._identifier));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.DeleteCacheEntryInput.DeleteCacheEntryInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._identifier);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDeleteCacheEntryInput theDefault = create(Dafny.Sequence<byte>.Empty);
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IDeleteCacheEntryInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDeleteCacheEntryInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDeleteCacheEntryInput>(software.amazon.cryptography.materialproviders.internaldafny.types.DeleteCacheEntryInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDeleteCacheEntryInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDeleteCacheEntryInput create(Dafny.ISequence<byte> identifier) {
      return new DeleteCacheEntryInput(identifier);
    }
    public static _IDeleteCacheEntryInput create_DeleteCacheEntryInput(Dafny.ISequence<byte> identifier) {
      return create(identifier);
    }
    public bool is_DeleteCacheEntryInput { get { return true; } }
    public Dafny.ISequence<byte> dtor_identifier {
      get {
        return this._identifier;
      }
    }
  }

  public interface _IDerivationAlgorithm {
    bool is_HKDF { get; }
    bool is_IDENTITY { get; }
    bool is_None { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IHKDF dtor_HKDF { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IIDENTITY dtor_IDENTITY { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._INone dtor_None { get; }
    _IDerivationAlgorithm DowncastClone();
  }
  public abstract class DerivationAlgorithm : _IDerivationAlgorithm {
    public DerivationAlgorithm() { }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm theDefault = create_HKDF(software.amazon.cryptography.materialproviders.internaldafny.types.HKDF.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm>(software.amazon.cryptography.materialproviders.internaldafny.types.DerivationAlgorithm.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDerivationAlgorithm create_HKDF(software.amazon.cryptography.materialproviders.internaldafny.types._IHKDF HKDF) {
      return new DerivationAlgorithm_HKDF(HKDF);
    }
    public static _IDerivationAlgorithm create_IDENTITY(software.amazon.cryptography.materialproviders.internaldafny.types._IIDENTITY IDENTITY) {
      return new DerivationAlgorithm_IDENTITY(IDENTITY);
    }
    public static _IDerivationAlgorithm create_None(software.amazon.cryptography.materialproviders.internaldafny.types._INone None) {
      return new DerivationAlgorithm_None(None);
    }
    public bool is_HKDF { get { return this is DerivationAlgorithm_HKDF; } }
    public bool is_IDENTITY { get { return this is DerivationAlgorithm_IDENTITY; } }
    public bool is_None { get { return this is DerivationAlgorithm_None; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IHKDF dtor_HKDF {
      get {
        var d = this;
        return ((DerivationAlgorithm_HKDF)d)._HKDF;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IIDENTITY dtor_IDENTITY {
      get {
        var d = this;
        return ((DerivationAlgorithm_IDENTITY)d)._IDENTITY;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._INone dtor_None {
      get {
        var d = this;
        return ((DerivationAlgorithm_None)d)._None;
      }
    }
    public abstract _IDerivationAlgorithm DowncastClone();
  }
  public class DerivationAlgorithm_HKDF : DerivationAlgorithm {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IHKDF _HKDF;
    public DerivationAlgorithm_HKDF(software.amazon.cryptography.materialproviders.internaldafny.types._IHKDF HKDF) {
      this._HKDF = HKDF;
    }
    public override _IDerivationAlgorithm DowncastClone() {
      if (this is _IDerivationAlgorithm dt) { return dt; }
      return new DerivationAlgorithm_HKDF(_HKDF);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.DerivationAlgorithm_HKDF;
      return oth != null && object.Equals(this._HKDF, oth._HKDF);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._HKDF));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.DerivationAlgorithm.HKDF";
      s += "(";
      s += Dafny.Helpers.ToString(this._HKDF);
      s += ")";
      return s;
    }
  }
  public class DerivationAlgorithm_IDENTITY : DerivationAlgorithm {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IIDENTITY _IDENTITY;
    public DerivationAlgorithm_IDENTITY(software.amazon.cryptography.materialproviders.internaldafny.types._IIDENTITY IDENTITY) {
      this._IDENTITY = IDENTITY;
    }
    public override _IDerivationAlgorithm DowncastClone() {
      if (this is _IDerivationAlgorithm dt) { return dt; }
      return new DerivationAlgorithm_IDENTITY(_IDENTITY);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.DerivationAlgorithm_IDENTITY;
      return oth != null && object.Equals(this._IDENTITY, oth._IDENTITY);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._IDENTITY));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.DerivationAlgorithm.IDENTITY";
      s += "(";
      s += Dafny.Helpers.ToString(this._IDENTITY);
      s += ")";
      return s;
    }
  }
  public class DerivationAlgorithm_None : DerivationAlgorithm {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._INone _None;
    public DerivationAlgorithm_None(software.amazon.cryptography.materialproviders.internaldafny.types._INone None) {
      this._None = None;
    }
    public override _IDerivationAlgorithm DowncastClone() {
      if (this is _IDerivationAlgorithm dt) { return dt; }
      return new DerivationAlgorithm_None(_None);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.DerivationAlgorithm_None;
      return oth != null && object.Equals(this._None, oth._None);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._None));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.DerivationAlgorithm.None";
      s += "(";
      s += Dafny.Helpers.ToString(this._None);
      s += ")";
      return s;
    }
  }

  public interface _IDIRECT__KEY__WRAPPING {
    bool is_DIRECT__KEY__WRAPPING { get; }
    _IDIRECT__KEY__WRAPPING DowncastClone();
  }
  public class DIRECT__KEY__WRAPPING : _IDIRECT__KEY__WRAPPING {
    public DIRECT__KEY__WRAPPING() {
    }
    public _IDIRECT__KEY__WRAPPING DowncastClone() {
      if (this is _IDIRECT__KEY__WRAPPING dt) { return dt; }
      return new DIRECT__KEY__WRAPPING();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.DIRECT__KEY__WRAPPING;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.DIRECT_KEY_WRAPPING.DIRECT_KEY_WRAPPING";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDIRECT__KEY__WRAPPING theDefault = create();
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IDIRECT__KEY__WRAPPING Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDIRECT__KEY__WRAPPING> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDIRECT__KEY__WRAPPING>(software.amazon.cryptography.materialproviders.internaldafny.types.DIRECT__KEY__WRAPPING.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDIRECT__KEY__WRAPPING> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDIRECT__KEY__WRAPPING create() {
      return new DIRECT__KEY__WRAPPING();
    }
    public static _IDIRECT__KEY__WRAPPING create_DIRECT__KEY__WRAPPING() {
      return create();
    }
    public bool is_DIRECT__KEY__WRAPPING { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_IDIRECT__KEY__WRAPPING> AllSingletonConstructors {
      get {
        yield return DIRECT__KEY__WRAPPING.create();
      }
    }
  }

  public interface _IDiscoveryFilter {
    bool is_DiscoveryFilter { get; }
    Dafny.ISequence<Dafny.ISequence<char>> dtor_accountIds { get; }
    Dafny.ISequence<char> dtor_partition { get; }
    _IDiscoveryFilter DowncastClone();
  }
  public class DiscoveryFilter : _IDiscoveryFilter {
    public readonly Dafny.ISequence<Dafny.ISequence<char>> _accountIds;
    public readonly Dafny.ISequence<char> _partition;
    public DiscoveryFilter(Dafny.ISequence<Dafny.ISequence<char>> accountIds, Dafny.ISequence<char> partition) {
      this._accountIds = accountIds;
      this._partition = partition;
    }
    public _IDiscoveryFilter DowncastClone() {
      if (this is _IDiscoveryFilter dt) { return dt; }
      return new DiscoveryFilter(_accountIds, _partition);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.DiscoveryFilter;
      return oth != null && object.Equals(this._accountIds, oth._accountIds) && object.Equals(this._partition, oth._partition);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._accountIds));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._partition));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.DiscoveryFilter.DiscoveryFilter";
      s += "(";
      s += Dafny.Helpers.ToString(this._accountIds);
      s += ", ";
      s += Dafny.Helpers.ToString(this._partition);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter theDefault = create(Dafny.Sequence<Dafny.ISequence<char>>.Empty, Dafny.Sequence<char>.Empty);
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter>(software.amazon.cryptography.materialproviders.internaldafny.types.DiscoveryFilter.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDiscoveryFilter create(Dafny.ISequence<Dafny.ISequence<char>> accountIds, Dafny.ISequence<char> partition) {
      return new DiscoveryFilter(accountIds, partition);
    }
    public static _IDiscoveryFilter create_DiscoveryFilter(Dafny.ISequence<Dafny.ISequence<char>> accountIds, Dafny.ISequence<char> partition) {
      return create(accountIds, partition);
    }
    public bool is_DiscoveryFilter { get { return true; } }
    public Dafny.ISequence<Dafny.ISequence<char>> dtor_accountIds {
      get {
        return this._accountIds;
      }
    }
    public Dafny.ISequence<char> dtor_partition {
      get {
        return this._partition;
      }
    }
  }

  public interface _IECDSA {
    bool is_ECDSA { get; }
    software.amazon.cryptography.primitives.internaldafny.types._IECDSASignatureAlgorithm dtor_curve { get; }
    _IECDSA DowncastClone();
  }
  public class ECDSA : _IECDSA {
    public readonly software.amazon.cryptography.primitives.internaldafny.types._IECDSASignatureAlgorithm _curve;
    public ECDSA(software.amazon.cryptography.primitives.internaldafny.types._IECDSASignatureAlgorithm curve) {
      this._curve = curve;
    }
    public _IECDSA DowncastClone() {
      if (this is _IECDSA dt) { return dt; }
      return new ECDSA(_curve);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.ECDSA;
      return oth != null && object.Equals(this._curve, oth._curve);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._curve));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.ECDSA.ECDSA";
      s += "(";
      s += Dafny.Helpers.ToString(this._curve);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IECDSA theDefault = create(software.amazon.cryptography.primitives.internaldafny.types.ECDSASignatureAlgorithm.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IECDSA Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IECDSA> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IECDSA>(software.amazon.cryptography.materialproviders.internaldafny.types.ECDSA.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IECDSA> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IECDSA create(software.amazon.cryptography.primitives.internaldafny.types._IECDSASignatureAlgorithm curve) {
      return new ECDSA(curve);
    }
    public static _IECDSA create_ECDSA(software.amazon.cryptography.primitives.internaldafny.types._IECDSASignatureAlgorithm curve) {
      return create(curve);
    }
    public bool is_ECDSA { get { return true; } }
    public software.amazon.cryptography.primitives.internaldafny.types._IECDSASignatureAlgorithm dtor_curve {
      get {
        return this._curve;
      }
    }
  }

  public interface _IEdkWrappingAlgorithm {
    bool is_DIRECT__KEY__WRAPPING { get; }
    bool is_IntermediateKeyWrapping { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IDIRECT__KEY__WRAPPING dtor_DIRECT__KEY__WRAPPING { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IIntermediateKeyWrapping dtor_IntermediateKeyWrapping { get; }
    _IEdkWrappingAlgorithm DowncastClone();
  }
  public abstract class EdkWrappingAlgorithm : _IEdkWrappingAlgorithm {
    public EdkWrappingAlgorithm() { }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IEdkWrappingAlgorithm theDefault = create_DIRECT__KEY__WRAPPING(software.amazon.cryptography.materialproviders.internaldafny.types.DIRECT__KEY__WRAPPING.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IEdkWrappingAlgorithm Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IEdkWrappingAlgorithm> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IEdkWrappingAlgorithm>(software.amazon.cryptography.materialproviders.internaldafny.types.EdkWrappingAlgorithm.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IEdkWrappingAlgorithm> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IEdkWrappingAlgorithm create_DIRECT__KEY__WRAPPING(software.amazon.cryptography.materialproviders.internaldafny.types._IDIRECT__KEY__WRAPPING DIRECT__KEY__WRAPPING) {
      return new EdkWrappingAlgorithm_DIRECT__KEY__WRAPPING(DIRECT__KEY__WRAPPING);
    }
    public static _IEdkWrappingAlgorithm create_IntermediateKeyWrapping(software.amazon.cryptography.materialproviders.internaldafny.types._IIntermediateKeyWrapping IntermediateKeyWrapping) {
      return new EdkWrappingAlgorithm_IntermediateKeyWrapping(IntermediateKeyWrapping);
    }
    public bool is_DIRECT__KEY__WRAPPING { get { return this is EdkWrappingAlgorithm_DIRECT__KEY__WRAPPING; } }
    public bool is_IntermediateKeyWrapping { get { return this is EdkWrappingAlgorithm_IntermediateKeyWrapping; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDIRECT__KEY__WRAPPING dtor_DIRECT__KEY__WRAPPING {
      get {
        var d = this;
        return ((EdkWrappingAlgorithm_DIRECT__KEY__WRAPPING)d)._DIRECT__KEY__WRAPPING;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IIntermediateKeyWrapping dtor_IntermediateKeyWrapping {
      get {
        var d = this;
        return ((EdkWrappingAlgorithm_IntermediateKeyWrapping)d)._IntermediateKeyWrapping;
      }
    }
    public abstract _IEdkWrappingAlgorithm DowncastClone();
  }
  public class EdkWrappingAlgorithm_DIRECT__KEY__WRAPPING : EdkWrappingAlgorithm {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDIRECT__KEY__WRAPPING _DIRECT__KEY__WRAPPING;
    public EdkWrappingAlgorithm_DIRECT__KEY__WRAPPING(software.amazon.cryptography.materialproviders.internaldafny.types._IDIRECT__KEY__WRAPPING DIRECT__KEY__WRAPPING) {
      this._DIRECT__KEY__WRAPPING = DIRECT__KEY__WRAPPING;
    }
    public override _IEdkWrappingAlgorithm DowncastClone() {
      if (this is _IEdkWrappingAlgorithm dt) { return dt; }
      return new EdkWrappingAlgorithm_DIRECT__KEY__WRAPPING(_DIRECT__KEY__WRAPPING);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.EdkWrappingAlgorithm_DIRECT__KEY__WRAPPING;
      return oth != null && object.Equals(this._DIRECT__KEY__WRAPPING, oth._DIRECT__KEY__WRAPPING);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._DIRECT__KEY__WRAPPING));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.EdkWrappingAlgorithm.DIRECT_KEY_WRAPPING";
      s += "(";
      s += Dafny.Helpers.ToString(this._DIRECT__KEY__WRAPPING);
      s += ")";
      return s;
    }
  }
  public class EdkWrappingAlgorithm_IntermediateKeyWrapping : EdkWrappingAlgorithm {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IIntermediateKeyWrapping _IntermediateKeyWrapping;
    public EdkWrappingAlgorithm_IntermediateKeyWrapping(software.amazon.cryptography.materialproviders.internaldafny.types._IIntermediateKeyWrapping IntermediateKeyWrapping) {
      this._IntermediateKeyWrapping = IntermediateKeyWrapping;
    }
    public override _IEdkWrappingAlgorithm DowncastClone() {
      if (this is _IEdkWrappingAlgorithm dt) { return dt; }
      return new EdkWrappingAlgorithm_IntermediateKeyWrapping(_IntermediateKeyWrapping);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.EdkWrappingAlgorithm_IntermediateKeyWrapping;
      return oth != null && object.Equals(this._IntermediateKeyWrapping, oth._IntermediateKeyWrapping);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._IntermediateKeyWrapping));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.EdkWrappingAlgorithm.IntermediateKeyWrapping";
      s += "(";
      s += Dafny.Helpers.ToString(this._IntermediateKeyWrapping);
      s += ")";
      return s;
    }
  }

  public interface _IEncrypt {
    bool is_AES__GCM { get; }
    software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM dtor_AES__GCM { get; }
    _IEncrypt DowncastClone();
  }
  public class Encrypt : _IEncrypt {
    public readonly software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM _AES__GCM;
    public Encrypt(software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM AES__GCM) {
      this._AES__GCM = AES__GCM;
    }
    public _IEncrypt DowncastClone() {
      if (this is _IEncrypt dt) { return dt; }
      return new Encrypt(_AES__GCM);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.Encrypt;
      return oth != null && object.Equals(this._AES__GCM, oth._AES__GCM);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._AES__GCM));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.Encrypt.AES_GCM";
      s += "(";
      s += Dafny.Helpers.ToString(this._AES__GCM);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt theDefault = create(software.amazon.cryptography.primitives.internaldafny.types.AES__GCM.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt>(software.amazon.cryptography.materialproviders.internaldafny.types.Encrypt.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IEncrypt create(software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM AES__GCM) {
      return new Encrypt(AES__GCM);
    }
    public static _IEncrypt create_AES__GCM(software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM AES__GCM) {
      return create(AES__GCM);
    }
    public bool is_AES__GCM { get { return true; } }
    public software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM dtor_AES__GCM {
      get {
        return this._AES__GCM;
      }
    }
  }

  public interface _IEncryptedDataKey {
    bool is_EncryptedDataKey { get; }
    Dafny.ISequence<byte> dtor_keyProviderId { get; }
    Dafny.ISequence<byte> dtor_keyProviderInfo { get; }
    Dafny.ISequence<byte> dtor_ciphertext { get; }
    _IEncryptedDataKey DowncastClone();
  }
  public class EncryptedDataKey : _IEncryptedDataKey {
    public readonly Dafny.ISequence<byte> _keyProviderId;
    public readonly Dafny.ISequence<byte> _keyProviderInfo;
    public readonly Dafny.ISequence<byte> _ciphertext;
    public EncryptedDataKey(Dafny.ISequence<byte> keyProviderId, Dafny.ISequence<byte> keyProviderInfo, Dafny.ISequence<byte> ciphertext) {
      this._keyProviderId = keyProviderId;
      this._keyProviderInfo = keyProviderInfo;
      this._ciphertext = ciphertext;
    }
    public _IEncryptedDataKey DowncastClone() {
      if (this is _IEncryptedDataKey dt) { return dt; }
      return new EncryptedDataKey(_keyProviderId, _keyProviderInfo, _ciphertext);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.EncryptedDataKey;
      return oth != null && object.Equals(this._keyProviderId, oth._keyProviderId) && object.Equals(this._keyProviderInfo, oth._keyProviderInfo) && object.Equals(this._ciphertext, oth._ciphertext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keyProviderId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keyProviderInfo));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._ciphertext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.EncryptedDataKey.EncryptedDataKey";
      s += "(";
      s += Dafny.Helpers.ToString(this._keyProviderId);
      s += ", ";
      s += Dafny.Helpers.ToString(this._keyProviderInfo);
      s += ", ";
      s += Dafny.Helpers.ToString(this._ciphertext);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey theDefault = create(UTF8.ValidUTF8Bytes.Default(), Dafny.Sequence<byte>.Empty, Dafny.Sequence<byte>.Empty);
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>(software.amazon.cryptography.materialproviders.internaldafny.types.EncryptedDataKey.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IEncryptedDataKey create(Dafny.ISequence<byte> keyProviderId, Dafny.ISequence<byte> keyProviderInfo, Dafny.ISequence<byte> ciphertext) {
      return new EncryptedDataKey(keyProviderId, keyProviderInfo, ciphertext);
    }
    public static _IEncryptedDataKey create_EncryptedDataKey(Dafny.ISequence<byte> keyProviderId, Dafny.ISequence<byte> keyProviderInfo, Dafny.ISequence<byte> ciphertext) {
      return create(keyProviderId, keyProviderInfo, ciphertext);
    }
    public bool is_EncryptedDataKey { get { return true; } }
    public Dafny.ISequence<byte> dtor_keyProviderId {
      get {
        return this._keyProviderId;
      }
    }
    public Dafny.ISequence<byte> dtor_keyProviderInfo {
      get {
        return this._keyProviderInfo;
      }
    }
    public Dafny.ISequence<byte> dtor_ciphertext {
      get {
        return this._ciphertext;
      }
    }
  }

  public interface _IEncryptionMaterials {
    bool is_EncryptionMaterials { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo dtor_algorithmSuite { get; }
    Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext { get; }
    Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> dtor_encryptedDataKeys { get; }
    Dafny.ISequence<Dafny.ISequence<byte>> dtor_requiredEncryptionContextKeys { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_plaintextDataKey { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_signingKey { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>> dtor_symmetricSigningKeys { get; }
    _IEncryptionMaterials DowncastClone();
  }
  public class EncryptionMaterials : _IEncryptionMaterials {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _algorithmSuite;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _encryptionContext;
    public readonly Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _encryptedDataKeys;
    public readonly Dafny.ISequence<Dafny.ISequence<byte>> _requiredEncryptionContextKeys;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<byte>> _plaintextDataKey;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<byte>> _signingKey;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>> _symmetricSigningKeys;
    public EncryptionMaterials(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo algorithmSuite, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> encryptedDataKeys, Dafny.ISequence<Dafny.ISequence<byte>> requiredEncryptionContextKeys, Wrappers_Compile._IOption<Dafny.ISequence<byte>> plaintextDataKey, Wrappers_Compile._IOption<Dafny.ISequence<byte>> signingKey, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>> symmetricSigningKeys) {
      this._algorithmSuite = algorithmSuite;
      this._encryptionContext = encryptionContext;
      this._encryptedDataKeys = encryptedDataKeys;
      this._requiredEncryptionContextKeys = requiredEncryptionContextKeys;
      this._plaintextDataKey = plaintextDataKey;
      this._signingKey = signingKey;
      this._symmetricSigningKeys = symmetricSigningKeys;
    }
    public _IEncryptionMaterials DowncastClone() {
      if (this is _IEncryptionMaterials dt) { return dt; }
      return new EncryptionMaterials(_algorithmSuite, _encryptionContext, _encryptedDataKeys, _requiredEncryptionContextKeys, _plaintextDataKey, _signingKey, _symmetricSigningKeys);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.EncryptionMaterials;
      return oth != null && object.Equals(this._algorithmSuite, oth._algorithmSuite) && object.Equals(this._encryptionContext, oth._encryptionContext) && object.Equals(this._encryptedDataKeys, oth._encryptedDataKeys) && object.Equals(this._requiredEncryptionContextKeys, oth._requiredEncryptionContextKeys) && object.Equals(this._plaintextDataKey, oth._plaintextDataKey) && object.Equals(this._signingKey, oth._signingKey) && object.Equals(this._symmetricSigningKeys, oth._symmetricSigningKeys);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._algorithmSuite));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptedDataKeys));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._requiredEncryptionContextKeys));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._plaintextDataKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._signingKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._symmetricSigningKeys));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.EncryptionMaterials.EncryptionMaterials";
      s += "(";
      s += Dafny.Helpers.ToString(this._algorithmSuite);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptedDataKeys);
      s += ", ";
      s += Dafny.Helpers.ToString(this._requiredEncryptionContextKeys);
      s += ", ";
      s += Dafny.Helpers.ToString(this._plaintextDataKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this._signingKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this._symmetricSigningKeys);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials theDefault = create(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteInfo.Default(), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.Empty, Dafny.Sequence<Dafny.ISequence<byte>>.Empty, Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials>(software.amazon.cryptography.materialproviders.internaldafny.types.EncryptionMaterials.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IEncryptionMaterials create(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo algorithmSuite, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> encryptedDataKeys, Dafny.ISequence<Dafny.ISequence<byte>> requiredEncryptionContextKeys, Wrappers_Compile._IOption<Dafny.ISequence<byte>> plaintextDataKey, Wrappers_Compile._IOption<Dafny.ISequence<byte>> signingKey, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>> symmetricSigningKeys) {
      return new EncryptionMaterials(algorithmSuite, encryptionContext, encryptedDataKeys, requiredEncryptionContextKeys, plaintextDataKey, signingKey, symmetricSigningKeys);
    }
    public static _IEncryptionMaterials create_EncryptionMaterials(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo algorithmSuite, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> encryptedDataKeys, Dafny.ISequence<Dafny.ISequence<byte>> requiredEncryptionContextKeys, Wrappers_Compile._IOption<Dafny.ISequence<byte>> plaintextDataKey, Wrappers_Compile._IOption<Dafny.ISequence<byte>> signingKey, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>> symmetricSigningKeys) {
      return create(algorithmSuite, encryptionContext, encryptedDataKeys, requiredEncryptionContextKeys, plaintextDataKey, signingKey, symmetricSigningKeys);
    }
    public bool is_EncryptionMaterials { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo dtor_algorithmSuite {
      get {
        return this._algorithmSuite;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this._encryptionContext;
      }
    }
    public Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> dtor_encryptedDataKeys {
      get {
        return this._encryptedDataKeys;
      }
    }
    public Dafny.ISequence<Dafny.ISequence<byte>> dtor_requiredEncryptionContextKeys {
      get {
        return this._requiredEncryptionContextKeys;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_plaintextDataKey {
      get {
        return this._plaintextDataKey;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_signingKey {
      get {
        return this._signingKey;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>> dtor_symmetricSigningKeys {
      get {
        return this._symmetricSigningKeys;
      }
    }
  }

  public interface _IESDKAlgorithmSuiteId {
    bool is_ALG__AES__128__GCM__IV12__TAG16__NO__KDF { get; }
    bool is_ALG__AES__192__GCM__IV12__TAG16__NO__KDF { get; }
    bool is_ALG__AES__256__GCM__IV12__TAG16__NO__KDF { get; }
    bool is_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256 { get; }
    bool is_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256 { get; }
    bool is_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256 { get; }
    bool is_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256 { get; }
    bool is_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384 { get; }
    bool is_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384 { get; }
    bool is_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY { get; }
    bool is_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384 { get; }
    _IESDKAlgorithmSuiteId DowncastClone();
  }
  public abstract class ESDKAlgorithmSuiteId : _IESDKAlgorithmSuiteId {
    public ESDKAlgorithmSuiteId() { }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId theDefault = create_ALG__AES__128__GCM__IV12__TAG16__NO__KDF();
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId>(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IESDKAlgorithmSuiteId create_ALG__AES__128__GCM__IV12__TAG16__NO__KDF() {
      return new ESDKAlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__NO__KDF();
    }
    public static _IESDKAlgorithmSuiteId create_ALG__AES__192__GCM__IV12__TAG16__NO__KDF() {
      return new ESDKAlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__NO__KDF();
    }
    public static _IESDKAlgorithmSuiteId create_ALG__AES__256__GCM__IV12__TAG16__NO__KDF() {
      return new ESDKAlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__NO__KDF();
    }
    public static _IESDKAlgorithmSuiteId create_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256() {
      return new ESDKAlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256();
    }
    public static _IESDKAlgorithmSuiteId create_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256() {
      return new ESDKAlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256();
    }
    public static _IESDKAlgorithmSuiteId create_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256() {
      return new ESDKAlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256();
    }
    public static _IESDKAlgorithmSuiteId create_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256() {
      return new ESDKAlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256();
    }
    public static _IESDKAlgorithmSuiteId create_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384() {
      return new ESDKAlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384();
    }
    public static _IESDKAlgorithmSuiteId create_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384() {
      return new ESDKAlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384();
    }
    public static _IESDKAlgorithmSuiteId create_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY() {
      return new ESDKAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY();
    }
    public static _IESDKAlgorithmSuiteId create_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384() {
      return new ESDKAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384();
    }
    public bool is_ALG__AES__128__GCM__IV12__TAG16__NO__KDF { get { return this is ESDKAlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__NO__KDF; } }
    public bool is_ALG__AES__192__GCM__IV12__TAG16__NO__KDF { get { return this is ESDKAlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__NO__KDF; } }
    public bool is_ALG__AES__256__GCM__IV12__TAG16__NO__KDF { get { return this is ESDKAlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__NO__KDF; } }
    public bool is_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256 { get { return this is ESDKAlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256; } }
    public bool is_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256 { get { return this is ESDKAlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256; } }
    public bool is_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256 { get { return this is ESDKAlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256; } }
    public bool is_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256 { get { return this is ESDKAlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256; } }
    public bool is_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384 { get { return this is ESDKAlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384; } }
    public bool is_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384 { get { return this is ESDKAlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384; } }
    public bool is_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY { get { return this is ESDKAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY; } }
    public bool is_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384 { get { return this is ESDKAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384; } }
    public static System.Collections.Generic.IEnumerable<_IESDKAlgorithmSuiteId> AllSingletonConstructors {
      get {
        yield return ESDKAlgorithmSuiteId.create_ALG__AES__128__GCM__IV12__TAG16__NO__KDF();
        yield return ESDKAlgorithmSuiteId.create_ALG__AES__192__GCM__IV12__TAG16__NO__KDF();
        yield return ESDKAlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__NO__KDF();
        yield return ESDKAlgorithmSuiteId.create_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256();
        yield return ESDKAlgorithmSuiteId.create_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256();
        yield return ESDKAlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256();
        yield return ESDKAlgorithmSuiteId.create_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256();
        yield return ESDKAlgorithmSuiteId.create_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384();
        yield return ESDKAlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384();
        yield return ESDKAlgorithmSuiteId.create_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY();
        yield return ESDKAlgorithmSuiteId.create_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384();
      }
    }
    public abstract _IESDKAlgorithmSuiteId DowncastClone();
  }
  public class ESDKAlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__NO__KDF : ESDKAlgorithmSuiteId {
    public ESDKAlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__NO__KDF() {
    }
    public override _IESDKAlgorithmSuiteId DowncastClone() {
      if (this is _IESDKAlgorithmSuiteId dt) { return dt; }
      return new ESDKAlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__NO__KDF();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__NO__KDF;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.ESDKAlgorithmSuiteId.ALG_AES_128_GCM_IV12_TAG16_NO_KDF";
      return s;
    }
  }
  public class ESDKAlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__NO__KDF : ESDKAlgorithmSuiteId {
    public ESDKAlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__NO__KDF() {
    }
    public override _IESDKAlgorithmSuiteId DowncastClone() {
      if (this is _IESDKAlgorithmSuiteId dt) { return dt; }
      return new ESDKAlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__NO__KDF();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__NO__KDF;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.ESDKAlgorithmSuiteId.ALG_AES_192_GCM_IV12_TAG16_NO_KDF";
      return s;
    }
  }
  public class ESDKAlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__NO__KDF : ESDKAlgorithmSuiteId {
    public ESDKAlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__NO__KDF() {
    }
    public override _IESDKAlgorithmSuiteId DowncastClone() {
      if (this is _IESDKAlgorithmSuiteId dt) { return dt; }
      return new ESDKAlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__NO__KDF();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__NO__KDF;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.ESDKAlgorithmSuiteId.ALG_AES_256_GCM_IV12_TAG16_NO_KDF";
      return s;
    }
  }
  public class ESDKAlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256 : ESDKAlgorithmSuiteId {
    public ESDKAlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256() {
    }
    public override _IESDKAlgorithmSuiteId DowncastClone() {
      if (this is _IESDKAlgorithmSuiteId dt) { return dt; }
      return new ESDKAlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.ESDKAlgorithmSuiteId.ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256";
      return s;
    }
  }
  public class ESDKAlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256 : ESDKAlgorithmSuiteId {
    public ESDKAlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256() {
    }
    public override _IESDKAlgorithmSuiteId DowncastClone() {
      if (this is _IESDKAlgorithmSuiteId dt) { return dt; }
      return new ESDKAlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 4;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.ESDKAlgorithmSuiteId.ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA256";
      return s;
    }
  }
  public class ESDKAlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256 : ESDKAlgorithmSuiteId {
    public ESDKAlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256() {
    }
    public override _IESDKAlgorithmSuiteId DowncastClone() {
      if (this is _IESDKAlgorithmSuiteId dt) { return dt; }
      return new ESDKAlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 5;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.ESDKAlgorithmSuiteId.ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA256";
      return s;
    }
  }
  public class ESDKAlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256 : ESDKAlgorithmSuiteId {
    public ESDKAlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256() {
    }
    public override _IESDKAlgorithmSuiteId DowncastClone() {
      if (this is _IESDKAlgorithmSuiteId dt) { return dt; }
      return new ESDKAlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 6;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.ESDKAlgorithmSuiteId.ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256";
      return s;
    }
  }
  public class ESDKAlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384 : ESDKAlgorithmSuiteId {
    public ESDKAlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384() {
    }
    public override _IESDKAlgorithmSuiteId DowncastClone() {
      if (this is _IESDKAlgorithmSuiteId dt) { return dt; }
      return new ESDKAlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 7;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.ESDKAlgorithmSuiteId.ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384";
      return s;
    }
  }
  public class ESDKAlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384 : ESDKAlgorithmSuiteId {
    public ESDKAlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384() {
    }
    public override _IESDKAlgorithmSuiteId DowncastClone() {
      if (this is _IESDKAlgorithmSuiteId dt) { return dt; }
      return new ESDKAlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 8;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.ESDKAlgorithmSuiteId.ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384";
      return s;
    }
  }
  public class ESDKAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY : ESDKAlgorithmSuiteId {
    public ESDKAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY() {
    }
    public override _IESDKAlgorithmSuiteId DowncastClone() {
      if (this is _IESDKAlgorithmSuiteId dt) { return dt; }
      return new ESDKAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 9;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.ESDKAlgorithmSuiteId.ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY";
      return s;
    }
  }
  public class ESDKAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384 : ESDKAlgorithmSuiteId {
    public ESDKAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384() {
    }
    public override _IESDKAlgorithmSuiteId DowncastClone() {
      if (this is _IESDKAlgorithmSuiteId dt) { return dt; }
      return new ESDKAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 10;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.ESDKAlgorithmSuiteId.ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384";
      return s;
    }
  }

  public interface _IESDKCommitmentPolicy {
    bool is_FORBID__ENCRYPT__ALLOW__DECRYPT { get; }
    bool is_REQUIRE__ENCRYPT__ALLOW__DECRYPT { get; }
    bool is_REQUIRE__ENCRYPT__REQUIRE__DECRYPT { get; }
    _IESDKCommitmentPolicy DowncastClone();
  }
  public abstract class ESDKCommitmentPolicy : _IESDKCommitmentPolicy {
    public ESDKCommitmentPolicy() { }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IESDKCommitmentPolicy theDefault = create_FORBID__ENCRYPT__ALLOW__DECRYPT();
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IESDKCommitmentPolicy Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IESDKCommitmentPolicy> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IESDKCommitmentPolicy>(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKCommitmentPolicy.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IESDKCommitmentPolicy> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IESDKCommitmentPolicy create_FORBID__ENCRYPT__ALLOW__DECRYPT() {
      return new ESDKCommitmentPolicy_FORBID__ENCRYPT__ALLOW__DECRYPT();
    }
    public static _IESDKCommitmentPolicy create_REQUIRE__ENCRYPT__ALLOW__DECRYPT() {
      return new ESDKCommitmentPolicy_REQUIRE__ENCRYPT__ALLOW__DECRYPT();
    }
    public static _IESDKCommitmentPolicy create_REQUIRE__ENCRYPT__REQUIRE__DECRYPT() {
      return new ESDKCommitmentPolicy_REQUIRE__ENCRYPT__REQUIRE__DECRYPT();
    }
    public bool is_FORBID__ENCRYPT__ALLOW__DECRYPT { get { return this is ESDKCommitmentPolicy_FORBID__ENCRYPT__ALLOW__DECRYPT; } }
    public bool is_REQUIRE__ENCRYPT__ALLOW__DECRYPT { get { return this is ESDKCommitmentPolicy_REQUIRE__ENCRYPT__ALLOW__DECRYPT; } }
    public bool is_REQUIRE__ENCRYPT__REQUIRE__DECRYPT { get { return this is ESDKCommitmentPolicy_REQUIRE__ENCRYPT__REQUIRE__DECRYPT; } }
    public static System.Collections.Generic.IEnumerable<_IESDKCommitmentPolicy> AllSingletonConstructors {
      get {
        yield return ESDKCommitmentPolicy.create_FORBID__ENCRYPT__ALLOW__DECRYPT();
        yield return ESDKCommitmentPolicy.create_REQUIRE__ENCRYPT__ALLOW__DECRYPT();
        yield return ESDKCommitmentPolicy.create_REQUIRE__ENCRYPT__REQUIRE__DECRYPT();
      }
    }
    public abstract _IESDKCommitmentPolicy DowncastClone();
  }
  public class ESDKCommitmentPolicy_FORBID__ENCRYPT__ALLOW__DECRYPT : ESDKCommitmentPolicy {
    public ESDKCommitmentPolicy_FORBID__ENCRYPT__ALLOW__DECRYPT() {
    }
    public override _IESDKCommitmentPolicy DowncastClone() {
      if (this is _IESDKCommitmentPolicy dt) { return dt; }
      return new ESDKCommitmentPolicy_FORBID__ENCRYPT__ALLOW__DECRYPT();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.ESDKCommitmentPolicy_FORBID__ENCRYPT__ALLOW__DECRYPT;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.ESDKCommitmentPolicy.FORBID_ENCRYPT_ALLOW_DECRYPT";
      return s;
    }
  }
  public class ESDKCommitmentPolicy_REQUIRE__ENCRYPT__ALLOW__DECRYPT : ESDKCommitmentPolicy {
    public ESDKCommitmentPolicy_REQUIRE__ENCRYPT__ALLOW__DECRYPT() {
    }
    public override _IESDKCommitmentPolicy DowncastClone() {
      if (this is _IESDKCommitmentPolicy dt) { return dt; }
      return new ESDKCommitmentPolicy_REQUIRE__ENCRYPT__ALLOW__DECRYPT();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.ESDKCommitmentPolicy_REQUIRE__ENCRYPT__ALLOW__DECRYPT;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.ESDKCommitmentPolicy.REQUIRE_ENCRYPT_ALLOW_DECRYPT";
      return s;
    }
  }
  public class ESDKCommitmentPolicy_REQUIRE__ENCRYPT__REQUIRE__DECRYPT : ESDKCommitmentPolicy {
    public ESDKCommitmentPolicy_REQUIRE__ENCRYPT__REQUIRE__DECRYPT() {
    }
    public override _IESDKCommitmentPolicy DowncastClone() {
      if (this is _IESDKCommitmentPolicy dt) { return dt; }
      return new ESDKCommitmentPolicy_REQUIRE__ENCRYPT__REQUIRE__DECRYPT();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.ESDKCommitmentPolicy_REQUIRE__ENCRYPT__REQUIRE__DECRYPT;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.ESDKCommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT";
      return s;
    }
  }

  public interface _IGetBranchKeyIdInput {
    bool is_GetBranchKeyIdInput { get; }
    Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext { get; }
    _IGetBranchKeyIdInput DowncastClone();
  }
  public class GetBranchKeyIdInput : _IGetBranchKeyIdInput {
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _encryptionContext;
    public GetBranchKeyIdInput(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      this._encryptionContext = encryptionContext;
    }
    public _IGetBranchKeyIdInput DowncastClone() {
      if (this is _IGetBranchKeyIdInput dt) { return dt; }
      return new GetBranchKeyIdInput(_encryptionContext);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.GetBranchKeyIdInput;
      return oth != null && object.Equals(this._encryptionContext, oth._encryptionContext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptionContext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.GetBranchKeyIdInput.GetBranchKeyIdInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._encryptionContext);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdInput theDefault = create(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty);
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdInput>(software.amazon.cryptography.materialproviders.internaldafny.types.GetBranchKeyIdInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetBranchKeyIdInput create(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      return new GetBranchKeyIdInput(encryptionContext);
    }
    public static _IGetBranchKeyIdInput create_GetBranchKeyIdInput(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      return create(encryptionContext);
    }
    public bool is_GetBranchKeyIdInput { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this._encryptionContext;
      }
    }
  }

  public interface _IGetBranchKeyIdOutput {
    bool is_GetBranchKeyIdOutput { get; }
    Dafny.ISequence<char> dtor_branchKeyId { get; }
    _IGetBranchKeyIdOutput DowncastClone();
  }
  public class GetBranchKeyIdOutput : _IGetBranchKeyIdOutput {
    public readonly Dafny.ISequence<char> _branchKeyId;
    public GetBranchKeyIdOutput(Dafny.ISequence<char> branchKeyId) {
      this._branchKeyId = branchKeyId;
    }
    public _IGetBranchKeyIdOutput DowncastClone() {
      if (this is _IGetBranchKeyIdOutput dt) { return dt; }
      return new GetBranchKeyIdOutput(_branchKeyId);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.GetBranchKeyIdOutput;
      return oth != null && object.Equals(this._branchKeyId, oth._branchKeyId);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._branchKeyId));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.GetBranchKeyIdOutput.GetBranchKeyIdOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._branchKeyId);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdOutput theDefault = create(Dafny.Sequence<char>.Empty);
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdOutput>(software.amazon.cryptography.materialproviders.internaldafny.types.GetBranchKeyIdOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetBranchKeyIdOutput create(Dafny.ISequence<char> branchKeyId) {
      return new GetBranchKeyIdOutput(branchKeyId);
    }
    public static _IGetBranchKeyIdOutput create_GetBranchKeyIdOutput(Dafny.ISequence<char> branchKeyId) {
      return create(branchKeyId);
    }
    public bool is_GetBranchKeyIdOutput { get { return true; } }
    public Dafny.ISequence<char> dtor_branchKeyId {
      get {
        return this._branchKeyId;
      }
    }
  }

  public interface _IGetCacheEntryInput {
    bool is_GetCacheEntryInput { get; }
    Dafny.ISequence<byte> dtor_identifier { get; }
    Wrappers_Compile._IOption<long> dtor_bytesUsed { get; }
    _IGetCacheEntryInput DowncastClone();
  }
  public class GetCacheEntryInput : _IGetCacheEntryInput {
    public readonly Dafny.ISequence<byte> _identifier;
    public readonly Wrappers_Compile._IOption<long> _bytesUsed;
    public GetCacheEntryInput(Dafny.ISequence<byte> identifier, Wrappers_Compile._IOption<long> bytesUsed) {
      this._identifier = identifier;
      this._bytesUsed = bytesUsed;
    }
    public _IGetCacheEntryInput DowncastClone() {
      if (this is _IGetCacheEntryInput dt) { return dt; }
      return new GetCacheEntryInput(_identifier, _bytesUsed);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.GetCacheEntryInput;
      return oth != null && object.Equals(this._identifier, oth._identifier) && object.Equals(this._bytesUsed, oth._bytesUsed);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._identifier));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bytesUsed));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.GetCacheEntryInput.GetCacheEntryInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._identifier);
      s += ", ";
      s += Dafny.Helpers.ToString(this._bytesUsed);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryInput theDefault = create(Dafny.Sequence<byte>.Empty, Wrappers_Compile.Option<long>.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryInput>(software.amazon.cryptography.materialproviders.internaldafny.types.GetCacheEntryInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetCacheEntryInput create(Dafny.ISequence<byte> identifier, Wrappers_Compile._IOption<long> bytesUsed) {
      return new GetCacheEntryInput(identifier, bytesUsed);
    }
    public static _IGetCacheEntryInput create_GetCacheEntryInput(Dafny.ISequence<byte> identifier, Wrappers_Compile._IOption<long> bytesUsed) {
      return create(identifier, bytesUsed);
    }
    public bool is_GetCacheEntryInput { get { return true; } }
    public Dafny.ISequence<byte> dtor_identifier {
      get {
        return this._identifier;
      }
    }
    public Wrappers_Compile._IOption<long> dtor_bytesUsed {
      get {
        return this._bytesUsed;
      }
    }
  }

  public interface _IGetCacheEntryOutput {
    bool is_GetCacheEntryOutput { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IMaterials dtor_materials { get; }
    long dtor_creationTime { get; }
    long dtor_expiryTime { get; }
    int dtor_messagesUsed { get; }
    int dtor_bytesUsed { get; }
    _IGetCacheEntryOutput DowncastClone();
  }
  public class GetCacheEntryOutput : _IGetCacheEntryOutput {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IMaterials _materials;
    public readonly long _creationTime;
    public readonly long _expiryTime;
    public readonly int _messagesUsed;
    public readonly int _bytesUsed;
    public GetCacheEntryOutput(software.amazon.cryptography.materialproviders.internaldafny.types._IMaterials materials, long creationTime, long expiryTime, int messagesUsed, int bytesUsed) {
      this._materials = materials;
      this._creationTime = creationTime;
      this._expiryTime = expiryTime;
      this._messagesUsed = messagesUsed;
      this._bytesUsed = bytesUsed;
    }
    public _IGetCacheEntryOutput DowncastClone() {
      if (this is _IGetCacheEntryOutput dt) { return dt; }
      return new GetCacheEntryOutput(_materials, _creationTime, _expiryTime, _messagesUsed, _bytesUsed);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.GetCacheEntryOutput;
      return oth != null && object.Equals(this._materials, oth._materials) && this._creationTime == oth._creationTime && this._expiryTime == oth._expiryTime && this._messagesUsed == oth._messagesUsed && this._bytesUsed == oth._bytesUsed;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._materials));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._creationTime));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._expiryTime));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._messagesUsed));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bytesUsed));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.GetCacheEntryOutput.GetCacheEntryOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._materials);
      s += ", ";
      s += Dafny.Helpers.ToString(this._creationTime);
      s += ", ";
      s += Dafny.Helpers.ToString(this._expiryTime);
      s += ", ";
      s += Dafny.Helpers.ToString(this._messagesUsed);
      s += ", ";
      s += Dafny.Helpers.ToString(this._bytesUsed);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput theDefault = create(software.amazon.cryptography.materialproviders.internaldafny.types.Materials.Default(), 0, 0, 0, 0);
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput>(software.amazon.cryptography.materialproviders.internaldafny.types.GetCacheEntryOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetCacheEntryOutput create(software.amazon.cryptography.materialproviders.internaldafny.types._IMaterials materials, long creationTime, long expiryTime, int messagesUsed, int bytesUsed) {
      return new GetCacheEntryOutput(materials, creationTime, expiryTime, messagesUsed, bytesUsed);
    }
    public static _IGetCacheEntryOutput create_GetCacheEntryOutput(software.amazon.cryptography.materialproviders.internaldafny.types._IMaterials materials, long creationTime, long expiryTime, int messagesUsed, int bytesUsed) {
      return create(materials, creationTime, expiryTime, messagesUsed, bytesUsed);
    }
    public bool is_GetCacheEntryOutput { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IMaterials dtor_materials {
      get {
        return this._materials;
      }
    }
    public long dtor_creationTime {
      get {
        return this._creationTime;
      }
    }
    public long dtor_expiryTime {
      get {
        return this._expiryTime;
      }
    }
    public int dtor_messagesUsed {
      get {
        return this._messagesUsed;
      }
    }
    public int dtor_bytesUsed {
      get {
        return this._bytesUsed;
      }
    }
  }

  public interface _IGetClientInput {
    bool is_GetClientInput { get; }
    Dafny.ISequence<char> dtor_region { get; }
    _IGetClientInput DowncastClone();
  }
  public class GetClientInput : _IGetClientInput {
    public readonly Dafny.ISequence<char> _region;
    public GetClientInput(Dafny.ISequence<char> region) {
      this._region = region;
    }
    public _IGetClientInput DowncastClone() {
      if (this is _IGetClientInput dt) { return dt; }
      return new GetClientInput(_region);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.GetClientInput;
      return oth != null && object.Equals(this._region, oth._region);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._region));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.GetClientInput.GetClientInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._region);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IGetClientInput theDefault = create(Dafny.Sequence<char>.Empty);
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IGetClientInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IGetClientInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IGetClientInput>(software.amazon.cryptography.materialproviders.internaldafny.types.GetClientInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IGetClientInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetClientInput create(Dafny.ISequence<char> region) {
      return new GetClientInput(region);
    }
    public static _IGetClientInput create_GetClientInput(Dafny.ISequence<char> region) {
      return create(region);
    }
    public bool is_GetClientInput { get { return true; } }
    public Dafny.ISequence<char> dtor_region {
      get {
        return this._region;
      }
    }
  }

  public interface _IGetEncryptionMaterialsInput {
    bool is_GetEncryptionMaterialsInput { get; }
    Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy dtor_commitmentPolicy { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId> dtor_algorithmSuiteId { get; }
    Wrappers_Compile._IOption<long> dtor_maxPlaintextLength { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>> dtor_requiredEncryptionContextKeys { get; }
    _IGetEncryptionMaterialsInput DowncastClone();
  }
  public class GetEncryptionMaterialsInput : _IGetEncryptionMaterialsInput {
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _encryptionContext;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy _commitmentPolicy;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId> _algorithmSuiteId;
    public readonly Wrappers_Compile._IOption<long> _maxPlaintextLength;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>> _requiredEncryptionContextKeys;
    public GetEncryptionMaterialsInput(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy commitmentPolicy, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId> algorithmSuiteId, Wrappers_Compile._IOption<long> maxPlaintextLength, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>> requiredEncryptionContextKeys) {
      this._encryptionContext = encryptionContext;
      this._commitmentPolicy = commitmentPolicy;
      this._algorithmSuiteId = algorithmSuiteId;
      this._maxPlaintextLength = maxPlaintextLength;
      this._requiredEncryptionContextKeys = requiredEncryptionContextKeys;
    }
    public _IGetEncryptionMaterialsInput DowncastClone() {
      if (this is _IGetEncryptionMaterialsInput dt) { return dt; }
      return new GetEncryptionMaterialsInput(_encryptionContext, _commitmentPolicy, _algorithmSuiteId, _maxPlaintextLength, _requiredEncryptionContextKeys);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.GetEncryptionMaterialsInput;
      return oth != null && object.Equals(this._encryptionContext, oth._encryptionContext) && object.Equals(this._commitmentPolicy, oth._commitmentPolicy) && object.Equals(this._algorithmSuiteId, oth._algorithmSuiteId) && object.Equals(this._maxPlaintextLength, oth._maxPlaintextLength) && object.Equals(this._requiredEncryptionContextKeys, oth._requiredEncryptionContextKeys);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._commitmentPolicy));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._algorithmSuiteId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._maxPlaintextLength));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._requiredEncryptionContextKeys));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.GetEncryptionMaterialsInput.GetEncryptionMaterialsInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this._commitmentPolicy);
      s += ", ";
      s += Dafny.Helpers.ToString(this._algorithmSuiteId);
      s += ", ";
      s += Dafny.Helpers.ToString(this._maxPlaintextLength);
      s += ", ";
      s += Dafny.Helpers.ToString(this._requiredEncryptionContextKeys);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsInput theDefault = create(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, software.amazon.cryptography.materialproviders.internaldafny.types.CommitmentPolicy.Default(), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId>.Default(), Wrappers_Compile.Option<long>.Default(), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsInput>(software.amazon.cryptography.materialproviders.internaldafny.types.GetEncryptionMaterialsInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetEncryptionMaterialsInput create(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy commitmentPolicy, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId> algorithmSuiteId, Wrappers_Compile._IOption<long> maxPlaintextLength, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>> requiredEncryptionContextKeys) {
      return new GetEncryptionMaterialsInput(encryptionContext, commitmentPolicy, algorithmSuiteId, maxPlaintextLength, requiredEncryptionContextKeys);
    }
    public static _IGetEncryptionMaterialsInput create_GetEncryptionMaterialsInput(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy commitmentPolicy, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId> algorithmSuiteId, Wrappers_Compile._IOption<long> maxPlaintextLength, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>> requiredEncryptionContextKeys) {
      return create(encryptionContext, commitmentPolicy, algorithmSuiteId, maxPlaintextLength, requiredEncryptionContextKeys);
    }
    public bool is_GetEncryptionMaterialsInput { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this._encryptionContext;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy dtor_commitmentPolicy {
      get {
        return this._commitmentPolicy;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId> dtor_algorithmSuiteId {
      get {
        return this._algorithmSuiteId;
      }
    }
    public Wrappers_Compile._IOption<long> dtor_maxPlaintextLength {
      get {
        return this._maxPlaintextLength;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>> dtor_requiredEncryptionContextKeys {
      get {
        return this._requiredEncryptionContextKeys;
      }
    }
  }

  public interface _IGetEncryptionMaterialsOutput {
    bool is_GetEncryptionMaterialsOutput { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials dtor_encryptionMaterials { get; }
    _IGetEncryptionMaterialsOutput DowncastClone();
  }
  public class GetEncryptionMaterialsOutput : _IGetEncryptionMaterialsOutput {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _encryptionMaterials;
    public GetEncryptionMaterialsOutput(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials encryptionMaterials) {
      this._encryptionMaterials = encryptionMaterials;
    }
    public _IGetEncryptionMaterialsOutput DowncastClone() {
      if (this is _IGetEncryptionMaterialsOutput dt) { return dt; }
      return new GetEncryptionMaterialsOutput(_encryptionMaterials);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.GetEncryptionMaterialsOutput;
      return oth != null && object.Equals(this._encryptionMaterials, oth._encryptionMaterials);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptionMaterials));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.GetEncryptionMaterialsOutput.GetEncryptionMaterialsOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._encryptionMaterials);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput theDefault = create(software.amazon.cryptography.materialproviders.internaldafny.types.EncryptionMaterials.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput>(software.amazon.cryptography.materialproviders.internaldafny.types.GetEncryptionMaterialsOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetEncryptionMaterialsOutput create(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials encryptionMaterials) {
      return new GetEncryptionMaterialsOutput(encryptionMaterials);
    }
    public static _IGetEncryptionMaterialsOutput create_GetEncryptionMaterialsOutput(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials encryptionMaterials) {
      return create(encryptionMaterials);
    }
    public bool is_GetEncryptionMaterialsOutput { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials dtor_encryptionMaterials {
      get {
        return this._encryptionMaterials;
      }
    }
  }

  public interface _IHKDF {
    bool is_HKDF { get; }
    software.amazon.cryptography.primitives.internaldafny.types._IDigestAlgorithm dtor_hmac { get; }
    int dtor_saltLength { get; }
    int dtor_inputKeyLength { get; }
    int dtor_outputKeyLength { get; }
    _IHKDF DowncastClone();
  }
  public class HKDF : _IHKDF {
    public readonly software.amazon.cryptography.primitives.internaldafny.types._IDigestAlgorithm _hmac;
    public readonly int _saltLength;
    public readonly int _inputKeyLength;
    public readonly int _outputKeyLength;
    public HKDF(software.amazon.cryptography.primitives.internaldafny.types._IDigestAlgorithm hmac, int saltLength, int inputKeyLength, int outputKeyLength) {
      this._hmac = hmac;
      this._saltLength = saltLength;
      this._inputKeyLength = inputKeyLength;
      this._outputKeyLength = outputKeyLength;
    }
    public _IHKDF DowncastClone() {
      if (this is _IHKDF dt) { return dt; }
      return new HKDF(_hmac, _saltLength, _inputKeyLength, _outputKeyLength);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.HKDF;
      return oth != null && object.Equals(this._hmac, oth._hmac) && this._saltLength == oth._saltLength && this._inputKeyLength == oth._inputKeyLength && this._outputKeyLength == oth._outputKeyLength;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._hmac));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._saltLength));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._inputKeyLength));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._outputKeyLength));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.HKDF.HKDF";
      s += "(";
      s += Dafny.Helpers.ToString(this._hmac);
      s += ", ";
      s += Dafny.Helpers.ToString(this._saltLength);
      s += ", ";
      s += Dafny.Helpers.ToString(this._inputKeyLength);
      s += ", ";
      s += Dafny.Helpers.ToString(this._outputKeyLength);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IHKDF theDefault = create(software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.Default(), 0, 0, 0);
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IHKDF Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IHKDF> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IHKDF>(software.amazon.cryptography.materialproviders.internaldafny.types.HKDF.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IHKDF> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IHKDF create(software.amazon.cryptography.primitives.internaldafny.types._IDigestAlgorithm hmac, int saltLength, int inputKeyLength, int outputKeyLength) {
      return new HKDF(hmac, saltLength, inputKeyLength, outputKeyLength);
    }
    public static _IHKDF create_HKDF(software.amazon.cryptography.primitives.internaldafny.types._IDigestAlgorithm hmac, int saltLength, int inputKeyLength, int outputKeyLength) {
      return create(hmac, saltLength, inputKeyLength, outputKeyLength);
    }
    public bool is_HKDF { get { return true; } }
    public software.amazon.cryptography.primitives.internaldafny.types._IDigestAlgorithm dtor_hmac {
      get {
        return this._hmac;
      }
    }
    public int dtor_saltLength {
      get {
        return this._saltLength;
      }
    }
    public int dtor_inputKeyLength {
      get {
        return this._inputKeyLength;
      }
    }
    public int dtor_outputKeyLength {
      get {
        return this._outputKeyLength;
      }
    }
  }

  public interface _IIDENTITY {
    bool is_IDENTITY { get; }
    _IIDENTITY DowncastClone();
  }
  public class IDENTITY : _IIDENTITY {
    public IDENTITY() {
    }
    public _IIDENTITY DowncastClone() {
      if (this is _IIDENTITY dt) { return dt; }
      return new IDENTITY();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.IDENTITY;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.IDENTITY.IDENTITY";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IIDENTITY theDefault = create();
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IIDENTITY Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IIDENTITY> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IIDENTITY>(software.amazon.cryptography.materialproviders.internaldafny.types.IDENTITY.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IIDENTITY> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IIDENTITY create() {
      return new IDENTITY();
    }
    public static _IIDENTITY create_IDENTITY() {
      return create();
    }
    public bool is_IDENTITY { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_IIDENTITY> AllSingletonConstructors {
      get {
        yield return IDENTITY.create();
      }
    }
  }

  public interface _IInitializeDecryptionMaterialsInput {
    bool is_InitializeDecryptionMaterialsInput { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId dtor_algorithmSuiteId { get; }
    Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext { get; }
    Dafny.ISequence<Dafny.ISequence<byte>> dtor_requiredEncryptionContextKeys { get; }
    _IInitializeDecryptionMaterialsInput DowncastClone();
  }
  public class InitializeDecryptionMaterialsInput : _IInitializeDecryptionMaterialsInput {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId _algorithmSuiteId;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _encryptionContext;
    public readonly Dafny.ISequence<Dafny.ISequence<byte>> _requiredEncryptionContextKeys;
    public InitializeDecryptionMaterialsInput(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId algorithmSuiteId, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<Dafny.ISequence<byte>> requiredEncryptionContextKeys) {
      this._algorithmSuiteId = algorithmSuiteId;
      this._encryptionContext = encryptionContext;
      this._requiredEncryptionContextKeys = requiredEncryptionContextKeys;
    }
    public _IInitializeDecryptionMaterialsInput DowncastClone() {
      if (this is _IInitializeDecryptionMaterialsInput dt) { return dt; }
      return new InitializeDecryptionMaterialsInput(_algorithmSuiteId, _encryptionContext, _requiredEncryptionContextKeys);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.InitializeDecryptionMaterialsInput;
      return oth != null && object.Equals(this._algorithmSuiteId, oth._algorithmSuiteId) && object.Equals(this._encryptionContext, oth._encryptionContext) && object.Equals(this._requiredEncryptionContextKeys, oth._requiredEncryptionContextKeys);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._algorithmSuiteId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._requiredEncryptionContextKeys));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.InitializeDecryptionMaterialsInput.InitializeDecryptionMaterialsInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._algorithmSuiteId);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this._requiredEncryptionContextKeys);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IInitializeDecryptionMaterialsInput theDefault = create(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.Default(), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Dafny.Sequence<Dafny.ISequence<byte>>.Empty);
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IInitializeDecryptionMaterialsInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IInitializeDecryptionMaterialsInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IInitializeDecryptionMaterialsInput>(software.amazon.cryptography.materialproviders.internaldafny.types.InitializeDecryptionMaterialsInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IInitializeDecryptionMaterialsInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IInitializeDecryptionMaterialsInput create(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId algorithmSuiteId, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<Dafny.ISequence<byte>> requiredEncryptionContextKeys) {
      return new InitializeDecryptionMaterialsInput(algorithmSuiteId, encryptionContext, requiredEncryptionContextKeys);
    }
    public static _IInitializeDecryptionMaterialsInput create_InitializeDecryptionMaterialsInput(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId algorithmSuiteId, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<Dafny.ISequence<byte>> requiredEncryptionContextKeys) {
      return create(algorithmSuiteId, encryptionContext, requiredEncryptionContextKeys);
    }
    public bool is_InitializeDecryptionMaterialsInput { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId dtor_algorithmSuiteId {
      get {
        return this._algorithmSuiteId;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this._encryptionContext;
      }
    }
    public Dafny.ISequence<Dafny.ISequence<byte>> dtor_requiredEncryptionContextKeys {
      get {
        return this._requiredEncryptionContextKeys;
      }
    }
  }

  public interface _IInitializeEncryptionMaterialsInput {
    bool is_InitializeEncryptionMaterialsInput { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId dtor_algorithmSuiteId { get; }
    Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext { get; }
    Dafny.ISequence<Dafny.ISequence<byte>> dtor_requiredEncryptionContextKeys { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_signingKey { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_verificationKey { get; }
    _IInitializeEncryptionMaterialsInput DowncastClone();
  }
  public class InitializeEncryptionMaterialsInput : _IInitializeEncryptionMaterialsInput {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId _algorithmSuiteId;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _encryptionContext;
    public readonly Dafny.ISequence<Dafny.ISequence<byte>> _requiredEncryptionContextKeys;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<byte>> _signingKey;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<byte>> _verificationKey;
    public InitializeEncryptionMaterialsInput(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId algorithmSuiteId, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<Dafny.ISequence<byte>> requiredEncryptionContextKeys, Wrappers_Compile._IOption<Dafny.ISequence<byte>> signingKey, Wrappers_Compile._IOption<Dafny.ISequence<byte>> verificationKey) {
      this._algorithmSuiteId = algorithmSuiteId;
      this._encryptionContext = encryptionContext;
      this._requiredEncryptionContextKeys = requiredEncryptionContextKeys;
      this._signingKey = signingKey;
      this._verificationKey = verificationKey;
    }
    public _IInitializeEncryptionMaterialsInput DowncastClone() {
      if (this is _IInitializeEncryptionMaterialsInput dt) { return dt; }
      return new InitializeEncryptionMaterialsInput(_algorithmSuiteId, _encryptionContext, _requiredEncryptionContextKeys, _signingKey, _verificationKey);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.InitializeEncryptionMaterialsInput;
      return oth != null && object.Equals(this._algorithmSuiteId, oth._algorithmSuiteId) && object.Equals(this._encryptionContext, oth._encryptionContext) && object.Equals(this._requiredEncryptionContextKeys, oth._requiredEncryptionContextKeys) && object.Equals(this._signingKey, oth._signingKey) && object.Equals(this._verificationKey, oth._verificationKey);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._algorithmSuiteId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._requiredEncryptionContextKeys));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._signingKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._verificationKey));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.InitializeEncryptionMaterialsInput.InitializeEncryptionMaterialsInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._algorithmSuiteId);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this._requiredEncryptionContextKeys);
      s += ", ";
      s += Dafny.Helpers.ToString(this._signingKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this._verificationKey);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IInitializeEncryptionMaterialsInput theDefault = create(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.Default(), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Dafny.Sequence<Dafny.ISequence<byte>>.Empty, Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IInitializeEncryptionMaterialsInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IInitializeEncryptionMaterialsInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IInitializeEncryptionMaterialsInput>(software.amazon.cryptography.materialproviders.internaldafny.types.InitializeEncryptionMaterialsInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IInitializeEncryptionMaterialsInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IInitializeEncryptionMaterialsInput create(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId algorithmSuiteId, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<Dafny.ISequence<byte>> requiredEncryptionContextKeys, Wrappers_Compile._IOption<Dafny.ISequence<byte>> signingKey, Wrappers_Compile._IOption<Dafny.ISequence<byte>> verificationKey) {
      return new InitializeEncryptionMaterialsInput(algorithmSuiteId, encryptionContext, requiredEncryptionContextKeys, signingKey, verificationKey);
    }
    public static _IInitializeEncryptionMaterialsInput create_InitializeEncryptionMaterialsInput(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId algorithmSuiteId, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.ISequence<Dafny.ISequence<byte>> requiredEncryptionContextKeys, Wrappers_Compile._IOption<Dafny.ISequence<byte>> signingKey, Wrappers_Compile._IOption<Dafny.ISequence<byte>> verificationKey) {
      return create(algorithmSuiteId, encryptionContext, requiredEncryptionContextKeys, signingKey, verificationKey);
    }
    public bool is_InitializeEncryptionMaterialsInput { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId dtor_algorithmSuiteId {
      get {
        return this._algorithmSuiteId;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this._encryptionContext;
      }
    }
    public Dafny.ISequence<Dafny.ISequence<byte>> dtor_requiredEncryptionContextKeys {
      get {
        return this._requiredEncryptionContextKeys;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_signingKey {
      get {
        return this._signingKey;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_verificationKey {
      get {
        return this._verificationKey;
      }
    }
  }

  public interface _IIntermediateKeyWrapping {
    bool is_IntermediateKeyWrapping { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm dtor_keyEncryptionKeyKdf { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm dtor_macKeyKdf { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt dtor_pdkEncryptAlgorithm { get; }
    _IIntermediateKeyWrapping DowncastClone();
  }
  public class IntermediateKeyWrapping : _IIntermediateKeyWrapping {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm _keyEncryptionKeyKdf;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm _macKeyKdf;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt _pdkEncryptAlgorithm;
    public IntermediateKeyWrapping(software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm keyEncryptionKeyKdf, software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm macKeyKdf, software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt pdkEncryptAlgorithm) {
      this._keyEncryptionKeyKdf = keyEncryptionKeyKdf;
      this._macKeyKdf = macKeyKdf;
      this._pdkEncryptAlgorithm = pdkEncryptAlgorithm;
    }
    public _IIntermediateKeyWrapping DowncastClone() {
      if (this is _IIntermediateKeyWrapping dt) { return dt; }
      return new IntermediateKeyWrapping(_keyEncryptionKeyKdf, _macKeyKdf, _pdkEncryptAlgorithm);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.IntermediateKeyWrapping;
      return oth != null && object.Equals(this._keyEncryptionKeyKdf, oth._keyEncryptionKeyKdf) && object.Equals(this._macKeyKdf, oth._macKeyKdf) && object.Equals(this._pdkEncryptAlgorithm, oth._pdkEncryptAlgorithm);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keyEncryptionKeyKdf));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._macKeyKdf));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._pdkEncryptAlgorithm));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.IntermediateKeyWrapping.IntermediateKeyWrapping";
      s += "(";
      s += Dafny.Helpers.ToString(this._keyEncryptionKeyKdf);
      s += ", ";
      s += Dafny.Helpers.ToString(this._macKeyKdf);
      s += ", ";
      s += Dafny.Helpers.ToString(this._pdkEncryptAlgorithm);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IIntermediateKeyWrapping theDefault = create(software.amazon.cryptography.materialproviders.internaldafny.types.DerivationAlgorithm.Default(), software.amazon.cryptography.materialproviders.internaldafny.types.DerivationAlgorithm.Default(), software.amazon.cryptography.materialproviders.internaldafny.types.Encrypt.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IIntermediateKeyWrapping Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IIntermediateKeyWrapping> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IIntermediateKeyWrapping>(software.amazon.cryptography.materialproviders.internaldafny.types.IntermediateKeyWrapping.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IIntermediateKeyWrapping> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IIntermediateKeyWrapping create(software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm keyEncryptionKeyKdf, software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm macKeyKdf, software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt pdkEncryptAlgorithm) {
      return new IntermediateKeyWrapping(keyEncryptionKeyKdf, macKeyKdf, pdkEncryptAlgorithm);
    }
    public static _IIntermediateKeyWrapping create_IntermediateKeyWrapping(software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm keyEncryptionKeyKdf, software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm macKeyKdf, software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt pdkEncryptAlgorithm) {
      return create(keyEncryptionKeyKdf, macKeyKdf, pdkEncryptAlgorithm);
    }
    public bool is_IntermediateKeyWrapping { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm dtor_keyEncryptionKeyKdf {
      get {
        return this._keyEncryptionKeyKdf;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm dtor_macKeyKdf {
      get {
        return this._macKeyKdf;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt dtor_pdkEncryptAlgorithm {
      get {
        return this._pdkEncryptAlgorithm;
      }
    }
  }

  public partial class IKeyringCallHistory {
    public IKeyringCallHistory() {
    }
  }

  public interface IKeyring {
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnEncrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnEncrypt_k(software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnDecrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnDecrypt_k(software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput input);
  }
  public class _Companion_IKeyring {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnEncrypt(software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring _this, software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out8;
      _out8 = (_this).OnEncrypt_k(input);
      output = _out8;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnDecrypt(software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring _this, software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out9;
      _out9 = (_this).OnDecrypt_k(input);
      output = _out9;
      return output;
    }
  }

  public interface _IMaterialProvidersConfig {
    bool is_MaterialProvidersConfig { get; }
    _IMaterialProvidersConfig DowncastClone();
  }
  public class MaterialProvidersConfig : _IMaterialProvidersConfig {
    public MaterialProvidersConfig() {
    }
    public _IMaterialProvidersConfig DowncastClone() {
      if (this is _IMaterialProvidersConfig dt) { return dt; }
      return new MaterialProvidersConfig();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.MaterialProvidersConfig;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.MaterialProvidersConfig.MaterialProvidersConfig";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IMaterialProvidersConfig theDefault = create();
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IMaterialProvidersConfig Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IMaterialProvidersConfig> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IMaterialProvidersConfig>(software.amazon.cryptography.materialproviders.internaldafny.types.MaterialProvidersConfig.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IMaterialProvidersConfig> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IMaterialProvidersConfig create() {
      return new MaterialProvidersConfig();
    }
    public static _IMaterialProvidersConfig create_MaterialProvidersConfig() {
      return create();
    }
    public bool is_MaterialProvidersConfig { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_IMaterialProvidersConfig> AllSingletonConstructors {
      get {
        yield return MaterialProvidersConfig.create();
      }
    }
  }

  public interface _IMaterials {
    bool is_Encryption { get; }
    bool is_Decryption { get; }
    bool is_BranchKey { get; }
    bool is_BeaconKey { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials dtor_Encryption { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials dtor_Decryption { get; }
    software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials dtor_BranchKey { get; }
    software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials dtor_BeaconKey { get; }
    _IMaterials DowncastClone();
  }
  public abstract class Materials : _IMaterials {
    public Materials() { }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IMaterials theDefault = create_Encryption(software.amazon.cryptography.materialproviders.internaldafny.types.EncryptionMaterials.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IMaterials Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IMaterials> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IMaterials>(software.amazon.cryptography.materialproviders.internaldafny.types.Materials.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IMaterials> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IMaterials create_Encryption(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials Encryption) {
      return new Materials_Encryption(Encryption);
    }
    public static _IMaterials create_Decryption(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials Decryption) {
      return new Materials_Decryption(Decryption);
    }
    public static _IMaterials create_BranchKey(software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials BranchKey) {
      return new Materials_BranchKey(BranchKey);
    }
    public static _IMaterials create_BeaconKey(software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials BeaconKey) {
      return new Materials_BeaconKey(BeaconKey);
    }
    public bool is_Encryption { get { return this is Materials_Encryption; } }
    public bool is_Decryption { get { return this is Materials_Decryption; } }
    public bool is_BranchKey { get { return this is Materials_BranchKey; } }
    public bool is_BeaconKey { get { return this is Materials_BeaconKey; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials dtor_Encryption {
      get {
        var d = this;
        return ((Materials_Encryption)d)._Encryption;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials dtor_Decryption {
      get {
        var d = this;
        return ((Materials_Decryption)d)._Decryption;
      }
    }
    public software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials dtor_BranchKey {
      get {
        var d = this;
        return ((Materials_BranchKey)d)._BranchKey;
      }
    }
    public software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials dtor_BeaconKey {
      get {
        var d = this;
        return ((Materials_BeaconKey)d)._BeaconKey;
      }
    }
    public abstract _IMaterials DowncastClone();
  }
  public class Materials_Encryption : Materials {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _Encryption;
    public Materials_Encryption(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials Encryption) {
      this._Encryption = Encryption;
    }
    public override _IMaterials DowncastClone() {
      if (this is _IMaterials dt) { return dt; }
      return new Materials_Encryption(_Encryption);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.Materials_Encryption;
      return oth != null && object.Equals(this._Encryption, oth._Encryption);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._Encryption));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.Materials.Encryption";
      s += "(";
      s += Dafny.Helpers.ToString(this._Encryption);
      s += ")";
      return s;
    }
  }
  public class Materials_Decryption : Materials {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _Decryption;
    public Materials_Decryption(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials Decryption) {
      this._Decryption = Decryption;
    }
    public override _IMaterials DowncastClone() {
      if (this is _IMaterials dt) { return dt; }
      return new Materials_Decryption(_Decryption);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.Materials_Decryption;
      return oth != null && object.Equals(this._Decryption, oth._Decryption);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._Decryption));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.Materials.Decryption";
      s += "(";
      s += Dafny.Helpers.ToString(this._Decryption);
      s += ")";
      return s;
    }
  }
  public class Materials_BranchKey : Materials {
    public readonly software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials _BranchKey;
    public Materials_BranchKey(software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials BranchKey) {
      this._BranchKey = BranchKey;
    }
    public override _IMaterials DowncastClone() {
      if (this is _IMaterials dt) { return dt; }
      return new Materials_BranchKey(_BranchKey);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.Materials_BranchKey;
      return oth != null && object.Equals(this._BranchKey, oth._BranchKey);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._BranchKey));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.Materials.BranchKey";
      s += "(";
      s += Dafny.Helpers.ToString(this._BranchKey);
      s += ")";
      return s;
    }
  }
  public class Materials_BeaconKey : Materials {
    public readonly software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials _BeaconKey;
    public Materials_BeaconKey(software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials BeaconKey) {
      this._BeaconKey = BeaconKey;
    }
    public override _IMaterials DowncastClone() {
      if (this is _IMaterials dt) { return dt; }
      return new Materials_BeaconKey(_BeaconKey);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.Materials_BeaconKey;
      return oth != null && object.Equals(this._BeaconKey, oth._BeaconKey);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._BeaconKey));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.Materials.BeaconKey";
      s += "(";
      s += Dafny.Helpers.ToString(this._BeaconKey);
      s += ")";
      return s;
    }
  }

  public interface _IMultiThreadedCache {
    bool is_MultiThreadedCache { get; }
    int dtor_entryCapacity { get; }
    Wrappers_Compile._IOption<int> dtor_entryPruningTailSize { get; }
    _IMultiThreadedCache DowncastClone();
  }
  public class MultiThreadedCache : _IMultiThreadedCache {
    public readonly int _entryCapacity;
    public readonly Wrappers_Compile._IOption<int> _entryPruningTailSize;
    public MultiThreadedCache(int entryCapacity, Wrappers_Compile._IOption<int> entryPruningTailSize) {
      this._entryCapacity = entryCapacity;
      this._entryPruningTailSize = entryPruningTailSize;
    }
    public _IMultiThreadedCache DowncastClone() {
      if (this is _IMultiThreadedCache dt) { return dt; }
      return new MultiThreadedCache(_entryCapacity, _entryPruningTailSize);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.MultiThreadedCache;
      return oth != null && this._entryCapacity == oth._entryCapacity && object.Equals(this._entryPruningTailSize, oth._entryPruningTailSize);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._entryCapacity));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._entryPruningTailSize));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.MultiThreadedCache.MultiThreadedCache";
      s += "(";
      s += Dafny.Helpers.ToString(this._entryCapacity);
      s += ", ";
      s += Dafny.Helpers.ToString(this._entryPruningTailSize);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IMultiThreadedCache theDefault = create(0, Wrappers_Compile.Option<int>.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IMultiThreadedCache Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IMultiThreadedCache> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IMultiThreadedCache>(software.amazon.cryptography.materialproviders.internaldafny.types.MultiThreadedCache.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IMultiThreadedCache> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IMultiThreadedCache create(int entryCapacity, Wrappers_Compile._IOption<int> entryPruningTailSize) {
      return new MultiThreadedCache(entryCapacity, entryPruningTailSize);
    }
    public static _IMultiThreadedCache create_MultiThreadedCache(int entryCapacity, Wrappers_Compile._IOption<int> entryPruningTailSize) {
      return create(entryCapacity, entryPruningTailSize);
    }
    public bool is_MultiThreadedCache { get { return true; } }
    public int dtor_entryCapacity {
      get {
        return this._entryCapacity;
      }
    }
    public Wrappers_Compile._IOption<int> dtor_entryPruningTailSize {
      get {
        return this._entryPruningTailSize;
      }
    }
  }

  public interface _INoCache {
    bool is_NoCache { get; }
    _INoCache DowncastClone();
  }
  public class NoCache : _INoCache {
    public NoCache() {
    }
    public _INoCache DowncastClone() {
      if (this is _INoCache dt) { return dt; }
      return new NoCache();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.NoCache;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.NoCache.NoCache";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._INoCache theDefault = create();
    public static software.amazon.cryptography.materialproviders.internaldafny.types._INoCache Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._INoCache> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._INoCache>(software.amazon.cryptography.materialproviders.internaldafny.types.NoCache.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._INoCache> _TypeDescriptor() {
      return _TYPE;
    }
    public static _INoCache create() {
      return new NoCache();
    }
    public static _INoCache create_NoCache() {
      return create();
    }
    public bool is_NoCache { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_INoCache> AllSingletonConstructors {
      get {
        yield return NoCache.create();
      }
    }
  }

  public interface _INone {
    bool is_None { get; }
    _INone DowncastClone();
  }
  public class None : _INone {
    public None() {
    }
    public _INone DowncastClone() {
      if (this is _INone dt) { return dt; }
      return new None();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.None;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.None.None";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._INone theDefault = create();
    public static software.amazon.cryptography.materialproviders.internaldafny.types._INone Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._INone> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._INone>(software.amazon.cryptography.materialproviders.internaldafny.types.None.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._INone> _TypeDescriptor() {
      return _TYPE;
    }
    public static _INone create() {
      return new None();
    }
    public static _INone create_None() {
      return create();
    }
    public bool is_None { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_INone> AllSingletonConstructors {
      get {
        yield return None.create();
      }
    }
  }

  public interface _IOnDecryptInput {
    bool is_OnDecryptInput { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials dtor_materials { get; }
    Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> dtor_encryptedDataKeys { get; }
    _IOnDecryptInput DowncastClone();
  }
  public class OnDecryptInput : _IOnDecryptInput {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _materials;
    public readonly Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _encryptedDataKeys;
    public OnDecryptInput(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials materials, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> encryptedDataKeys) {
      this._materials = materials;
      this._encryptedDataKeys = encryptedDataKeys;
    }
    public _IOnDecryptInput DowncastClone() {
      if (this is _IOnDecryptInput dt) { return dt; }
      return new OnDecryptInput(_materials, _encryptedDataKeys);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.OnDecryptInput;
      return oth != null && object.Equals(this._materials, oth._materials) && object.Equals(this._encryptedDataKeys, oth._encryptedDataKeys);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._materials));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptedDataKeys));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.OnDecryptInput.OnDecryptInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._materials);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptedDataKeys);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput theDefault = create(software.amazon.cryptography.materialproviders.internaldafny.types.DecryptionMaterials.Default(), Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.Empty);
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput>(software.amazon.cryptography.materialproviders.internaldafny.types.OnDecryptInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IOnDecryptInput create(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials materials, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> encryptedDataKeys) {
      return new OnDecryptInput(materials, encryptedDataKeys);
    }
    public static _IOnDecryptInput create_OnDecryptInput(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials materials, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> encryptedDataKeys) {
      return create(materials, encryptedDataKeys);
    }
    public bool is_OnDecryptInput { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials dtor_materials {
      get {
        return this._materials;
      }
    }
    public Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> dtor_encryptedDataKeys {
      get {
        return this._encryptedDataKeys;
      }
    }
  }

  public interface _IOnDecryptOutput {
    bool is_OnDecryptOutput { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials dtor_materials { get; }
    _IOnDecryptOutput DowncastClone();
  }
  public class OnDecryptOutput : _IOnDecryptOutput {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _materials;
    public OnDecryptOutput(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials materials) {
      this._materials = materials;
    }
    public _IOnDecryptOutput DowncastClone() {
      if (this is _IOnDecryptOutput dt) { return dt; }
      return new OnDecryptOutput(_materials);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.OnDecryptOutput;
      return oth != null && object.Equals(this._materials, oth._materials);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._materials));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.OnDecryptOutput.OnDecryptOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._materials);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput theDefault = create(software.amazon.cryptography.materialproviders.internaldafny.types.DecryptionMaterials.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>(software.amazon.cryptography.materialproviders.internaldafny.types.OnDecryptOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IOnDecryptOutput create(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials materials) {
      return new OnDecryptOutput(materials);
    }
    public static _IOnDecryptOutput create_OnDecryptOutput(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials materials) {
      return create(materials);
    }
    public bool is_OnDecryptOutput { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials dtor_materials {
      get {
        return this._materials;
      }
    }
  }

  public interface _IOnEncryptInput {
    bool is_OnEncryptInput { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials dtor_materials { get; }
    _IOnEncryptInput DowncastClone();
  }
  public class OnEncryptInput : _IOnEncryptInput {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _materials;
    public OnEncryptInput(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials materials) {
      this._materials = materials;
    }
    public _IOnEncryptInput DowncastClone() {
      if (this is _IOnEncryptInput dt) { return dt; }
      return new OnEncryptInput(_materials);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.OnEncryptInput;
      return oth != null && object.Equals(this._materials, oth._materials);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._materials));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.OnEncryptInput.OnEncryptInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._materials);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput theDefault = create(software.amazon.cryptography.materialproviders.internaldafny.types.EncryptionMaterials.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput>(software.amazon.cryptography.materialproviders.internaldafny.types.OnEncryptInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IOnEncryptInput create(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials materials) {
      return new OnEncryptInput(materials);
    }
    public static _IOnEncryptInput create_OnEncryptInput(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials materials) {
      return create(materials);
    }
    public bool is_OnEncryptInput { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials dtor_materials {
      get {
        return this._materials;
      }
    }
  }

  public interface _IOnEncryptOutput {
    bool is_OnEncryptOutput { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials dtor_materials { get; }
    _IOnEncryptOutput DowncastClone();
  }
  public class OnEncryptOutput : _IOnEncryptOutput {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _materials;
    public OnEncryptOutput(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials materials) {
      this._materials = materials;
    }
    public _IOnEncryptOutput DowncastClone() {
      if (this is _IOnEncryptOutput dt) { return dt; }
      return new OnEncryptOutput(_materials);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.OnEncryptOutput;
      return oth != null && object.Equals(this._materials, oth._materials);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._materials));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.OnEncryptOutput.OnEncryptOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._materials);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput theDefault = create(software.amazon.cryptography.materialproviders.internaldafny.types.EncryptionMaterials.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>(software.amazon.cryptography.materialproviders.internaldafny.types.OnEncryptOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IOnEncryptOutput create(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials materials) {
      return new OnEncryptOutput(materials);
    }
    public static _IOnEncryptOutput create_OnEncryptOutput(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials materials) {
      return create(materials);
    }
    public bool is_OnEncryptOutput { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials dtor_materials {
      get {
        return this._materials;
      }
    }
  }

  public interface _IPaddingScheme {
    bool is_PKCS1 { get; }
    bool is_OAEP__SHA1__MGF1 { get; }
    bool is_OAEP__SHA256__MGF1 { get; }
    bool is_OAEP__SHA384__MGF1 { get; }
    bool is_OAEP__SHA512__MGF1 { get; }
    _IPaddingScheme DowncastClone();
  }
  public abstract class PaddingScheme : _IPaddingScheme {
    public PaddingScheme() { }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IPaddingScheme theDefault = create_PKCS1();
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IPaddingScheme Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IPaddingScheme> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IPaddingScheme>(software.amazon.cryptography.materialproviders.internaldafny.types.PaddingScheme.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IPaddingScheme> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IPaddingScheme create_PKCS1() {
      return new PaddingScheme_PKCS1();
    }
    public static _IPaddingScheme create_OAEP__SHA1__MGF1() {
      return new PaddingScheme_OAEP__SHA1__MGF1();
    }
    public static _IPaddingScheme create_OAEP__SHA256__MGF1() {
      return new PaddingScheme_OAEP__SHA256__MGF1();
    }
    public static _IPaddingScheme create_OAEP__SHA384__MGF1() {
      return new PaddingScheme_OAEP__SHA384__MGF1();
    }
    public static _IPaddingScheme create_OAEP__SHA512__MGF1() {
      return new PaddingScheme_OAEP__SHA512__MGF1();
    }
    public bool is_PKCS1 { get { return this is PaddingScheme_PKCS1; } }
    public bool is_OAEP__SHA1__MGF1 { get { return this is PaddingScheme_OAEP__SHA1__MGF1; } }
    public bool is_OAEP__SHA256__MGF1 { get { return this is PaddingScheme_OAEP__SHA256__MGF1; } }
    public bool is_OAEP__SHA384__MGF1 { get { return this is PaddingScheme_OAEP__SHA384__MGF1; } }
    public bool is_OAEP__SHA512__MGF1 { get { return this is PaddingScheme_OAEP__SHA512__MGF1; } }
    public static System.Collections.Generic.IEnumerable<_IPaddingScheme> AllSingletonConstructors {
      get {
        yield return PaddingScheme.create_PKCS1();
        yield return PaddingScheme.create_OAEP__SHA1__MGF1();
        yield return PaddingScheme.create_OAEP__SHA256__MGF1();
        yield return PaddingScheme.create_OAEP__SHA384__MGF1();
        yield return PaddingScheme.create_OAEP__SHA512__MGF1();
      }
    }
    public abstract _IPaddingScheme DowncastClone();
  }
  public class PaddingScheme_PKCS1 : PaddingScheme {
    public PaddingScheme_PKCS1() {
    }
    public override _IPaddingScheme DowncastClone() {
      if (this is _IPaddingScheme dt) { return dt; }
      return new PaddingScheme_PKCS1();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.PaddingScheme_PKCS1;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.PaddingScheme.PKCS1";
      return s;
    }
  }
  public class PaddingScheme_OAEP__SHA1__MGF1 : PaddingScheme {
    public PaddingScheme_OAEP__SHA1__MGF1() {
    }
    public override _IPaddingScheme DowncastClone() {
      if (this is _IPaddingScheme dt) { return dt; }
      return new PaddingScheme_OAEP__SHA1__MGF1();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.PaddingScheme_OAEP__SHA1__MGF1;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.PaddingScheme.OAEP_SHA1_MGF1";
      return s;
    }
  }
  public class PaddingScheme_OAEP__SHA256__MGF1 : PaddingScheme {
    public PaddingScheme_OAEP__SHA256__MGF1() {
    }
    public override _IPaddingScheme DowncastClone() {
      if (this is _IPaddingScheme dt) { return dt; }
      return new PaddingScheme_OAEP__SHA256__MGF1();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.PaddingScheme_OAEP__SHA256__MGF1;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.PaddingScheme.OAEP_SHA256_MGF1";
      return s;
    }
  }
  public class PaddingScheme_OAEP__SHA384__MGF1 : PaddingScheme {
    public PaddingScheme_OAEP__SHA384__MGF1() {
    }
    public override _IPaddingScheme DowncastClone() {
      if (this is _IPaddingScheme dt) { return dt; }
      return new PaddingScheme_OAEP__SHA384__MGF1();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.PaddingScheme_OAEP__SHA384__MGF1;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.PaddingScheme.OAEP_SHA384_MGF1";
      return s;
    }
  }
  public class PaddingScheme_OAEP__SHA512__MGF1 : PaddingScheme {
    public PaddingScheme_OAEP__SHA512__MGF1() {
    }
    public override _IPaddingScheme DowncastClone() {
      if (this is _IPaddingScheme dt) { return dt; }
      return new PaddingScheme_OAEP__SHA512__MGF1();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.PaddingScheme_OAEP__SHA512__MGF1;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 4;
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.PaddingScheme.OAEP_SHA512_MGF1";
      return s;
    }
  }

  public partial class PositiveInteger {
    private static readonly Dafny.TypeDescriptor<int> _TYPE = new Dafny.TypeDescriptor<int>(0);
    public static Dafny.TypeDescriptor<int> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class PositiveLong {
    private static readonly Dafny.TypeDescriptor<long> _TYPE = new Dafny.TypeDescriptor<long>(0);
    public static Dafny.TypeDescriptor<long> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public interface _IPutCacheEntryInput {
    bool is_PutCacheEntryInput { get; }
    Dafny.ISequence<byte> dtor_identifier { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IMaterials dtor_materials { get; }
    long dtor_creationTime { get; }
    long dtor_expiryTime { get; }
    Wrappers_Compile._IOption<int> dtor_messagesUsed { get; }
    Wrappers_Compile._IOption<int> dtor_bytesUsed { get; }
    _IPutCacheEntryInput DowncastClone();
  }
  public class PutCacheEntryInput : _IPutCacheEntryInput {
    public readonly Dafny.ISequence<byte> _identifier;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IMaterials _materials;
    public readonly long _creationTime;
    public readonly long _expiryTime;
    public readonly Wrappers_Compile._IOption<int> _messagesUsed;
    public readonly Wrappers_Compile._IOption<int> _bytesUsed;
    public PutCacheEntryInput(Dafny.ISequence<byte> identifier, software.amazon.cryptography.materialproviders.internaldafny.types._IMaterials materials, long creationTime, long expiryTime, Wrappers_Compile._IOption<int> messagesUsed, Wrappers_Compile._IOption<int> bytesUsed) {
      this._identifier = identifier;
      this._materials = materials;
      this._creationTime = creationTime;
      this._expiryTime = expiryTime;
      this._messagesUsed = messagesUsed;
      this._bytesUsed = bytesUsed;
    }
    public _IPutCacheEntryInput DowncastClone() {
      if (this is _IPutCacheEntryInput dt) { return dt; }
      return new PutCacheEntryInput(_identifier, _materials, _creationTime, _expiryTime, _messagesUsed, _bytesUsed);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.PutCacheEntryInput;
      return oth != null && object.Equals(this._identifier, oth._identifier) && object.Equals(this._materials, oth._materials) && this._creationTime == oth._creationTime && this._expiryTime == oth._expiryTime && object.Equals(this._messagesUsed, oth._messagesUsed) && object.Equals(this._bytesUsed, oth._bytesUsed);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._identifier));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._materials));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._creationTime));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._expiryTime));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._messagesUsed));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bytesUsed));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.PutCacheEntryInput.PutCacheEntryInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._identifier);
      s += ", ";
      s += Dafny.Helpers.ToString(this._materials);
      s += ", ";
      s += Dafny.Helpers.ToString(this._creationTime);
      s += ", ";
      s += Dafny.Helpers.ToString(this._expiryTime);
      s += ", ";
      s += Dafny.Helpers.ToString(this._messagesUsed);
      s += ", ";
      s += Dafny.Helpers.ToString(this._bytesUsed);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IPutCacheEntryInput theDefault = create(Dafny.Sequence<byte>.Empty, software.amazon.cryptography.materialproviders.internaldafny.types.Materials.Default(), 0, 0, Wrappers_Compile.Option<int>.Default(), Wrappers_Compile.Option<int>.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IPutCacheEntryInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IPutCacheEntryInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IPutCacheEntryInput>(software.amazon.cryptography.materialproviders.internaldafny.types.PutCacheEntryInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IPutCacheEntryInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IPutCacheEntryInput create(Dafny.ISequence<byte> identifier, software.amazon.cryptography.materialproviders.internaldafny.types._IMaterials materials, long creationTime, long expiryTime, Wrappers_Compile._IOption<int> messagesUsed, Wrappers_Compile._IOption<int> bytesUsed) {
      return new PutCacheEntryInput(identifier, materials, creationTime, expiryTime, messagesUsed, bytesUsed);
    }
    public static _IPutCacheEntryInput create_PutCacheEntryInput(Dafny.ISequence<byte> identifier, software.amazon.cryptography.materialproviders.internaldafny.types._IMaterials materials, long creationTime, long expiryTime, Wrappers_Compile._IOption<int> messagesUsed, Wrappers_Compile._IOption<int> bytesUsed) {
      return create(identifier, materials, creationTime, expiryTime, messagesUsed, bytesUsed);
    }
    public bool is_PutCacheEntryInput { get { return true; } }
    public Dafny.ISequence<byte> dtor_identifier {
      get {
        return this._identifier;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IMaterials dtor_materials {
      get {
        return this._materials;
      }
    }
    public long dtor_creationTime {
      get {
        return this._creationTime;
      }
    }
    public long dtor_expiryTime {
      get {
        return this._expiryTime;
      }
    }
    public Wrappers_Compile._IOption<int> dtor_messagesUsed {
      get {
        return this._messagesUsed;
      }
    }
    public Wrappers_Compile._IOption<int> dtor_bytesUsed {
      get {
        return this._bytesUsed;
      }
    }
  }

  public interface _ISignatureAlgorithm {
    bool is_ECDSA { get; }
    bool is_None { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IECDSA dtor_ECDSA { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._INone dtor_None { get; }
    _ISignatureAlgorithm DowncastClone();
  }
  public abstract class SignatureAlgorithm : _ISignatureAlgorithm {
    public SignatureAlgorithm() { }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._ISignatureAlgorithm theDefault = create_ECDSA(software.amazon.cryptography.materialproviders.internaldafny.types.ECDSA.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._ISignatureAlgorithm Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ISignatureAlgorithm> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ISignatureAlgorithm>(software.amazon.cryptography.materialproviders.internaldafny.types.SignatureAlgorithm.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ISignatureAlgorithm> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ISignatureAlgorithm create_ECDSA(software.amazon.cryptography.materialproviders.internaldafny.types._IECDSA ECDSA) {
      return new SignatureAlgorithm_ECDSA(ECDSA);
    }
    public static _ISignatureAlgorithm create_None(software.amazon.cryptography.materialproviders.internaldafny.types._INone None) {
      return new SignatureAlgorithm_None(None);
    }
    public bool is_ECDSA { get { return this is SignatureAlgorithm_ECDSA; } }
    public bool is_None { get { return this is SignatureAlgorithm_None; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IECDSA dtor_ECDSA {
      get {
        var d = this;
        return ((SignatureAlgorithm_ECDSA)d)._ECDSA;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._INone dtor_None {
      get {
        var d = this;
        return ((SignatureAlgorithm_None)d)._None;
      }
    }
    public abstract _ISignatureAlgorithm DowncastClone();
  }
  public class SignatureAlgorithm_ECDSA : SignatureAlgorithm {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IECDSA _ECDSA;
    public SignatureAlgorithm_ECDSA(software.amazon.cryptography.materialproviders.internaldafny.types._IECDSA ECDSA) {
      this._ECDSA = ECDSA;
    }
    public override _ISignatureAlgorithm DowncastClone() {
      if (this is _ISignatureAlgorithm dt) { return dt; }
      return new SignatureAlgorithm_ECDSA(_ECDSA);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.SignatureAlgorithm_ECDSA;
      return oth != null && object.Equals(this._ECDSA, oth._ECDSA);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._ECDSA));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.SignatureAlgorithm.ECDSA";
      s += "(";
      s += Dafny.Helpers.ToString(this._ECDSA);
      s += ")";
      return s;
    }
  }
  public class SignatureAlgorithm_None : SignatureAlgorithm {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._INone _None;
    public SignatureAlgorithm_None(software.amazon.cryptography.materialproviders.internaldafny.types._INone None) {
      this._None = None;
    }
    public override _ISignatureAlgorithm DowncastClone() {
      if (this is _ISignatureAlgorithm dt) { return dt; }
      return new SignatureAlgorithm_None(_None);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.SignatureAlgorithm_None;
      return oth != null && object.Equals(this._None, oth._None);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._None));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.SignatureAlgorithm.None";
      s += "(";
      s += Dafny.Helpers.ToString(this._None);
      s += ")";
      return s;
    }
  }

  public interface _ISingleThreadedCache {
    bool is_SingleThreadedCache { get; }
    int dtor_entryCapacity { get; }
    Wrappers_Compile._IOption<int> dtor_entryPruningTailSize { get; }
    _ISingleThreadedCache DowncastClone();
  }
  public class SingleThreadedCache : _ISingleThreadedCache {
    public readonly int _entryCapacity;
    public readonly Wrappers_Compile._IOption<int> _entryPruningTailSize;
    public SingleThreadedCache(int entryCapacity, Wrappers_Compile._IOption<int> entryPruningTailSize) {
      this._entryCapacity = entryCapacity;
      this._entryPruningTailSize = entryPruningTailSize;
    }
    public _ISingleThreadedCache DowncastClone() {
      if (this is _ISingleThreadedCache dt) { return dt; }
      return new SingleThreadedCache(_entryCapacity, _entryPruningTailSize);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.SingleThreadedCache;
      return oth != null && this._entryCapacity == oth._entryCapacity && object.Equals(this._entryPruningTailSize, oth._entryPruningTailSize);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._entryCapacity));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._entryPruningTailSize));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.SingleThreadedCache.SingleThreadedCache";
      s += "(";
      s += Dafny.Helpers.ToString(this._entryCapacity);
      s += ", ";
      s += Dafny.Helpers.ToString(this._entryPruningTailSize);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._ISingleThreadedCache theDefault = create(0, Wrappers_Compile.Option<int>.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._ISingleThreadedCache Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ISingleThreadedCache> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ISingleThreadedCache>(software.amazon.cryptography.materialproviders.internaldafny.types.SingleThreadedCache.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ISingleThreadedCache> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ISingleThreadedCache create(int entryCapacity, Wrappers_Compile._IOption<int> entryPruningTailSize) {
      return new SingleThreadedCache(entryCapacity, entryPruningTailSize);
    }
    public static _ISingleThreadedCache create_SingleThreadedCache(int entryCapacity, Wrappers_Compile._IOption<int> entryPruningTailSize) {
      return create(entryCapacity, entryPruningTailSize);
    }
    public bool is_SingleThreadedCache { get { return true; } }
    public int dtor_entryCapacity {
      get {
        return this._entryCapacity;
      }
    }
    public Wrappers_Compile._IOption<int> dtor_entryPruningTailSize {
      get {
        return this._entryPruningTailSize;
      }
    }
  }

  public interface _IStormTrackingCache {
    bool is_StormTrackingCache { get; }
    int dtor_entryCapacity { get; }
    Wrappers_Compile._IOption<int> dtor_entryPruningTailSize { get; }
    int dtor_gracePeriod { get; }
    int dtor_graceInterval { get; }
    int dtor_fanOut { get; }
    int dtor_inFlightTTL { get; }
    int dtor_sleepMilli { get; }
    _IStormTrackingCache DowncastClone();
  }
  public class StormTrackingCache : _IStormTrackingCache {
    public readonly int _entryCapacity;
    public readonly Wrappers_Compile._IOption<int> _entryPruningTailSize;
    public readonly int _gracePeriod;
    public readonly int _graceInterval;
    public readonly int _fanOut;
    public readonly int _inFlightTTL;
    public readonly int _sleepMilli;
    public StormTrackingCache(int entryCapacity, Wrappers_Compile._IOption<int> entryPruningTailSize, int gracePeriod, int graceInterval, int fanOut, int inFlightTTL, int sleepMilli) {
      this._entryCapacity = entryCapacity;
      this._entryPruningTailSize = entryPruningTailSize;
      this._gracePeriod = gracePeriod;
      this._graceInterval = graceInterval;
      this._fanOut = fanOut;
      this._inFlightTTL = inFlightTTL;
      this._sleepMilli = sleepMilli;
    }
    public _IStormTrackingCache DowncastClone() {
      if (this is _IStormTrackingCache dt) { return dt; }
      return new StormTrackingCache(_entryCapacity, _entryPruningTailSize, _gracePeriod, _graceInterval, _fanOut, _inFlightTTL, _sleepMilli);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.StormTrackingCache;
      return oth != null && this._entryCapacity == oth._entryCapacity && object.Equals(this._entryPruningTailSize, oth._entryPruningTailSize) && this._gracePeriod == oth._gracePeriod && this._graceInterval == oth._graceInterval && this._fanOut == oth._fanOut && this._inFlightTTL == oth._inFlightTTL && this._sleepMilli == oth._sleepMilli;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._entryCapacity));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._entryPruningTailSize));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._gracePeriod));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._graceInterval));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._fanOut));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._inFlightTTL));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sleepMilli));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.StormTrackingCache.StormTrackingCache";
      s += "(";
      s += Dafny.Helpers.ToString(this._entryCapacity);
      s += ", ";
      s += Dafny.Helpers.ToString(this._entryPruningTailSize);
      s += ", ";
      s += Dafny.Helpers.ToString(this._gracePeriod);
      s += ", ";
      s += Dafny.Helpers.ToString(this._graceInterval);
      s += ", ";
      s += Dafny.Helpers.ToString(this._fanOut);
      s += ", ";
      s += Dafny.Helpers.ToString(this._inFlightTTL);
      s += ", ";
      s += Dafny.Helpers.ToString(this._sleepMilli);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IStormTrackingCache theDefault = create(0, Wrappers_Compile.Option<int>.Default(), 0, 0, 0, 0, 0);
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IStormTrackingCache Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IStormTrackingCache> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IStormTrackingCache>(software.amazon.cryptography.materialproviders.internaldafny.types.StormTrackingCache.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IStormTrackingCache> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IStormTrackingCache create(int entryCapacity, Wrappers_Compile._IOption<int> entryPruningTailSize, int gracePeriod, int graceInterval, int fanOut, int inFlightTTL, int sleepMilli) {
      return new StormTrackingCache(entryCapacity, entryPruningTailSize, gracePeriod, graceInterval, fanOut, inFlightTTL, sleepMilli);
    }
    public static _IStormTrackingCache create_StormTrackingCache(int entryCapacity, Wrappers_Compile._IOption<int> entryPruningTailSize, int gracePeriod, int graceInterval, int fanOut, int inFlightTTL, int sleepMilli) {
      return create(entryCapacity, entryPruningTailSize, gracePeriod, graceInterval, fanOut, inFlightTTL, sleepMilli);
    }
    public bool is_StormTrackingCache { get { return true; } }
    public int dtor_entryCapacity {
      get {
        return this._entryCapacity;
      }
    }
    public Wrappers_Compile._IOption<int> dtor_entryPruningTailSize {
      get {
        return this._entryPruningTailSize;
      }
    }
    public int dtor_gracePeriod {
      get {
        return this._gracePeriod;
      }
    }
    public int dtor_graceInterval {
      get {
        return this._graceInterval;
      }
    }
    public int dtor_fanOut {
      get {
        return this._fanOut;
      }
    }
    public int dtor_inFlightTTL {
      get {
        return this._inFlightTTL;
      }
    }
    public int dtor_sleepMilli {
      get {
        return this._sleepMilli;
      }
    }
  }

  public interface _ISymmetricSignatureAlgorithm {
    bool is_HMAC { get; }
    bool is_None { get; }
    software.amazon.cryptography.primitives.internaldafny.types._IDigestAlgorithm dtor_HMAC { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._INone dtor_None { get; }
    _ISymmetricSignatureAlgorithm DowncastClone();
  }
  public abstract class SymmetricSignatureAlgorithm : _ISymmetricSignatureAlgorithm {
    public SymmetricSignatureAlgorithm() { }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._ISymmetricSignatureAlgorithm theDefault = create_HMAC(software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._ISymmetricSignatureAlgorithm Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ISymmetricSignatureAlgorithm> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ISymmetricSignatureAlgorithm>(software.amazon.cryptography.materialproviders.internaldafny.types.SymmetricSignatureAlgorithm.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._ISymmetricSignatureAlgorithm> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ISymmetricSignatureAlgorithm create_HMAC(software.amazon.cryptography.primitives.internaldafny.types._IDigestAlgorithm HMAC) {
      return new SymmetricSignatureAlgorithm_HMAC(HMAC);
    }
    public static _ISymmetricSignatureAlgorithm create_None(software.amazon.cryptography.materialproviders.internaldafny.types._INone None) {
      return new SymmetricSignatureAlgorithm_None(None);
    }
    public bool is_HMAC { get { return this is SymmetricSignatureAlgorithm_HMAC; } }
    public bool is_None { get { return this is SymmetricSignatureAlgorithm_None; } }
    public software.amazon.cryptography.primitives.internaldafny.types._IDigestAlgorithm dtor_HMAC {
      get {
        var d = this;
        return ((SymmetricSignatureAlgorithm_HMAC)d)._HMAC;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._INone dtor_None {
      get {
        var d = this;
        return ((SymmetricSignatureAlgorithm_None)d)._None;
      }
    }
    public abstract _ISymmetricSignatureAlgorithm DowncastClone();
  }
  public class SymmetricSignatureAlgorithm_HMAC : SymmetricSignatureAlgorithm {
    public readonly software.amazon.cryptography.primitives.internaldafny.types._IDigestAlgorithm _HMAC;
    public SymmetricSignatureAlgorithm_HMAC(software.amazon.cryptography.primitives.internaldafny.types._IDigestAlgorithm HMAC) {
      this._HMAC = HMAC;
    }
    public override _ISymmetricSignatureAlgorithm DowncastClone() {
      if (this is _ISymmetricSignatureAlgorithm dt) { return dt; }
      return new SymmetricSignatureAlgorithm_HMAC(_HMAC);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.SymmetricSignatureAlgorithm_HMAC;
      return oth != null && object.Equals(this._HMAC, oth._HMAC);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._HMAC));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.SymmetricSignatureAlgorithm.HMAC";
      s += "(";
      s += Dafny.Helpers.ToString(this._HMAC);
      s += ")";
      return s;
    }
  }
  public class SymmetricSignatureAlgorithm_None : SymmetricSignatureAlgorithm {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._INone _None;
    public SymmetricSignatureAlgorithm_None(software.amazon.cryptography.materialproviders.internaldafny.types._INone None) {
      this._None = None;
    }
    public override _ISymmetricSignatureAlgorithm DowncastClone() {
      if (this is _ISymmetricSignatureAlgorithm dt) { return dt; }
      return new SymmetricSignatureAlgorithm_None(_None);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.SymmetricSignatureAlgorithm_None;
      return oth != null && object.Equals(this._None, oth._None);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._None));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.SymmetricSignatureAlgorithm.None";
      s += "(";
      s += Dafny.Helpers.ToString(this._None);
      s += ")";
      return s;
    }
  }

  public interface _IUpdateUsageMetadataInput {
    bool is_UpdateUsageMetadataInput { get; }
    Dafny.ISequence<byte> dtor_identifier { get; }
    int dtor_bytesUsed { get; }
    _IUpdateUsageMetadataInput DowncastClone();
  }
  public class UpdateUsageMetadataInput : _IUpdateUsageMetadataInput {
    public readonly Dafny.ISequence<byte> _identifier;
    public readonly int _bytesUsed;
    public UpdateUsageMetadataInput(Dafny.ISequence<byte> identifier, int bytesUsed) {
      this._identifier = identifier;
      this._bytesUsed = bytesUsed;
    }
    public _IUpdateUsageMetadataInput DowncastClone() {
      if (this is _IUpdateUsageMetadataInput dt) { return dt; }
      return new UpdateUsageMetadataInput(_identifier, _bytesUsed);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.UpdateUsageMetadataInput;
      return oth != null && object.Equals(this._identifier, oth._identifier) && this._bytesUsed == oth._bytesUsed;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._identifier));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._bytesUsed));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.UpdateUsageMetadataInput.UpdateUsageMetadataInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._identifier);
      s += ", ";
      s += Dafny.Helpers.ToString(this._bytesUsed);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IUpdateUsageMetadataInput theDefault = create(Dafny.Sequence<byte>.Empty, 0);
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IUpdateUsageMetadataInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IUpdateUsageMetadataInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IUpdateUsageMetadataInput>(software.amazon.cryptography.materialproviders.internaldafny.types.UpdateUsageMetadataInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IUpdateUsageMetadataInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IUpdateUsageMetadataInput create(Dafny.ISequence<byte> identifier, int bytesUsed) {
      return new UpdateUsageMetadataInput(identifier, bytesUsed);
    }
    public static _IUpdateUsageMetadataInput create_UpdateUsageMetadataInput(Dafny.ISequence<byte> identifier, int bytesUsed) {
      return create(identifier, bytesUsed);
    }
    public bool is_UpdateUsageMetadataInput { get { return true; } }
    public Dafny.ISequence<byte> dtor_identifier {
      get {
        return this._identifier;
      }
    }
    public int dtor_bytesUsed {
      get {
        return this._bytesUsed;
      }
    }
  }

  public interface _IValidateCommitmentPolicyOnDecryptInput {
    bool is_ValidateCommitmentPolicyOnDecryptInput { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId dtor_algorithm { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy dtor_commitmentPolicy { get; }
    _IValidateCommitmentPolicyOnDecryptInput DowncastClone();
  }
  public class ValidateCommitmentPolicyOnDecryptInput : _IValidateCommitmentPolicyOnDecryptInput {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId _algorithm;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy _commitmentPolicy;
    public ValidateCommitmentPolicyOnDecryptInput(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId algorithm, software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy commitmentPolicy) {
      this._algorithm = algorithm;
      this._commitmentPolicy = commitmentPolicy;
    }
    public _IValidateCommitmentPolicyOnDecryptInput DowncastClone() {
      if (this is _IValidateCommitmentPolicyOnDecryptInput dt) { return dt; }
      return new ValidateCommitmentPolicyOnDecryptInput(_algorithm, _commitmentPolicy);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.ValidateCommitmentPolicyOnDecryptInput;
      return oth != null && object.Equals(this._algorithm, oth._algorithm) && object.Equals(this._commitmentPolicy, oth._commitmentPolicy);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._algorithm));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._commitmentPolicy));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.ValidateCommitmentPolicyOnDecryptInput.ValidateCommitmentPolicyOnDecryptInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._algorithm);
      s += ", ";
      s += Dafny.Helpers.ToString(this._commitmentPolicy);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IValidateCommitmentPolicyOnDecryptInput theDefault = create(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.Default(), software.amazon.cryptography.materialproviders.internaldafny.types.CommitmentPolicy.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IValidateCommitmentPolicyOnDecryptInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IValidateCommitmentPolicyOnDecryptInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IValidateCommitmentPolicyOnDecryptInput>(software.amazon.cryptography.materialproviders.internaldafny.types.ValidateCommitmentPolicyOnDecryptInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IValidateCommitmentPolicyOnDecryptInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IValidateCommitmentPolicyOnDecryptInput create(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId algorithm, software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy commitmentPolicy) {
      return new ValidateCommitmentPolicyOnDecryptInput(algorithm, commitmentPolicy);
    }
    public static _IValidateCommitmentPolicyOnDecryptInput create_ValidateCommitmentPolicyOnDecryptInput(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId algorithm, software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy commitmentPolicy) {
      return create(algorithm, commitmentPolicy);
    }
    public bool is_ValidateCommitmentPolicyOnDecryptInput { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId dtor_algorithm {
      get {
        return this._algorithm;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy dtor_commitmentPolicy {
      get {
        return this._commitmentPolicy;
      }
    }
  }

  public interface _IValidateCommitmentPolicyOnEncryptInput {
    bool is_ValidateCommitmentPolicyOnEncryptInput { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId dtor_algorithm { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy dtor_commitmentPolicy { get; }
    _IValidateCommitmentPolicyOnEncryptInput DowncastClone();
  }
  public class ValidateCommitmentPolicyOnEncryptInput : _IValidateCommitmentPolicyOnEncryptInput {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId _algorithm;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy _commitmentPolicy;
    public ValidateCommitmentPolicyOnEncryptInput(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId algorithm, software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy commitmentPolicy) {
      this._algorithm = algorithm;
      this._commitmentPolicy = commitmentPolicy;
    }
    public _IValidateCommitmentPolicyOnEncryptInput DowncastClone() {
      if (this is _IValidateCommitmentPolicyOnEncryptInput dt) { return dt; }
      return new ValidateCommitmentPolicyOnEncryptInput(_algorithm, _commitmentPolicy);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.ValidateCommitmentPolicyOnEncryptInput;
      return oth != null && object.Equals(this._algorithm, oth._algorithm) && object.Equals(this._commitmentPolicy, oth._commitmentPolicy);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._algorithm));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._commitmentPolicy));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.ValidateCommitmentPolicyOnEncryptInput.ValidateCommitmentPolicyOnEncryptInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._algorithm);
      s += ", ";
      s += Dafny.Helpers.ToString(this._commitmentPolicy);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IValidateCommitmentPolicyOnEncryptInput theDefault = create(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.Default(), software.amazon.cryptography.materialproviders.internaldafny.types.CommitmentPolicy.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IValidateCommitmentPolicyOnEncryptInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IValidateCommitmentPolicyOnEncryptInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IValidateCommitmentPolicyOnEncryptInput>(software.amazon.cryptography.materialproviders.internaldafny.types.ValidateCommitmentPolicyOnEncryptInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IValidateCommitmentPolicyOnEncryptInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IValidateCommitmentPolicyOnEncryptInput create(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId algorithm, software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy commitmentPolicy) {
      return new ValidateCommitmentPolicyOnEncryptInput(algorithm, commitmentPolicy);
    }
    public static _IValidateCommitmentPolicyOnEncryptInput create_ValidateCommitmentPolicyOnEncryptInput(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId algorithm, software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy commitmentPolicy) {
      return create(algorithm, commitmentPolicy);
    }
    public bool is_ValidateCommitmentPolicyOnEncryptInput { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId dtor_algorithm {
      get {
        return this._algorithm;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy dtor_commitmentPolicy {
      get {
        return this._commitmentPolicy;
      }
    }
  }

  public interface _IValidDecryptionMaterialsTransitionInput {
    bool is_ValidDecryptionMaterialsTransitionInput { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials dtor_start { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials dtor_stop { get; }
    _IValidDecryptionMaterialsTransitionInput DowncastClone();
  }
  public class ValidDecryptionMaterialsTransitionInput : _IValidDecryptionMaterialsTransitionInput {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _start;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _stop;
    public ValidDecryptionMaterialsTransitionInput(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials start, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials stop) {
      this._start = start;
      this._stop = stop;
    }
    public _IValidDecryptionMaterialsTransitionInput DowncastClone() {
      if (this is _IValidDecryptionMaterialsTransitionInput dt) { return dt; }
      return new ValidDecryptionMaterialsTransitionInput(_start, _stop);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.ValidDecryptionMaterialsTransitionInput;
      return oth != null && object.Equals(this._start, oth._start) && object.Equals(this._stop, oth._stop);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._start));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._stop));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.ValidDecryptionMaterialsTransitionInput.ValidDecryptionMaterialsTransitionInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._start);
      s += ", ";
      s += Dafny.Helpers.ToString(this._stop);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IValidDecryptionMaterialsTransitionInput theDefault = create(software.amazon.cryptography.materialproviders.internaldafny.types.DecryptionMaterials.Default(), software.amazon.cryptography.materialproviders.internaldafny.types.DecryptionMaterials.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IValidDecryptionMaterialsTransitionInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IValidDecryptionMaterialsTransitionInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IValidDecryptionMaterialsTransitionInput>(software.amazon.cryptography.materialproviders.internaldafny.types.ValidDecryptionMaterialsTransitionInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IValidDecryptionMaterialsTransitionInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IValidDecryptionMaterialsTransitionInput create(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials start, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials stop) {
      return new ValidDecryptionMaterialsTransitionInput(start, stop);
    }
    public static _IValidDecryptionMaterialsTransitionInput create_ValidDecryptionMaterialsTransitionInput(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials start, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials stop) {
      return create(start, stop);
    }
    public bool is_ValidDecryptionMaterialsTransitionInput { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials dtor_start {
      get {
        return this._start;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials dtor_stop {
      get {
        return this._stop;
      }
    }
  }

  public interface _IValidEncryptionMaterialsTransitionInput {
    bool is_ValidEncryptionMaterialsTransitionInput { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials dtor_start { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials dtor_stop { get; }
    _IValidEncryptionMaterialsTransitionInput DowncastClone();
  }
  public class ValidEncryptionMaterialsTransitionInput : _IValidEncryptionMaterialsTransitionInput {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _start;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _stop;
    public ValidEncryptionMaterialsTransitionInput(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials start, software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials stop) {
      this._start = start;
      this._stop = stop;
    }
    public _IValidEncryptionMaterialsTransitionInput DowncastClone() {
      if (this is _IValidEncryptionMaterialsTransitionInput dt) { return dt; }
      return new ValidEncryptionMaterialsTransitionInput(_start, _stop);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.ValidEncryptionMaterialsTransitionInput;
      return oth != null && object.Equals(this._start, oth._start) && object.Equals(this._stop, oth._stop);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._start));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._stop));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.ValidEncryptionMaterialsTransitionInput.ValidEncryptionMaterialsTransitionInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._start);
      s += ", ";
      s += Dafny.Helpers.ToString(this._stop);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IValidEncryptionMaterialsTransitionInput theDefault = create(software.amazon.cryptography.materialproviders.internaldafny.types.EncryptionMaterials.Default(), software.amazon.cryptography.materialproviders.internaldafny.types.EncryptionMaterials.Default());
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IValidEncryptionMaterialsTransitionInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IValidEncryptionMaterialsTransitionInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IValidEncryptionMaterialsTransitionInput>(software.amazon.cryptography.materialproviders.internaldafny.types.ValidEncryptionMaterialsTransitionInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IValidEncryptionMaterialsTransitionInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IValidEncryptionMaterialsTransitionInput create(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials start, software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials stop) {
      return new ValidEncryptionMaterialsTransitionInput(start, stop);
    }
    public static _IValidEncryptionMaterialsTransitionInput create_ValidEncryptionMaterialsTransitionInput(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials start, software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials stop) {
      return create(start, stop);
    }
    public bool is_ValidEncryptionMaterialsTransitionInput { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials dtor_start {
      get {
        return this._start;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials dtor_stop {
      get {
        return this._stop;
      }
    }
  }

  public interface _IError {
    bool is_AwsCryptographicMaterialProvidersException { get; }
    bool is_EntryAlreadyExists { get; }
    bool is_EntryDoesNotExist { get; }
    bool is_InvalidAlgorithmSuiteInfo { get; }
    bool is_InvalidAlgorithmSuiteInfoOnDecrypt { get; }
    bool is_InvalidAlgorithmSuiteInfoOnEncrypt { get; }
    bool is_InvalidDecryptionMaterials { get; }
    bool is_InvalidDecryptionMaterialsTransition { get; }
    bool is_InvalidEncryptionMaterials { get; }
    bool is_InvalidEncryptionMaterialsTransition { get; }
    bool is_AwsCryptographyKeyStore { get; }
    bool is_AwsCryptographyPrimitives { get; }
    bool is_ComAmazonawsDynamodb { get; }
    bool is_ComAmazonawsKms { get; }
    bool is_CollectionOfErrors { get; }
    bool is_Opaque { get; }
    Dafny.ISequence<char> dtor_message { get; }
    software.amazon.cryptography.keystore.internaldafny.types._IError dtor_AwsCryptographyKeyStore { get; }
    software.amazon.cryptography.primitives.internaldafny.types._IError dtor_AwsCryptographyPrimitives { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IError dtor_ComAmazonawsDynamodb { get; }
    software.amazon.cryptography.services.kms.internaldafny.types._IError dtor_ComAmazonawsKms { get; }
    Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError> dtor_list { get; }
    object dtor_obj { get; }
    _IError DowncastClone();
  }
  public abstract class Error : _IError {
    public Error() { }
    private static readonly software.amazon.cryptography.materialproviders.internaldafny.types._IError theDefault = create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.Empty);
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IError Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(software.amazon.cryptography.materialproviders.internaldafny.types.Error.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IError create_AwsCryptographicMaterialProvidersException(Dafny.ISequence<char> message) {
      return new Error_AwsCryptographicMaterialProvidersException(message);
    }
    public static _IError create_EntryAlreadyExists(Dafny.ISequence<char> message) {
      return new Error_EntryAlreadyExists(message);
    }
    public static _IError create_EntryDoesNotExist(Dafny.ISequence<char> message) {
      return new Error_EntryDoesNotExist(message);
    }
    public static _IError create_InvalidAlgorithmSuiteInfo(Dafny.ISequence<char> message) {
      return new Error_InvalidAlgorithmSuiteInfo(message);
    }
    public static _IError create_InvalidAlgorithmSuiteInfoOnDecrypt(Dafny.ISequence<char> message) {
      return new Error_InvalidAlgorithmSuiteInfoOnDecrypt(message);
    }
    public static _IError create_InvalidAlgorithmSuiteInfoOnEncrypt(Dafny.ISequence<char> message) {
      return new Error_InvalidAlgorithmSuiteInfoOnEncrypt(message);
    }
    public static _IError create_InvalidDecryptionMaterials(Dafny.ISequence<char> message) {
      return new Error_InvalidDecryptionMaterials(message);
    }
    public static _IError create_InvalidDecryptionMaterialsTransition(Dafny.ISequence<char> message) {
      return new Error_InvalidDecryptionMaterialsTransition(message);
    }
    public static _IError create_InvalidEncryptionMaterials(Dafny.ISequence<char> message) {
      return new Error_InvalidEncryptionMaterials(message);
    }
    public static _IError create_InvalidEncryptionMaterialsTransition(Dafny.ISequence<char> message) {
      return new Error_InvalidEncryptionMaterialsTransition(message);
    }
    public static _IError create_AwsCryptographyKeyStore(software.amazon.cryptography.keystore.internaldafny.types._IError AwsCryptographyKeyStore) {
      return new Error_AwsCryptographyKeyStore(AwsCryptographyKeyStore);
    }
    public static _IError create_AwsCryptographyPrimitives(software.amazon.cryptography.primitives.internaldafny.types._IError AwsCryptographyPrimitives) {
      return new Error_AwsCryptographyPrimitives(AwsCryptographyPrimitives);
    }
    public static _IError create_ComAmazonawsDynamodb(software.amazon.cryptography.services.dynamodb.internaldafny.types._IError ComAmazonawsDynamodb) {
      return new Error_ComAmazonawsDynamodb(ComAmazonawsDynamodb);
    }
    public static _IError create_ComAmazonawsKms(software.amazon.cryptography.services.kms.internaldafny.types._IError ComAmazonawsKms) {
      return new Error_ComAmazonawsKms(ComAmazonawsKms);
    }
    public static _IError create_CollectionOfErrors(Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError> list, Dafny.ISequence<char> message) {
      return new Error_CollectionOfErrors(list, message);
    }
    public static _IError create_Opaque(object obj) {
      return new Error_Opaque(obj);
    }
    public bool is_AwsCryptographicMaterialProvidersException { get { return this is Error_AwsCryptographicMaterialProvidersException; } }
    public bool is_EntryAlreadyExists { get { return this is Error_EntryAlreadyExists; } }
    public bool is_EntryDoesNotExist { get { return this is Error_EntryDoesNotExist; } }
    public bool is_InvalidAlgorithmSuiteInfo { get { return this is Error_InvalidAlgorithmSuiteInfo; } }
    public bool is_InvalidAlgorithmSuiteInfoOnDecrypt { get { return this is Error_InvalidAlgorithmSuiteInfoOnDecrypt; } }
    public bool is_InvalidAlgorithmSuiteInfoOnEncrypt { get { return this is Error_InvalidAlgorithmSuiteInfoOnEncrypt; } }
    public bool is_InvalidDecryptionMaterials { get { return this is Error_InvalidDecryptionMaterials; } }
    public bool is_InvalidDecryptionMaterialsTransition { get { return this is Error_InvalidDecryptionMaterialsTransition; } }
    public bool is_InvalidEncryptionMaterials { get { return this is Error_InvalidEncryptionMaterials; } }
    public bool is_InvalidEncryptionMaterialsTransition { get { return this is Error_InvalidEncryptionMaterialsTransition; } }
    public bool is_AwsCryptographyKeyStore { get { return this is Error_AwsCryptographyKeyStore; } }
    public bool is_AwsCryptographyPrimitives { get { return this is Error_AwsCryptographyPrimitives; } }
    public bool is_ComAmazonawsDynamodb { get { return this is Error_ComAmazonawsDynamodb; } }
    public bool is_ComAmazonawsKms { get { return this is Error_ComAmazonawsKms; } }
    public bool is_CollectionOfErrors { get { return this is Error_CollectionOfErrors; } }
    public bool is_Opaque { get { return this is Error_Opaque; } }
    public Dafny.ISequence<char> dtor_message {
      get {
        var d = this;
        if (d is Error_AwsCryptographicMaterialProvidersException) { return ((Error_AwsCryptographicMaterialProvidersException)d)._message; }
        if (d is Error_EntryAlreadyExists) { return ((Error_EntryAlreadyExists)d)._message; }
        if (d is Error_EntryDoesNotExist) { return ((Error_EntryDoesNotExist)d)._message; }
        if (d is Error_InvalidAlgorithmSuiteInfo) { return ((Error_InvalidAlgorithmSuiteInfo)d)._message; }
        if (d is Error_InvalidAlgorithmSuiteInfoOnDecrypt) { return ((Error_InvalidAlgorithmSuiteInfoOnDecrypt)d)._message; }
        if (d is Error_InvalidAlgorithmSuiteInfoOnEncrypt) { return ((Error_InvalidAlgorithmSuiteInfoOnEncrypt)d)._message; }
        if (d is Error_InvalidDecryptionMaterials) { return ((Error_InvalidDecryptionMaterials)d)._message; }
        if (d is Error_InvalidDecryptionMaterialsTransition) { return ((Error_InvalidDecryptionMaterialsTransition)d)._message; }
        if (d is Error_InvalidEncryptionMaterials) { return ((Error_InvalidEncryptionMaterials)d)._message; }
        if (d is Error_InvalidEncryptionMaterialsTransition) { return ((Error_InvalidEncryptionMaterialsTransition)d)._message; }
        return ((Error_CollectionOfErrors)d)._message;
      }
    }
    public software.amazon.cryptography.keystore.internaldafny.types._IError dtor_AwsCryptographyKeyStore {
      get {
        var d = this;
        return ((Error_AwsCryptographyKeyStore)d)._AwsCryptographyKeyStore;
      }
    }
    public software.amazon.cryptography.primitives.internaldafny.types._IError dtor_AwsCryptographyPrimitives {
      get {
        var d = this;
        return ((Error_AwsCryptographyPrimitives)d)._AwsCryptographyPrimitives;
      }
    }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IError dtor_ComAmazonawsDynamodb {
      get {
        var d = this;
        return ((Error_ComAmazonawsDynamodb)d)._ComAmazonawsDynamodb;
      }
    }
    public software.amazon.cryptography.services.kms.internaldafny.types._IError dtor_ComAmazonawsKms {
      get {
        var d = this;
        return ((Error_ComAmazonawsKms)d)._ComAmazonawsKms;
      }
    }
    public Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError> dtor_list {
      get {
        var d = this;
        return ((Error_CollectionOfErrors)d)._list;
      }
    }
    public object dtor_obj {
      get {
        var d = this;
        return ((Error_Opaque)d)._obj;
      }
    }
    public abstract _IError DowncastClone();
  }
  public class Error_AwsCryptographicMaterialProvidersException : Error {
    public readonly Dafny.ISequence<char> _message;
    public Error_AwsCryptographicMaterialProvidersException(Dafny.ISequence<char> message) {
      this._message = message;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_AwsCryptographicMaterialProvidersException(_message);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.Error_AwsCryptographicMaterialProvidersException;
      return oth != null && object.Equals(this._message, oth._message);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._message));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.Error.AwsCryptographicMaterialProvidersException";
      s += "(";
      s += Dafny.Helpers.ToString(this._message);
      s += ")";
      return s;
    }
  }
  public class Error_EntryAlreadyExists : Error {
    public readonly Dafny.ISequence<char> _message;
    public Error_EntryAlreadyExists(Dafny.ISequence<char> message) {
      this._message = message;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_EntryAlreadyExists(_message);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.Error_EntryAlreadyExists;
      return oth != null && object.Equals(this._message, oth._message);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._message));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.Error.EntryAlreadyExists";
      s += "(";
      s += Dafny.Helpers.ToString(this._message);
      s += ")";
      return s;
    }
  }
  public class Error_EntryDoesNotExist : Error {
    public readonly Dafny.ISequence<char> _message;
    public Error_EntryDoesNotExist(Dafny.ISequence<char> message) {
      this._message = message;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_EntryDoesNotExist(_message);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.Error_EntryDoesNotExist;
      return oth != null && object.Equals(this._message, oth._message);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._message));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.Error.EntryDoesNotExist";
      s += "(";
      s += Dafny.Helpers.ToString(this._message);
      s += ")";
      return s;
    }
  }
  public class Error_InvalidAlgorithmSuiteInfo : Error {
    public readonly Dafny.ISequence<char> _message;
    public Error_InvalidAlgorithmSuiteInfo(Dafny.ISequence<char> message) {
      this._message = message;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_InvalidAlgorithmSuiteInfo(_message);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.Error_InvalidAlgorithmSuiteInfo;
      return oth != null && object.Equals(this._message, oth._message);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._message));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.Error.InvalidAlgorithmSuiteInfo";
      s += "(";
      s += Dafny.Helpers.ToString(this._message);
      s += ")";
      return s;
    }
  }
  public class Error_InvalidAlgorithmSuiteInfoOnDecrypt : Error {
    public readonly Dafny.ISequence<char> _message;
    public Error_InvalidAlgorithmSuiteInfoOnDecrypt(Dafny.ISequence<char> message) {
      this._message = message;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_InvalidAlgorithmSuiteInfoOnDecrypt(_message);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.Error_InvalidAlgorithmSuiteInfoOnDecrypt;
      return oth != null && object.Equals(this._message, oth._message);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 4;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._message));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.Error.InvalidAlgorithmSuiteInfoOnDecrypt";
      s += "(";
      s += Dafny.Helpers.ToString(this._message);
      s += ")";
      return s;
    }
  }
  public class Error_InvalidAlgorithmSuiteInfoOnEncrypt : Error {
    public readonly Dafny.ISequence<char> _message;
    public Error_InvalidAlgorithmSuiteInfoOnEncrypt(Dafny.ISequence<char> message) {
      this._message = message;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_InvalidAlgorithmSuiteInfoOnEncrypt(_message);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.Error_InvalidAlgorithmSuiteInfoOnEncrypt;
      return oth != null && object.Equals(this._message, oth._message);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 5;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._message));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.Error.InvalidAlgorithmSuiteInfoOnEncrypt";
      s += "(";
      s += Dafny.Helpers.ToString(this._message);
      s += ")";
      return s;
    }
  }
  public class Error_InvalidDecryptionMaterials : Error {
    public readonly Dafny.ISequence<char> _message;
    public Error_InvalidDecryptionMaterials(Dafny.ISequence<char> message) {
      this._message = message;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_InvalidDecryptionMaterials(_message);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.Error_InvalidDecryptionMaterials;
      return oth != null && object.Equals(this._message, oth._message);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 6;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._message));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.Error.InvalidDecryptionMaterials";
      s += "(";
      s += Dafny.Helpers.ToString(this._message);
      s += ")";
      return s;
    }
  }
  public class Error_InvalidDecryptionMaterialsTransition : Error {
    public readonly Dafny.ISequence<char> _message;
    public Error_InvalidDecryptionMaterialsTransition(Dafny.ISequence<char> message) {
      this._message = message;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_InvalidDecryptionMaterialsTransition(_message);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.Error_InvalidDecryptionMaterialsTransition;
      return oth != null && object.Equals(this._message, oth._message);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 7;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._message));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.Error.InvalidDecryptionMaterialsTransition";
      s += "(";
      s += Dafny.Helpers.ToString(this._message);
      s += ")";
      return s;
    }
  }
  public class Error_InvalidEncryptionMaterials : Error {
    public readonly Dafny.ISequence<char> _message;
    public Error_InvalidEncryptionMaterials(Dafny.ISequence<char> message) {
      this._message = message;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_InvalidEncryptionMaterials(_message);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.Error_InvalidEncryptionMaterials;
      return oth != null && object.Equals(this._message, oth._message);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 8;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._message));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.Error.InvalidEncryptionMaterials";
      s += "(";
      s += Dafny.Helpers.ToString(this._message);
      s += ")";
      return s;
    }
  }
  public class Error_InvalidEncryptionMaterialsTransition : Error {
    public readonly Dafny.ISequence<char> _message;
    public Error_InvalidEncryptionMaterialsTransition(Dafny.ISequence<char> message) {
      this._message = message;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_InvalidEncryptionMaterialsTransition(_message);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.Error_InvalidEncryptionMaterialsTransition;
      return oth != null && object.Equals(this._message, oth._message);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 9;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._message));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.Error.InvalidEncryptionMaterialsTransition";
      s += "(";
      s += Dafny.Helpers.ToString(this._message);
      s += ")";
      return s;
    }
  }
  public class Error_AwsCryptographyKeyStore : Error {
    public readonly software.amazon.cryptography.keystore.internaldafny.types._IError _AwsCryptographyKeyStore;
    public Error_AwsCryptographyKeyStore(software.amazon.cryptography.keystore.internaldafny.types._IError AwsCryptographyKeyStore) {
      this._AwsCryptographyKeyStore = AwsCryptographyKeyStore;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_AwsCryptographyKeyStore(_AwsCryptographyKeyStore);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.Error_AwsCryptographyKeyStore;
      return oth != null && object.Equals(this._AwsCryptographyKeyStore, oth._AwsCryptographyKeyStore);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 10;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._AwsCryptographyKeyStore));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.Error.AwsCryptographyKeyStore";
      s += "(";
      s += Dafny.Helpers.ToString(this._AwsCryptographyKeyStore);
      s += ")";
      return s;
    }
  }
  public class Error_AwsCryptographyPrimitives : Error {
    public readonly software.amazon.cryptography.primitives.internaldafny.types._IError _AwsCryptographyPrimitives;
    public Error_AwsCryptographyPrimitives(software.amazon.cryptography.primitives.internaldafny.types._IError AwsCryptographyPrimitives) {
      this._AwsCryptographyPrimitives = AwsCryptographyPrimitives;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_AwsCryptographyPrimitives(_AwsCryptographyPrimitives);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.Error_AwsCryptographyPrimitives;
      return oth != null && object.Equals(this._AwsCryptographyPrimitives, oth._AwsCryptographyPrimitives);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 11;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._AwsCryptographyPrimitives));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.Error.AwsCryptographyPrimitives";
      s += "(";
      s += Dafny.Helpers.ToString(this._AwsCryptographyPrimitives);
      s += ")";
      return s;
    }
  }
  public class Error_ComAmazonawsDynamodb : Error {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IError _ComAmazonawsDynamodb;
    public Error_ComAmazonawsDynamodb(software.amazon.cryptography.services.dynamodb.internaldafny.types._IError ComAmazonawsDynamodb) {
      this._ComAmazonawsDynamodb = ComAmazonawsDynamodb;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_ComAmazonawsDynamodb(_ComAmazonawsDynamodb);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.Error_ComAmazonawsDynamodb;
      return oth != null && object.Equals(this._ComAmazonawsDynamodb, oth._ComAmazonawsDynamodb);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 12;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._ComAmazonawsDynamodb));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.Error.ComAmazonawsDynamodb";
      s += "(";
      s += Dafny.Helpers.ToString(this._ComAmazonawsDynamodb);
      s += ")";
      return s;
    }
  }
  public class Error_ComAmazonawsKms : Error {
    public readonly software.amazon.cryptography.services.kms.internaldafny.types._IError _ComAmazonawsKms;
    public Error_ComAmazonawsKms(software.amazon.cryptography.services.kms.internaldafny.types._IError ComAmazonawsKms) {
      this._ComAmazonawsKms = ComAmazonawsKms;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_ComAmazonawsKms(_ComAmazonawsKms);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.Error_ComAmazonawsKms;
      return oth != null && object.Equals(this._ComAmazonawsKms, oth._ComAmazonawsKms);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 13;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._ComAmazonawsKms));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.Error.ComAmazonawsKms";
      s += "(";
      s += Dafny.Helpers.ToString(this._ComAmazonawsKms);
      s += ")";
      return s;
    }
  }
  public class Error_CollectionOfErrors : Error {
    public readonly Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _list;
    public readonly Dafny.ISequence<char> _message;
    public Error_CollectionOfErrors(Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError> list, Dafny.ISequence<char> message) {
      this._list = list;
      this._message = message;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_CollectionOfErrors(_list, _message);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.Error_CollectionOfErrors;
      return oth != null && object.Equals(this._list, oth._list) && object.Equals(this._message, oth._message);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 14;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._list));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._message));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.Error.CollectionOfErrors";
      s += "(";
      s += Dafny.Helpers.ToString(this._list);
      s += ", ";
      s += Dafny.Helpers.ToString(this._message);
      s += ")";
      return s;
    }
  }
  public class Error_Opaque : Error {
    public readonly object _obj;
    public Error_Opaque(object obj) {
      this._obj = obj;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_Opaque(_obj);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.materialproviders.internaldafny.types.Error_Opaque;
      return oth != null && this._obj == oth._obj;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 15;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._obj));
      return (int) hash;
    }
    public override string ToString() {
      string s = "software.amazon.cryptography.materialproviders.internaldafny.types_Compile.Error.Opaque";
      s += "(";
      s += Dafny.Helpers.ToString(this._obj);
      s += ")";
      return s;
    }
  }

  public partial class OpaqueError {
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(software.amazon.cryptography.materialproviders.internaldafny.types.Error.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class __default {
    public static bool IsValid__CountingNumber(int x) {
      return (1) <= (x);
    }
    public static bool IsValid__PositiveInteger(int x) {
      return (0) <= (x);
    }
    public static bool IsValid__PositiveLong(long x) {
      return (0L) <= (x);
    }
  }
} // end of namespace software.amazon.cryptography.materialproviders.internaldafny.types
namespace AlgorithmSuites_Compile {

  public partial class AlgorithmSuite {
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteInfo.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class __default {
    public static bool SupportedESDKEncrypt_q(software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt e) {
      return (((true) && ((((((e).dtor_AES__GCM).dtor_keyLength) == (32)) || ((((e).dtor_AES__GCM).dtor_keyLength) == (24))) || ((((e).dtor_AES__GCM).dtor_keyLength) == (16)))) && ((((e).dtor_AES__GCM).dtor_tagLength) == (16))) && ((((e).dtor_AES__GCM).dtor_ivLength) == (12));
    }
    public static bool SupportedDBEEncrypt_q(software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt e) {
      return (((true) && ((((e).dtor_AES__GCM).dtor_keyLength) == (32))) && ((((e).dtor_AES__GCM).dtor_tagLength) == (16))) && ((((e).dtor_AES__GCM).dtor_ivLength) == (12));
    }
    public static bool SupportedDBEEDKWrapping_q(software.amazon.cryptography.materialproviders.internaldafny.types._IEdkWrappingAlgorithm p) {
      return (((((((p).is_IntermediateKeyWrapping) && (true)) && ((((((p).dtor_IntermediateKeyWrapping).dtor_pdkEncryptAlgorithm).dtor_AES__GCM).dtor_keyLength) == (32))) && ((((((p).dtor_IntermediateKeyWrapping).dtor_pdkEncryptAlgorithm).dtor_AES__GCM).dtor_tagLength) == (16))) && ((((((p).dtor_IntermediateKeyWrapping).dtor_pdkEncryptAlgorithm).dtor_AES__GCM).dtor_ivLength) == (12))) && ((((p).dtor_IntermediateKeyWrapping).dtor_macKeyKdf).is_HKDF)) && ((((p).dtor_IntermediateKeyWrapping).dtor_keyEncryptionKeyKdf).is_HKDF);
    }
    public static bool KeyDerivationAlgorithm_q(software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm kdf) {
      return (!((true) && ((kdf).is_HKDF)) || (((((kdf).dtor_HKDF).dtor_inputKeyLength) == (((kdf).dtor_HKDF).dtor_outputKeyLength)) && (!(object.Equals(((kdf).dtor_HKDF).dtor_hmac, software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__512())) || ((((kdf).dtor_HKDF).dtor_inputKeyLength) == (32))))) && (!((kdf).is_None));
    }
    public static bool CommitmentDerivationAlgorithm_q(software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm kdf) {
      return (!((true) && ((kdf).is_HKDF)) || (((((((kdf).dtor_HKDF).dtor_hmac).is_SHA__512) && ((((kdf).dtor_HKDF).dtor_saltLength) == (32))) && ((((kdf).dtor_HKDF).dtor_inputKeyLength) == (32))) && ((((kdf).dtor_HKDF).dtor_outputKeyLength) == (32)))) && (!((kdf).is_IDENTITY));
    }
    public static bool EdkWrappingAlgorithm_q(software.amazon.cryptography.materialproviders.internaldafny.types._IEdkWrappingAlgorithm alg) {
      return ((((((alg).is_IntermediateKeyWrapping) && ((((alg).dtor_IntermediateKeyWrapping).dtor_keyEncryptionKeyKdf).is_HKDF)) && ((((alg).dtor_IntermediateKeyWrapping).dtor_macKeyKdf).is_HKDF)) && (true)) && ((((((alg).dtor_IntermediateKeyWrapping).dtor_pdkEncryptAlgorithm).dtor_AES__GCM).dtor_keyLength) == (32))) || ((alg).is_DIRECT__KEY__WRAPPING);
    }
    public static bool AlgorithmSuiteInfo_q(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo a) {
      return ((((((((AlgorithmSuites_Compile.__default.KeyDerivationAlgorithm_q((a).dtor_kdf)) && (AlgorithmSuites_Compile.__default.CommitmentDerivationAlgorithm_q((a).dtor_commitment))) && (AlgorithmSuites_Compile.__default.EdkWrappingAlgorithm_q((a).dtor_edkWrapping))) && (!(((a).dtor_kdf).is_HKDF) || ((true) && (((((a).dtor_kdf).dtor_HKDF).dtor_outputKeyLength) == ((((a).dtor_encrypt).dtor_AES__GCM).dtor_keyLength))))) && (!(((a).dtor_signature).is_ECDSA) || (((a).dtor_kdf).is_HKDF))) && (!(((a).dtor_commitment).is_HKDF) || ((((((a).dtor_commitment).dtor_HKDF).dtor_saltLength) == (32)) && (object.Equals((a).dtor_commitment, (a).dtor_kdf))))) && (!(((a).dtor_edkWrapping).is_IntermediateKeyWrapping) || (((((a).dtor_kdf).is_HKDF) && (object.Equals((((a).dtor_edkWrapping).dtor_IntermediateKeyWrapping).dtor_keyEncryptionKeyKdf, (a).dtor_kdf))) && (object.Equals((((a).dtor_edkWrapping).dtor_IntermediateKeyWrapping).dtor_macKeyKdf, (a).dtor_kdf))))) && (!((((a).dtor_kdf).is_HKDF) && (((a).dtor_commitment).is_None)) || (((((a).dtor_kdf).dtor_HKDF).dtor_saltLength) == (0)))) && (!(!(((a).dtor_symmetricSignature).is_None)) || ((true) && (((a).dtor_edkWrapping).is_IntermediateKeyWrapping)));
    }
    public static bool ESDKAlgorithmSuite_q(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo a) {
      return ((AlgorithmSuites_Compile.__default.AlgorithmSuiteInfo_q(a)) && (AlgorithmSuites_Compile.__default.SupportedESDKEncrypt_q((a).dtor_encrypt))) && (((System.Func<software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId, bool>)((_source0) => {
        if (_source0.is_ALG__AES__128__GCM__IV12__TAG16__NO__KDF) {
          return ((((((((((a).dtor_binaryId).Equals(Dafny.Sequence<byte>.FromElements((byte)(0), (byte)(20)))) && (((a).dtor_messageVersion) == (1))) && (true)) && (((((a).dtor_encrypt).dtor_AES__GCM).dtor_keyLength) == (16))) && (((a).dtor_kdf).is_IDENTITY)) && (((a).dtor_signature).is_None)) && (((a).dtor_commitment).is_None)) && (((a).dtor_symmetricSignature).is_None)) && (((a).dtor_edkWrapping).is_DIRECT__KEY__WRAPPING);
        } else if (_source0.is_ALG__AES__192__GCM__IV12__TAG16__NO__KDF) {
          return ((((((((((a).dtor_binaryId).Equals(Dafny.Sequence<byte>.FromElements((byte)(0), (byte)(70)))) && (((a).dtor_messageVersion) == (1))) && (true)) && (((((a).dtor_encrypt).dtor_AES__GCM).dtor_keyLength) == (24))) && (((a).dtor_kdf).is_IDENTITY)) && (((a).dtor_signature).is_None)) && (((a).dtor_commitment).is_None)) && (((a).dtor_symmetricSignature).is_None)) && (((a).dtor_edkWrapping).is_DIRECT__KEY__WRAPPING);
        } else if (_source0.is_ALG__AES__256__GCM__IV12__TAG16__NO__KDF) {
          return ((((((((((a).dtor_binaryId).Equals(Dafny.Sequence<byte>.FromElements((byte)(0), (byte)(120)))) && (((a).dtor_messageVersion) == (1))) && (true)) && (((((a).dtor_encrypt).dtor_AES__GCM).dtor_keyLength) == (32))) && (((a).dtor_kdf).is_IDENTITY)) && (((a).dtor_signature).is_None)) && (((a).dtor_commitment).is_None)) && (((a).dtor_symmetricSignature).is_None)) && (((a).dtor_edkWrapping).is_DIRECT__KEY__WRAPPING);
        } else if (_source0.is_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256) {
          return (((((((((((a).dtor_binaryId).Equals(Dafny.Sequence<byte>.FromElements((byte)(1), (byte)(20)))) && (((a).dtor_messageVersion) == (1))) && (true)) && (((((a).dtor_encrypt).dtor_AES__GCM).dtor_keyLength) == (16))) && (((a).dtor_kdf).is_HKDF)) && (object.Equals((((a).dtor_kdf).dtor_HKDF).dtor_hmac, software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__256()))) && (((a).dtor_signature).is_None)) && (((a).dtor_commitment).is_None)) && (((a).dtor_symmetricSignature).is_None)) && (((a).dtor_edkWrapping).is_DIRECT__KEY__WRAPPING);
        } else if (_source0.is_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256) {
          return (((((((((((a).dtor_binaryId).Equals(Dafny.Sequence<byte>.FromElements((byte)(1), (byte)(70)))) && (((a).dtor_messageVersion) == (1))) && (true)) && (((((a).dtor_encrypt).dtor_AES__GCM).dtor_keyLength) == (24))) && (((a).dtor_kdf).is_HKDF)) && (object.Equals((((a).dtor_kdf).dtor_HKDF).dtor_hmac, software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__256()))) && (((a).dtor_signature).is_None)) && (((a).dtor_commitment).is_None)) && (((a).dtor_symmetricSignature).is_None)) && (((a).dtor_edkWrapping).is_DIRECT__KEY__WRAPPING);
        } else if (_source0.is_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256) {
          return (((((((((((a).dtor_binaryId).Equals(Dafny.Sequence<byte>.FromElements((byte)(1), (byte)(120)))) && (((a).dtor_messageVersion) == (1))) && (true)) && (((((a).dtor_encrypt).dtor_AES__GCM).dtor_keyLength) == (32))) && (((a).dtor_kdf).is_HKDF)) && (object.Equals((((a).dtor_kdf).dtor_HKDF).dtor_hmac, software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__256()))) && (((a).dtor_signature).is_None)) && (((a).dtor_commitment).is_None)) && (((a).dtor_symmetricSignature).is_None)) && (((a).dtor_edkWrapping).is_DIRECT__KEY__WRAPPING);
        } else if (_source0.is_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256) {
          return ((((((((((((a).dtor_binaryId).Equals(Dafny.Sequence<byte>.FromElements((byte)(2), (byte)(20)))) && (((a).dtor_messageVersion) == (1))) && (true)) && (((((a).dtor_encrypt).dtor_AES__GCM).dtor_keyLength) == (16))) && (((a).dtor_kdf).is_HKDF)) && (object.Equals((((a).dtor_kdf).dtor_HKDF).dtor_hmac, software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__256()))) && (((a).dtor_signature).is_ECDSA)) && (object.Equals((((a).dtor_signature).dtor_ECDSA).dtor_curve, software.amazon.cryptography.primitives.internaldafny.types.ECDSASignatureAlgorithm.create_ECDSA__P256()))) && (((a).dtor_commitment).is_None)) && (((a).dtor_symmetricSignature).is_None)) && (((a).dtor_edkWrapping).is_DIRECT__KEY__WRAPPING);
        } else if (_source0.is_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384) {
          return ((((((((((((a).dtor_binaryId).Equals(Dafny.Sequence<byte>.FromElements((byte)(3), (byte)(70)))) && (((a).dtor_messageVersion) == (1))) && (true)) && (((((a).dtor_encrypt).dtor_AES__GCM).dtor_keyLength) == (24))) && (((a).dtor_kdf).is_HKDF)) && (object.Equals((((a).dtor_kdf).dtor_HKDF).dtor_hmac, software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__384()))) && (((a).dtor_signature).is_ECDSA)) && (object.Equals((((a).dtor_signature).dtor_ECDSA).dtor_curve, software.amazon.cryptography.primitives.internaldafny.types.ECDSASignatureAlgorithm.create_ECDSA__P384()))) && (((a).dtor_commitment).is_None)) && (((a).dtor_symmetricSignature).is_None)) && (((a).dtor_edkWrapping).is_DIRECT__KEY__WRAPPING);
        } else if (_source0.is_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384) {
          return ((((((((((((a).dtor_binaryId).Equals(Dafny.Sequence<byte>.FromElements((byte)(3), (byte)(120)))) && (((a).dtor_messageVersion) == (1))) && (true)) && (((((a).dtor_encrypt).dtor_AES__GCM).dtor_keyLength) == (32))) && (((a).dtor_kdf).is_HKDF)) && (object.Equals((((a).dtor_kdf).dtor_HKDF).dtor_hmac, software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__384()))) && (((a).dtor_signature).is_ECDSA)) && (object.Equals((((a).dtor_signature).dtor_ECDSA).dtor_curve, software.amazon.cryptography.primitives.internaldafny.types.ECDSASignatureAlgorithm.create_ECDSA__P384()))) && (((a).dtor_commitment).is_None)) && (((a).dtor_symmetricSignature).is_None)) && (((a).dtor_edkWrapping).is_DIRECT__KEY__WRAPPING);
        } else if (_source0.is_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY) {
          return (((((((((((a).dtor_binaryId).Equals(Dafny.Sequence<byte>.FromElements((byte)(4), (byte)(120)))) && (((a).dtor_messageVersion) == (2))) && (true)) && (((((a).dtor_encrypt).dtor_AES__GCM).dtor_keyLength) == (32))) && (((a).dtor_kdf).is_HKDF)) && (object.Equals((((a).dtor_kdf).dtor_HKDF).dtor_hmac, software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__512()))) && (((a).dtor_signature).is_None)) && (((a).dtor_commitment).is_HKDF)) && (((a).dtor_symmetricSignature).is_None)) && (((a).dtor_edkWrapping).is_DIRECT__KEY__WRAPPING);
        } else {
          return ((((((((((((a).dtor_binaryId).Equals(Dafny.Sequence<byte>.FromElements((byte)(5), (byte)(120)))) && (((a).dtor_messageVersion) == (2))) && (true)) && (((((a).dtor_encrypt).dtor_AES__GCM).dtor_keyLength) == (32))) && (((a).dtor_kdf).is_HKDF)) && (object.Equals((((a).dtor_kdf).dtor_HKDF).dtor_hmac, software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__512()))) && (((a).dtor_signature).is_ECDSA)) && (object.Equals((((a).dtor_signature).dtor_ECDSA).dtor_curve, software.amazon.cryptography.primitives.internaldafny.types.ECDSASignatureAlgorithm.create_ECDSA__P384()))) && (((a).dtor_commitment).is_HKDF)) && (((a).dtor_symmetricSignature).is_None)) && (((a).dtor_edkWrapping).is_DIRECT__KEY__WRAPPING);
        }
      }))(((a).dtor_id).dtor_ESDK));
    }
    public static bool DBEAlgorithmSuite_q(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo a) {
      return (((AlgorithmSuites_Compile.__default.AlgorithmSuiteInfo_q(a)) && (AlgorithmSuites_Compile.__default.SupportedDBEEncrypt_q((a).dtor_encrypt))) && (AlgorithmSuites_Compile.__default.SupportedDBEEDKWrapping_q((a).dtor_edkWrapping))) && (((System.Func<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId, bool>)((_source1) => {
        if (_source1.is_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__SYMSIG__HMAC__SHA384) {
          return ((((((((((((((a).dtor_binaryId).Equals(Dafny.Sequence<byte>.FromElements((byte)(103), (byte)(0)))) && (((a).dtor_messageVersion) == (1))) && (true)) && (((((a).dtor_encrypt).dtor_AES__GCM).dtor_keyLength) == (32))) && (((a).dtor_kdf).is_HKDF)) && (object.Equals((((a).dtor_kdf).dtor_HKDF).dtor_hmac, software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__512()))) && (((a).dtor_signature).is_None)) && (((a).dtor_commitment).is_HKDF)) && (((a).dtor_symmetricSignature).is_HMAC)) && (object.Equals(((a).dtor_symmetricSignature).dtor_HMAC, software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__384()))) && (((a).dtor_edkWrapping).is_IntermediateKeyWrapping)) && (true)) && (((((((a).dtor_edkWrapping).dtor_IntermediateKeyWrapping).dtor_pdkEncryptAlgorithm).dtor_AES__GCM).dtor_keyLength) == (32));
        } else {
          return (((((((((((((((a).dtor_binaryId).Equals(Dafny.Sequence<byte>.FromElements((byte)(103), (byte)(1)))) && (((a).dtor_messageVersion) == (1))) && (true)) && (((((a).dtor_encrypt).dtor_AES__GCM).dtor_keyLength) == (32))) && (((a).dtor_kdf).is_HKDF)) && (object.Equals((((a).dtor_kdf).dtor_HKDF).dtor_hmac, software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__512()))) && (((a).dtor_signature).is_ECDSA)) && (object.Equals((((a).dtor_signature).dtor_ECDSA).dtor_curve, software.amazon.cryptography.primitives.internaldafny.types.ECDSASignatureAlgorithm.create_ECDSA__P384()))) && (((a).dtor_commitment).is_HKDF)) && (((a).dtor_symmetricSignature).is_HMAC)) && (object.Equals(((a).dtor_symmetricSignature).dtor_HMAC, software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__384()))) && (((a).dtor_edkWrapping).is_IntermediateKeyWrapping)) && (true)) && (((((((a).dtor_edkWrapping).dtor_IntermediateKeyWrapping).dtor_pdkEncryptAlgorithm).dtor_AES__GCM).dtor_keyLength) == (32));
        }
      }))(((a).dtor_id).dtor_DBE));
    }
    public static bool AlgorithmSuite_q(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo a) {
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId _source2 = (a).dtor_id;
      if (_source2.is_ESDK) {
        software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId _0___mcc_h0 = _source2.dtor_ESDK;
        return AlgorithmSuites_Compile.__default.ESDKAlgorithmSuite_q(a);
      } else {
        software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId _1___mcc_h1 = _source2.dtor_DBE;
        return AlgorithmSuites_Compile.__default.DBEAlgorithmSuite_q(a);
      }
    }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm HKDF__SHA__256(int keyLength) {
      return software.amazon.cryptography.materialproviders.internaldafny.types.DerivationAlgorithm.create_HKDF(software.amazon.cryptography.materialproviders.internaldafny.types.HKDF.create(software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__256(), (int)(0), keyLength, keyLength));
    }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm HKDF__SHA__384(int keyLength) {
      return software.amazon.cryptography.materialproviders.internaldafny.types.DerivationAlgorithm.create_HKDF(software.amazon.cryptography.materialproviders.internaldafny.types.HKDF.create(software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__384(), (int)(0), keyLength, keyLength));
    }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IDerivationAlgorithm HKDF__SHA__512(int keyLength) {
      return software.amazon.cryptography.materialproviders.internaldafny.types.DerivationAlgorithm.create_HKDF(software.amazon.cryptography.materialproviders.internaldafny.types.HKDF.create(software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__512(), (int)(32), keyLength, keyLength));
    }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo GetSuite(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId id) {
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId _source3 = id;
      if (_source3.is_ESDK) {
        software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId _2___mcc_h0 = _source3.dtor_ESDK;
        software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId _3_e = _2___mcc_h0;
        return AlgorithmSuites_Compile.__default.GetESDKSuite(_3_e);
      } else {
        software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId _4___mcc_h1 = _source3.dtor_DBE;
        software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId _5_e = _4___mcc_h1;
        return AlgorithmSuites_Compile.__default.GetDBESuite(_5_e);
      }
    }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo GetDBESuite(software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId id) {
      return Dafny.Map<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>.Select(AlgorithmSuites_Compile.__default.SupportedDBEAlgorithmSuites,id);
    }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo GetESDKSuite(software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId id) {
      return Dafny.Map<software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>.Select(AlgorithmSuites_Compile.__default.SupportedESDKAlgorithmSuites,id);
    }
    public static int GetEncryptKeyLength(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo a) {
      software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt _source4 = (a).dtor_encrypt;
      {
        software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM _6___mcc_h0 = _source4.dtor_AES__GCM;
        software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM _7_e = _6___mcc_h0;
        return (_7_e).dtor_keyLength;
      }
    }
    public static int GetEncryptTagLength(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo a) {
      software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt _source5 = (a).dtor_encrypt;
      {
        software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM _8___mcc_h0 = _source5.dtor_AES__GCM;
        software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM _9_e = _8___mcc_h0;
        return (_9_e).dtor_tagLength;
      }
    }
    public static int GetEncryptIvLength(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo a) {
      software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt _source6 = (a).dtor_encrypt;
      {
        software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM _10___mcc_h0 = _source6.dtor_AES__GCM;
        software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM _11_e = _10___mcc_h0;
        return (_11_e).dtor_ivLength;
      }
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetAlgorithmSuiteInfo(Dafny.ISequence<byte> binaryId_q) {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _12_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((AlgorithmSuites_Compile.__default.AlgorithmSuiteInfoByBinaryId).Contains(binaryId_q), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Invalid BinaryId")));
      if ((_12_valueOrError0).IsFailure()) {
        return (_12_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>();
      } else {
        return Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(Dafny.Map<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>.Select(AlgorithmSuites_Compile.__default.AlgorithmSuiteInfoByBinaryId,binaryId_q));
      }
    }
    public static int Bits128 { get {
      return (int)(16);
    } }
    public static int TagLen { get {
      return (int)(16);
    } }
    public static int IvLen { get {
      return (int)(12);
    } }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt AES__128__GCM__IV12__TAG16 { get {
      return software.amazon.cryptography.materialproviders.internaldafny.types.Encrypt.create(software.amazon.cryptography.primitives.internaldafny.types.AES__GCM.create(AlgorithmSuites_Compile.__default.Bits128, AlgorithmSuites_Compile.__default.TagLen, AlgorithmSuites_Compile.__default.IvLen));
    } }
    public static int Bits192 { get {
      return (int)(24);
    } }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt AES__192__GCM__IV12__TAG16 { get {
      return software.amazon.cryptography.materialproviders.internaldafny.types.Encrypt.create(software.amazon.cryptography.primitives.internaldafny.types.AES__GCM.create(AlgorithmSuites_Compile.__default.Bits192, AlgorithmSuites_Compile.__default.TagLen, AlgorithmSuites_Compile.__default.IvLen));
    } }
    public static int Bits256 { get {
      return (int)(32);
    } }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IEncrypt AES__256__GCM__IV12__TAG16 { get {
      return software.amazon.cryptography.materialproviders.internaldafny.types.Encrypt.create(software.amazon.cryptography.primitives.internaldafny.types.AES__GCM.create(AlgorithmSuites_Compile.__default.Bits256, AlgorithmSuites_Compile.__default.TagLen, AlgorithmSuites_Compile.__default.IvLen));
    } }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IEdkWrappingAlgorithm EDK__INTERMEDIATE__WRAPPING__AES__GCM__256__HKDF__SHA__512 { get {
      return software.amazon.cryptography.materialproviders.internaldafny.types.EdkWrappingAlgorithm.create_IntermediateKeyWrapping(software.amazon.cryptography.materialproviders.internaldafny.types.IntermediateKeyWrapping.create(AlgorithmSuites_Compile.__default.HKDF__SHA__512(AlgorithmSuites_Compile.__default.Bits256), AlgorithmSuites_Compile.__default.HKDF__SHA__512(AlgorithmSuites_Compile.__default.Bits256), AlgorithmSuites_Compile.__default.AES__256__GCM__IV12__TAG16));
    } }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo DBE__ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__SYMSIG__HMAC__SHA384 { get {
      return software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteInfo.create(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.create_DBE(software.amazon.cryptography.materialproviders.internaldafny.types.DBEAlgorithmSuiteId.create_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__SYMSIG__HMAC__SHA384()), Dafny.Sequence<byte>.FromElements((byte)(103), (byte)(0)), 1, AlgorithmSuites_Compile.__default.AES__256__GCM__IV12__TAG16, AlgorithmSuites_Compile.__default.HKDF__SHA__512(AlgorithmSuites_Compile.__default.Bits256), AlgorithmSuites_Compile.__default.HKDF__SHA__512(AlgorithmSuites_Compile.__default.Bits256), software.amazon.cryptography.materialproviders.internaldafny.types.SignatureAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.SymmetricSignatureAlgorithm.create_HMAC(software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__384()), AlgorithmSuites_Compile.__default.EDK__INTERMEDIATE__WRAPPING__AES__GCM__256__HKDF__SHA__512);
    } }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo DBE__ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384__SYMSIG__HMAC__SHA384 { get {
      return software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteInfo.create(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.create_DBE(software.amazon.cryptography.materialproviders.internaldafny.types.DBEAlgorithmSuiteId.create_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384__SYMSIG__HMAC__SHA384()), Dafny.Sequence<byte>.FromElements((byte)(103), (byte)(1)), 1, AlgorithmSuites_Compile.__default.AES__256__GCM__IV12__TAG16, AlgorithmSuites_Compile.__default.HKDF__SHA__512(AlgorithmSuites_Compile.__default.Bits256), AlgorithmSuites_Compile.__default.HKDF__SHA__512(AlgorithmSuites_Compile.__default.Bits256), software.amazon.cryptography.materialproviders.internaldafny.types.SignatureAlgorithm.create_ECDSA(software.amazon.cryptography.materialproviders.internaldafny.types.ECDSA.create(software.amazon.cryptography.primitives.internaldafny.types.ECDSASignatureAlgorithm.create_ECDSA__P384())), software.amazon.cryptography.materialproviders.internaldafny.types.SymmetricSignatureAlgorithm.create_HMAC(software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__384()), AlgorithmSuites_Compile.__default.EDK__INTERMEDIATE__WRAPPING__AES__GCM__256__HKDF__SHA__512);
    } }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo ESDK__ALG__AES__128__GCM__IV12__TAG16__NO__KDF { get {
      return software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteInfo.create(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.create_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__128__GCM__IV12__TAG16__NO__KDF()), Dafny.Sequence<byte>.FromElements((byte)(0), (byte)(20)), 1, AlgorithmSuites_Compile.__default.AES__128__GCM__IV12__TAG16, software.amazon.cryptography.materialproviders.internaldafny.types.DerivationAlgorithm.create_IDENTITY(software.amazon.cryptography.materialproviders.internaldafny.types.IDENTITY.create()), software.amazon.cryptography.materialproviders.internaldafny.types.DerivationAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.SignatureAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.SymmetricSignatureAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.EdkWrappingAlgorithm.create_DIRECT__KEY__WRAPPING(software.amazon.cryptography.materialproviders.internaldafny.types.DIRECT__KEY__WRAPPING.create()));
    } }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo ESDK__ALG__AES__192__GCM__IV12__TAG16__NO__KDF { get {
      return software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteInfo.create(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.create_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__192__GCM__IV12__TAG16__NO__KDF()), Dafny.Sequence<byte>.FromElements((byte)(0), (byte)(70)), 1, AlgorithmSuites_Compile.__default.AES__192__GCM__IV12__TAG16, software.amazon.cryptography.materialproviders.internaldafny.types.DerivationAlgorithm.create_IDENTITY(software.amazon.cryptography.materialproviders.internaldafny.types.IDENTITY.create()), software.amazon.cryptography.materialproviders.internaldafny.types.DerivationAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.SignatureAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.SymmetricSignatureAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.EdkWrappingAlgorithm.create_DIRECT__KEY__WRAPPING(software.amazon.cryptography.materialproviders.internaldafny.types.DIRECT__KEY__WRAPPING.create()));
    } }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo ESDK__ALG__AES__256__GCM__IV12__TAG16__NO__KDF { get {
      return software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteInfo.create(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.create_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__NO__KDF()), Dafny.Sequence<byte>.FromElements((byte)(0), (byte)(120)), 1, AlgorithmSuites_Compile.__default.AES__256__GCM__IV12__TAG16, software.amazon.cryptography.materialproviders.internaldafny.types.DerivationAlgorithm.create_IDENTITY(software.amazon.cryptography.materialproviders.internaldafny.types.IDENTITY.create()), software.amazon.cryptography.materialproviders.internaldafny.types.DerivationAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.SignatureAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.SymmetricSignatureAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.EdkWrappingAlgorithm.create_DIRECT__KEY__WRAPPING(software.amazon.cryptography.materialproviders.internaldafny.types.DIRECT__KEY__WRAPPING.create()));
    } }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo ESDK__ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256 { get {
      return software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteInfo.create(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.create_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256()), Dafny.Sequence<byte>.FromElements((byte)(1), (byte)(20)), 1, AlgorithmSuites_Compile.__default.AES__128__GCM__IV12__TAG16, AlgorithmSuites_Compile.__default.HKDF__SHA__256(AlgorithmSuites_Compile.__default.Bits128), software.amazon.cryptography.materialproviders.internaldafny.types.DerivationAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.SignatureAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.SymmetricSignatureAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.EdkWrappingAlgorithm.create_DIRECT__KEY__WRAPPING(software.amazon.cryptography.materialproviders.internaldafny.types.DIRECT__KEY__WRAPPING.create()));
    } }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo ESDK__ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256 { get {
      return software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteInfo.create(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.create_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256()), Dafny.Sequence<byte>.FromElements((byte)(1), (byte)(70)), 1, AlgorithmSuites_Compile.__default.AES__192__GCM__IV12__TAG16, AlgorithmSuites_Compile.__default.HKDF__SHA__256(AlgorithmSuites_Compile.__default.Bits192), software.amazon.cryptography.materialproviders.internaldafny.types.DerivationAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.SignatureAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.SymmetricSignatureAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.EdkWrappingAlgorithm.create_DIRECT__KEY__WRAPPING(software.amazon.cryptography.materialproviders.internaldafny.types.DIRECT__KEY__WRAPPING.create()));
    } }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo ESDK__ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256 { get {
      return software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteInfo.create(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.create_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256()), Dafny.Sequence<byte>.FromElements((byte)(1), (byte)(120)), 1, AlgorithmSuites_Compile.__default.AES__256__GCM__IV12__TAG16, AlgorithmSuites_Compile.__default.HKDF__SHA__256(AlgorithmSuites_Compile.__default.Bits256), software.amazon.cryptography.materialproviders.internaldafny.types.DerivationAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.SignatureAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.SymmetricSignatureAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.EdkWrappingAlgorithm.create_DIRECT__KEY__WRAPPING(software.amazon.cryptography.materialproviders.internaldafny.types.DIRECT__KEY__WRAPPING.create()));
    } }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo ESDK__ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256 { get {
      return software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteInfo.create(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.create_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256()), Dafny.Sequence<byte>.FromElements((byte)(2), (byte)(20)), 1, AlgorithmSuites_Compile.__default.AES__128__GCM__IV12__TAG16, AlgorithmSuites_Compile.__default.HKDF__SHA__256(AlgorithmSuites_Compile.__default.Bits128), software.amazon.cryptography.materialproviders.internaldafny.types.DerivationAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.SignatureAlgorithm.create_ECDSA(software.amazon.cryptography.materialproviders.internaldafny.types.ECDSA.create(software.amazon.cryptography.primitives.internaldafny.types.ECDSASignatureAlgorithm.create_ECDSA__P256())), software.amazon.cryptography.materialproviders.internaldafny.types.SymmetricSignatureAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.EdkWrappingAlgorithm.create_DIRECT__KEY__WRAPPING(software.amazon.cryptography.materialproviders.internaldafny.types.DIRECT__KEY__WRAPPING.create()));
    } }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo ESDK__ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384 { get {
      return software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteInfo.create(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.create_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384()), Dafny.Sequence<byte>.FromElements((byte)(3), (byte)(70)), 1, AlgorithmSuites_Compile.__default.AES__192__GCM__IV12__TAG16, AlgorithmSuites_Compile.__default.HKDF__SHA__384(AlgorithmSuites_Compile.__default.Bits192), software.amazon.cryptography.materialproviders.internaldafny.types.DerivationAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.SignatureAlgorithm.create_ECDSA(software.amazon.cryptography.materialproviders.internaldafny.types.ECDSA.create(software.amazon.cryptography.primitives.internaldafny.types.ECDSASignatureAlgorithm.create_ECDSA__P384())), software.amazon.cryptography.materialproviders.internaldafny.types.SymmetricSignatureAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.EdkWrappingAlgorithm.create_DIRECT__KEY__WRAPPING(software.amazon.cryptography.materialproviders.internaldafny.types.DIRECT__KEY__WRAPPING.create()));
    } }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo ESDK__ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384 { get {
      return software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteInfo.create(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.create_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384()), Dafny.Sequence<byte>.FromElements((byte)(3), (byte)(120)), 1, AlgorithmSuites_Compile.__default.AES__256__GCM__IV12__TAG16, AlgorithmSuites_Compile.__default.HKDF__SHA__384(AlgorithmSuites_Compile.__default.Bits256), software.amazon.cryptography.materialproviders.internaldafny.types.DerivationAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.SignatureAlgorithm.create_ECDSA(software.amazon.cryptography.materialproviders.internaldafny.types.ECDSA.create(software.amazon.cryptography.primitives.internaldafny.types.ECDSASignatureAlgorithm.create_ECDSA__P384())), software.amazon.cryptography.materialproviders.internaldafny.types.SymmetricSignatureAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.EdkWrappingAlgorithm.create_DIRECT__KEY__WRAPPING(software.amazon.cryptography.materialproviders.internaldafny.types.DIRECT__KEY__WRAPPING.create()));
    } }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo ESDK__ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY { get {
      return software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteInfo.create(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.create_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY()), Dafny.Sequence<byte>.FromElements((byte)(4), (byte)(120)), 2, AlgorithmSuites_Compile.__default.AES__256__GCM__IV12__TAG16, AlgorithmSuites_Compile.__default.HKDF__SHA__512(AlgorithmSuites_Compile.__default.Bits256), AlgorithmSuites_Compile.__default.HKDF__SHA__512(AlgorithmSuites_Compile.__default.Bits256), software.amazon.cryptography.materialproviders.internaldafny.types.SignatureAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.SymmetricSignatureAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.EdkWrappingAlgorithm.create_DIRECT__KEY__WRAPPING(software.amazon.cryptography.materialproviders.internaldafny.types.DIRECT__KEY__WRAPPING.create()));
    } }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo ESDK__ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384 { get {
      return software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteInfo.create(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.create_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384()), Dafny.Sequence<byte>.FromElements((byte)(5), (byte)(120)), 2, AlgorithmSuites_Compile.__default.AES__256__GCM__IV12__TAG16, AlgorithmSuites_Compile.__default.HKDF__SHA__512(AlgorithmSuites_Compile.__default.Bits256), AlgorithmSuites_Compile.__default.HKDF__SHA__512(AlgorithmSuites_Compile.__default.Bits256), software.amazon.cryptography.materialproviders.internaldafny.types.SignatureAlgorithm.create_ECDSA(software.amazon.cryptography.materialproviders.internaldafny.types.ECDSA.create(software.amazon.cryptography.primitives.internaldafny.types.ECDSASignatureAlgorithm.create_ECDSA__P384())), software.amazon.cryptography.materialproviders.internaldafny.types.SymmetricSignatureAlgorithm.create_None(software.amazon.cryptography.materialproviders.internaldafny.types.None.create()), software.amazon.cryptography.materialproviders.internaldafny.types.EdkWrappingAlgorithm.create_DIRECT__KEY__WRAPPING(software.amazon.cryptography.materialproviders.internaldafny.types.DIRECT__KEY__WRAPPING.create()));
    } }
    public static Dafny.IMap<software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId,software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo> SupportedESDKAlgorithmSuites { get {
      return Dafny.Map<software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>.FromElements(new Dafny.Pair<software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__128__GCM__IV12__TAG16__NO__KDF(), AlgorithmSuites_Compile.__default.ESDK__ALG__AES__128__GCM__IV12__TAG16__NO__KDF), new Dafny.Pair<software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__192__GCM__IV12__TAG16__NO__KDF(), AlgorithmSuites_Compile.__default.ESDK__ALG__AES__192__GCM__IV12__TAG16__NO__KDF), new Dafny.Pair<software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__NO__KDF(), AlgorithmSuites_Compile.__default.ESDK__ALG__AES__256__GCM__IV12__TAG16__NO__KDF), new Dafny.Pair<software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256(), AlgorithmSuites_Compile.__default.ESDK__ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256), new Dafny.Pair<software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256(), AlgorithmSuites_Compile.__default.ESDK__ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256), new Dafny.Pair<software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256(), AlgorithmSuites_Compile.__default.ESDK__ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256), new Dafny.Pair<software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256(), AlgorithmSuites_Compile.__default.ESDK__ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256), new Dafny.Pair<software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384(), AlgorithmSuites_Compile.__default.ESDK__ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384), new Dafny.Pair<software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384(), AlgorithmSuites_Compile.__default.ESDK__ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384), new Dafny.Pair<software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY(), AlgorithmSuites_Compile.__default.ESDK__ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY), new Dafny.Pair<software.amazon.cryptography.materialproviders.internaldafny.types._IESDKAlgorithmSuiteId, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384(), AlgorithmSuites_Compile.__default.ESDK__ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384));
    } }
    public static Dafny.IMap<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId,software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo> SupportedDBEAlgorithmSuites { get {
      return Dafny.Map<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>.FromElements(new Dafny.Pair<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(software.amazon.cryptography.materialproviders.internaldafny.types.DBEAlgorithmSuiteId.create_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__SYMSIG__HMAC__SHA384(), AlgorithmSuites_Compile.__default.DBE__ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__SYMSIG__HMAC__SHA384), new Dafny.Pair<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(software.amazon.cryptography.materialproviders.internaldafny.types.DBEAlgorithmSuiteId.create_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384__SYMSIG__HMAC__SHA384(), AlgorithmSuites_Compile.__default.DBE__ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384__SYMSIG__HMAC__SHA384));
    } }
    public static Dafny.IMap<Dafny.ISequence<byte>,software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo> AlgorithmSuiteInfoByBinaryId { get {
      return Dafny.Map<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(Dafny.Sequence<byte>.FromElements((byte)(0), (byte)(20)), AlgorithmSuites_Compile.__default.ESDK__ALG__AES__128__GCM__IV12__TAG16__NO__KDF), new Dafny.Pair<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(Dafny.Sequence<byte>.FromElements((byte)(0), (byte)(70)), AlgorithmSuites_Compile.__default.ESDK__ALG__AES__192__GCM__IV12__TAG16__NO__KDF), new Dafny.Pair<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(Dafny.Sequence<byte>.FromElements((byte)(0), (byte)(120)), AlgorithmSuites_Compile.__default.ESDK__ALG__AES__256__GCM__IV12__TAG16__NO__KDF), new Dafny.Pair<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(Dafny.Sequence<byte>.FromElements((byte)(1), (byte)(20)), AlgorithmSuites_Compile.__default.ESDK__ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256), new Dafny.Pair<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(Dafny.Sequence<byte>.FromElements((byte)(1), (byte)(70)), AlgorithmSuites_Compile.__default.ESDK__ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA256), new Dafny.Pair<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(Dafny.Sequence<byte>.FromElements((byte)(1), (byte)(120)), AlgorithmSuites_Compile.__default.ESDK__ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA256), new Dafny.Pair<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(Dafny.Sequence<byte>.FromElements((byte)(2), (byte)(20)), AlgorithmSuites_Compile.__default.ESDK__ALG__AES__128__GCM__IV12__TAG16__HKDF__SHA256__ECDSA__P256), new Dafny.Pair<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(Dafny.Sequence<byte>.FromElements((byte)(3), (byte)(70)), AlgorithmSuites_Compile.__default.ESDK__ALG__AES__192__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384), new Dafny.Pair<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(Dafny.Sequence<byte>.FromElements((byte)(3), (byte)(120)), AlgorithmSuites_Compile.__default.ESDK__ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384), new Dafny.Pair<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(Dafny.Sequence<byte>.FromElements((byte)(4), (byte)(120)), AlgorithmSuites_Compile.__default.ESDK__ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY), new Dafny.Pair<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(Dafny.Sequence<byte>.FromElements((byte)(5), (byte)(120)), AlgorithmSuites_Compile.__default.ESDK__ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384), new Dafny.Pair<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(Dafny.Sequence<byte>.FromElements((byte)(103), (byte)(0)), AlgorithmSuites_Compile.__default.DBE__ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__SYMSIG__HMAC__SHA384), new Dafny.Pair<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>(Dafny.Sequence<byte>.FromElements((byte)(103), (byte)(1)), AlgorithmSuites_Compile.__default.DBE__ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384__SYMSIG__HMAC__SHA384));
    } }
  }
} // end of namespace AlgorithmSuites_Compile
namespace Materials_Compile {

  public partial class DecryptionMaterialsPendingPlaintextDataKey {
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>(software.amazon.cryptography.materialproviders.internaldafny.types.DecryptionMaterials.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class SealedDecryptionMaterials {
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>(software.amazon.cryptography.materialproviders.internaldafny.types.DecryptionMaterials.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> InitializeEncryptionMaterials(software.amazon.cryptography.materialproviders.internaldafny.types._IInitializeEncryptionMaterialsInput input) {
      var _pat_let_tv0 = input;
      var _pat_let_tv1 = input;
      var _pat_let_tv2 = input;
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _13_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(!((input).dtor_encryptionContext).Contains(Materials_Compile.__default.EC__PUBLIC__KEY__FIELD), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Encryption Context ")));
      if ((_13_valueOrError0).IsFailure()) {
        return (_13_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials>();
      } else {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _14_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Dafny.Helpers.Id<Func<software.amazon.cryptography.materialproviders.internaldafny.types._IInitializeEncryptionMaterialsInput, bool>>((_15_input) => Dafny.Helpers.Quantifier<Dafny.ISequence<byte>>(((_15_input).dtor_requiredEncryptionContextKeys).UniqueElements, true, (((_forall_var_0) => {
          Dafny.ISequence<byte> _16_key = (Dafny.ISequence<byte>)_forall_var_0;
          return !(((_15_input).dtor_requiredEncryptionContextKeys).Contains(_16_key)) || (((_15_input).dtor_encryptionContext).Contains(_16_key));
        }))))(input), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Required encryption context keys do not exist in provided encryption context.")));
        if ((_14_valueOrError1).IsFailure()) {
          return (_14_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials>();
        } else {
          software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _17_suite = AlgorithmSuites_Compile.__default.GetSuite((input).dtor_algorithmSuiteId);
          Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _18_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((_17_suite).dtor_signature).is_ECDSA) == ((((input).dtor_signingKey).is_Some) && (((input).dtor_verificationKey).is_Some)), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Missing signature key for signed suite.")));
          if ((_18_valueOrError2).IsFailure()) {
            return (_18_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials>();
          } else {
            Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _19_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((_17_suite).dtor_signature).is_None) == ((((input).dtor_signingKey).is_None) && (((input).dtor_verificationKey).is_None)), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Signature key not allowed for non-signed suites.")));
            if ((_19_valueOrError3).IsFailure()) {
              return (_19_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials>();
            } else {
              Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _20_valueOrError4 = ((System.Func<software.amazon.cryptography.materialproviders.internaldafny.types._ISignatureAlgorithm, Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>)((_source7) => {
                if (_source7.is_ECDSA) {
                  software.amazon.cryptography.materialproviders.internaldafny.types._IECDSA _21___mcc_h0 = _source7.dtor_ECDSA;
                  return Dafny.Helpers.Let<software.amazon.cryptography.materialproviders.internaldafny.types._IECDSA, Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>(_21___mcc_h0, _pat_let0_0 => Dafny.Helpers.Let<software.amazon.cryptography.materialproviders.internaldafny.types._IECDSA, Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>(_pat_let0_0, _22_curve => Dafny.Helpers.Let<Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>(Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.Encode(Base64_Compile.__default.Encode(((_pat_let_tv0).dtor_verificationKey).dtor_value)), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_23_e) => {
                    return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(_23_e);
                  }))), _pat_let1_0 => Dafny.Helpers.Let<Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>(_pat_let1_0, _24_valueOrError5 => (((_24_valueOrError5).IsFailure()) ? ((_24_valueOrError5).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>()) : (Dafny.Helpers.Let<Dafny.ISequence<byte>, Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>((_24_valueOrError5).Extract(), _pat_let2_0 => Dafny.Helpers.Let<Dafny.ISequence<byte>, Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>(_pat_let2_0, _25_enc__vk => Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Update((_pat_let_tv1).dtor_encryptionContext, Materials_Compile.__default.EC__PUBLIC__KEY__FIELD, _25_enc__vk))))))))));
                } else {
                  software.amazon.cryptography.materialproviders.internaldafny.types._INone _26___mcc_h2 = _source7.dtor_None;
                  return Dafny.Helpers.Let<software.amazon.cryptography.materialproviders.internaldafny.types._ISignatureAlgorithm, Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>((_17_suite).dtor_signature, _pat_let3_0 => Dafny.Helpers.Let<software.amazon.cryptography.materialproviders.internaldafny.types._ISignatureAlgorithm, Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>(_pat_let3_0, _27_None => Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success((_pat_let_tv2).dtor_encryptionContext)));
                }
              }))((_17_suite).dtor_signature);
              if ((_20_valueOrError4).IsFailure()) {
                return (_20_valueOrError4).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials>();
              } else {
                Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _28_encryptionContext = (_20_valueOrError4).Extract();
                return Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.EncryptionMaterials.create(_17_suite, _28_encryptionContext, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.FromElements(), (input).dtor_requiredEncryptionContextKeys, Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), (input).dtor_signingKey, ((((_17_suite).dtor_symmetricSignature).is_None) ? (Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.create_None()) : (Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.create_Some(Dafny.Sequence<Dafny.ISequence<byte>>.FromElements())))));
              }
            }
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> InitializeDecryptionMaterials(software.amazon.cryptography.materialproviders.internaldafny.types._IInitializeDecryptionMaterialsInput input) {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _29_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Dafny.Helpers.Id<Func<software.amazon.cryptography.materialproviders.internaldafny.types._IInitializeDecryptionMaterialsInput, bool>>((_30_input) => Dafny.Helpers.Quantifier<Dafny.ISequence<byte>>(((_30_input).dtor_requiredEncryptionContextKeys).UniqueElements, true, (((_forall_var_1) => {
        Dafny.ISequence<byte> _31_key = (Dafny.ISequence<byte>)_forall_var_1;
        return !(((_30_input).dtor_requiredEncryptionContextKeys).Contains(_31_key)) || (((_30_input).dtor_encryptionContext).Contains(_31_key));
      }))))(input), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Reporoduced encryption context key did not exist in provided encryption context.")));
      if ((_29_valueOrError0).IsFailure()) {
        return (_29_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
      } else {
        software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _32_suite = AlgorithmSuites_Compile.__default.GetSuite((input).dtor_algorithmSuiteId);
        Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _33_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((_32_suite).dtor_signature).is_ECDSA) == (((input).dtor_encryptionContext).Contains(Materials_Compile.__default.EC__PUBLIC__KEY__FIELD)), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Encryption Context missing verification key.")));
        if ((_33_valueOrError1).IsFailure()) {
          return (_33_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        } else {
          Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _34_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((_32_suite).dtor_signature).is_None) == (!((input).dtor_encryptionContext).Contains(Materials_Compile.__default.EC__PUBLIC__KEY__FIELD)), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Verification key can not exist in non-signed Algorithm Suites.")));
          if ((_34_valueOrError2).IsFailure()) {
            return (_34_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
          } else {
            Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _35_valueOrError3 = Materials_Compile.__default.DecodeVerificationKey((input).dtor_encryptionContext);
            if ((_35_valueOrError3).IsFailure()) {
              return (_35_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
            } else {
              Wrappers_Compile._IOption<Dafny.ISequence<byte>> _36_verificationKey = (_35_valueOrError3).Extract();
              return Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.DecryptionMaterials.create(_32_suite, (input).dtor_encryptionContext, (input).dtor_requiredEncryptionContextKeys, Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), _36_verificationKey, Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None()));
            }
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> DecodeVerificationKey(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      if ((encryptionContext).Contains(Materials_Compile.__default.EC__PUBLIC__KEY__FIELD)) {
        Dafny.ISequence<byte> _37_utf8Key = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(encryptionContext,Materials_Compile.__default.EC__PUBLIC__KEY__FIELD);
        Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _38_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.Decode(_37_utf8Key), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_39_e) => {
          return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(_39_e);
        })));
        if ((_38_valueOrError0).IsFailure()) {
          return (_38_valueOrError0).PropagateFailure<Wrappers_Compile._IOption<Dafny.ISequence<byte>>>();
        } else {
          Dafny.ISequence<char> _40_base64Key = (_38_valueOrError0).Extract();
          Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _41_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Base64_Compile.__default.Decode(_40_base64Key), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_42_e) => {
            return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(_42_e);
          })));
          if ((_41_valueOrError1).IsFailure()) {
            return (_41_valueOrError1).PropagateFailure<Wrappers_Compile._IOption<Dafny.ISequence<byte>>>();
          } else {
            Dafny.ISequence<byte> _43_key = (_41_valueOrError1).Extract();
            return Wrappers_Compile.Result<Wrappers_Compile._IOption<Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_43_key));
          }
        }
      } else {
        return Wrappers_Compile.Result<Wrappers_Compile._IOption<Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None());
      }
    }
    public static bool ValidEncryptionMaterialsTransition(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials oldMat, software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials newMat)
    {
      return ((((((((((object.Equals((newMat).dtor_algorithmSuite, (oldMat).dtor_algorithmSuite)) && (((newMat).dtor_encryptionContext).Equals((oldMat).dtor_encryptionContext))) && (((newMat).dtor_requiredEncryptionContextKeys).Equals((oldMat).dtor_requiredEncryptionContextKeys))) && (object.Equals((newMat).dtor_signingKey, (oldMat).dtor_signingKey))) && (((((oldMat).dtor_plaintextDataKey).is_None) && (((newMat).dtor_plaintextDataKey).is_Some)) || (object.Equals((oldMat).dtor_plaintextDataKey, (newMat).dtor_plaintextDataKey)))) && (((newMat).dtor_plaintextDataKey).is_Some)) && ((new BigInteger(((oldMat).dtor_encryptedDataKeys).Count)) <= (new BigInteger(((newMat).dtor_encryptedDataKeys).Count)))) && (Dafny.MultiSet<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.IsSubsetOf(Dafny.MultiSet<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.FromSeq((oldMat).dtor_encryptedDataKeys), Dafny.MultiSet<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.FromSeq((newMat).dtor_encryptedDataKeys)))) && (!(!((((oldMat).dtor_algorithmSuite).dtor_symmetricSignature).is_None)) || (((((newMat).dtor_symmetricSigningKeys).is_Some) && (((oldMat).dtor_symmetricSigningKeys).is_Some)) && (Dafny.MultiSet<Dafny.ISequence<byte>>.IsSubsetOf(Dafny.MultiSet<Dafny.ISequence<byte>>.FromSeq(((oldMat).dtor_symmetricSigningKeys).dtor_value), Dafny.MultiSet<Dafny.ISequence<byte>>.FromSeq(((newMat).dtor_symmetricSigningKeys).dtor_value)))))) && (Materials_Compile.__default.ValidEncryptionMaterials(oldMat))) && (Materials_Compile.__default.ValidEncryptionMaterials(newMat));
    }
    public static bool ValidEncryptionMaterials(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials encryptionMaterials) {
      var _pat_let_tv3 = encryptionMaterials;
      var _pat_let_tv4 = encryptionMaterials;
      var _pat_let_tv5 = encryptionMaterials;
      var _pat_let_tv6 = encryptionMaterials;
      var _pat_let_tv7 = encryptionMaterials;
      var _pat_let_tv8 = encryptionMaterials;
      var _pat_let_tv9 = encryptionMaterials;
      var _pat_let_tv10 = encryptionMaterials;
      var _pat_let_tv11 = encryptionMaterials;
      var _pat_let_tv12 = encryptionMaterials;
      var _pat_let_tv13 = encryptionMaterials;
      var _pat_let_tv14 = encryptionMaterials;
      var _pat_let_tv15 = encryptionMaterials;
      var _pat_let_tv16 = encryptionMaterials;
      return (AlgorithmSuites_Compile.__default.AlgorithmSuite_q((encryptionMaterials).dtor_algorithmSuite)) && (Dafny.Helpers.Let<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo, bool>((encryptionMaterials).dtor_algorithmSuite, _pat_let4_0 => Dafny.Helpers.Let<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo, bool>(_pat_let4_0, _44_suite => ((((((((((((_44_suite).dtor_signature).is_None) == (((_pat_let_tv3).dtor_signingKey).is_None)) && (!(((_pat_let_tv4).dtor_plaintextDataKey).is_Some) || ((new BigInteger(AlgorithmSuites_Compile.__default.GetEncryptKeyLength(_44_suite))) == (new BigInteger((((_pat_let_tv5).dtor_plaintextDataKey).dtor_value).Count))))) && (!(((_pat_let_tv6).dtor_plaintextDataKey).is_None) || ((new BigInteger(((_pat_let_tv7).dtor_encryptedDataKeys).Count)).Sign == 0))) && ((!(((_44_suite).dtor_signature).is_None)) == (((_pat_let_tv8).dtor_encryptionContext).Contains(Materials_Compile.__default.EC__PUBLIC__KEY__FIELD)))) && ((((_44_suite).dtor_signature).is_ECDSA) == (((_pat_let_tv9).dtor_signingKey).is_Some))) && ((!(((_44_suite).dtor_signature).is_None)) == (((_pat_let_tv10).dtor_encryptionContext).Contains(Materials_Compile.__default.EC__PUBLIC__KEY__FIELD)))) && (!((((_44_suite).dtor_symmetricSignature).is_HMAC) && (((_pat_let_tv11).dtor_symmetricSigningKeys).is_Some)) || ((new BigInteger((((_pat_let_tv12).dtor_symmetricSigningKeys).dtor_value).Count)) == (new BigInteger(((_pat_let_tv13).dtor_encryptedDataKeys).Count))))) && (!(((_44_suite).dtor_symmetricSignature).is_HMAC) || (((_pat_let_tv14).dtor_symmetricSigningKeys).is_Some))) && (!(((_44_suite).dtor_symmetricSignature).is_None) || (((_pat_let_tv15).dtor_symmetricSigningKeys).is_None))) && (Dafny.Helpers.Id<Func<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, bool>>((_45_encryptionMaterials) => Dafny.Helpers.Quantifier<Dafny.ISequence<byte>>(((_45_encryptionMaterials).dtor_requiredEncryptionContextKeys).UniqueElements, true, (((_forall_var_2) => {
        Dafny.ISequence<byte> _46_key = (Dafny.ISequence<byte>)_forall_var_2;
        return !(((_45_encryptionMaterials).dtor_requiredEncryptionContextKeys).Contains(_46_key)) || (((_45_encryptionMaterials).dtor_encryptionContext).Contains(_46_key));
      }))))(_pat_let_tv16)))));
    }
    public static bool EncryptionMaterialsHasPlaintextDataKey(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials encryptionMaterials) {
      return ((((encryptionMaterials).dtor_plaintextDataKey).is_Some) && ((new BigInteger(((encryptionMaterials).dtor_encryptedDataKeys).Count)).Sign == 1)) && (Materials_Compile.__default.ValidEncryptionMaterials(encryptionMaterials));
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> EncryptionMaterialAddEncryptedDataKeys(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials encryptionMaterials, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> encryptedDataKeysToAdd, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>> symmetricSigningKeysToAdd)
    {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _47_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.ValidEncryptionMaterials(encryptionMaterials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_InvalidEncryptionMaterialsTransition(Dafny.Sequence<char>.FromString("Attempt to modify invalid encryption material.")));
      if ((_47_valueOrError0).IsFailure()) {
        return (_47_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials>();
      } else {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _48_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((encryptionMaterials).dtor_plaintextDataKey).is_Some, software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_InvalidEncryptionMaterialsTransition(Dafny.Sequence<char>.FromString("Adding encrypted data keys without a plaintext data key is not allowed.")));
        if ((_48_valueOrError1).IsFailure()) {
          return (_48_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials>();
        } else {
          Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _49_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(!((symmetricSigningKeysToAdd).is_None) || ((((encryptionMaterials).dtor_algorithmSuite).dtor_symmetricSignature).is_None), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_InvalidEncryptionMaterialsTransition(Dafny.Sequence<char>.FromString("Adding encrypted data keys without a symmetric signing key when using symmetric signing is not allowed.")));
          if ((_49_valueOrError2).IsFailure()) {
            return (_49_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials>();
          } else {
            Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _50_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(!((symmetricSigningKeysToAdd).is_Some) || (!((((encryptionMaterials).dtor_algorithmSuite).dtor_symmetricSignature).is_None)), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_InvalidEncryptionMaterialsTransition(Dafny.Sequence<char>.FromString("Adding encrypted data keys with a symmetric signing key when not using symmetric signing is not allowed.")));
            if ((_50_valueOrError3).IsFailure()) {
              return (_50_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials>();
            } else {
              Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>> _51_symmetricSigningKeys = (((symmetricSigningKeysToAdd).is_None) ? ((encryptionMaterials).dtor_symmetricSigningKeys) : (Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.create_Some(Dafny.Sequence<Dafny.ISequence<byte>>.Concat(((encryptionMaterials).dtor_symmetricSigningKeys).dtor_value, (symmetricSigningKeysToAdd).dtor_value))));
              return Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.EncryptionMaterials.create((encryptionMaterials).dtor_algorithmSuite, (encryptionMaterials).dtor_encryptionContext, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.Concat((encryptionMaterials).dtor_encryptedDataKeys, encryptedDataKeysToAdd), (encryptionMaterials).dtor_requiredEncryptionContextKeys, (encryptionMaterials).dtor_plaintextDataKey, (encryptionMaterials).dtor_signingKey, _51_symmetricSigningKeys));
            }
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> EncryptionMaterialAddDataKey(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials encryptionMaterials, Dafny.ISequence<byte> plaintextDataKey, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> encryptedDataKeysToAdd, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>> symmetricSigningKeysToAdd)
    {
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _52_suite = (encryptionMaterials).dtor_algorithmSuite;
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _53_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.ValidEncryptionMaterials(encryptionMaterials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_InvalidEncryptionMaterialsTransition(Dafny.Sequence<char>.FromString("Attempt to modify invalid encryption material.")));
      if ((_53_valueOrError0).IsFailure()) {
        return (_53_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials>();
      } else {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _54_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((encryptionMaterials).dtor_plaintextDataKey).is_None, software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_InvalidEncryptionMaterialsTransition(Dafny.Sequence<char>.FromString("Attempt to modify plaintextDataKey.")));
        if ((_54_valueOrError1).IsFailure()) {
          return (_54_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials>();
        } else {
          Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _55_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger(AlgorithmSuites_Compile.__default.GetEncryptKeyLength(_52_suite))) == (new BigInteger((plaintextDataKey).Count)), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_InvalidEncryptionMaterialsTransition(Dafny.Sequence<char>.FromString("plaintextDataKey does not match Algorithm Suite specification.")));
          if ((_55_valueOrError2).IsFailure()) {
            return (_55_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials>();
          } else {
            Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _56_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((symmetricSigningKeysToAdd).is_None) == ((((encryptionMaterials).dtor_algorithmSuite).dtor_symmetricSignature).is_None), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_InvalidEncryptionMaterialsTransition(Dafny.Sequence<char>.FromString("Adding encrypted data keys without a symmetric signing key when using symmetric signing is not allowed.")));
            if ((_56_valueOrError3).IsFailure()) {
              return (_56_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials>();
            } else {
              Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _57_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((symmetricSigningKeysToAdd).is_Some) == (!((((encryptionMaterials).dtor_algorithmSuite).dtor_symmetricSignature).is_None)), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_InvalidEncryptionMaterialsTransition(Dafny.Sequence<char>.FromString("Adding encrypted data keys with a symmetric signing key when not using symmetric signing is not allowed.")));
              if ((_57_valueOrError4).IsFailure()) {
                return (_57_valueOrError4).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials>();
              } else {
                Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>> _58_symmetricSigningKeys = (((symmetricSigningKeysToAdd).is_None) ? ((encryptionMaterials).dtor_symmetricSigningKeys) : (Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.create_Some(Dafny.Sequence<Dafny.ISequence<byte>>.Concat(((encryptionMaterials).dtor_symmetricSigningKeys).dtor_value, (symmetricSigningKeysToAdd).dtor_value))));
                return Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.EncryptionMaterials.create((encryptionMaterials).dtor_algorithmSuite, (encryptionMaterials).dtor_encryptionContext, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.Concat((encryptionMaterials).dtor_encryptedDataKeys, encryptedDataKeysToAdd), (encryptionMaterials).dtor_requiredEncryptionContextKeys, Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(plaintextDataKey), (encryptionMaterials).dtor_signingKey, _58_symmetricSigningKeys));
              }
            }
          }
        }
      }
    }
    public static bool DecryptionMaterialsTransitionIsValid(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials oldMat, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials newMat)
    {
      return ((((((((object.Equals((newMat).dtor_algorithmSuite, (oldMat).dtor_algorithmSuite)) && (((newMat).dtor_encryptionContext).Equals((oldMat).dtor_encryptionContext))) && (((newMat).dtor_requiredEncryptionContextKeys).Equals((oldMat).dtor_requiredEncryptionContextKeys))) && (object.Equals((newMat).dtor_verificationKey, (oldMat).dtor_verificationKey))) && (((oldMat).dtor_plaintextDataKey).is_None)) && (((newMat).dtor_plaintextDataKey).is_Some)) && (((oldMat).dtor_symmetricSigningKey).is_None)) && (Materials_Compile.__default.ValidDecryptionMaterials(oldMat))) && (Materials_Compile.__default.ValidDecryptionMaterials(newMat));
    }
    public static bool ValidDecryptionMaterials(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials decryptionMaterials) {
      var _pat_let_tv17 = decryptionMaterials;
      var _pat_let_tv18 = decryptionMaterials;
      var _pat_let_tv19 = decryptionMaterials;
      var _pat_let_tv20 = decryptionMaterials;
      var _pat_let_tv21 = decryptionMaterials;
      var _pat_let_tv22 = decryptionMaterials;
      var _pat_let_tv23 = decryptionMaterials;
      var _pat_let_tv24 = decryptionMaterials;
      var _pat_let_tv25 = decryptionMaterials;
      return (AlgorithmSuites_Compile.__default.AlgorithmSuite_q((decryptionMaterials).dtor_algorithmSuite)) && (Dafny.Helpers.Let<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo, bool>((decryptionMaterials).dtor_algorithmSuite, _pat_let5_0 => Dafny.Helpers.Let<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo, bool>(_pat_let5_0, _59_suite => ((((((!(((_pat_let_tv17).dtor_plaintextDataKey).is_Some) || ((new BigInteger(AlgorithmSuites_Compile.__default.GetEncryptKeyLength(_59_suite))) == (new BigInteger((((_pat_let_tv18).dtor_plaintextDataKey).dtor_value).Count)))) && ((!(((_59_suite).dtor_signature).is_None)) == (((_pat_let_tv19).dtor_encryptionContext).Contains(Materials_Compile.__default.EC__PUBLIC__KEY__FIELD)))) && ((((_59_suite).dtor_signature).is_ECDSA) == (((_pat_let_tv20).dtor_verificationKey).is_Some))) && ((!(((_59_suite).dtor_signature).is_None)) == (((_pat_let_tv21).dtor_encryptionContext).Contains(Materials_Compile.__default.EC__PUBLIC__KEY__FIELD)))) && (!(!(((_59_suite).dtor_symmetricSignature).is_None)) || ((((_pat_let_tv22).dtor_plaintextDataKey).is_Some) == (((_pat_let_tv23).dtor_symmetricSigningKey).is_Some)))) && (!(((_59_suite).dtor_symmetricSignature).is_None) || (((_pat_let_tv24).dtor_symmetricSigningKey).is_None))) && (Dafny.Helpers.Id<Func<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, bool>>((_60_decryptionMaterials) => Dafny.Helpers.Quantifier<Dafny.ISequence<byte>>(((_60_decryptionMaterials).dtor_requiredEncryptionContextKeys).UniqueElements, true, (((_forall_var_3) => {
        Dafny.ISequence<byte> _61_k = (Dafny.ISequence<byte>)_forall_var_3;
        return !(((_60_decryptionMaterials).dtor_requiredEncryptionContextKeys).Contains(_61_k)) || (((_60_decryptionMaterials).dtor_encryptionContext).Contains(_61_k));
      }))))(_pat_let_tv25)))));
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> DecryptionMaterialsAddDataKey(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials decryptionMaterials, Dafny.ISequence<byte> plaintextDataKey, Wrappers_Compile._IOption<Dafny.ISequence<byte>> symmetricSigningKey)
    {
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _62_suite = (decryptionMaterials).dtor_algorithmSuite;
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _63_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.ValidDecryptionMaterials(decryptionMaterials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_InvalidDecryptionMaterialsTransition(Dafny.Sequence<char>.FromString("Attempt to modify invalid decryption material.")));
      if ((_63_valueOrError0).IsFailure()) {
        return (_63_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
      } else {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _64_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((decryptionMaterials).dtor_plaintextDataKey).is_None, software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_InvalidDecryptionMaterialsTransition(Dafny.Sequence<char>.FromString("Attempt to modify plaintextDataKey.")));
        if ((_64_valueOrError1).IsFailure()) {
          return (_64_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        } else {
          Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _65_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger(AlgorithmSuites_Compile.__default.GetEncryptKeyLength(_62_suite))) == (new BigInteger((plaintextDataKey).Count)), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_InvalidDecryptionMaterialsTransition(Dafny.Sequence<char>.FromString("plaintextDataKey does not match Algorithm Suite specification.")));
          if ((_65_valueOrError2).IsFailure()) {
            return (_65_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
          } else {
            Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _66_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((symmetricSigningKey).is_Some) == (!((((decryptionMaterials).dtor_algorithmSuite).dtor_symmetricSignature).is_None)), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_InvalidDecryptionMaterialsTransition(Dafny.Sequence<char>.FromString("symmetric signature key must be added with plaintextDataKey if using an algorithm suite with symmetric signing.")));
            if ((_66_valueOrError3).IsFailure()) {
              return (_66_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
            } else {
              Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _67_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((symmetricSigningKey).is_None) == ((((decryptionMaterials).dtor_algorithmSuite).dtor_symmetricSignature).is_None), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_InvalidDecryptionMaterialsTransition(Dafny.Sequence<char>.FromString("symmetric signature key cannot be added with plaintextDataKey if using an algorithm suite without symmetric signing.")));
              if ((_67_valueOrError4).IsFailure()) {
                return (_67_valueOrError4).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
              } else {
                return Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.DecryptionMaterials.create((decryptionMaterials).dtor_algorithmSuite, (decryptionMaterials).dtor_encryptionContext, (decryptionMaterials).dtor_requiredEncryptionContextKeys, Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(plaintextDataKey), (decryptionMaterials).dtor_verificationKey, symmetricSigningKey));
              }
            }
          }
        }
      }
    }
    public static bool DecryptionMaterialsWithoutPlaintextDataKey(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials decryptionMaterials) {
      return (((decryptionMaterials).dtor_plaintextDataKey).is_None) && (Materials_Compile.__default.ValidDecryptionMaterials(decryptionMaterials));
    }
    public static bool DecryptionMaterialsWithPlaintextDataKey(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials decryptionMaterials) {
      return (((decryptionMaterials).dtor_plaintextDataKey).is_Some) && (Materials_Compile.__default.ValidDecryptionMaterials(decryptionMaterials));
    }
    public static Dafny.ISequence<byte> EC__PUBLIC__KEY__FIELD { get {
      Dafny.ISequence<byte> _68_s = Dafny.Sequence<byte>.FromElements((byte)(97), (byte)(119), (byte)(115), (byte)(45), (byte)(99), (byte)(114), (byte)(121), (byte)(112), (byte)(116), (byte)(111), (byte)(45), (byte)(112), (byte)(117), (byte)(98), (byte)(108), (byte)(105), (byte)(99), (byte)(45), (byte)(107), (byte)(101), (byte)(121));
      return _68_s;
    } }
    public static Dafny.ISet<Dafny.ISequence<byte>> RESERVED__KEY__VALUES { get {
      return Dafny.Set<Dafny.ISequence<byte>>.FromElements(Materials_Compile.__default.EC__PUBLIC__KEY__FIELD);
    } }
  }
} // end of namespace Materials_Compile
namespace Keyring_Compile {

  public interface VerifiableInterface : software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring {
  }
  public class _Companion_VerifiableInterface {
  }

} // end of namespace Keyring_Compile
namespace MultiKeyring_Compile {

  public partial class MultiKeyring : Keyring_Compile.VerifiableInterface, software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring {
    public MultiKeyring() {
      this._generatorKeyring = Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>.Default();
      this._childKeyrings = Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>.Empty;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnEncrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out10;
      _out10 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_IKeyring.OnEncrypt(this, input);
      return _out10;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnDecrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out11;
      _out11 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_IKeyring.OnDecrypt(this, input);
      return _out11;
    }
    public void __ctor(Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> generatorKeyring, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> childKeyrings)
    {
      (this)._generatorKeyring = generatorKeyring;
      (this)._childKeyrings = childKeyrings;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnEncrypt_k(software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      if ((((this).generatorKeyring).is_None) && ((((input).dtor_materials).dtor_plaintextDataKey).is_None)) {
        Dafny.ISequence<char> _69_exception;
        _69_exception = Dafny.Sequence<char>.FromString("Need either a generator keyring or input encryption materials which contain a plaintext data key");
        res = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(_69_exception));
        return res;
      }
      software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _70_returnMaterials;
      _70_returnMaterials = (input).dtor_materials;
      if (((this).generatorKeyring).is_Some) {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _71_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
        _71_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((input).dtor_materials).dtor_plaintextDataKey).is_None, software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("This multi keyring has a generator but provided Encryption Materials already contain plaintext data key")));
        if ((_71_valueOrError0).IsFailure()) {
          res = (_71_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
          return res;
        }
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _72_onEncryptOutput;
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out12;
        _out12 = (((this).generatorKeyring).dtor_value).OnEncrypt(input);
        _72_onEncryptOutput = _out12;
        Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _73_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
        _73_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((_72_onEncryptOutput).is_Success, software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Generator keyring failed to generate plaintext data key")));
        if ((_73_valueOrError1).IsFailure()) {
          res = (_73_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
          return res;
        }
        Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _74_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
        _74_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.ValidEncryptionMaterialsTransition((input).dtor_materials, ((_72_onEncryptOutput).dtor_value).dtor_materials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Generator keyring returned invalid encryption materials")));
        if ((_74_valueOrError2).IsFailure()) {
          res = (_74_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
          return res;
        }
        _70_returnMaterials = ((_72_onEncryptOutput).dtor_value).dtor_materials;
      }
      BigInteger _hi0 = new BigInteger(((this).childKeyrings).Count);
      for (BigInteger _75_i = BigInteger.Zero; _75_i < _hi0; _75_i++) {
        software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput _76_onEncryptInput;
        _76_onEncryptInput = software.amazon.cryptography.materialproviders.internaldafny.types.OnEncryptInput.create(_70_returnMaterials);
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _77_onEncryptOutput;
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out13;
        _out13 = (((this).childKeyrings).Select(_75_i)).OnEncrypt(_76_onEncryptInput);
        _77_onEncryptOutput = _out13;
        Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _78_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
        _78_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((_77_onEncryptOutput).is_Success, software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Child keyring failed to encrypt plaintext data key")));
        if ((_78_valueOrError3).IsFailure()) {
          res = (_78_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
          return res;
        }
        Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _79_valueOrError4 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
        _79_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.ValidEncryptionMaterialsTransition(_70_returnMaterials, ((_77_onEncryptOutput).dtor_value).dtor_materials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Child keyring performed invalid transition on encryption materials")));
        if ((_79_valueOrError4).IsFailure()) {
          res = (_79_valueOrError4).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
          return res;
        }
        _70_returnMaterials = ((_77_onEncryptOutput).dtor_value).dtor_materials;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _80_valueOrError5 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _80_valueOrError5 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.ValidEncryptionMaterialsTransition((input).dtor_materials, _70_returnMaterials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("A child or generator keyring modified the encryption materials in illegal ways.")));
      if ((_80_valueOrError5).IsFailure()) {
        res = (_80_valueOrError5).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
        return res;
      }
      res = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.OnEncryptOutput.create(_70_returnMaterials));
      return res;
      return res;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnDecrypt_k(software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _81_materials;
      _81_materials = (input).dtor_materials;
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _82_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _82_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.DecryptionMaterialsWithoutPlaintextDataKey((input).dtor_materials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Keyring received decryption materials that already contain a plaintext data key.")));
      if ((_82_valueOrError0).IsFailure()) {
        res = (_82_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return res;
      }
      Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _83_failures;
      _83_failures = Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.FromElements();
      if (((this).generatorKeyring).is_Some) {
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _84_result;
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out14;
        _out14 = MultiKeyring_Compile.__default.AttemptDecryptDataKey(((this).generatorKeyring).dtor_value, input);
        _84_result = _out14;
        if ((_84_result).is_Success) {
          if (((((_84_result).dtor_value).dtor_materials).dtor_plaintextDataKey).is_Some) {
            res = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success((_84_result).dtor_value);
            return res;
          }
        } else {
          _83_failures = Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Concat(_83_failures, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.FromElements((_84_result).dtor_error));
        }
      }
      BigInteger _hi1 = new BigInteger(((this).childKeyrings).Count);
      for (BigInteger _85_j = BigInteger.Zero; _85_j < _hi1; _85_j++) {
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _86_result;
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out15;
        _out15 = MultiKeyring_Compile.__default.AttemptDecryptDataKey(((this).childKeyrings).Select(_85_j), input);
        _86_result = _out15;
        if ((_86_result).is_Success) {
          res = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success((_86_result).dtor_value);
          return res;
        } else {
          _83_failures = Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Concat(_83_failures, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.FromElements((_86_result).dtor_error));
        }
      }
      software.amazon.cryptography.materialproviders.internaldafny.types._IError _87_combinedResult;
      _87_combinedResult = software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_CollectionOfErrors(_83_failures, Dafny.Sequence<char>.FromString("No Configured Keyring was able to decrypt the Data Key. The list of encountered Exceptions is available via `list`."));
      res = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Failure(_87_combinedResult);
      return res;
      return res;
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> _generatorKeyring {get; set;}
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> generatorKeyring { get {
      return this._generatorKeyring;
    } }
    public Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> _childKeyrings {get; set;}
    public Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> childKeyrings { get {
      return this._childKeyrings;
    } }
  }

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> AttemptDecryptDataKey(software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring keyring, software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput _88_output;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _89_valueOrError0 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out16;
      _out16 = (keyring).OnDecrypt(input);
      _89_valueOrError0 = _out16;
      if ((_89_valueOrError0).IsFailure()) {
        res = (_89_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return res;
      }
      _88_output = (_89_valueOrError0).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _90_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _90_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.DecryptionMaterialsTransitionIsValid((input).dtor_materials, (_88_output).dtor_materials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Keyring performed invalid material transition")));
      if ((_90_valueOrError1).IsFailure()) {
        res = (_90_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return res;
      }
      res = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_88_output);
      return res;
      return res;
    }
  }
} // end of namespace MultiKeyring_Compile
namespace AwsArnParsing_Compile {

  public interface _IAwsResource {
    bool is_AwsResource { get; }
    Dafny.ISequence<char> dtor_resourceType { get; }
    Dafny.ISequence<char> dtor_value { get; }
    _IAwsResource DowncastClone();
    bool Valid();
    Dafny.ISequence<char> _ToString();
  }
  public class AwsResource : _IAwsResource {
    public readonly Dafny.ISequence<char> _resourceType;
    public readonly Dafny.ISequence<char> _value;
    public AwsResource(Dafny.ISequence<char> resourceType, Dafny.ISequence<char> @value) {
      this._resourceType = resourceType;
      this._value = @value;
    }
    public _IAwsResource DowncastClone() {
      if (this is _IAwsResource dt) { return dt; }
      return new AwsResource(_resourceType, _value);
    }
    public override bool Equals(object other) {
      var oth = other as AwsArnParsing_Compile.AwsResource;
      return oth != null && object.Equals(this._resourceType, oth._resourceType) && object.Equals(this._value, oth._value);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._resourceType));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._value));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsArnParsing_Compile.AwsResource.AwsResource";
      s += "(";
      s += Dafny.Helpers.ToString(this._resourceType);
      s += ", ";
      s += Dafny.Helpers.ToString(this._value);
      s += ")";
      return s;
    }
    private static readonly AwsArnParsing_Compile._IAwsResource theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty);
    public static AwsArnParsing_Compile._IAwsResource Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AwsArnParsing_Compile._IAwsResource> _TYPE = new Dafny.TypeDescriptor<AwsArnParsing_Compile._IAwsResource>(AwsArnParsing_Compile.AwsResource.Default());
    public static Dafny.TypeDescriptor<AwsArnParsing_Compile._IAwsResource> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IAwsResource create(Dafny.ISequence<char> resourceType, Dafny.ISequence<char> @value) {
      return new AwsResource(resourceType, @value);
    }
    public static _IAwsResource create_AwsResource(Dafny.ISequence<char> resourceType, Dafny.ISequence<char> @value) {
      return create(resourceType, @value);
    }
    public bool is_AwsResource { get { return true; } }
    public Dafny.ISequence<char> dtor_resourceType {
      get {
        return this._resourceType;
      }
    }
    public Dafny.ISequence<char> dtor_value {
      get {
        return this._value;
      }
    }
    public bool Valid() {
      return (true) && ((new BigInteger(((this).dtor_value).Count)).Sign == 1);
    }
    public Dafny.ISequence<char> _ToString() {
      return Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat((this).dtor_resourceType, Dafny.Sequence<char>.FromString("/")), (this).dtor_value);
    }
  }

  public interface _IAwsArn {
    bool is_AwsArn { get; }
    Dafny.ISequence<char> dtor_arnLiteral { get; }
    Dafny.ISequence<char> dtor_partition { get; }
    Dafny.ISequence<char> dtor_service { get; }
    Dafny.ISequence<char> dtor_region { get; }
    Dafny.ISequence<char> dtor_account { get; }
    AwsArnParsing_Compile._IAwsResource dtor_resource { get; }
    _IAwsArn DowncastClone();
    bool Valid();
    Dafny.ISequence<char> _ToString();
    Dafny.ISequence<char> ToArnString(Wrappers_Compile._IOption<Dafny.ISequence<char>> customRegion);
  }
  public class AwsArn : _IAwsArn {
    public readonly Dafny.ISequence<char> _arnLiteral;
    public readonly Dafny.ISequence<char> _partition;
    public readonly Dafny.ISequence<char> _service;
    public readonly Dafny.ISequence<char> _region;
    public readonly Dafny.ISequence<char> _account;
    public readonly AwsArnParsing_Compile._IAwsResource _resource;
    public AwsArn(Dafny.ISequence<char> arnLiteral, Dafny.ISequence<char> partition, Dafny.ISequence<char> service, Dafny.ISequence<char> region, Dafny.ISequence<char> account, AwsArnParsing_Compile._IAwsResource resource) {
      this._arnLiteral = arnLiteral;
      this._partition = partition;
      this._service = service;
      this._region = region;
      this._account = account;
      this._resource = resource;
    }
    public _IAwsArn DowncastClone() {
      if (this is _IAwsArn dt) { return dt; }
      return new AwsArn(_arnLiteral, _partition, _service, _region, _account, _resource);
    }
    public override bool Equals(object other) {
      var oth = other as AwsArnParsing_Compile.AwsArn;
      return oth != null && object.Equals(this._arnLiteral, oth._arnLiteral) && object.Equals(this._partition, oth._partition) && object.Equals(this._service, oth._service) && object.Equals(this._region, oth._region) && object.Equals(this._account, oth._account) && object.Equals(this._resource, oth._resource);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._arnLiteral));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._partition));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._service));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._region));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._account));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._resource));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsArnParsing_Compile.AwsArn.AwsArn";
      s += "(";
      s += Dafny.Helpers.ToString(this._arnLiteral);
      s += ", ";
      s += Dafny.Helpers.ToString(this._partition);
      s += ", ";
      s += Dafny.Helpers.ToString(this._service);
      s += ", ";
      s += Dafny.Helpers.ToString(this._region);
      s += ", ";
      s += Dafny.Helpers.ToString(this._account);
      s += ", ";
      s += Dafny.Helpers.ToString(this._resource);
      s += ")";
      return s;
    }
    private static readonly AwsArnParsing_Compile._IAwsArn theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, AwsArnParsing_Compile.AwsResource.Default());
    public static AwsArnParsing_Compile._IAwsArn Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AwsArnParsing_Compile._IAwsArn> _TYPE = new Dafny.TypeDescriptor<AwsArnParsing_Compile._IAwsArn>(AwsArnParsing_Compile.AwsArn.Default());
    public static Dafny.TypeDescriptor<AwsArnParsing_Compile._IAwsArn> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IAwsArn create(Dafny.ISequence<char> arnLiteral, Dafny.ISequence<char> partition, Dafny.ISequence<char> service, Dafny.ISequence<char> region, Dafny.ISequence<char> account, AwsArnParsing_Compile._IAwsResource resource) {
      return new AwsArn(arnLiteral, partition, service, region, account, resource);
    }
    public static _IAwsArn create_AwsArn(Dafny.ISequence<char> arnLiteral, Dafny.ISequence<char> partition, Dafny.ISequence<char> service, Dafny.ISequence<char> region, Dafny.ISequence<char> account, AwsArnParsing_Compile._IAwsResource resource) {
      return create(arnLiteral, partition, service, region, account, resource);
    }
    public bool is_AwsArn { get { return true; } }
    public Dafny.ISequence<char> dtor_arnLiteral {
      get {
        return this._arnLiteral;
      }
    }
    public Dafny.ISequence<char> dtor_partition {
      get {
        return this._partition;
      }
    }
    public Dafny.ISequence<char> dtor_service {
      get {
        return this._service;
      }
    }
    public Dafny.ISequence<char> dtor_region {
      get {
        return this._region;
      }
    }
    public Dafny.ISequence<char> dtor_account {
      get {
        return this._account;
      }
    }
    public AwsArnParsing_Compile._IAwsResource dtor_resource {
      get {
        return this._resource;
      }
    }
    public bool Valid() {
      return (((((((this).dtor_arnLiteral).Equals(Dafny.Sequence<char>.FromString("arn"))) && ((new BigInteger(((this).dtor_partition).Count)).Sign == 1)) && ((new BigInteger(((this).dtor_service).Count)).Sign == 1)) && ((new BigInteger(((this).dtor_region).Count)).Sign == 1)) && ((new BigInteger(((this).dtor_account).Count)).Sign == 1)) && (((this).dtor_resource).Valid());
    }
    public Dafny.ISequence<char> _ToString() {
      return (this).ToArnString(Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None());
    }
    public Dafny.ISequence<char> ToArnString(Wrappers_Compile._IOption<Dafny.ISequence<char>> customRegion) {
      _IAwsArn _this = this;
    TAIL_CALL_START: ;
      Wrappers_Compile._IOption<Dafny.ISequence<char>> _source8 = customRegion;
      if (_source8.is_None) {
        var _in0 = _this;
        Wrappers_Compile._IOption<Dafny.ISequence<char>> _in1 = Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some((_this).dtor_region);
        _this = _in0;
        customRegion = _in1;
        goto TAIL_CALL_START;
      } else {
        Dafny.ISequence<char> _91___mcc_h0 = _source8.dtor_value;
        Dafny.ISequence<char> _92_customRegion = _91___mcc_h0;
        return StandardLibrary_Compile.__default.Join<char>(Dafny.Sequence<Dafny.ISequence<char>>.FromElements((_this).dtor_arnLiteral, (_this).dtor_partition, (_this).dtor_service, _92_customRegion, (_this).dtor_account, ((_this).dtor_resource)._ToString()), Dafny.Sequence<char>.FromString(":"));
      }
    }
  }

  public partial class AwsKmsArn {
    private static readonly Dafny.TypeDescriptor<AwsArnParsing_Compile._IAwsArn> _TYPE = new Dafny.TypeDescriptor<AwsArnParsing_Compile._IAwsArn>(AwsArnParsing_Compile.AwsArn.Default());
    public static Dafny.TypeDescriptor<AwsArnParsing_Compile._IAwsArn> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class AwsKmsResource {
    private static readonly Dafny.TypeDescriptor<AwsArnParsing_Compile._IAwsResource> _TYPE = new Dafny.TypeDescriptor<AwsArnParsing_Compile._IAwsResource>(AwsArnParsing_Compile.AwsResource.Default());
    public static Dafny.TypeDescriptor<AwsArnParsing_Compile._IAwsResource> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public interface _IAwsKmsIdentifier {
    bool is_AwsKmsArnIdentifier { get; }
    bool is_AwsKmsRawResourceIdentifier { get; }
    AwsArnParsing_Compile._IAwsArn dtor_a { get; }
    AwsArnParsing_Compile._IAwsResource dtor_r { get; }
    _IAwsKmsIdentifier DowncastClone();
    Dafny.ISequence<char> _ToString();
  }
  public abstract class AwsKmsIdentifier : _IAwsKmsIdentifier {
    public AwsKmsIdentifier() { }
    private static readonly AwsArnParsing_Compile._IAwsKmsIdentifier theDefault = create_AwsKmsArnIdentifier(AwsArnParsing_Compile.AwsArn.Default());
    public static AwsArnParsing_Compile._IAwsKmsIdentifier Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AwsArnParsing_Compile._IAwsKmsIdentifier> _TYPE = new Dafny.TypeDescriptor<AwsArnParsing_Compile._IAwsKmsIdentifier>(AwsArnParsing_Compile.AwsKmsIdentifier.Default());
    public static Dafny.TypeDescriptor<AwsArnParsing_Compile._IAwsKmsIdentifier> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IAwsKmsIdentifier create_AwsKmsArnIdentifier(AwsArnParsing_Compile._IAwsArn a) {
      return new AwsKmsIdentifier_AwsKmsArnIdentifier(a);
    }
    public static _IAwsKmsIdentifier create_AwsKmsRawResourceIdentifier(AwsArnParsing_Compile._IAwsResource r) {
      return new AwsKmsIdentifier_AwsKmsRawResourceIdentifier(r);
    }
    public bool is_AwsKmsArnIdentifier { get { return this is AwsKmsIdentifier_AwsKmsArnIdentifier; } }
    public bool is_AwsKmsRawResourceIdentifier { get { return this is AwsKmsIdentifier_AwsKmsRawResourceIdentifier; } }
    public AwsArnParsing_Compile._IAwsArn dtor_a {
      get {
        var d = this;
        return ((AwsKmsIdentifier_AwsKmsArnIdentifier)d)._a;
      }
    }
    public AwsArnParsing_Compile._IAwsResource dtor_r {
      get {
        var d = this;
        return ((AwsKmsIdentifier_AwsKmsRawResourceIdentifier)d)._r;
      }
    }
    public abstract _IAwsKmsIdentifier DowncastClone();
    public Dafny.ISequence<char> _ToString() {
      AwsArnParsing_Compile._IAwsKmsIdentifier _source9 = this;
      if (_source9.is_AwsKmsArnIdentifier) {
        AwsArnParsing_Compile._IAwsArn _93___mcc_h0 = _source9.dtor_a;
        AwsArnParsing_Compile._IAwsArn _94_a = _93___mcc_h0;
        return (_94_a)._ToString();
      } else {
        AwsArnParsing_Compile._IAwsResource _95___mcc_h1 = _source9.dtor_r;
        AwsArnParsing_Compile._IAwsResource _96_r = _95___mcc_h1;
        return (_96_r)._ToString();
      }
    }
  }
  public class AwsKmsIdentifier_AwsKmsArnIdentifier : AwsKmsIdentifier {
    public readonly AwsArnParsing_Compile._IAwsArn _a;
    public AwsKmsIdentifier_AwsKmsArnIdentifier(AwsArnParsing_Compile._IAwsArn a) {
      this._a = a;
    }
    public override _IAwsKmsIdentifier DowncastClone() {
      if (this is _IAwsKmsIdentifier dt) { return dt; }
      return new AwsKmsIdentifier_AwsKmsArnIdentifier(_a);
    }
    public override bool Equals(object other) {
      var oth = other as AwsArnParsing_Compile.AwsKmsIdentifier_AwsKmsArnIdentifier;
      return oth != null && object.Equals(this._a, oth._a);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._a));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsArnParsing_Compile.AwsKmsIdentifier.AwsKmsArnIdentifier";
      s += "(";
      s += Dafny.Helpers.ToString(this._a);
      s += ")";
      return s;
    }
  }
  public class AwsKmsIdentifier_AwsKmsRawResourceIdentifier : AwsKmsIdentifier {
    public readonly AwsArnParsing_Compile._IAwsResource _r;
    public AwsKmsIdentifier_AwsKmsRawResourceIdentifier(AwsArnParsing_Compile._IAwsResource r) {
      this._r = r;
    }
    public override _IAwsKmsIdentifier DowncastClone() {
      if (this is _IAwsKmsIdentifier dt) { return dt; }
      return new AwsKmsIdentifier_AwsKmsRawResourceIdentifier(_r);
    }
    public override bool Equals(object other) {
      var oth = other as AwsArnParsing_Compile.AwsKmsIdentifier_AwsKmsRawResourceIdentifier;
      return oth != null && object.Equals(this._r, oth._r);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._r));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsArnParsing_Compile.AwsKmsIdentifier.AwsKmsRawResourceIdentifier";
      s += "(";
      s += Dafny.Helpers.ToString(this._r);
      s += ")";
      return s;
    }
  }

  public partial class AmazonDynamodbTableArn {
    private static readonly Dafny.TypeDescriptor<AwsArnParsing_Compile._IAwsArn> _TYPE = new Dafny.TypeDescriptor<AwsArnParsing_Compile._IAwsArn>(AwsArnParsing_Compile.AwsArn.Default());
    public static Dafny.TypeDescriptor<AwsArnParsing_Compile._IAwsArn> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class AmazonDynamodbResource {
    private static readonly Dafny.TypeDescriptor<AwsArnParsing_Compile._IAwsResource> _TYPE = new Dafny.TypeDescriptor<AwsArnParsing_Compile._IAwsResource>(AwsArnParsing_Compile.AwsResource.Default());
    public static Dafny.TypeDescriptor<AwsArnParsing_Compile._IAwsResource> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public interface _IAmazonDynamodbTableName {
    bool is_AmazonDynamodbTableArn { get; }
    AwsArnParsing_Compile._IAwsArn dtor_a { get; }
    _IAmazonDynamodbTableName DowncastClone();
    Dafny.ISequence<char> GetTableName();
  }
  public class AmazonDynamodbTableName : _IAmazonDynamodbTableName {
    public readonly AwsArnParsing_Compile._IAwsArn _a;
    public AmazonDynamodbTableName(AwsArnParsing_Compile._IAwsArn a) {
      this._a = a;
    }
    public _IAmazonDynamodbTableName DowncastClone() {
      if (this is _IAmazonDynamodbTableName dt) { return dt; }
      return new AmazonDynamodbTableName(_a);
    }
    public override bool Equals(object other) {
      var oth = other as AwsArnParsing_Compile.AmazonDynamodbTableName;
      return oth != null && object.Equals(this._a, oth._a);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._a));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsArnParsing_Compile.AmazonDynamodbTableName.AmazonDynamodbTableArn";
      s += "(";
      s += Dafny.Helpers.ToString(this._a);
      s += ")";
      return s;
    }
    private static readonly AwsArnParsing_Compile._IAmazonDynamodbTableName theDefault = create(AwsArnParsing_Compile.AwsArn.Default());
    public static AwsArnParsing_Compile._IAmazonDynamodbTableName Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AwsArnParsing_Compile._IAmazonDynamodbTableName> _TYPE = new Dafny.TypeDescriptor<AwsArnParsing_Compile._IAmazonDynamodbTableName>(AwsArnParsing_Compile.AmazonDynamodbTableName.Default());
    public static Dafny.TypeDescriptor<AwsArnParsing_Compile._IAmazonDynamodbTableName> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IAmazonDynamodbTableName create(AwsArnParsing_Compile._IAwsArn a) {
      return new AmazonDynamodbTableName(a);
    }
    public static _IAmazonDynamodbTableName create_AmazonDynamodbTableArn(AwsArnParsing_Compile._IAwsArn a) {
      return create(a);
    }
    public bool is_AmazonDynamodbTableArn { get { return true; } }
    public AwsArnParsing_Compile._IAwsArn dtor_a {
      get {
        return this._a;
      }
    }
    public Dafny.ISequence<char> GetTableName() {
      AwsArnParsing_Compile._IAmazonDynamodbTableName _source10 = this;
      {
        AwsArnParsing_Compile._IAwsArn _97___mcc_h0 = _source10.dtor_a;
        AwsArnParsing_Compile._IAwsArn _98_a = _97___mcc_h0;
        return ((_98_a).dtor_resource).dtor_value;
      }
    }
  }

  public partial class AwsKmsIdentifierString {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<char>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<char>>(Dafny.Sequence<char>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<char>> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class __default {
    public static bool ValidAwsKmsResource(AwsArnParsing_Compile._IAwsResource resource) {
      return ((resource).Valid()) && ((((resource).dtor_resourceType).Equals(Dafny.Sequence<char>.FromString("key"))) || (((resource).dtor_resourceType).Equals(Dafny.Sequence<char>.FromString("alias"))));
    }
    public static bool ValidAwsKmsArn(AwsArnParsing_Compile._IAwsArn arn) {
      return (((arn).Valid()) && (((arn).dtor_service).Equals(Dafny.Sequence<char>.FromString("kms")))) && (AwsArnParsing_Compile.__default.ValidAwsKmsResource((arn).dtor_resource));
    }
    public static Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsResource, Dafny.ISequence<char>> ParseAwsKmsRawResources(Dafny.ISequence<char> identifier) {
      Dafny.ISequence<Dafny.ISequence<char>> _99_info = StandardLibrary_Compile.__default.Split<char>(identifier, '/');
      Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _100_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(!((_99_info).Select(BigInteger.Zero)).Equals(Dafny.Sequence<char>.FromString("key")), Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Malformed raw key id: "), identifier));
      if ((_100_valueOrError0).IsFailure()) {
        return (_100_valueOrError0).PropagateFailure<AwsArnParsing_Compile._IAwsResource>();
      } else if ((new BigInteger((_99_info).Count)) == (BigInteger.One)) {
        return AwsArnParsing_Compile.__default.ParseAwsKmsResources(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("key/"), identifier));
      } else {
        return AwsArnParsing_Compile.__default.ParseAwsKmsResources(identifier);
      }
    }
    public static Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsResource, Dafny.ISequence<char>> ParseAwsKmsResources(Dafny.ISequence<char> identifier) {
      Dafny.ISequence<Dafny.ISequence<char>> _101_info = StandardLibrary_Compile.__default.Split<char>(identifier, '/');
      Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _102_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger((_101_info).Count)) > (BigInteger.One), Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Malformed resource: "), identifier));
      if ((_102_valueOrError0).IsFailure()) {
        return (_102_valueOrError0).PropagateFailure<AwsArnParsing_Compile._IAwsResource>();
      } else {
        Dafny.ISequence<char> _103_resourceType = (_101_info).Select(BigInteger.Zero);
        Dafny.ISequence<char> _104_value = StandardLibrary_Compile.__default.Join<char>((_101_info).Drop(BigInteger.One), Dafny.Sequence<char>.FromString("/"));
        AwsArnParsing_Compile._IAwsResource _105_resource = AwsArnParsing_Compile.AwsResource.create(_103_resourceType, _104_value);
        Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _106_valueOrError1 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(AwsArnParsing_Compile.__default.ValidAwsKmsResource(_105_resource), Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Malformed resource: "), identifier));
        if ((_106_valueOrError1).IsFailure()) {
          return (_106_valueOrError1).PropagateFailure<AwsArnParsing_Compile._IAwsResource>();
        } else {
          return Wrappers_Compile.Result<AwsArnParsing_Compile._IAwsResource, Dafny.ISequence<char>>.create_Success(_105_resource);
        }
      }
    }
    public static bool ValidAmazonDynamodbResource(AwsArnParsing_Compile._IAwsResource resource) {
      return ((resource).Valid()) && (((resource).dtor_resourceType).Equals(Dafny.Sequence<char>.FromString("table")));
    }
    public static bool ValidAmazonDynamodbArn(AwsArnParsing_Compile._IAwsArn arn) {
      return (((arn).Valid()) && (((arn).dtor_service).Equals(Dafny.Sequence<char>.FromString("dynamodb")))) && (AwsArnParsing_Compile.__default.ValidAmazonDynamodbResource((arn).dtor_resource));
    }
    public static Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsResource, Dafny.ISequence<char>> ParseAmazonDynamodbResources(Dafny.ISequence<char> identifier) {
      Wrappers_Compile._IOption<_System._ITuple2<Dafny.ISequence<char>, Dafny.ISequence<char>>> _107_info = StandardLibrary_Compile.__default.SplitOnce_q<char>(identifier, '/');
      Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _108_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((_107_info).is_Some, Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Malformed resource: "), identifier));
      if ((_108_valueOrError0).IsFailure()) {
        return (_108_valueOrError0).PropagateFailure<AwsArnParsing_Compile._IAwsResource>();
      } else {
        Dafny.ISequence<char> _109_resourceType = ((_107_info).dtor_value).dtor__0;
        Dafny.ISequence<char> _110_value = ((_107_info).dtor_value).dtor__1;
        Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _111_valueOrError1 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(software.amazon.cryptography.services.dynamodb.internaldafny.types.__default.IsValid__TableName(_110_value), Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Table Name invalid: "), identifier));
        if ((_111_valueOrError1).IsFailure()) {
          return (_111_valueOrError1).PropagateFailure<AwsArnParsing_Compile._IAwsResource>();
        } else {
          AwsArnParsing_Compile._IAwsResource _112_resource = AwsArnParsing_Compile.AwsResource.create(_109_resourceType, _110_value);
          Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _113_valueOrError2 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(AwsArnParsing_Compile.__default.ValidAmazonDynamodbResource(_112_resource), Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Malformed resource: "), identifier));
          if ((_113_valueOrError2).IsFailure()) {
            return (_113_valueOrError2).PropagateFailure<AwsArnParsing_Compile._IAwsResource>();
          } else {
            return Wrappers_Compile.Result<AwsArnParsing_Compile._IAwsResource, Dafny.ISequence<char>>.create_Success(_112_resource);
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsArn, Dafny.ISequence<char>> ParseAwsKmsArn(Dafny.ISequence<char> identifier) {
      Dafny.ISequence<Dafny.ISequence<char>> _114_components = StandardLibrary_Compile.__default.Split<char>(identifier, ':');
      Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _115_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger(6)) == (new BigInteger((_114_components).Count)), Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Malformed arn: "), identifier));
      if ((_115_valueOrError0).IsFailure()) {
        return (_115_valueOrError0).PropagateFailure<AwsArnParsing_Compile._IAwsArn>();
      } else {
        Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsResource, Dafny.ISequence<char>> _116_valueOrError1 = AwsArnParsing_Compile.__default.ParseAwsKmsResources((_114_components).Select(new BigInteger(5)));
        if ((_116_valueOrError1).IsFailure()) {
          return (_116_valueOrError1).PropagateFailure<AwsArnParsing_Compile._IAwsArn>();
        } else {
          AwsArnParsing_Compile._IAwsResource _117_resource = (_116_valueOrError1).Extract();
          AwsArnParsing_Compile._IAwsArn _118_arn = AwsArnParsing_Compile.AwsArn.create((_114_components).Select(BigInteger.Zero), (_114_components).Select(BigInteger.One), (_114_components).Select(new BigInteger(2)), (_114_components).Select(new BigInteger(3)), (_114_components).Select(new BigInteger(4)), _117_resource);
          Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _119_valueOrError2 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(AwsArnParsing_Compile.__default.ValidAwsKmsArn(_118_arn), Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Malformed Arn:"), identifier));
          if ((_119_valueOrError2).IsFailure()) {
            return (_119_valueOrError2).PropagateFailure<AwsArnParsing_Compile._IAwsArn>();
          } else {
            return Wrappers_Compile.Result<AwsArnParsing_Compile._IAwsArn, Dafny.ISequence<char>>.create_Success(_118_arn);
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsArn, Dafny.ISequence<char>> ParseAmazonDynamodbTableArn(Dafny.ISequence<char> identifier) {
      Dafny.ISequence<Dafny.ISequence<char>> _120_components = StandardLibrary_Compile.__default.Split<char>(identifier, ':');
      Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _121_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger(6)) == (new BigInteger((_120_components).Count)), Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Malformed arn: "), identifier));
      if ((_121_valueOrError0).IsFailure()) {
        return (_121_valueOrError0).PropagateFailure<AwsArnParsing_Compile._IAwsArn>();
      } else {
        Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsResource, Dafny.ISequence<char>> _122_valueOrError1 = AwsArnParsing_Compile.__default.ParseAmazonDynamodbResources((_120_components).Select(new BigInteger(5)));
        if ((_122_valueOrError1).IsFailure()) {
          return (_122_valueOrError1).PropagateFailure<AwsArnParsing_Compile._IAwsArn>();
        } else {
          AwsArnParsing_Compile._IAwsResource _123_resource = (_122_valueOrError1).Extract();
          AwsArnParsing_Compile._IAwsArn _124_arn = AwsArnParsing_Compile.AwsArn.create((_120_components).Select(BigInteger.Zero), (_120_components).Select(BigInteger.One), (_120_components).Select(new BigInteger(2)), (_120_components).Select(new BigInteger(3)), (_120_components).Select(new BigInteger(4)), _123_resource);
          Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _125_valueOrError2 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(AwsArnParsing_Compile.__default.ValidAmazonDynamodbArn(_124_arn), Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Malformed Arn:"), identifier));
          if ((_125_valueOrError2).IsFailure()) {
            return (_125_valueOrError2).PropagateFailure<AwsArnParsing_Compile._IAwsArn>();
          } else {
            return Wrappers_Compile.Result<AwsArnParsing_Compile._IAwsArn, Dafny.ISequence<char>>.create_Success(_124_arn);
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsKmsIdentifier, Dafny.ISequence<char>> ParseAwsKmsIdentifier(Dafny.ISequence<char> identifier) {
      if (Dafny.Sequence<char>.IsPrefixOf(Dafny.Sequence<char>.FromString("arn:"), identifier)) {
        Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsArn, Dafny.ISequence<char>> _126_valueOrError0 = AwsArnParsing_Compile.__default.ParseAwsKmsArn(identifier);
        if ((_126_valueOrError0).IsFailure()) {
          return (_126_valueOrError0).PropagateFailure<AwsArnParsing_Compile._IAwsKmsIdentifier>();
        } else {
          AwsArnParsing_Compile._IAwsArn _127_arn = (_126_valueOrError0).Extract();
          return Wrappers_Compile.Result<AwsArnParsing_Compile._IAwsKmsIdentifier, Dafny.ISequence<char>>.create_Success(AwsArnParsing_Compile.AwsKmsIdentifier.create_AwsKmsArnIdentifier(_127_arn));
        }
      } else {
        Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsResource, Dafny.ISequence<char>> _128_valueOrError1 = AwsArnParsing_Compile.__default.ParseAwsKmsRawResources(identifier);
        if ((_128_valueOrError1).IsFailure()) {
          return (_128_valueOrError1).PropagateFailure<AwsArnParsing_Compile._IAwsKmsIdentifier>();
        } else {
          AwsArnParsing_Compile._IAwsResource _129_r = (_128_valueOrError1).Extract();
          return Wrappers_Compile.Result<AwsArnParsing_Compile._IAwsKmsIdentifier, Dafny.ISequence<char>>.create_Success(AwsArnParsing_Compile.AwsKmsIdentifier.create_AwsKmsRawResourceIdentifier(_129_r));
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> ParseAmazonDynamodbTableName(Dafny.ISequence<char> identifier) {
      Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsArn, Dafny.ISequence<char>> _130_valueOrError0 = AwsArnParsing_Compile.__default.ParseAmazonDynamodbTableArn(identifier);
      if ((_130_valueOrError0).IsFailure()) {
        return (_130_valueOrError0).PropagateFailure<Dafny.ISequence<char>>();
      } else {
        AwsArnParsing_Compile._IAwsArn _131_arn = (_130_valueOrError0).Extract();
        AwsArnParsing_Compile._IAmazonDynamodbTableName _132_tableArn = AwsArnParsing_Compile.AmazonDynamodbTableName.create(_131_arn);
        Dafny.ISequence<char> _133_tableName = (_132_tableArn).GetTableName();
        return Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.create_Success(_133_tableName);
      }
    }
    public static bool IsMultiRegionAwsKmsArn(AwsArnParsing_Compile._IAwsArn arn) {
      return AwsArnParsing_Compile.__default.IsMultiRegionAwsKmsResource((arn).dtor_resource);
    }
    public static bool IsMultiRegionAwsKmsIdentifier(AwsArnParsing_Compile._IAwsKmsIdentifier identifier) {
      AwsArnParsing_Compile._IAwsKmsIdentifier _source11 = identifier;
      if (_source11.is_AwsKmsArnIdentifier) {
        AwsArnParsing_Compile._IAwsArn _134___mcc_h0 = _source11.dtor_a;
        AwsArnParsing_Compile._IAwsArn _135_arn = _134___mcc_h0;
        return AwsArnParsing_Compile.__default.IsMultiRegionAwsKmsArn(_135_arn);
      } else {
        AwsArnParsing_Compile._IAwsResource _136___mcc_h1 = _source11.dtor_r;
        AwsArnParsing_Compile._IAwsResource _137_r = _136___mcc_h1;
        return AwsArnParsing_Compile.__default.IsMultiRegionAwsKmsResource(_137_r);
      }
    }
    public static bool IsMultiRegionAwsKmsResource(AwsArnParsing_Compile._IAwsResource resource) {
      return (((resource).dtor_resourceType).Equals(Dafny.Sequence<char>.FromString("key"))) && (Dafny.Sequence<char>.IsPrefixOf(Dafny.Sequence<char>.FromString("mrk-"), (resource).dtor_value));
    }
    public static Wrappers_Compile._IOption<Dafny.ISequence<char>> GetRegion(AwsArnParsing_Compile._IAwsKmsIdentifier identifier) {
      AwsArnParsing_Compile._IAwsKmsIdentifier _source12 = identifier;
      if (_source12.is_AwsKmsArnIdentifier) {
        AwsArnParsing_Compile._IAwsArn _138___mcc_h0 = _source12.dtor_a;
        AwsArnParsing_Compile._IAwsArn _139_a = _138___mcc_h0;
        return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some((_139_a).dtor_region);
      } else {
        AwsArnParsing_Compile._IAwsResource _140___mcc_h1 = _source12.dtor_r;
        return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None();
      }
    }
    public static Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsKmsIdentifier, Dafny.ISequence<char>> IsAwsKmsIdentifierString(Dafny.ISequence<char> s) {
      Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _141_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(UTF8.__default.IsASCIIString(s), Dafny.Sequence<char>.FromString("Not a valid ASCII string."));
      if ((_141_valueOrError0).IsFailure()) {
        return (_141_valueOrError0).PropagateFailure<AwsArnParsing_Compile._IAwsKmsIdentifier>();
      } else {
        Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _142_valueOrError1 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(((new BigInteger((s).Count)).Sign == 1) && ((new BigInteger((s).Count)) <= (AwsArnParsing_Compile.__default.MAX__AWS__KMS__IDENTIFIER__LENGTH)), Dafny.Sequence<char>.FromString("Identifier exceeds maximum length."));
        if ((_142_valueOrError1).IsFailure()) {
          return (_142_valueOrError1).PropagateFailure<AwsArnParsing_Compile._IAwsKmsIdentifier>();
        } else {
          return AwsArnParsing_Compile.__default.ParseAwsKmsIdentifier(s);
        }
      }
    }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IError Error(Dafny.ISequence<char> s) {
      return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(s);
    }
    public static Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> ValidateDdbTableArn(Dafny.ISequence<char> tableArn) {
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _143_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(AwsArnParsing_Compile.__default.ParseAmazonDynamodbTableName(tableArn), AwsArnParsing_Compile.__default.Error);
      if ((_143_valueOrError0).IsFailure()) {
        return (_143_valueOrError0).PropagateFailure<_System._ITuple0>();
      } else {
        Dafny.ISequence<char> _144___v1 = (_143_valueOrError0).Extract();
        Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _145_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.IsASCIIString(tableArn), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Table Arn is not ASCII")));
        if ((_145_valueOrError1).IsFailure()) {
          return (_145_valueOrError1).PropagateFailure<_System._ITuple0>();
        } else {
          Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _146_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(software.amazon.cryptography.services.dynamodb.internaldafny.types.__default.IsValid__TableName((AwsArnParsing_Compile.__default.ParseAmazonDynamodbTableName(tableArn)).dtor_value), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Table Name is too long")));
          if ((_146_valueOrError2).IsFailure()) {
            return (_146_valueOrError2).PropagateFailure<_System._ITuple0>();
          } else {
            return Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_System.Tuple0.create());
          }
        }
      }
    }
    public static BigInteger MAX__AWS__KMS__IDENTIFIER__LENGTH { get {
      return new BigInteger(2048);
    } }
  }
} // end of namespace AwsArnParsing_Compile
namespace AwsKmsMrkAreUnique_Compile {

  public partial class __default {
    public static Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> AwsKmsMrkAreUnique(Dafny.ISequence<AwsArnParsing_Compile._IAwsKmsIdentifier> identifiers) {
      Dafny.ISequence<AwsArnParsing_Compile._IAwsKmsIdentifier> _147_mrks = Seq_Compile.__default.Filter<AwsArnParsing_Compile._IAwsKmsIdentifier>(AwsArnParsing_Compile.__default.IsMultiRegionAwsKmsIdentifier, identifiers);
      if ((new BigInteger((_147_mrks).Count)).Sign == 0) {
        return Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Pass();
      } else {
        Dafny.ISequence<Dafny.ISequence<char>> _148_mrkKeyIds = Seq_Compile.__default.Map<AwsArnParsing_Compile._IAwsKmsIdentifier, Dafny.ISequence<char>>(AwsKmsMrkAreUnique_Compile.__default.GetKeyId, _147_mrks);
        Dafny.ISet<Dafny.ISequence<char>> _149_setMrks = Seq_Compile.__default.ToSet<Dafny.ISequence<char>>(_148_mrkKeyIds);
        if ((new BigInteger((_148_mrkKeyIds).Count)) == (new BigInteger((_149_setMrks).Count))) {
          return Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Pass();
        } else {
          Dafny.ISet<Dafny.ISequence<char>> _150_duplicateMrkIds = Dafny.Helpers.Id<Func<Dafny.ISequence<Dafny.ISequence<char>>, Dafny.ISet<Dafny.ISequence<char>>>>((_151_mrkKeyIds) => ((System.Func<Dafny.ISet<Dafny.ISequence<char>>>)(() => {
            var _coll0 = new System.Collections.Generic.List<Dafny.ISequence<char>>();
            foreach (Dafny.ISequence<char> _compr_0 in (_151_mrkKeyIds).Elements) {
              Dafny.ISequence<char> _152_x = (Dafny.ISequence<char>)_compr_0;
              if (((_151_mrkKeyIds).Contains(_152_x)) && (((Dafny.MultiSet<Dafny.ISequence<char>>.FromSeq(_151_mrkKeyIds)).Select(_152_x)) >= (BigInteger.One))) {
                _coll0.Add(_152_x);
              }
            }
            return Dafny.Set<Dafny.ISequence<char>>.FromCollection(_coll0);
          }))())(_148_mrkKeyIds);
          Func<AwsArnParsing_Compile._IAwsKmsIdentifier, bool> _153_isDuplicate = Dafny.Helpers.Id<Func<Dafny.ISet<Dafny.ISequence<char>>, Func<AwsArnParsing_Compile._IAwsKmsIdentifier, bool>>>((_154_duplicateMrkIds) => ((System.Func<AwsArnParsing_Compile._IAwsKmsIdentifier, bool>)((_155_identifier) => {
            return (_154_duplicateMrkIds).Contains(AwsKmsMrkAreUnique_Compile.__default.GetKeyId(_155_identifier));
          })))(_150_duplicateMrkIds);
          Func<AwsArnParsing_Compile._IAwsKmsIdentifier, Dafny.ISequence<char>> _156_identifierToString = ((System.Func<AwsArnParsing_Compile._IAwsKmsIdentifier, Dafny.ISequence<char>>)((_157_i) => {
            return (_157_i)._ToString();
          }));
          Dafny.ISequence<AwsArnParsing_Compile._IAwsKmsIdentifier> _158_duplicateIdentifiers = Seq_Compile.__default.Filter<AwsArnParsing_Compile._IAwsKmsIdentifier>(_153_isDuplicate, identifiers);
          Dafny.ISequence<Dafny.ISequence<char>> _159_duplicates = Seq_Compile.__default.Map<AwsArnParsing_Compile._IAwsKmsIdentifier, Dafny.ISequence<char>>(_156_identifierToString, _158_duplicateIdentifiers);
          if ((new BigInteger((_159_duplicates).Count)).Sign == 0) {
            return Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Fail(software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Impossible")));
          } else {
            return Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Fail(software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Related multi-Region keys: "), StandardLibrary_Compile.__default.Join<char>(_159_duplicates, Dafny.Sequence<char>.FromString(","))), Dafny.Sequence<char>.FromString("are not allowed."))));
          }
        }
      }
    }
    public static Dafny.ISequence<char> GetKeyId(AwsArnParsing_Compile._IAwsKmsIdentifier identifier) {
      AwsArnParsing_Compile._IAwsKmsIdentifier _source13 = identifier;
      if (_source13.is_AwsKmsArnIdentifier) {
        AwsArnParsing_Compile._IAwsArn _160___mcc_h0 = _source13.dtor_a;
        AwsArnParsing_Compile._IAwsArn _161_a = _160___mcc_h0;
        return ((_161_a).dtor_resource).dtor_value;
      } else {
        AwsArnParsing_Compile._IAwsResource _162___mcc_h1 = _source13.dtor_r;
        AwsArnParsing_Compile._IAwsResource _163_i = _162___mcc_h1;
        return (_163_i).dtor_value;
      }
    }
  }
} // end of namespace AwsKmsMrkAreUnique_Compile
namespace AwsKmsMrkMatchForDecrypt_Compile {

  public partial class __default {
    public static bool AwsKmsMrkMatchForDecrypt(AwsArnParsing_Compile._IAwsKmsIdentifier configuredAwsKmsIdentifier, AwsArnParsing_Compile._IAwsKmsIdentifier messageAwsKmsIdentifer)
    {
      if (object.Equals(configuredAwsKmsIdentifier, messageAwsKmsIdentifer)) {
        return true;
      } else {
        _System._ITuple2<AwsArnParsing_Compile._IAwsKmsIdentifier, AwsArnParsing_Compile._IAwsKmsIdentifier> _source14 = _System.Tuple2<AwsArnParsing_Compile._IAwsKmsIdentifier, AwsArnParsing_Compile._IAwsKmsIdentifier>.create(messageAwsKmsIdentifer, configuredAwsKmsIdentifier);
        {
          AwsArnParsing_Compile._IAwsKmsIdentifier _164___mcc_h0 = _source14.dtor__0;
          AwsArnParsing_Compile._IAwsKmsIdentifier _165___mcc_h1 = _source14.dtor__1;
          AwsArnParsing_Compile._IAwsKmsIdentifier _source15 = _164___mcc_h0;
          if (_source15.is_AwsKmsArnIdentifier) {
            AwsArnParsing_Compile._IAwsArn _166___mcc_h2 = _source15.dtor_a;
            AwsArnParsing_Compile._IAwsKmsIdentifier _source16 = _165___mcc_h1;
            if (_source16.is_AwsKmsArnIdentifier) {
              AwsArnParsing_Compile._IAwsArn _167___mcc_h4 = _source16.dtor_a;
              AwsArnParsing_Compile._IAwsArn _168_messageAwsKmsArn = _167___mcc_h4;
              AwsArnParsing_Compile._IAwsArn _169_configuredAwsKmsArn = _166___mcc_h2;
              if ((!(AwsArnParsing_Compile.__default.IsMultiRegionAwsKmsArn(_169_configuredAwsKmsArn))) || (!(AwsArnParsing_Compile.__default.IsMultiRegionAwsKmsArn(_168_messageAwsKmsArn)))) {
                return false;
              } else {
                return (((((_168_messageAwsKmsArn).dtor_partition).Equals((_169_configuredAwsKmsArn).dtor_partition)) && (((_168_messageAwsKmsArn).dtor_service).Equals((_169_configuredAwsKmsArn).dtor_service))) && (((_168_messageAwsKmsArn).dtor_account).Equals((_169_configuredAwsKmsArn).dtor_account))) && (object.Equals((_168_messageAwsKmsArn).dtor_resource, (_169_configuredAwsKmsArn).dtor_resource));
              }
            } else {
              AwsArnParsing_Compile._IAwsResource _170___mcc_h6 = _source16.dtor_r;
              return false;
            }
          } else {
            AwsArnParsing_Compile._IAwsResource _171___mcc_h8 = _source15.dtor_r;
            return false;
          }
        }
      }
    }
  }
} // end of namespace AwsKmsMrkMatchForDecrypt_Compile
namespace AwsKmsUtils_Compile {

  public partial class OnDecryptMrkAwareEncryptedDataKeyFilter : Actions_Compile.DeterministicActionWithResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.DeterministicAction<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, Wrappers_Compile._IResult<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public OnDecryptMrkAwareEncryptedDataKeyFilter() {
      this._awsKmsKey = default(AwsArnParsing_Compile._IAwsKmsIdentifier);
      this._providerId = UTF8.ValidUTF8Bytes.Default();
    }
    public void __ctor(AwsArnParsing_Compile._IAwsKmsIdentifier awsKmsKey, Dafny.ISequence<byte> providerId)
    {
      (this)._awsKmsKey = awsKmsKey;
      (this)._providerId = providerId;
    }
    public Wrappers_Compile._IResult<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey edk)
    {
      Wrappers_Compile._IResult<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = Wrappers_Compile.Result<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(false);
      if (!((edk).dtor_keyProviderId).Equals((this).providerId)) {
        res = Wrappers_Compile.Result<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(false);
        return res;
      }
      if (!(UTF8.__default.ValidUTF8Seq((edk).dtor_keyProviderInfo))) {
        res = Wrappers_Compile.Result<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Invalid AWS KMS encoding, provider info is not UTF8.")));
        return res;
      }
      Dafny.ISequence<char> _172_keyId;
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _173_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<char>.Empty);
      _173_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.Decode((edk).dtor_keyProviderInfo), AwsKmsUtils_Compile.__default.WrapStringToError);
      if ((_173_valueOrError0).IsFailure()) {
        res = (_173_valueOrError0).PropagateFailure<bool>();
        return res;
      }
      _172_keyId = (_173_valueOrError0).Extract();
      AwsArnParsing_Compile._IAwsArn _174_arn;
      Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsArn, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _175_valueOrError1 = default(Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsArn, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      _175_valueOrError1 = Wrappers_Compile.Result<AwsArnParsing_Compile._IAwsArn, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(AwsArnParsing_Compile.__default.ParseAwsKmsArn(_172_keyId), AwsKmsUtils_Compile.__default.WrapStringToError);
      if ((_175_valueOrError1).IsFailure()) {
        res = (_175_valueOrError1).PropagateFailure<bool>();
        return res;
      }
      _174_arn = (_175_valueOrError1).Extract();
      res = Wrappers_Compile.Result<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(AwsKmsMrkMatchForDecrypt_Compile.__default.AwsKmsMrkMatchForDecrypt((this).awsKmsKey, AwsArnParsing_Compile.AwsKmsIdentifier.create_AwsKmsArnIdentifier(_174_arn)));
      return res;
      return res;
    }
    public AwsArnParsing_Compile._IAwsKmsIdentifier _awsKmsKey {get; set;}
    public AwsArnParsing_Compile._IAwsKmsIdentifier awsKmsKey { get {
      return this._awsKmsKey;
    } }
    public Dafny.ISequence<byte> _providerId {get; set;}
    public Dafny.ISequence<byte> providerId { get {
      return this._providerId;
    } }
  }

  public partial class __default {
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> StringifyEncryptionContext(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> utf8EncCtx) {
      if ((new BigInteger((utf8EncCtx).Count)).Sign == 0) {
        return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.FromElements());
      } else {
        Dafny.IMap<Dafny.ISequence<byte>,Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<char>, Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> _176_stringifyResults = Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.IMap<Dafny.ISequence<byte>,Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<char>, Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>>>((_177_utf8EncCtx) => ((System.Func<Dafny.IMap<Dafny.ISequence<byte>,Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<char>, Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>>)(() => {
          var _coll1 = new System.Collections.Generic.List<Dafny.Pair<Dafny.ISequence<byte>,Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<char>, Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>>();
          foreach (Dafny.ISequence<byte> _compr_1 in ((_177_utf8EncCtx).Keys).Elements) {
            Dafny.ISequence<byte> _178_utf8Key = (Dafny.ISequence<byte>)_compr_1;
            if (((_177_utf8EncCtx).Keys).Contains(_178_utf8Key)) {
              _coll1.Add(new Dafny.Pair<Dafny.ISequence<byte>,Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<char>, Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>(_178_utf8Key, AwsKmsUtils_Compile.__default.StringifyEncryptionContextPair(_178_utf8Key, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(_177_utf8EncCtx,_178_utf8Key))));
            }
          }
          return Dafny.Map<Dafny.ISequence<byte>,Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<char>, Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>.FromCollection(_coll1);
        }))())(utf8EncCtx);
        if (Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<byte>,Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<char>, Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>, bool>>((_179_stringifyResults) => Dafny.Helpers.Quantifier<Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<char>, Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>(((_179_stringifyResults).Values).Elements, false, (((_exists_var_0) => {
          Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<char>, Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _180_r = (Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<char>, Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)_exists_var_0;
          return (((_179_stringifyResults).Values).Contains(_180_r)) && ((_180_r).is_Failure);
        }))))(_176_stringifyResults)) {
          return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Encryption context contains invalid UTF8")));
        } else {
          bool _181_stringKeysUnique = Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<byte>,Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<char>, Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>, bool>>((_182_stringifyResults) => Dafny.Helpers.Quantifier<Dafny.ISequence<byte>>((_182_stringifyResults).Keys.Elements, true, (((_forall_var_4) => {
            Dafny.ISequence<byte> _183_k = (Dafny.ISequence<byte>)_forall_var_4;
            return Dafny.Helpers.Quantifier<Dafny.ISequence<byte>>((_182_stringifyResults).Keys.Elements, true, (((_forall_var_5) => {
              Dafny.ISequence<byte> _184_k_k = (Dafny.ISequence<byte>)_forall_var_5;
              return !(((_182_stringifyResults).Contains(_183_k)) && ((_182_stringifyResults).Contains(_184_k_k))) || (!(!(_183_k).Equals(_184_k_k)) || (!(((Dafny.Map<Dafny.ISequence<byte>, Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<char>, Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>.Select(_182_stringifyResults,_183_k)).dtor_value).dtor__0).Equals(((Dafny.Map<Dafny.ISequence<byte>, Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<char>, Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>.Select(_182_stringifyResults,_184_k_k)).dtor_value).dtor__0)));
            })));
          }))))(_176_stringifyResults);
          if (!(_181_stringKeysUnique)) {
            return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Encryption context keys are not unique")));
          } else {
            return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<byte>,Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<char>, Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>>((_185_stringifyResults) => ((System.Func<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>)(() => {
  var _coll2 = new System.Collections.Generic.List<Dafny.Pair<Dafny.ISequence<char>,Dafny.ISequence<char>>>();
  foreach (Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<char>, Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _compr_2 in ((_185_stringifyResults).Values).Elements) {
    Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<char>, Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _186_r = (Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<char>, Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)_compr_2;
    if (((_185_stringifyResults).Values).Contains(_186_r)) {
      _coll2.Add(new Dafny.Pair<Dafny.ISequence<char>,Dafny.ISequence<char>>(((_186_r).dtor_value).dtor__0, ((_186_r).dtor_value).dtor__1));
    }
  }
  return Dafny.Map<Dafny.ISequence<char>,Dafny.ISequence<char>>.FromCollection(_coll2);
}))())(_176_stringifyResults));
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<char>, Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> StringifyEncryptionContextPair(Dafny.ISequence<byte> utf8Key, Dafny.ISequence<byte> utf8Value)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _187_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.Decode(utf8Key), AwsKmsUtils_Compile.__default.WrapStringToError);
      if ((_187_valueOrError0).IsFailure()) {
        return (_187_valueOrError0).PropagateFailure<_System._ITuple2<Dafny.ISequence<char>, Dafny.ISequence<char>>>();
      } else {
        Dafny.ISequence<char> _188_key = (_187_valueOrError0).Extract();
        Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _189_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.Decode(utf8Value), AwsKmsUtils_Compile.__default.WrapStringToError);
        if ((_189_valueOrError1).IsFailure()) {
          return (_189_valueOrError1).PropagateFailure<_System._ITuple2<Dafny.ISequence<char>, Dafny.ISequence<char>>>();
        } else {
          Dafny.ISequence<char> _190_value = (_189_valueOrError1).Extract();
          return Wrappers_Compile.Result<_System._ITuple2<Dafny.ISequence<char>, Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_System.Tuple2<Dafny.ISequence<char>, Dafny.ISequence<char>>.create(_188_key, _190_value));
        }
      }
    }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IError WrapStringToError(Dafny.ISequence<char> e) {
      return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(e);
    }
    public static Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> ValidateKmsKeyId(Dafny.ISequence<char> keyId) {
      Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsKmsIdentifier, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _191_valueOrError0 = Wrappers_Compile.Result<AwsArnParsing_Compile._IAwsKmsIdentifier, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(AwsArnParsing_Compile.__default.ParseAwsKmsIdentifier(keyId), AwsKmsUtils_Compile.__default.WrapStringToError);
      if ((_191_valueOrError0).IsFailure()) {
        return (_191_valueOrError0).PropagateFailure<_System._ITuple0>();
      } else {
        AwsArnParsing_Compile._IAwsKmsIdentifier _192___v0 = (_191_valueOrError0).Extract();
        Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _193_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.IsASCIIString(keyId), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Key identifier is not ASCII")));
        if ((_193_valueOrError1).IsFailure()) {
          return (_193_valueOrError1).PropagateFailure<_System._ITuple0>();
        } else {
          Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _194_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((new BigInteger((keyId).Count)).Sign == 1) && ((new BigInteger((keyId).Count)) <= (AwsArnParsing_Compile.__default.MAX__AWS__KMS__IDENTIFIER__LENGTH)), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Key identifier is too long")));
          if ((_194_valueOrError2).IsFailure()) {
            return (_194_valueOrError2).PropagateFailure<_System._ITuple0>();
          } else {
            return Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_System.Tuple0.create());
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetValidGrantTokens(Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens) {
      Dafny.ISequence<Dafny.ISequence<char>> _195_tokens = Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.UnwrapOr(grantTokens, Dafny.Sequence<Dafny.ISequence<char>>.FromElements());
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _196_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((new BigInteger((_195_tokens).Count)).Sign != -1) && ((new BigInteger((_195_tokens).Count)) <= (new BigInteger(10))), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Grant token list can have no more than 10 tokens")));
      if ((_196_valueOrError0).IsFailure()) {
        return (_196_valueOrError0).PropagateFailure<Dafny.ISequence<Dafny.ISequence<char>>>();
      } else {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _197_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Dafny.Helpers.Id<Func<Dafny.ISequence<Dafny.ISequence<char>>, bool>>((_198_tokens) => Dafny.Helpers.Quantifier<Dafny.ISequence<char>>((_198_tokens).UniqueElements, true, (((_forall_var_6) => {
          Dafny.ISequence<char> _199_token = (Dafny.ISequence<char>)_forall_var_6;
          return !((_198_tokens).Contains(_199_token)) || (((BigInteger.One) <= (new BigInteger((_199_token).Count))) && ((new BigInteger((_199_token).Count)) <= (new BigInteger(8192))));
        }))))(_195_tokens), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Grant token list contains a grant token with invalid length")));
        if ((_197_valueOrError1).IsFailure()) {
          return (_197_valueOrError1).PropagateFailure<Dafny.ISequence<Dafny.ISequence<char>>>();
        } else {
          return Wrappers_Compile.Result<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_195_tokens);
        }
      }
    }
    public static Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> ParseKeyNamespaceAndName(Dafny.ISequence<char> keyNamespace, Dafny.ISequence<char> keyName)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _200_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.Encode(keyNamespace), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_201_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Key namespace could not be UTF8-encoded"), _201_e));
      })));
      if ((_200_valueOrError0).IsFailure()) {
        return (_200_valueOrError0).PropagateFailure<_System._ITuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>();
      } else {
        Dafny.ISequence<byte> _202_namespace = (_200_valueOrError0).Extract();
        Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _203_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger((_202_namespace).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Key namespace too long")));
        if ((_203_valueOrError1).IsFailure()) {
          return (_203_valueOrError1).PropagateFailure<_System._ITuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>();
        } else {
          Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _204_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.Encode(keyName), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_205_e) => {
            return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Key name could not be UTF8-encoded"), _205_e));
          })));
          if ((_204_valueOrError2).IsFailure()) {
            return (_204_valueOrError2).PropagateFailure<_System._ITuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>();
          } else {
            Dafny.ISequence<byte> _206_name = (_204_valueOrError2).Extract();
            Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _207_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger((_206_name).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Key name too long")));
            if ((_207_valueOrError3).IsFailure()) {
              return (_207_valueOrError3).PropagateFailure<_System._ITuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>>();
            } else {
              return Wrappers_Compile.Result<_System._ITuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.create(_202_namespace, _206_name));
            }
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> ValidateDiscoveryFilter(software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter filter) {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _208_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger(((filter).dtor_accountIds).Count)).Sign == 1, software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Discovery filter must have at least one account ID")));
      if ((_208_valueOrError0).IsFailure()) {
        return (_208_valueOrError0).PropagateFailure<_System._ITuple0>();
      } else {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _209_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Dafny.Helpers.Id<Func<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter, bool>>((_210_filter) => Dafny.Helpers.Quantifier<Dafny.ISequence<char>>(((_210_filter).dtor_accountIds).UniqueElements, true, (((_forall_var_7) => {
          Dafny.ISequence<char> _211_accountId = (Dafny.ISequence<char>)_forall_var_7;
          return !(((_210_filter).dtor_accountIds).Contains(_211_accountId)) || ((new BigInteger((_211_accountId).Count)).Sign == 1);
        }))))(filter), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Discovery filter account IDs cannot be blank")));
        if ((_209_valueOrError1).IsFailure()) {
          return (_209_valueOrError1).PropagateFailure<_System._ITuple0>();
        } else {
          Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _212_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger(((filter).dtor_partition).Count)).Sign == 1, software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Discovery filter partition cannot be blank")));
          if ((_212_valueOrError2).IsFailure()) {
            return (_212_valueOrError2).PropagateFailure<_System._ITuple0>();
          } else {
            return Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_System.Tuple0.create());
          }
        }
      }
    }
  }
} // end of namespace AwsKmsUtils_Compile
namespace Constants_Compile {

  public partial class AwsKmsEncryptedDataKey {
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>(software.amazon.cryptography.materialproviders.internaldafny.types.EncryptedDataKey.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public interface _IAwsKmsEdkHelper {
    bool is_AwsKmsEdkHelper { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey dtor_edk { get; }
    AwsArnParsing_Compile._IAwsArn dtor_arn { get; }
    _IAwsKmsEdkHelper DowncastClone();
  }
  public class AwsKmsEdkHelper : _IAwsKmsEdkHelper {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey _edk;
    public readonly AwsArnParsing_Compile._IAwsArn _arn;
    public AwsKmsEdkHelper(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey edk, AwsArnParsing_Compile._IAwsArn arn) {
      this._edk = edk;
      this._arn = arn;
    }
    public _IAwsKmsEdkHelper DowncastClone() {
      if (this is _IAwsKmsEdkHelper dt) { return dt; }
      return new AwsKmsEdkHelper(_edk, _arn);
    }
    public override bool Equals(object other) {
      var oth = other as Constants_Compile.AwsKmsEdkHelper;
      return oth != null && object.Equals(this._edk, oth._edk) && object.Equals(this._arn, oth._arn);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._edk));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._arn));
      return (int) hash;
    }
    public override string ToString() {
      string s = "Constants_Compile.AwsKmsEdkHelper.AwsKmsEdkHelper";
      s += "(";
      s += Dafny.Helpers.ToString(this._edk);
      s += ", ";
      s += Dafny.Helpers.ToString(this._arn);
      s += ")";
      return s;
    }
    private static readonly Constants_Compile._IAwsKmsEdkHelper theDefault = create(software.amazon.cryptography.materialproviders.internaldafny.types.EncryptedDataKey.Default(), AwsArnParsing_Compile.AwsArn.Default());
    public static Constants_Compile._IAwsKmsEdkHelper Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Constants_Compile._IAwsKmsEdkHelper> _TYPE = new Dafny.TypeDescriptor<Constants_Compile._IAwsKmsEdkHelper>(Constants_Compile.AwsKmsEdkHelper.Default());
    public static Dafny.TypeDescriptor<Constants_Compile._IAwsKmsEdkHelper> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IAwsKmsEdkHelper create(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey edk, AwsArnParsing_Compile._IAwsArn arn) {
      return new AwsKmsEdkHelper(edk, arn);
    }
    public static _IAwsKmsEdkHelper create_AwsKmsEdkHelper(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey edk, AwsArnParsing_Compile._IAwsArn arn) {
      return create(edk, arn);
    }
    public bool is_AwsKmsEdkHelper { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey dtor_edk {
      get {
        return this._edk;
      }
    }
    public AwsArnParsing_Compile._IAwsArn dtor_arn {
      get {
        return this._arn;
      }
    }
  }

  public partial class __default {
    public static Dafny.ISequence<byte> PROVIDER__ID { get {
      Dafny.ISequence<byte> _213_s = Dafny.Sequence<byte>.FromElements((byte)(97), (byte)(119), (byte)(115), (byte)(45), (byte)(107), (byte)(109), (byte)(115));
      return _213_s;
    } }
    public static Dafny.ISequence<byte> PROVIDER__ID__HIERARCHY { get {
      Dafny.ISequence<byte> _214_s = Dafny.Sequence<byte>.FromElements((byte)(97), (byte)(119), (byte)(115), (byte)(45), (byte)(107), (byte)(109), (byte)(115), (byte)(45), (byte)(104), (byte)(105), (byte)(101), (byte)(114), (byte)(97), (byte)(114), (byte)(99), (byte)(104), (byte)(121));
      return _214_s;
    } }
    public static Dafny.ISequence<byte> RSA__PROVIDER__ID { get {
      Dafny.ISequence<byte> _215_s = Dafny.Sequence<byte>.FromElements((byte)(97), (byte)(119), (byte)(115), (byte)(45), (byte)(107), (byte)(109), (byte)(115), (byte)(45), (byte)(114), (byte)(115), (byte)(97));
      return _215_s;
    } }
  }
} // end of namespace Constants_Compile
namespace Aws_mCryptography_Compile {

} // end of namespace Aws_mCryptography_Compile
namespace Aws_Compile {

} // end of namespace Aws_Compile
namespace MaterialWrapping_Compile {

  public interface _IGenerateAndWrapInput {
    bool is_GenerateAndWrapInput { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo dtor_algorithmSuite { get; }
    Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext { get; }
    _IGenerateAndWrapInput DowncastClone();
  }
  public class GenerateAndWrapInput : _IGenerateAndWrapInput {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _algorithmSuite;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _encryptionContext;
    public GenerateAndWrapInput(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo algorithmSuite, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      this._algorithmSuite = algorithmSuite;
      this._encryptionContext = encryptionContext;
    }
    public _IGenerateAndWrapInput DowncastClone() {
      if (this is _IGenerateAndWrapInput dt) { return dt; }
      return new GenerateAndWrapInput(_algorithmSuite, _encryptionContext);
    }
    public override bool Equals(object other) {
      var oth = other as MaterialWrapping_Compile.GenerateAndWrapInput;
      return oth != null && object.Equals(this._algorithmSuite, oth._algorithmSuite) && object.Equals(this._encryptionContext, oth._encryptionContext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._algorithmSuite));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptionContext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "MaterialWrapping_Compile.GenerateAndWrapInput.GenerateAndWrapInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._algorithmSuite);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptionContext);
      s += ")";
      return s;
    }
    private static readonly MaterialWrapping_Compile._IGenerateAndWrapInput theDefault = create(software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteInfo.Default(), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty);
    public static MaterialWrapping_Compile._IGenerateAndWrapInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<MaterialWrapping_Compile._IGenerateAndWrapInput> _TYPE = new Dafny.TypeDescriptor<MaterialWrapping_Compile._IGenerateAndWrapInput>(MaterialWrapping_Compile.GenerateAndWrapInput.Default());
    public static Dafny.TypeDescriptor<MaterialWrapping_Compile._IGenerateAndWrapInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGenerateAndWrapInput create(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo algorithmSuite, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      return new GenerateAndWrapInput(algorithmSuite, encryptionContext);
    }
    public static _IGenerateAndWrapInput create_GenerateAndWrapInput(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo algorithmSuite, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      return create(algorithmSuite, encryptionContext);
    }
    public bool is_GenerateAndWrapInput { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo dtor_algorithmSuite {
      get {
        return this._algorithmSuite;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this._encryptionContext;
      }
    }
  }

  public interface _IGenerateAndWrapOutput<T> {
    bool is_GenerateAndWrapOutput { get; }
    Dafny.ISequence<byte> dtor_plaintextMaterial { get; }
    Dafny.ISequence<byte> dtor_wrappedMaterial { get; }
    T dtor_wrapInfo { get; }
    _IGenerateAndWrapOutput<__T> DowncastClone<__T>(Func<T, __T> converter0);
  }
  public class GenerateAndWrapOutput<T> : _IGenerateAndWrapOutput<T> {
    public readonly Dafny.ISequence<byte> _plaintextMaterial;
    public readonly Dafny.ISequence<byte> _wrappedMaterial;
    public readonly T _wrapInfo;
    public GenerateAndWrapOutput(Dafny.ISequence<byte> plaintextMaterial, Dafny.ISequence<byte> wrappedMaterial, T wrapInfo) {
      this._plaintextMaterial = plaintextMaterial;
      this._wrappedMaterial = wrappedMaterial;
      this._wrapInfo = wrapInfo;
    }
    public _IGenerateAndWrapOutput<__T> DowncastClone<__T>(Func<T, __T> converter0) {
      if (this is _IGenerateAndWrapOutput<__T> dt) { return dt; }
      return new GenerateAndWrapOutput<__T>(_plaintextMaterial, _wrappedMaterial, converter0(_wrapInfo));
    }
    public override bool Equals(object other) {
      var oth = other as MaterialWrapping_Compile.GenerateAndWrapOutput<T>;
      return oth != null && object.Equals(this._plaintextMaterial, oth._plaintextMaterial) && object.Equals(this._wrappedMaterial, oth._wrappedMaterial) && object.Equals(this._wrapInfo, oth._wrapInfo);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._plaintextMaterial));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._wrappedMaterial));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._wrapInfo));
      return (int) hash;
    }
    public override string ToString() {
      string s = "MaterialWrapping_Compile.GenerateAndWrapOutput.GenerateAndWrapOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._plaintextMaterial);
      s += ", ";
      s += Dafny.Helpers.ToString(this._wrappedMaterial);
      s += ", ";
      s += Dafny.Helpers.ToString(this._wrapInfo);
      s += ")";
      return s;
    }
    public static MaterialWrapping_Compile._IGenerateAndWrapOutput<T> Default(T _default_T) {
      return create(Dafny.Sequence<byte>.Empty, Dafny.Sequence<byte>.Empty, _default_T);
    }
    public static Dafny.TypeDescriptor<MaterialWrapping_Compile._IGenerateAndWrapOutput<T>> _TypeDescriptor(Dafny.TypeDescriptor<T> _td_T) {
      return new Dafny.TypeDescriptor<MaterialWrapping_Compile._IGenerateAndWrapOutput<T>>(MaterialWrapping_Compile.GenerateAndWrapOutput<T>.Default(_td_T.Default()));
    }
    public static _IGenerateAndWrapOutput<T> create(Dafny.ISequence<byte> plaintextMaterial, Dafny.ISequence<byte> wrappedMaterial, T wrapInfo) {
      return new GenerateAndWrapOutput<T>(plaintextMaterial, wrappedMaterial, wrapInfo);
    }
    public static _IGenerateAndWrapOutput<T> create_GenerateAndWrapOutput(Dafny.ISequence<byte> plaintextMaterial, Dafny.ISequence<byte> wrappedMaterial, T wrapInfo) {
      return create(plaintextMaterial, wrappedMaterial, wrapInfo);
    }
    public bool is_GenerateAndWrapOutput { get { return true; } }
    public Dafny.ISequence<byte> dtor_plaintextMaterial {
      get {
        return this._plaintextMaterial;
      }
    }
    public Dafny.ISequence<byte> dtor_wrappedMaterial {
      get {
        return this._wrappedMaterial;
      }
    }
    public T dtor_wrapInfo {
      get {
        return this._wrapInfo;
      }
    }
  }

  public interface _IWrapInput {
    bool is_WrapInput { get; }
    Dafny.ISequence<byte> dtor_plaintextMaterial { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo dtor_algorithmSuite { get; }
    Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext { get; }
    _IWrapInput DowncastClone();
  }
  public class WrapInput : _IWrapInput {
    public readonly Dafny.ISequence<byte> _plaintextMaterial;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _algorithmSuite;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _encryptionContext;
    public WrapInput(Dafny.ISequence<byte> plaintextMaterial, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo algorithmSuite, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      this._plaintextMaterial = plaintextMaterial;
      this._algorithmSuite = algorithmSuite;
      this._encryptionContext = encryptionContext;
    }
    public _IWrapInput DowncastClone() {
      if (this is _IWrapInput dt) { return dt; }
      return new WrapInput(_plaintextMaterial, _algorithmSuite, _encryptionContext);
    }
    public override bool Equals(object other) {
      var oth = other as MaterialWrapping_Compile.WrapInput;
      return oth != null && object.Equals(this._plaintextMaterial, oth._plaintextMaterial) && object.Equals(this._algorithmSuite, oth._algorithmSuite) && object.Equals(this._encryptionContext, oth._encryptionContext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._plaintextMaterial));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._algorithmSuite));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptionContext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "MaterialWrapping_Compile.WrapInput.WrapInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._plaintextMaterial);
      s += ", ";
      s += Dafny.Helpers.ToString(this._algorithmSuite);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptionContext);
      s += ")";
      return s;
    }
    private static readonly MaterialWrapping_Compile._IWrapInput theDefault = create(Dafny.Sequence<byte>.Empty, software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteInfo.Default(), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty);
    public static MaterialWrapping_Compile._IWrapInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<MaterialWrapping_Compile._IWrapInput> _TYPE = new Dafny.TypeDescriptor<MaterialWrapping_Compile._IWrapInput>(MaterialWrapping_Compile.WrapInput.Default());
    public static Dafny.TypeDescriptor<MaterialWrapping_Compile._IWrapInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IWrapInput create(Dafny.ISequence<byte> plaintextMaterial, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo algorithmSuite, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      return new WrapInput(plaintextMaterial, algorithmSuite, encryptionContext);
    }
    public static _IWrapInput create_WrapInput(Dafny.ISequence<byte> plaintextMaterial, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo algorithmSuite, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      return create(plaintextMaterial, algorithmSuite, encryptionContext);
    }
    public bool is_WrapInput { get { return true; } }
    public Dafny.ISequence<byte> dtor_plaintextMaterial {
      get {
        return this._plaintextMaterial;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo dtor_algorithmSuite {
      get {
        return this._algorithmSuite;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this._encryptionContext;
      }
    }
  }

  public interface _IWrapOutput<T> {
    bool is_WrapOutput { get; }
    Dafny.ISequence<byte> dtor_wrappedMaterial { get; }
    T dtor_wrapInfo { get; }
    _IWrapOutput<__T> DowncastClone<__T>(Func<T, __T> converter0);
  }
  public class WrapOutput<T> : _IWrapOutput<T> {
    public readonly Dafny.ISequence<byte> _wrappedMaterial;
    public readonly T _wrapInfo;
    public WrapOutput(Dafny.ISequence<byte> wrappedMaterial, T wrapInfo) {
      this._wrappedMaterial = wrappedMaterial;
      this._wrapInfo = wrapInfo;
    }
    public _IWrapOutput<__T> DowncastClone<__T>(Func<T, __T> converter0) {
      if (this is _IWrapOutput<__T> dt) { return dt; }
      return new WrapOutput<__T>(_wrappedMaterial, converter0(_wrapInfo));
    }
    public override bool Equals(object other) {
      var oth = other as MaterialWrapping_Compile.WrapOutput<T>;
      return oth != null && object.Equals(this._wrappedMaterial, oth._wrappedMaterial) && object.Equals(this._wrapInfo, oth._wrapInfo);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._wrappedMaterial));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._wrapInfo));
      return (int) hash;
    }
    public override string ToString() {
      string s = "MaterialWrapping_Compile.WrapOutput.WrapOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._wrappedMaterial);
      s += ", ";
      s += Dafny.Helpers.ToString(this._wrapInfo);
      s += ")";
      return s;
    }
    public static MaterialWrapping_Compile._IWrapOutput<T> Default(T _default_T) {
      return create(Dafny.Sequence<byte>.Empty, _default_T);
    }
    public static Dafny.TypeDescriptor<MaterialWrapping_Compile._IWrapOutput<T>> _TypeDescriptor(Dafny.TypeDescriptor<T> _td_T) {
      return new Dafny.TypeDescriptor<MaterialWrapping_Compile._IWrapOutput<T>>(MaterialWrapping_Compile.WrapOutput<T>.Default(_td_T.Default()));
    }
    public static _IWrapOutput<T> create(Dafny.ISequence<byte> wrappedMaterial, T wrapInfo) {
      return new WrapOutput<T>(wrappedMaterial, wrapInfo);
    }
    public static _IWrapOutput<T> create_WrapOutput(Dafny.ISequence<byte> wrappedMaterial, T wrapInfo) {
      return create(wrappedMaterial, wrapInfo);
    }
    public bool is_WrapOutput { get { return true; } }
    public Dafny.ISequence<byte> dtor_wrappedMaterial {
      get {
        return this._wrappedMaterial;
      }
    }
    public T dtor_wrapInfo {
      get {
        return this._wrapInfo;
      }
    }
  }

  public interface _IUnwrapInput {
    bool is_UnwrapInput { get; }
    Dafny.ISequence<byte> dtor_wrappedMaterial { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo dtor_algorithmSuite { get; }
    Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext { get; }
    _IUnwrapInput DowncastClone();
  }
  public class UnwrapInput : _IUnwrapInput {
    public readonly Dafny.ISequence<byte> _wrappedMaterial;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _algorithmSuite;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _encryptionContext;
    public UnwrapInput(Dafny.ISequence<byte> wrappedMaterial, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo algorithmSuite, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      this._wrappedMaterial = wrappedMaterial;
      this._algorithmSuite = algorithmSuite;
      this._encryptionContext = encryptionContext;
    }
    public _IUnwrapInput DowncastClone() {
      if (this is _IUnwrapInput dt) { return dt; }
      return new UnwrapInput(_wrappedMaterial, _algorithmSuite, _encryptionContext);
    }
    public override bool Equals(object other) {
      var oth = other as MaterialWrapping_Compile.UnwrapInput;
      return oth != null && object.Equals(this._wrappedMaterial, oth._wrappedMaterial) && object.Equals(this._algorithmSuite, oth._algorithmSuite) && object.Equals(this._encryptionContext, oth._encryptionContext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._wrappedMaterial));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._algorithmSuite));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptionContext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "MaterialWrapping_Compile.UnwrapInput.UnwrapInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._wrappedMaterial);
      s += ", ";
      s += Dafny.Helpers.ToString(this._algorithmSuite);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptionContext);
      s += ")";
      return s;
    }
    private static readonly MaterialWrapping_Compile._IUnwrapInput theDefault = create(Dafny.Sequence<byte>.Empty, software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteInfo.Default(), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty);
    public static MaterialWrapping_Compile._IUnwrapInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<MaterialWrapping_Compile._IUnwrapInput> _TYPE = new Dafny.TypeDescriptor<MaterialWrapping_Compile._IUnwrapInput>(MaterialWrapping_Compile.UnwrapInput.Default());
    public static Dafny.TypeDescriptor<MaterialWrapping_Compile._IUnwrapInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IUnwrapInput create(Dafny.ISequence<byte> wrappedMaterial, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo algorithmSuite, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      return new UnwrapInput(wrappedMaterial, algorithmSuite, encryptionContext);
    }
    public static _IUnwrapInput create_UnwrapInput(Dafny.ISequence<byte> wrappedMaterial, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo algorithmSuite, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      return create(wrappedMaterial, algorithmSuite, encryptionContext);
    }
    public bool is_UnwrapInput { get { return true; } }
    public Dafny.ISequence<byte> dtor_wrappedMaterial {
      get {
        return this._wrappedMaterial;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo dtor_algorithmSuite {
      get {
        return this._algorithmSuite;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this._encryptionContext;
      }
    }
  }

  public interface _IUnwrapOutput<T> {
    bool is_UnwrapOutput { get; }
    Dafny.ISequence<byte> dtor_unwrappedMaterial { get; }
    T dtor_unwrapInfo { get; }
    _IUnwrapOutput<__T> DowncastClone<__T>(Func<T, __T> converter0);
  }
  public class UnwrapOutput<T> : _IUnwrapOutput<T> {
    public readonly Dafny.ISequence<byte> _unwrappedMaterial;
    public readonly T _unwrapInfo;
    public UnwrapOutput(Dafny.ISequence<byte> unwrappedMaterial, T unwrapInfo) {
      this._unwrappedMaterial = unwrappedMaterial;
      this._unwrapInfo = unwrapInfo;
    }
    public _IUnwrapOutput<__T> DowncastClone<__T>(Func<T, __T> converter0) {
      if (this is _IUnwrapOutput<__T> dt) { return dt; }
      return new UnwrapOutput<__T>(_unwrappedMaterial, converter0(_unwrapInfo));
    }
    public override bool Equals(object other) {
      var oth = other as MaterialWrapping_Compile.UnwrapOutput<T>;
      return oth != null && object.Equals(this._unwrappedMaterial, oth._unwrappedMaterial) && object.Equals(this._unwrapInfo, oth._unwrapInfo);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._unwrappedMaterial));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._unwrapInfo));
      return (int) hash;
    }
    public override string ToString() {
      string s = "MaterialWrapping_Compile.UnwrapOutput.UnwrapOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._unwrappedMaterial);
      s += ", ";
      s += Dafny.Helpers.ToString(this._unwrapInfo);
      s += ")";
      return s;
    }
    public static MaterialWrapping_Compile._IUnwrapOutput<T> Default(T _default_T) {
      return create(Dafny.Sequence<byte>.Empty, _default_T);
    }
    public static Dafny.TypeDescriptor<MaterialWrapping_Compile._IUnwrapOutput<T>> _TypeDescriptor(Dafny.TypeDescriptor<T> _td_T) {
      return new Dafny.TypeDescriptor<MaterialWrapping_Compile._IUnwrapOutput<T>>(MaterialWrapping_Compile.UnwrapOutput<T>.Default(_td_T.Default()));
    }
    public static _IUnwrapOutput<T> create(Dafny.ISequence<byte> unwrappedMaterial, T unwrapInfo) {
      return new UnwrapOutput<T>(unwrappedMaterial, unwrapInfo);
    }
    public static _IUnwrapOutput<T> create_UnwrapOutput(Dafny.ISequence<byte> unwrappedMaterial, T unwrapInfo) {
      return create(unwrappedMaterial, unwrapInfo);
    }
    public bool is_UnwrapOutput { get { return true; } }
    public Dafny.ISequence<byte> dtor_unwrappedMaterial {
      get {
        return this._unwrappedMaterial;
      }
    }
    public T dtor_unwrapInfo {
      get {
        return this._unwrapInfo;
      }
    }
  }

  public interface GenerateAndWrapMaterial<T> : Actions_Compile.ActionWithResult<MaterialWrapping_Compile._IGenerateAndWrapInput, MaterialWrapping_Compile._IGenerateAndWrapOutput<T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<MaterialWrapping_Compile._IGenerateAndWrapInput, Wrappers_Compile._IResult<MaterialWrapping_Compile._IGenerateAndWrapOutput<T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
  }
  public class _Companion_GenerateAndWrapMaterial<T> {
  }

  public interface WrapMaterial<T> : Actions_Compile.ActionWithResult<MaterialWrapping_Compile._IWrapInput, MaterialWrapping_Compile._IWrapOutput<T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<MaterialWrapping_Compile._IWrapInput, Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
  }
  public class _Companion_WrapMaterial<T> {
  }

  public interface UnwrapMaterial<T> : Actions_Compile.ActionWithResult<MaterialWrapping_Compile._IUnwrapInput, MaterialWrapping_Compile._IUnwrapOutput<T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<MaterialWrapping_Compile._IUnwrapInput, Wrappers_Compile._IResult<MaterialWrapping_Compile._IUnwrapOutput<T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
  }
  public class _Companion_UnwrapMaterial<T> {
  }

} // end of namespace MaterialWrapping_Compile
namespace CanonicalEncryptionContext_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> EncryptionContextToAAD(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _216_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger((encryptionContext).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Encryption Context is too large")));
      if ((_216_valueOrError0).IsFailure()) {
        return (_216_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
      } else {
        Dafny.ISequence<Dafny.ISequence<byte>> _217_keys = StandardLibrary_Compile.__default.SetToOrderedSequence<byte>((encryptionContext).Keys, StandardLibrary_mUInt_Compile.__default.UInt8Less);
        if ((new BigInteger((_217_keys).Count)).Sign == 0) {
          return Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(Dafny.Sequence<byte>.FromElements());
        } else {
          Func<Dafny.ISequence<byte>, Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> _218_KeyIntoPairBytes = Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Func<Dafny.ISequence<byte>, Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>>>((_219_encryptionContext) => ((System.Func<Dafny.ISequence<byte>, Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>)((_220_k) => {
            return Dafny.Helpers.Let<Dafny.ISequence<byte>, Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(_219_encryptionContext,_220_k), _pat_let6_0 => Dafny.Helpers.Let<Dafny.ISequence<byte>, Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>(_pat_let6_0, _221_v => Dafny.Helpers.Let<Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>(Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((StandardLibrary_mUInt_Compile.__default.HasUint16Len<byte>(_220_k)) && (StandardLibrary_mUInt_Compile.__default.HasUint16Len<byte>(_221_v)), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Unable to serialize encryption context"))), _pat_let7_0 => Dafny.Helpers.Let<Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>(_pat_let7_0, _222_valueOrError1 => (((_222_valueOrError1).IsFailure()) ? ((_222_valueOrError1).PropagateFailure<Dafny.ISequence<byte>>()) : (Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)(_220_k).Count), _220_k), StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)(_221_v).Count)), _221_v))))))));
          })))(encryptionContext);
          Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _223_valueOrError2 = Seq_Compile.__default.MapWithResult<Dafny.ISequence<byte>, Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_218_KeyIntoPairBytes, _217_keys);
          if ((_223_valueOrError2).IsFailure()) {
            return (_223_valueOrError2).PropagateFailure<Dafny.ISequence<byte>>();
          } else {
            Dafny.ISequence<Dafny.ISequence<byte>> _224_pairsBytes = (_223_valueOrError2).Extract();
            Dafny.ISequence<byte> _225_allBytes = Dafny.Sequence<byte>.Concat(StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)(_217_keys).Count), Seq_Compile.__default.Flatten<byte>(_224_pairsBytes));
            return Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_225_allBytes);
          }
        }
      }
    }
  }
} // end of namespace CanonicalEncryptionContext_Compile
namespace IntermediateKeyWrapping_Compile {

  public interface _IIntermediateUnwrapOutput<T> {
    bool is_IntermediateUnwrapOutput { get; }
    Dafny.ISequence<byte> dtor_plaintextDataKey { get; }
    Dafny.ISequence<byte> dtor_symmetricSigningKey { get; }
    T dtor_unwrapInfo { get; }
    _IIntermediateUnwrapOutput<__T> DowncastClone<__T>(Func<T, __T> converter0);
  }
  public class IntermediateUnwrapOutput<T> : _IIntermediateUnwrapOutput<T> {
    public readonly Dafny.ISequence<byte> _plaintextDataKey;
    public readonly Dafny.ISequence<byte> _symmetricSigningKey;
    public readonly T _unwrapInfo;
    public IntermediateUnwrapOutput(Dafny.ISequence<byte> plaintextDataKey, Dafny.ISequence<byte> symmetricSigningKey, T unwrapInfo) {
      this._plaintextDataKey = plaintextDataKey;
      this._symmetricSigningKey = symmetricSigningKey;
      this._unwrapInfo = unwrapInfo;
    }
    public _IIntermediateUnwrapOutput<__T> DowncastClone<__T>(Func<T, __T> converter0) {
      if (this is _IIntermediateUnwrapOutput<__T> dt) { return dt; }
      return new IntermediateUnwrapOutput<__T>(_plaintextDataKey, _symmetricSigningKey, converter0(_unwrapInfo));
    }
    public override bool Equals(object other) {
      var oth = other as IntermediateKeyWrapping_Compile.IntermediateUnwrapOutput<T>;
      return oth != null && object.Equals(this._plaintextDataKey, oth._plaintextDataKey) && object.Equals(this._symmetricSigningKey, oth._symmetricSigningKey) && object.Equals(this._unwrapInfo, oth._unwrapInfo);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._plaintextDataKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._symmetricSigningKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._unwrapInfo));
      return (int) hash;
    }
    public override string ToString() {
      string s = "IntermediateKeyWrapping_Compile.IntermediateUnwrapOutput.IntermediateUnwrapOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._plaintextDataKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this._symmetricSigningKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this._unwrapInfo);
      s += ")";
      return s;
    }
    public static IntermediateKeyWrapping_Compile._IIntermediateUnwrapOutput<T> Default(T _default_T) {
      return create(Dafny.Sequence<byte>.Empty, Dafny.Sequence<byte>.Empty, _default_T);
    }
    public static Dafny.TypeDescriptor<IntermediateKeyWrapping_Compile._IIntermediateUnwrapOutput<T>> _TypeDescriptor(Dafny.TypeDescriptor<T> _td_T) {
      return new Dafny.TypeDescriptor<IntermediateKeyWrapping_Compile._IIntermediateUnwrapOutput<T>>(IntermediateKeyWrapping_Compile.IntermediateUnwrapOutput<T>.Default(_td_T.Default()));
    }
    public static _IIntermediateUnwrapOutput<T> create(Dafny.ISequence<byte> plaintextDataKey, Dafny.ISequence<byte> symmetricSigningKey, T unwrapInfo) {
      return new IntermediateUnwrapOutput<T>(plaintextDataKey, symmetricSigningKey, unwrapInfo);
    }
    public static _IIntermediateUnwrapOutput<T> create_IntermediateUnwrapOutput(Dafny.ISequence<byte> plaintextDataKey, Dafny.ISequence<byte> symmetricSigningKey, T unwrapInfo) {
      return create(plaintextDataKey, symmetricSigningKey, unwrapInfo);
    }
    public bool is_IntermediateUnwrapOutput { get { return true; } }
    public Dafny.ISequence<byte> dtor_plaintextDataKey {
      get {
        return this._plaintextDataKey;
      }
    }
    public Dafny.ISequence<byte> dtor_symmetricSigningKey {
      get {
        return this._symmetricSigningKey;
      }
    }
    public T dtor_unwrapInfo {
      get {
        return this._unwrapInfo;
      }
    }
  }

  public interface _IIntermediateGenerateAndWrapOutput<T> {
    bool is_IntermediateGenerateAndWrapOutput { get; }
    Dafny.ISequence<byte> dtor_plaintextDataKey { get; }
    Dafny.ISequence<byte> dtor_wrappedMaterial { get; }
    Dafny.ISequence<byte> dtor_symmetricSigningKey { get; }
    T dtor_wrapInfo { get; }
    _IIntermediateGenerateAndWrapOutput<__T> DowncastClone<__T>(Func<T, __T> converter0);
  }
  public class IntermediateGenerateAndWrapOutput<T> : _IIntermediateGenerateAndWrapOutput<T> {
    public readonly Dafny.ISequence<byte> _plaintextDataKey;
    public readonly Dafny.ISequence<byte> _wrappedMaterial;
    public readonly Dafny.ISequence<byte> _symmetricSigningKey;
    public readonly T _wrapInfo;
    public IntermediateGenerateAndWrapOutput(Dafny.ISequence<byte> plaintextDataKey, Dafny.ISequence<byte> wrappedMaterial, Dafny.ISequence<byte> symmetricSigningKey, T wrapInfo) {
      this._plaintextDataKey = plaintextDataKey;
      this._wrappedMaterial = wrappedMaterial;
      this._symmetricSigningKey = symmetricSigningKey;
      this._wrapInfo = wrapInfo;
    }
    public _IIntermediateGenerateAndWrapOutput<__T> DowncastClone<__T>(Func<T, __T> converter0) {
      if (this is _IIntermediateGenerateAndWrapOutput<__T> dt) { return dt; }
      return new IntermediateGenerateAndWrapOutput<__T>(_plaintextDataKey, _wrappedMaterial, _symmetricSigningKey, converter0(_wrapInfo));
    }
    public override bool Equals(object other) {
      var oth = other as IntermediateKeyWrapping_Compile.IntermediateGenerateAndWrapOutput<T>;
      return oth != null && object.Equals(this._plaintextDataKey, oth._plaintextDataKey) && object.Equals(this._wrappedMaterial, oth._wrappedMaterial) && object.Equals(this._symmetricSigningKey, oth._symmetricSigningKey) && object.Equals(this._wrapInfo, oth._wrapInfo);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._plaintextDataKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._wrappedMaterial));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._symmetricSigningKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._wrapInfo));
      return (int) hash;
    }
    public override string ToString() {
      string s = "IntermediateKeyWrapping_Compile.IntermediateGenerateAndWrapOutput.IntermediateGenerateAndWrapOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._plaintextDataKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this._wrappedMaterial);
      s += ", ";
      s += Dafny.Helpers.ToString(this._symmetricSigningKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this._wrapInfo);
      s += ")";
      return s;
    }
    public static IntermediateKeyWrapping_Compile._IIntermediateGenerateAndWrapOutput<T> Default(T _default_T) {
      return create(Dafny.Sequence<byte>.Empty, Dafny.Sequence<byte>.Empty, Dafny.Sequence<byte>.Empty, _default_T);
    }
    public static Dafny.TypeDescriptor<IntermediateKeyWrapping_Compile._IIntermediateGenerateAndWrapOutput<T>> _TypeDescriptor(Dafny.TypeDescriptor<T> _td_T) {
      return new Dafny.TypeDescriptor<IntermediateKeyWrapping_Compile._IIntermediateGenerateAndWrapOutput<T>>(IntermediateKeyWrapping_Compile.IntermediateGenerateAndWrapOutput<T>.Default(_td_T.Default()));
    }
    public static _IIntermediateGenerateAndWrapOutput<T> create(Dafny.ISequence<byte> plaintextDataKey, Dafny.ISequence<byte> wrappedMaterial, Dafny.ISequence<byte> symmetricSigningKey, T wrapInfo) {
      return new IntermediateGenerateAndWrapOutput<T>(plaintextDataKey, wrappedMaterial, symmetricSigningKey, wrapInfo);
    }
    public static _IIntermediateGenerateAndWrapOutput<T> create_IntermediateGenerateAndWrapOutput(Dafny.ISequence<byte> plaintextDataKey, Dafny.ISequence<byte> wrappedMaterial, Dafny.ISequence<byte> symmetricSigningKey, T wrapInfo) {
      return create(plaintextDataKey, wrappedMaterial, symmetricSigningKey, wrapInfo);
    }
    public bool is_IntermediateGenerateAndWrapOutput { get { return true; } }
    public Dafny.ISequence<byte> dtor_plaintextDataKey {
      get {
        return this._plaintextDataKey;
      }
    }
    public Dafny.ISequence<byte> dtor_wrappedMaterial {
      get {
        return this._wrappedMaterial;
      }
    }
    public Dafny.ISequence<byte> dtor_symmetricSigningKey {
      get {
        return this._symmetricSigningKey;
      }
    }
    public T dtor_wrapInfo {
      get {
        return this._wrapInfo;
      }
    }
  }

  public interface _IIntermediateWrapOutput<T> {
    bool is_IntermediateWrapOutput { get; }
    Dafny.ISequence<byte> dtor_wrappedMaterial { get; }
    Dafny.ISequence<byte> dtor_symmetricSigningKey { get; }
    T dtor_wrapInfo { get; }
    _IIntermediateWrapOutput<__T> DowncastClone<__T>(Func<T, __T> converter0);
  }
  public class IntermediateWrapOutput<T> : _IIntermediateWrapOutput<T> {
    public readonly Dafny.ISequence<byte> _wrappedMaterial;
    public readonly Dafny.ISequence<byte> _symmetricSigningKey;
    public readonly T _wrapInfo;
    public IntermediateWrapOutput(Dafny.ISequence<byte> wrappedMaterial, Dafny.ISequence<byte> symmetricSigningKey, T wrapInfo) {
      this._wrappedMaterial = wrappedMaterial;
      this._symmetricSigningKey = symmetricSigningKey;
      this._wrapInfo = wrapInfo;
    }
    public _IIntermediateWrapOutput<__T> DowncastClone<__T>(Func<T, __T> converter0) {
      if (this is _IIntermediateWrapOutput<__T> dt) { return dt; }
      return new IntermediateWrapOutput<__T>(_wrappedMaterial, _symmetricSigningKey, converter0(_wrapInfo));
    }
    public override bool Equals(object other) {
      var oth = other as IntermediateKeyWrapping_Compile.IntermediateWrapOutput<T>;
      return oth != null && object.Equals(this._wrappedMaterial, oth._wrappedMaterial) && object.Equals(this._symmetricSigningKey, oth._symmetricSigningKey) && object.Equals(this._wrapInfo, oth._wrapInfo);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._wrappedMaterial));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._symmetricSigningKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._wrapInfo));
      return (int) hash;
    }
    public override string ToString() {
      string s = "IntermediateKeyWrapping_Compile.IntermediateWrapOutput.IntermediateWrapOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._wrappedMaterial);
      s += ", ";
      s += Dafny.Helpers.ToString(this._symmetricSigningKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this._wrapInfo);
      s += ")";
      return s;
    }
    public static IntermediateKeyWrapping_Compile._IIntermediateWrapOutput<T> Default(T _default_T) {
      return create(Dafny.Sequence<byte>.Empty, Dafny.Sequence<byte>.Empty, _default_T);
    }
    public static Dafny.TypeDescriptor<IntermediateKeyWrapping_Compile._IIntermediateWrapOutput<T>> _TypeDescriptor(Dafny.TypeDescriptor<T> _td_T) {
      return new Dafny.TypeDescriptor<IntermediateKeyWrapping_Compile._IIntermediateWrapOutput<T>>(IntermediateKeyWrapping_Compile.IntermediateWrapOutput<T>.Default(_td_T.Default()));
    }
    public static _IIntermediateWrapOutput<T> create(Dafny.ISequence<byte> wrappedMaterial, Dafny.ISequence<byte> symmetricSigningKey, T wrapInfo) {
      return new IntermediateWrapOutput<T>(wrappedMaterial, symmetricSigningKey, wrapInfo);
    }
    public static _IIntermediateWrapOutput<T> create_IntermediateWrapOutput(Dafny.ISequence<byte> wrappedMaterial, Dafny.ISequence<byte> symmetricSigningKey, T wrapInfo) {
      return create(wrappedMaterial, symmetricSigningKey, wrapInfo);
    }
    public bool is_IntermediateWrapOutput { get { return true; } }
    public Dafny.ISequence<byte> dtor_wrappedMaterial {
      get {
        return this._wrappedMaterial;
      }
    }
    public Dafny.ISequence<byte> dtor_symmetricSigningKey {
      get {
        return this._symmetricSigningKey;
      }
    }
    public T dtor_wrapInfo {
      get {
        return this._wrapInfo;
      }
    }
  }

  public interface _IDeserializedIntermediateWrappedMaterial {
    bool is_DeserializedIntermediateWrappedMaterial { get; }
    Dafny.ISequence<byte> dtor_encryptedPdk { get; }
    Dafny.ISequence<byte> dtor_providerWrappedIkm { get; }
    _IDeserializedIntermediateWrappedMaterial DowncastClone();
  }
  public class DeserializedIntermediateWrappedMaterial : _IDeserializedIntermediateWrappedMaterial {
    public readonly Dafny.ISequence<byte> _encryptedPdk;
    public readonly Dafny.ISequence<byte> _providerWrappedIkm;
    public DeserializedIntermediateWrappedMaterial(Dafny.ISequence<byte> encryptedPdk, Dafny.ISequence<byte> providerWrappedIkm) {
      this._encryptedPdk = encryptedPdk;
      this._providerWrappedIkm = providerWrappedIkm;
    }
    public _IDeserializedIntermediateWrappedMaterial DowncastClone() {
      if (this is _IDeserializedIntermediateWrappedMaterial dt) { return dt; }
      return new DeserializedIntermediateWrappedMaterial(_encryptedPdk, _providerWrappedIkm);
    }
    public override bool Equals(object other) {
      var oth = other as IntermediateKeyWrapping_Compile.DeserializedIntermediateWrappedMaterial;
      return oth != null && object.Equals(this._encryptedPdk, oth._encryptedPdk) && object.Equals(this._providerWrappedIkm, oth._providerWrappedIkm);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptedPdk));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._providerWrappedIkm));
      return (int) hash;
    }
    public override string ToString() {
      string s = "IntermediateKeyWrapping_Compile.DeserializedIntermediateWrappedMaterial.DeserializedIntermediateWrappedMaterial";
      s += "(";
      s += Dafny.Helpers.ToString(this._encryptedPdk);
      s += ", ";
      s += Dafny.Helpers.ToString(this._providerWrappedIkm);
      s += ")";
      return s;
    }
    private static readonly IntermediateKeyWrapping_Compile._IDeserializedIntermediateWrappedMaterial theDefault = create(Dafny.Sequence<byte>.Empty, Dafny.Sequence<byte>.Empty);
    public static IntermediateKeyWrapping_Compile._IDeserializedIntermediateWrappedMaterial Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<IntermediateKeyWrapping_Compile._IDeserializedIntermediateWrappedMaterial> _TYPE = new Dafny.TypeDescriptor<IntermediateKeyWrapping_Compile._IDeserializedIntermediateWrappedMaterial>(IntermediateKeyWrapping_Compile.DeserializedIntermediateWrappedMaterial.Default());
    public static Dafny.TypeDescriptor<IntermediateKeyWrapping_Compile._IDeserializedIntermediateWrappedMaterial> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDeserializedIntermediateWrappedMaterial create(Dafny.ISequence<byte> encryptedPdk, Dafny.ISequence<byte> providerWrappedIkm) {
      return new DeserializedIntermediateWrappedMaterial(encryptedPdk, providerWrappedIkm);
    }
    public static _IDeserializedIntermediateWrappedMaterial create_DeserializedIntermediateWrappedMaterial(Dafny.ISequence<byte> encryptedPdk, Dafny.ISequence<byte> providerWrappedIkm) {
      return create(encryptedPdk, providerWrappedIkm);
    }
    public bool is_DeserializedIntermediateWrappedMaterial { get { return true; } }
    public Dafny.ISequence<byte> dtor_encryptedPdk {
      get {
        return this._encryptedPdk;
      }
    }
    public Dafny.ISequence<byte> dtor_providerWrappedIkm {
      get {
        return this._providerWrappedIkm;
      }
    }
  }

  public interface _IPdkEncryptionAndSymmetricSigningKeys {
    bool is_PdkEncryptionAndSymmetricSigningKeys { get; }
    Dafny.ISequence<byte> dtor_pdkEncryptionKey { get; }
    Dafny.ISequence<byte> dtor_symmetricSigningKey { get; }
    _IPdkEncryptionAndSymmetricSigningKeys DowncastClone();
  }
  public class PdkEncryptionAndSymmetricSigningKeys : _IPdkEncryptionAndSymmetricSigningKeys {
    public readonly Dafny.ISequence<byte> _pdkEncryptionKey;
    public readonly Dafny.ISequence<byte> _symmetricSigningKey;
    public PdkEncryptionAndSymmetricSigningKeys(Dafny.ISequence<byte> pdkEncryptionKey, Dafny.ISequence<byte> symmetricSigningKey) {
      this._pdkEncryptionKey = pdkEncryptionKey;
      this._symmetricSigningKey = symmetricSigningKey;
    }
    public _IPdkEncryptionAndSymmetricSigningKeys DowncastClone() {
      if (this is _IPdkEncryptionAndSymmetricSigningKeys dt) { return dt; }
      return new PdkEncryptionAndSymmetricSigningKeys(_pdkEncryptionKey, _symmetricSigningKey);
    }
    public override bool Equals(object other) {
      var oth = other as IntermediateKeyWrapping_Compile.PdkEncryptionAndSymmetricSigningKeys;
      return oth != null && object.Equals(this._pdkEncryptionKey, oth._pdkEncryptionKey) && object.Equals(this._symmetricSigningKey, oth._symmetricSigningKey);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._pdkEncryptionKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._symmetricSigningKey));
      return (int) hash;
    }
    public override string ToString() {
      string s = "IntermediateKeyWrapping_Compile.PdkEncryptionAndSymmetricSigningKeys.PdkEncryptionAndSymmetricSigningKeys";
      s += "(";
      s += Dafny.Helpers.ToString(this._pdkEncryptionKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this._symmetricSigningKey);
      s += ")";
      return s;
    }
    private static readonly IntermediateKeyWrapping_Compile._IPdkEncryptionAndSymmetricSigningKeys theDefault = create(Dafny.Sequence<byte>.Empty, Dafny.Sequence<byte>.Empty);
    public static IntermediateKeyWrapping_Compile._IPdkEncryptionAndSymmetricSigningKeys Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<IntermediateKeyWrapping_Compile._IPdkEncryptionAndSymmetricSigningKeys> _TYPE = new Dafny.TypeDescriptor<IntermediateKeyWrapping_Compile._IPdkEncryptionAndSymmetricSigningKeys>(IntermediateKeyWrapping_Compile.PdkEncryptionAndSymmetricSigningKeys.Default());
    public static Dafny.TypeDescriptor<IntermediateKeyWrapping_Compile._IPdkEncryptionAndSymmetricSigningKeys> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IPdkEncryptionAndSymmetricSigningKeys create(Dafny.ISequence<byte> pdkEncryptionKey, Dafny.ISequence<byte> symmetricSigningKey) {
      return new PdkEncryptionAndSymmetricSigningKeys(pdkEncryptionKey, symmetricSigningKey);
    }
    public static _IPdkEncryptionAndSymmetricSigningKeys create_PdkEncryptionAndSymmetricSigningKeys(Dafny.ISequence<byte> pdkEncryptionKey, Dafny.ISequence<byte> symmetricSigningKey) {
      return create(pdkEncryptionKey, symmetricSigningKey);
    }
    public bool is_PdkEncryptionAndSymmetricSigningKeys { get { return true; } }
    public Dafny.ISequence<byte> dtor_pdkEncryptionKey {
      get {
        return this._pdkEncryptionKey;
      }
    }
    public Dafny.ISequence<byte> dtor_symmetricSigningKey {
      get {
        return this._symmetricSigningKey;
      }
    }
  }

  public partial class __default {
    public static Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IIntermediateUnwrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> IntermediateUnwrap<__T>(MaterialWrapping_Compile.UnwrapMaterial<__T> unwrap, Dafny.ISequence<byte> wrappedMaterial, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo algorithmSuite, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext)
    {
      Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IIntermediateUnwrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IIntermediateUnwrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.primitives.internaldafny.types._IError> _226_maybeCrypto;
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.primitives.internaldafny.types._IError> _out17;
      _out17 = software.amazon.cryptography.primitives.internaldafny.__default.AtomicPrimitives(software.amazon.cryptography.primitives.internaldafny.__default.DefaultCryptoConfig());
      _226_maybeCrypto = _out17;
      software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _227_cryptoPrimitives;
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _228_valueOrError0 = default(Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      _228_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_226_maybeCrypto, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_229_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_229_e);
      })));
      if ((_228_valueOrError0).IsFailure()) {
        res = (_228_valueOrError0).PropagateFailure<IntermediateKeyWrapping_Compile._IIntermediateUnwrapOutput<__T>>();
        return res;
      }
      _227_cryptoPrimitives = (_228_valueOrError0).Extract();
      IntermediateKeyWrapping_Compile._IDeserializedIntermediateWrappedMaterial _230_deserializedWrapped;
      Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IDeserializedIntermediateWrappedMaterial, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _231_valueOrError1 = Wrappers_Compile.Result<IntermediateKeyWrapping_Compile._IDeserializedIntermediateWrappedMaterial, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(IntermediateKeyWrapping_Compile.DeserializedIntermediateWrappedMaterial.Default());
      _231_valueOrError1 = IntermediateKeyWrapping_Compile.__default.DeserializeIntermediateWrappedMaterial(wrappedMaterial, algorithmSuite);
      if ((_231_valueOrError1).IsFailure()) {
        res = (_231_valueOrError1).PropagateFailure<IntermediateKeyWrapping_Compile._IIntermediateUnwrapOutput<__T>>();
        return res;
      }
      _230_deserializedWrapped = (_231_valueOrError1).Extract();
      IntermediateKeyWrapping_Compile._IDeserializedIntermediateWrappedMaterial _let_tmp_rhs0 = _230_deserializedWrapped;
      Dafny.ISequence<byte> _232_encryptedPdk = _let_tmp_rhs0.dtor_encryptedPdk;
      Dafny.ISequence<byte> _233_providerWrappedIkm = _let_tmp_rhs0.dtor_providerWrappedIkm;
      MaterialWrapping_Compile._IUnwrapOutput<__T> _234_unwrapOutput;
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IUnwrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _235_valueOrError2 = default(Wrappers_Compile._IResult<MaterialWrapping_Compile._IUnwrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IUnwrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out18;
      _out18 = (unwrap).Invoke(MaterialWrapping_Compile.UnwrapInput.create(_233_providerWrappedIkm, algorithmSuite, encryptionContext));
      _235_valueOrError2 = _out18;
      if ((_235_valueOrError2).IsFailure()) {
        res = (_235_valueOrError2).PropagateFailure<IntermediateKeyWrapping_Compile._IIntermediateUnwrapOutput<__T>>();
        return res;
      }
      _234_unwrapOutput = (_235_valueOrError2).Extract();
      MaterialWrapping_Compile._IUnwrapOutput<__T> _let_tmp_rhs1 = _234_unwrapOutput;
      Dafny.ISequence<byte> _236_intermediateMaterial = _let_tmp_rhs1.dtor_unwrappedMaterial;
      __T _237_unwrapInfo = _let_tmp_rhs1.dtor_unwrapInfo;
      IntermediateKeyWrapping_Compile._IPdkEncryptionAndSymmetricSigningKeys _238_derivedKeys;
      Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IPdkEncryptionAndSymmetricSigningKeys, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _239_valueOrError3 = Wrappers_Compile.Result<IntermediateKeyWrapping_Compile._IPdkEncryptionAndSymmetricSigningKeys, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(IntermediateKeyWrapping_Compile.PdkEncryptionAndSymmetricSigningKeys.Default());
      Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IPdkEncryptionAndSymmetricSigningKeys, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out19;
      _out19 = IntermediateKeyWrapping_Compile.__default.DeriveKeysFromIntermediateMaterial(_236_intermediateMaterial, algorithmSuite, encryptionContext, _227_cryptoPrimitives);
      _239_valueOrError3 = _out19;
      if ((_239_valueOrError3).IsFailure()) {
        res = (_239_valueOrError3).PropagateFailure<IntermediateKeyWrapping_Compile._IIntermediateUnwrapOutput<__T>>();
        return res;
      }
      _238_derivedKeys = (_239_valueOrError3).Extract();
      IntermediateKeyWrapping_Compile._IPdkEncryptionAndSymmetricSigningKeys _let_tmp_rhs2 = _238_derivedKeys;
      Dafny.ISequence<byte> _240_pdkEncryptionKey = _let_tmp_rhs2.dtor_pdkEncryptionKey;
      Dafny.ISequence<byte> _241_symmetricSigningKey = _let_tmp_rhs2.dtor_symmetricSigningKey;
      Dafny.ISequence<byte> _242_iv;
      _242_iv = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim0 = new BigInteger(AlgorithmSuites_Compile.__default.GetEncryptIvLength(algorithmSuite));
        var arr0 = new byte[Dafny.Helpers.ToIntChecked(dim0, "array size exceeds memory limit")];
        for (int i0 = 0; i0 < dim0; i0++) {
          var _243___v0 = (BigInteger) i0;
          arr0[(int)(_243___v0)] = (byte)(0);
        }
        return Dafny.Sequence<byte>.FromArray(arr0);
      }))();
      BigInteger _244_tagIndex;
      _244_tagIndex = (new BigInteger((_232_encryptedPdk).Count)) - (new BigInteger(AlgorithmSuites_Compile.__default.GetEncryptTagLength(algorithmSuite)));
      Dafny.ISequence<byte> _245_aad;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _246_valueOrError4 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _246_valueOrError4 = CanonicalEncryptionContext_Compile.__default.EncryptionContextToAAD(encryptionContext);
      if ((_246_valueOrError4).IsFailure()) {
        res = (_246_valueOrError4).PropagateFailure<IntermediateKeyWrapping_Compile._IIntermediateUnwrapOutput<__T>>();
        return res;
      }
      _245_aad = (_246_valueOrError4).Extract();
      software.amazon.cryptography.primitives.internaldafny.types._IAESDecryptInput _247_decInput;
      _247_decInput = software.amazon.cryptography.primitives.internaldafny.types.AESDecryptInput.create(((algorithmSuite).dtor_encrypt).dtor_AES__GCM, _240_pdkEncryptionKey, (_232_encryptedPdk).Take(_244_tagIndex), (_232_encryptedPdk).Drop(_244_tagIndex), _242_iv, _245_aad);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _248_decOutR;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out20;
      _out20 = (_227_cryptoPrimitives).AESDecrypt(_247_decInput);
      _248_decOutR = _out20;
      Dafny.ISequence<byte> _249_plaintextDataKey;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _250_valueOrError5 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _250_valueOrError5 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_248_decOutR, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_251_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_251_e);
      })));
      if ((_250_valueOrError5).IsFailure()) {
        res = (_250_valueOrError5).PropagateFailure<IntermediateKeyWrapping_Compile._IIntermediateUnwrapOutput<__T>>();
        return res;
      }
      _249_plaintextDataKey = (_250_valueOrError5).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _252_valueOrError6 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _252_valueOrError6 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger((_249_plaintextDataKey).Count)) == (new BigInteger(AlgorithmSuites_Compile.__default.GetEncryptKeyLength(algorithmSuite))), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Unexpected AES_GCM Decrypt length")));
      if ((_252_valueOrError6).IsFailure()) {
        res = (_252_valueOrError6).PropagateFailure<IntermediateKeyWrapping_Compile._IIntermediateUnwrapOutput<__T>>();
        return res;
      }
      res = Wrappers_Compile.Result<IntermediateKeyWrapping_Compile._IIntermediateUnwrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(IntermediateKeyWrapping_Compile.IntermediateUnwrapOutput<__T>.create(_249_plaintextDataKey, _241_symmetricSigningKey, _237_unwrapInfo));
      return res;
      return res;
    }
    public static Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IIntermediateWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> IntermediateWrap<__T>(MaterialWrapping_Compile.GenerateAndWrapMaterial<__T> generateAndWrap, Dafny.ISequence<byte> plaintextDataKey, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo algorithmSuite, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext)
    {
      Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IIntermediateWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IIntermediateWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.primitives.internaldafny.types._IError> _253_maybeCrypto;
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.primitives.internaldafny.types._IError> _out21;
      _out21 = software.amazon.cryptography.primitives.internaldafny.__default.AtomicPrimitives(software.amazon.cryptography.primitives.internaldafny.__default.DefaultCryptoConfig());
      _253_maybeCrypto = _out21;
      software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _254_cryptoPrimitives;
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _255_valueOrError0 = default(Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      _255_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_253_maybeCrypto, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_256_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_256_e);
      })));
      if ((_255_valueOrError0).IsFailure()) {
        res = (_255_valueOrError0).PropagateFailure<IntermediateKeyWrapping_Compile._IIntermediateWrapOutput<__T>>();
        return res;
      }
      _254_cryptoPrimitives = (_255_valueOrError0).Extract();
      MaterialWrapping_Compile._IGenerateAndWrapOutput<__T> _257_generateAndWrapOutput;
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IGenerateAndWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _258_valueOrError1 = default(Wrappers_Compile._IResult<MaterialWrapping_Compile._IGenerateAndWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IGenerateAndWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out22;
      _out22 = (generateAndWrap).Invoke(MaterialWrapping_Compile.GenerateAndWrapInput.create(algorithmSuite, encryptionContext));
      _258_valueOrError1 = _out22;
      if ((_258_valueOrError1).IsFailure()) {
        res = (_258_valueOrError1).PropagateFailure<IntermediateKeyWrapping_Compile._IIntermediateWrapOutput<__T>>();
        return res;
      }
      _257_generateAndWrapOutput = (_258_valueOrError1).Extract();
      MaterialWrapping_Compile._IGenerateAndWrapOutput<__T> _let_tmp_rhs3 = _257_generateAndWrapOutput;
      Dafny.ISequence<byte> _259_intermediateMaterial = _let_tmp_rhs3.dtor_plaintextMaterial;
      Dafny.ISequence<byte> _260_providerWrappedIkm = _let_tmp_rhs3.dtor_wrappedMaterial;
      __T _261_wrapInfo = _let_tmp_rhs3.dtor_wrapInfo;
      IntermediateKeyWrapping_Compile._IPdkEncryptionAndSymmetricSigningKeys _262_derivedKeys;
      Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IPdkEncryptionAndSymmetricSigningKeys, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _263_valueOrError2 = Wrappers_Compile.Result<IntermediateKeyWrapping_Compile._IPdkEncryptionAndSymmetricSigningKeys, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(IntermediateKeyWrapping_Compile.PdkEncryptionAndSymmetricSigningKeys.Default());
      Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IPdkEncryptionAndSymmetricSigningKeys, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out23;
      _out23 = IntermediateKeyWrapping_Compile.__default.DeriveKeysFromIntermediateMaterial(_259_intermediateMaterial, algorithmSuite, encryptionContext, _254_cryptoPrimitives);
      _263_valueOrError2 = _out23;
      if ((_263_valueOrError2).IsFailure()) {
        res = (_263_valueOrError2).PropagateFailure<IntermediateKeyWrapping_Compile._IIntermediateWrapOutput<__T>>();
        return res;
      }
      _262_derivedKeys = (_263_valueOrError2).Extract();
      IntermediateKeyWrapping_Compile._IPdkEncryptionAndSymmetricSigningKeys _let_tmp_rhs4 = _262_derivedKeys;
      Dafny.ISequence<byte> _264_pdkEncryptionKey = _let_tmp_rhs4.dtor_pdkEncryptionKey;
      Dafny.ISequence<byte> _265_symmetricSigningKey = _let_tmp_rhs4.dtor_symmetricSigningKey;
      Dafny.ISequence<byte> _266_iv;
      _266_iv = ((System.Func<Dafny.ISequence<byte>>) (() => {
        BigInteger dim1 = new BigInteger(AlgorithmSuites_Compile.__default.GetEncryptIvLength(algorithmSuite));
        var arr1 = new byte[Dafny.Helpers.ToIntChecked(dim1, "array size exceeds memory limit")];
        for (int i1 = 0; i1 < dim1; i1++) {
          var _267___v1 = (BigInteger) i1;
          arr1[(int)(_267___v1)] = (byte)(0);
        }
        return Dafny.Sequence<byte>.FromArray(arr1);
      }))();
      Dafny.ISequence<byte> _268_aad;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _269_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _269_valueOrError3 = CanonicalEncryptionContext_Compile.__default.EncryptionContextToAAD(encryptionContext);
      if ((_269_valueOrError3).IsFailure()) {
        res = (_269_valueOrError3).PropagateFailure<IntermediateKeyWrapping_Compile._IIntermediateWrapOutput<__T>>();
        return res;
      }
      _268_aad = (_269_valueOrError3).Extract();
      software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptInput _270_encInput;
      _270_encInput = software.amazon.cryptography.primitives.internaldafny.types.AESEncryptInput.create(((algorithmSuite).dtor_encrypt).dtor_AES__GCM, _266_iv, _264_pdkEncryptionKey, plaintextDataKey, _268_aad);
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput, software.amazon.cryptography.primitives.internaldafny.types._IError> _271_encOutR;
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput, software.amazon.cryptography.primitives.internaldafny.types._IError> _out24;
      _out24 = (_254_cryptoPrimitives).AESEncrypt(_270_encInput);
      _271_encOutR = _out24;
      software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput _272_encryptedPdk;
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _273_valueOrError4 = Wrappers_Compile.Result<software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(software.amazon.cryptography.primitives.internaldafny.types.AESEncryptOutput.Default());
      _273_valueOrError4 = Wrappers_Compile.Result<software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_271_encOutR, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_274_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_274_e);
      })));
      if ((_273_valueOrError4).IsFailure()) {
        res = (_273_valueOrError4).PropagateFailure<IntermediateKeyWrapping_Compile._IIntermediateWrapOutput<__T>>();
        return res;
      }
      _272_encryptedPdk = (_273_valueOrError4).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _275_valueOrError5 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _275_valueOrError5 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger((Dafny.Sequence<byte>.Concat((_272_encryptedPdk).dtor_cipherText, (_272_encryptedPdk).dtor_authTag)).Count)) == (new BigInteger((AlgorithmSuites_Compile.__default.GetEncryptKeyLength(algorithmSuite)) + (AlgorithmSuites_Compile.__default.GetEncryptTagLength(algorithmSuite)))), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Unexpected AES_GCM Encrypt length")));
      if ((_275_valueOrError5).IsFailure()) {
        res = (_275_valueOrError5).PropagateFailure<IntermediateKeyWrapping_Compile._IIntermediateWrapOutput<__T>>();
        return res;
      }
      Dafny.ISequence<byte> _276_serializedMaterial;
      _276_serializedMaterial = Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat((_272_encryptedPdk).dtor_cipherText, (_272_encryptedPdk).dtor_authTag), _260_providerWrappedIkm);
      res = Wrappers_Compile.Result<IntermediateKeyWrapping_Compile._IIntermediateWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(IntermediateKeyWrapping_Compile.IntermediateWrapOutput<__T>.create(_276_serializedMaterial, _265_symmetricSigningKey, _261_wrapInfo));
      return res;
      return res;
    }
    public static Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IIntermediateGenerateAndWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> IntermediateGenerateAndWrap<__T>(MaterialWrapping_Compile.GenerateAndWrapMaterial<__T> generateAndWrap, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo algorithmSuite, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext)
    {
      Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IIntermediateGenerateAndWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IIntermediateGenerateAndWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.primitives.internaldafny.types._IError> _277_maybeCrypto;
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.primitives.internaldafny.types._IError> _out25;
      _out25 = software.amazon.cryptography.primitives.internaldafny.__default.AtomicPrimitives(software.amazon.cryptography.primitives.internaldafny.__default.DefaultCryptoConfig());
      _277_maybeCrypto = _out25;
      software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _278_cryptoPrimitives;
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _279_valueOrError0 = default(Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      _279_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_277_maybeCrypto, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_280_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_280_e);
      })));
      if ((_279_valueOrError0).IsFailure()) {
        res = (_279_valueOrError0).PropagateFailure<IntermediateKeyWrapping_Compile._IIntermediateGenerateAndWrapOutput<__T>>();
        return res;
      }
      _278_cryptoPrimitives = (_279_valueOrError0).Extract();
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _281_generateBytesResult;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out26;
      _out26 = (_278_cryptoPrimitives).GenerateRandomBytes(software.amazon.cryptography.primitives.internaldafny.types.GenerateRandomBytesInput.create(AlgorithmSuites_Compile.__default.GetEncryptKeyLength(algorithmSuite)));
      _281_generateBytesResult = _out26;
      Dafny.ISequence<byte> _282_plaintextDataKey;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _283_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _283_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_281_generateBytesResult, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_284_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_284_e);
      })));
      if ((_283_valueOrError1).IsFailure()) {
        res = (_283_valueOrError1).PropagateFailure<IntermediateKeyWrapping_Compile._IIntermediateGenerateAndWrapOutput<__T>>();
        return res;
      }
      _282_plaintextDataKey = (_283_valueOrError1).Extract();
      IntermediateKeyWrapping_Compile._IIntermediateWrapOutput<__T> _285_wrapOutput;
      Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IIntermediateWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _286_valueOrError2 = default(Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IIntermediateWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IIntermediateWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out27;
      _out27 = IntermediateKeyWrapping_Compile.__default.IntermediateWrap<__T>(generateAndWrap, _282_plaintextDataKey, algorithmSuite, encryptionContext);
      _286_valueOrError2 = _out27;
      if ((_286_valueOrError2).IsFailure()) {
        res = (_286_valueOrError2).PropagateFailure<IntermediateKeyWrapping_Compile._IIntermediateGenerateAndWrapOutput<__T>>();
        return res;
      }
      _285_wrapOutput = (_286_valueOrError2).Extract();
      res = Wrappers_Compile.Result<IntermediateKeyWrapping_Compile._IIntermediateGenerateAndWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(IntermediateKeyWrapping_Compile.IntermediateGenerateAndWrapOutput<__T>.create(_282_plaintextDataKey, (_285_wrapOutput).dtor_wrappedMaterial, (_285_wrapOutput).dtor_symmetricSigningKey, (_285_wrapOutput).dtor_wrapInfo));
      return res;
      return res;
    }
    public static Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IDeserializedIntermediateWrappedMaterial, software.amazon.cryptography.materialproviders.internaldafny.types._IError> DeserializeIntermediateWrappedMaterial(Dafny.ISequence<byte> material, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo algSuite)
    {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _287_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger((material).Count)) >= (new BigInteger((AlgorithmSuites_Compile.__default.GetEncryptKeyLength(algSuite)) + (AlgorithmSuites_Compile.__default.GetEncryptTagLength(algSuite)))), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Unable to deserialize Intermediate Key Wrapped material: too short.")));
      if ((_287_valueOrError0).IsFailure()) {
        return (_287_valueOrError0).PropagateFailure<IntermediateKeyWrapping_Compile._IDeserializedIntermediateWrappedMaterial>();
      } else {
        int _288_encryptedPdkLen = (AlgorithmSuites_Compile.__default.GetEncryptKeyLength(algSuite)) + (AlgorithmSuites_Compile.__default.GetEncryptTagLength(algSuite));
        return Wrappers_Compile.Result<IntermediateKeyWrapping_Compile._IDeserializedIntermediateWrappedMaterial, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(IntermediateKeyWrapping_Compile.DeserializedIntermediateWrappedMaterial.create((material).Take(_288_encryptedPdkLen), (material).Drop(_288_encryptedPdkLen)));
      }
    }
    public static Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IPdkEncryptionAndSymmetricSigningKeys, software.amazon.cryptography.materialproviders.internaldafny.types._IError> DeriveKeysFromIntermediateMaterial(Dafny.ISequence<byte> intermediateMaterial, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo algorithmSuite, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives)
    {
      Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IPdkEncryptionAndSymmetricSigningKeys, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = Wrappers_Compile.Result<IntermediateKeyWrapping_Compile._IPdkEncryptionAndSymmetricSigningKeys, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(IntermediateKeyWrapping_Compile.PdkEncryptionAndSymmetricSigningKeys.Default());
      software.amazon.cryptography.primitives.internaldafny.types._IHkdfExtractInput _289_hkdfExtractInput;
      _289_hkdfExtractInput = software.amazon.cryptography.primitives.internaldafny.types.HkdfExtractInput.create((((algorithmSuite).dtor_commitment).dtor_HKDF).dtor_hmac, Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), intermediateMaterial);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _290_maybePseudoRandomKey;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out28;
      _out28 = (cryptoPrimitives).HkdfExtract(_289_hkdfExtractInput);
      _290_maybePseudoRandomKey = _out28;
      Dafny.ISequence<byte> _291_pseudoRandomKey;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _292_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _292_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_290_maybePseudoRandomKey, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_293_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_293_e);
      })));
      if ((_292_valueOrError0).IsFailure()) {
        res = (_292_valueOrError0).PropagateFailure<IntermediateKeyWrapping_Compile._IPdkEncryptionAndSymmetricSigningKeys>();
        return res;
      }
      _291_pseudoRandomKey = (_292_valueOrError0).Extract();
      software.amazon.cryptography.primitives.internaldafny.types._IHkdfExpandInput _294_symmetricSigningKeyInput;
      _294_symmetricSigningKeyInput = software.amazon.cryptography.primitives.internaldafny.types.HkdfExpandInput.create((((algorithmSuite).dtor_commitment).dtor_HKDF).dtor_hmac, _291_pseudoRandomKey, IntermediateKeyWrapping_Compile.__default.KEYWRAP__MAC__INFO, (((algorithmSuite).dtor_commitment).dtor_HKDF).dtor_outputKeyLength);
      software.amazon.cryptography.primitives.internaldafny.types._IHkdfExpandInput _295_pdkEncryptionKeyInput;
      _295_pdkEncryptionKeyInput = Dafny.Helpers.Let<software.amazon.cryptography.primitives.internaldafny.types._IHkdfExpandInput, software.amazon.cryptography.primitives.internaldafny.types._IHkdfExpandInput>(_294_symmetricSigningKeyInput, _pat_let8_0 => Dafny.Helpers.Let<software.amazon.cryptography.primitives.internaldafny.types._IHkdfExpandInput, software.amazon.cryptography.primitives.internaldafny.types._IHkdfExpandInput>(_pat_let8_0, _296_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IHkdfExpandInput>(IntermediateKeyWrapping_Compile.__default.KEYWRAP__ENC__INFO, _pat_let9_0 => Dafny.Helpers.Let<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IHkdfExpandInput>(_pat_let9_0, _297_dt__update_hinfo_h0 => software.amazon.cryptography.primitives.internaldafny.types.HkdfExpandInput.create((_296_dt__update__tmp_h0).dtor_digestAlgorithm, (_296_dt__update__tmp_h0).dtor_prk, _297_dt__update_hinfo_h0, (_296_dt__update__tmp_h0).dtor_expectedLength)))));
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _298_maybeSymmetricSigningKey;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out29;
      _out29 = (cryptoPrimitives).HkdfExpand(_294_symmetricSigningKeyInput);
      _298_maybeSymmetricSigningKey = _out29;
      Dafny.ISequence<byte> _299_symmetricSigningKey;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _300_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _300_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_298_maybeSymmetricSigningKey, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_301_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_301_e);
      })));
      if ((_300_valueOrError1).IsFailure()) {
        res = (_300_valueOrError1).PropagateFailure<IntermediateKeyWrapping_Compile._IPdkEncryptionAndSymmetricSigningKeys>();
        return res;
      }
      _299_symmetricSigningKey = (_300_valueOrError1).Extract();
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _302_maybePdkEncryptionKey;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out30;
      _out30 = (cryptoPrimitives).HkdfExpand(_295_pdkEncryptionKeyInput);
      _302_maybePdkEncryptionKey = _out30;
      Dafny.ISequence<byte> _303_pdkEncryptionKey;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _304_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _304_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_302_maybePdkEncryptionKey, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_305_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_305_e);
      })));
      if ((_304_valueOrError2).IsFailure()) {
        res = (_304_valueOrError2).PropagateFailure<IntermediateKeyWrapping_Compile._IPdkEncryptionAndSymmetricSigningKeys>();
        return res;
      }
      _303_pdkEncryptionKey = (_304_valueOrError2).Extract();
      res = Wrappers_Compile.Result<IntermediateKeyWrapping_Compile._IPdkEncryptionAndSymmetricSigningKeys, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(IntermediateKeyWrapping_Compile.PdkEncryptionAndSymmetricSigningKeys.create(_303_pdkEncryptionKey, _299_symmetricSigningKey));
      return res;
      return res;
    }
    public static Dafny.ISequence<byte> KEYWRAP__MAC__INFO { get {
      return UTF8.__default.EncodeAscii(Dafny.Sequence<char>.FromString("AWS_MPL_INTERMEDIATE_KEYWRAP_MAC"));
    } }
    public static Dafny.ISequence<byte> KEYWRAP__ENC__INFO { get {
      return UTF8.__default.EncodeAscii(Dafny.Sequence<char>.FromString("AWS_MPL_INTERMEDIATE_KEYWRAP_ENC"));
    } }
  }
} // end of namespace IntermediateKeyWrapping_Compile
namespace EdkWrapping_Compile {

  public interface _IWrapEdkMaterialOutput<T> {
    bool is_WrapOnlyEdkMaterialOutput { get; }
    bool is_GenerateAndWrapEdkMaterialOutput { get; }
    Dafny.ISequence<byte> dtor_wrappedMaterial { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_symmetricSigningKey { get; }
    T dtor_wrapInfo { get; }
    Dafny.ISequence<byte> dtor_plaintextDataKey { get; }
    _IWrapEdkMaterialOutput<__T> DowncastClone<__T>(Func<T, __T> converter0);
  }
  public abstract class WrapEdkMaterialOutput<T> : _IWrapEdkMaterialOutput<T> {
    public WrapEdkMaterialOutput() { }
    public static EdkWrapping_Compile._IWrapEdkMaterialOutput<T> Default(T _default_T) {
      return create_WrapOnlyEdkMaterialOutput(Dafny.Sequence<byte>.Empty, Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default(), _default_T);
    }
    public static Dafny.TypeDescriptor<EdkWrapping_Compile._IWrapEdkMaterialOutput<T>> _TypeDescriptor(Dafny.TypeDescriptor<T> _td_T) {
      return new Dafny.TypeDescriptor<EdkWrapping_Compile._IWrapEdkMaterialOutput<T>>(EdkWrapping_Compile.WrapEdkMaterialOutput<T>.Default(_td_T.Default()));
    }
    public static _IWrapEdkMaterialOutput<T> create_WrapOnlyEdkMaterialOutput(Dafny.ISequence<byte> wrappedMaterial, Wrappers_Compile._IOption<Dafny.ISequence<byte>> symmetricSigningKey, T wrapInfo) {
      return new WrapEdkMaterialOutput_WrapOnlyEdkMaterialOutput<T>(wrappedMaterial, symmetricSigningKey, wrapInfo);
    }
    public static _IWrapEdkMaterialOutput<T> create_GenerateAndWrapEdkMaterialOutput(Dafny.ISequence<byte> plaintextDataKey, Dafny.ISequence<byte> wrappedMaterial, Wrappers_Compile._IOption<Dafny.ISequence<byte>> symmetricSigningKey, T wrapInfo) {
      return new WrapEdkMaterialOutput_GenerateAndWrapEdkMaterialOutput<T>(plaintextDataKey, wrappedMaterial, symmetricSigningKey, wrapInfo);
    }
    public bool is_WrapOnlyEdkMaterialOutput { get { return this is WrapEdkMaterialOutput_WrapOnlyEdkMaterialOutput<T>; } }
    public bool is_GenerateAndWrapEdkMaterialOutput { get { return this is WrapEdkMaterialOutput_GenerateAndWrapEdkMaterialOutput<T>; } }
    public Dafny.ISequence<byte> dtor_wrappedMaterial {
      get {
        var d = this;
        if (d is WrapEdkMaterialOutput_WrapOnlyEdkMaterialOutput<T>) { return ((WrapEdkMaterialOutput_WrapOnlyEdkMaterialOutput<T>)d)._wrappedMaterial; }
        return ((WrapEdkMaterialOutput_GenerateAndWrapEdkMaterialOutput<T>)d)._wrappedMaterial;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_symmetricSigningKey {
      get {
        var d = this;
        if (d is WrapEdkMaterialOutput_WrapOnlyEdkMaterialOutput<T>) { return ((WrapEdkMaterialOutput_WrapOnlyEdkMaterialOutput<T>)d)._symmetricSigningKey; }
        return ((WrapEdkMaterialOutput_GenerateAndWrapEdkMaterialOutput<T>)d)._symmetricSigningKey;
      }
    }
    public T dtor_wrapInfo {
      get {
        var d = this;
        if (d is WrapEdkMaterialOutput_WrapOnlyEdkMaterialOutput<T>) { return ((WrapEdkMaterialOutput_WrapOnlyEdkMaterialOutput<T>)d)._wrapInfo; }
        return ((WrapEdkMaterialOutput_GenerateAndWrapEdkMaterialOutput<T>)d)._wrapInfo;
      }
    }
    public Dafny.ISequence<byte> dtor_plaintextDataKey {
      get {
        var d = this;
        return ((WrapEdkMaterialOutput_GenerateAndWrapEdkMaterialOutput<T>)d)._plaintextDataKey;
      }
    }
    public abstract _IWrapEdkMaterialOutput<__T> DowncastClone<__T>(Func<T, __T> converter0);
  }
  public class WrapEdkMaterialOutput_WrapOnlyEdkMaterialOutput<T> : WrapEdkMaterialOutput<T> {
    public readonly Dafny.ISequence<byte> _wrappedMaterial;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<byte>> _symmetricSigningKey;
    public readonly T _wrapInfo;
    public WrapEdkMaterialOutput_WrapOnlyEdkMaterialOutput(Dafny.ISequence<byte> wrappedMaterial, Wrappers_Compile._IOption<Dafny.ISequence<byte>> symmetricSigningKey, T wrapInfo) {
      this._wrappedMaterial = wrappedMaterial;
      this._symmetricSigningKey = symmetricSigningKey;
      this._wrapInfo = wrapInfo;
    }
    public override _IWrapEdkMaterialOutput<__T> DowncastClone<__T>(Func<T, __T> converter0) {
      if (this is _IWrapEdkMaterialOutput<__T> dt) { return dt; }
      return new WrapEdkMaterialOutput_WrapOnlyEdkMaterialOutput<__T>(_wrappedMaterial, _symmetricSigningKey, converter0(_wrapInfo));
    }
    public override bool Equals(object other) {
      var oth = other as EdkWrapping_Compile.WrapEdkMaterialOutput_WrapOnlyEdkMaterialOutput<T>;
      return oth != null && object.Equals(this._wrappedMaterial, oth._wrappedMaterial) && object.Equals(this._symmetricSigningKey, oth._symmetricSigningKey) && object.Equals(this._wrapInfo, oth._wrapInfo);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._wrappedMaterial));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._symmetricSigningKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._wrapInfo));
      return (int) hash;
    }
    public override string ToString() {
      string s = "EdkWrapping_Compile.WrapEdkMaterialOutput.WrapOnlyEdkMaterialOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._wrappedMaterial);
      s += ", ";
      s += Dafny.Helpers.ToString(this._symmetricSigningKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this._wrapInfo);
      s += ")";
      return s;
    }
  }
  public class WrapEdkMaterialOutput_GenerateAndWrapEdkMaterialOutput<T> : WrapEdkMaterialOutput<T> {
    public readonly Dafny.ISequence<byte> _plaintextDataKey;
    public readonly Dafny.ISequence<byte> _wrappedMaterial;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<byte>> _symmetricSigningKey;
    public readonly T _wrapInfo;
    public WrapEdkMaterialOutput_GenerateAndWrapEdkMaterialOutput(Dafny.ISequence<byte> plaintextDataKey, Dafny.ISequence<byte> wrappedMaterial, Wrappers_Compile._IOption<Dafny.ISequence<byte>> symmetricSigningKey, T wrapInfo) {
      this._plaintextDataKey = plaintextDataKey;
      this._wrappedMaterial = wrappedMaterial;
      this._symmetricSigningKey = symmetricSigningKey;
      this._wrapInfo = wrapInfo;
    }
    public override _IWrapEdkMaterialOutput<__T> DowncastClone<__T>(Func<T, __T> converter0) {
      if (this is _IWrapEdkMaterialOutput<__T> dt) { return dt; }
      return new WrapEdkMaterialOutput_GenerateAndWrapEdkMaterialOutput<__T>(_plaintextDataKey, _wrappedMaterial, _symmetricSigningKey, converter0(_wrapInfo));
    }
    public override bool Equals(object other) {
      var oth = other as EdkWrapping_Compile.WrapEdkMaterialOutput_GenerateAndWrapEdkMaterialOutput<T>;
      return oth != null && object.Equals(this._plaintextDataKey, oth._plaintextDataKey) && object.Equals(this._wrappedMaterial, oth._wrappedMaterial) && object.Equals(this._symmetricSigningKey, oth._symmetricSigningKey) && object.Equals(this._wrapInfo, oth._wrapInfo);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._plaintextDataKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._wrappedMaterial));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._symmetricSigningKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._wrapInfo));
      return (int) hash;
    }
    public override string ToString() {
      string s = "EdkWrapping_Compile.WrapEdkMaterialOutput.GenerateAndWrapEdkMaterialOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._plaintextDataKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this._wrappedMaterial);
      s += ", ";
      s += Dafny.Helpers.ToString(this._symmetricSigningKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this._wrapInfo);
      s += ")";
      return s;
    }
  }

  public interface _IUnwrapEdkMaterialOutput<T> {
    bool is_UnwrapEdkMaterialOutput { get; }
    Dafny.ISequence<byte> dtor_plaintextDataKey { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_symmetricSigningKey { get; }
    T dtor_unwrapInfo { get; }
    _IUnwrapEdkMaterialOutput<__T> DowncastClone<__T>(Func<T, __T> converter0);
  }
  public class UnwrapEdkMaterialOutput<T> : _IUnwrapEdkMaterialOutput<T> {
    public readonly Dafny.ISequence<byte> _plaintextDataKey;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<byte>> _symmetricSigningKey;
    public readonly T _unwrapInfo;
    public UnwrapEdkMaterialOutput(Dafny.ISequence<byte> plaintextDataKey, Wrappers_Compile._IOption<Dafny.ISequence<byte>> symmetricSigningKey, T unwrapInfo) {
      this._plaintextDataKey = plaintextDataKey;
      this._symmetricSigningKey = symmetricSigningKey;
      this._unwrapInfo = unwrapInfo;
    }
    public _IUnwrapEdkMaterialOutput<__T> DowncastClone<__T>(Func<T, __T> converter0) {
      if (this is _IUnwrapEdkMaterialOutput<__T> dt) { return dt; }
      return new UnwrapEdkMaterialOutput<__T>(_plaintextDataKey, _symmetricSigningKey, converter0(_unwrapInfo));
    }
    public override bool Equals(object other) {
      var oth = other as EdkWrapping_Compile.UnwrapEdkMaterialOutput<T>;
      return oth != null && object.Equals(this._plaintextDataKey, oth._plaintextDataKey) && object.Equals(this._symmetricSigningKey, oth._symmetricSigningKey) && object.Equals(this._unwrapInfo, oth._unwrapInfo);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._plaintextDataKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._symmetricSigningKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._unwrapInfo));
      return (int) hash;
    }
    public override string ToString() {
      string s = "EdkWrapping_Compile.UnwrapEdkMaterialOutput.UnwrapEdkMaterialOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._plaintextDataKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this._symmetricSigningKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this._unwrapInfo);
      s += ")";
      return s;
    }
    public static EdkWrapping_Compile._IUnwrapEdkMaterialOutput<T> Default(T _default_T) {
      return create(Dafny.Sequence<byte>.Empty, Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default(), _default_T);
    }
    public static Dafny.TypeDescriptor<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<T>> _TypeDescriptor(Dafny.TypeDescriptor<T> _td_T) {
      return new Dafny.TypeDescriptor<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<T>>(EdkWrapping_Compile.UnwrapEdkMaterialOutput<T>.Default(_td_T.Default()));
    }
    public static _IUnwrapEdkMaterialOutput<T> create(Dafny.ISequence<byte> plaintextDataKey, Wrappers_Compile._IOption<Dafny.ISequence<byte>> symmetricSigningKey, T unwrapInfo) {
      return new UnwrapEdkMaterialOutput<T>(plaintextDataKey, symmetricSigningKey, unwrapInfo);
    }
    public static _IUnwrapEdkMaterialOutput<T> create_UnwrapEdkMaterialOutput(Dafny.ISequence<byte> plaintextDataKey, Wrappers_Compile._IOption<Dafny.ISequence<byte>> symmetricSigningKey, T unwrapInfo) {
      return create(plaintextDataKey, symmetricSigningKey, unwrapInfo);
    }
    public bool is_UnwrapEdkMaterialOutput { get { return true; } }
    public Dafny.ISequence<byte> dtor_plaintextDataKey {
      get {
        return this._plaintextDataKey;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_symmetricSigningKey {
      get {
        return this._symmetricSigningKey;
      }
    }
    public T dtor_unwrapInfo {
      get {
        return this._unwrapInfo;
      }
    }
  }

  public partial class __default {
    public static Wrappers_Compile._IResult<EdkWrapping_Compile._IWrapEdkMaterialOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> WrapEdkMaterial<__T>(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials encryptionMaterials, MaterialWrapping_Compile.WrapMaterial<__T> wrap, MaterialWrapping_Compile.GenerateAndWrapMaterial<__T> generateAndWrap)
    {
      Wrappers_Compile._IResult<EdkWrapping_Compile._IWrapEdkMaterialOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> ret = default(Wrappers_Compile._IResult<EdkWrapping_Compile._IWrapEdkMaterialOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _306_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _306_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.ValidEncryptionMaterials(encryptionMaterials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Invalid materials for decryption.")));
      if ((_306_valueOrError0).IsFailure()) {
        ret = (_306_valueOrError0).PropagateFailure<EdkWrapping_Compile._IWrapEdkMaterialOutput<__T>>();
        return ret;
      }
      if ((((encryptionMaterials).dtor_plaintextDataKey).is_Some) && ((((encryptionMaterials).dtor_algorithmSuite).dtor_edkWrapping).is_DIRECT__KEY__WRAPPING)) {
        MaterialWrapping_Compile._IWrapOutput<__T> _307_directOutput;
        Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _308_valueOrError1 = default(Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out31;
        _out31 = (wrap).Invoke(MaterialWrapping_Compile.WrapInput.create(((encryptionMaterials).dtor_plaintextDataKey).dtor_value, (encryptionMaterials).dtor_algorithmSuite, (encryptionMaterials).dtor_encryptionContext));
        _308_valueOrError1 = _out31;
        if ((_308_valueOrError1).IsFailure()) {
          ret = (_308_valueOrError1).PropagateFailure<EdkWrapping_Compile._IWrapEdkMaterialOutput<__T>>();
          return ret;
        }
        _307_directOutput = (_308_valueOrError1).Extract();
        ret = Wrappers_Compile.Result<EdkWrapping_Compile._IWrapEdkMaterialOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(EdkWrapping_Compile.WrapEdkMaterialOutput<__T>.create_WrapOnlyEdkMaterialOutput((_307_directOutput).dtor_wrappedMaterial, Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), (_307_directOutput).dtor_wrapInfo));
        return ret;
      } else if ((((encryptionMaterials).dtor_plaintextDataKey).is_Some) && ((((encryptionMaterials).dtor_algorithmSuite).dtor_edkWrapping).is_IntermediateKeyWrapping)) {
        IntermediateKeyWrapping_Compile._IIntermediateWrapOutput<__T> _309_intermediateOutput;
        Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IIntermediateWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _310_valueOrError2 = default(Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IIntermediateWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IIntermediateWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out32;
        _out32 = IntermediateKeyWrapping_Compile.__default.IntermediateWrap<__T>(generateAndWrap, ((encryptionMaterials).dtor_plaintextDataKey).dtor_value, (encryptionMaterials).dtor_algorithmSuite, (encryptionMaterials).dtor_encryptionContext);
        _310_valueOrError2 = _out32;
        if ((_310_valueOrError2).IsFailure()) {
          ret = (_310_valueOrError2).PropagateFailure<EdkWrapping_Compile._IWrapEdkMaterialOutput<__T>>();
          return ret;
        }
        _309_intermediateOutput = (_310_valueOrError2).Extract();
        ret = Wrappers_Compile.Result<EdkWrapping_Compile._IWrapEdkMaterialOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(EdkWrapping_Compile.WrapEdkMaterialOutput<__T>.create_WrapOnlyEdkMaterialOutput((_309_intermediateOutput).dtor_wrappedMaterial, Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some((_309_intermediateOutput).dtor_symmetricSigningKey), (_309_intermediateOutput).dtor_wrapInfo));
        return ret;
      } else if ((((encryptionMaterials).dtor_plaintextDataKey).is_None) && ((((encryptionMaterials).dtor_algorithmSuite).dtor_edkWrapping).is_DIRECT__KEY__WRAPPING)) {
        MaterialWrapping_Compile._IGenerateAndWrapOutput<__T> _311_directOutput;
        Wrappers_Compile._IResult<MaterialWrapping_Compile._IGenerateAndWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _312_valueOrError3 = default(Wrappers_Compile._IResult<MaterialWrapping_Compile._IGenerateAndWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        Wrappers_Compile._IResult<MaterialWrapping_Compile._IGenerateAndWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out33;
        _out33 = (generateAndWrap).Invoke(MaterialWrapping_Compile.GenerateAndWrapInput.create((encryptionMaterials).dtor_algorithmSuite, (encryptionMaterials).dtor_encryptionContext));
        _312_valueOrError3 = _out33;
        if ((_312_valueOrError3).IsFailure()) {
          ret = (_312_valueOrError3).PropagateFailure<EdkWrapping_Compile._IWrapEdkMaterialOutput<__T>>();
          return ret;
        }
        _311_directOutput = (_312_valueOrError3).Extract();
        ret = Wrappers_Compile.Result<EdkWrapping_Compile._IWrapEdkMaterialOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(EdkWrapping_Compile.WrapEdkMaterialOutput<__T>.create_GenerateAndWrapEdkMaterialOutput((_311_directOutput).dtor_plaintextMaterial, (_311_directOutput).dtor_wrappedMaterial, Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), (_311_directOutput).dtor_wrapInfo));
        return ret;
      } else if ((((encryptionMaterials).dtor_plaintextDataKey).is_None) && ((((encryptionMaterials).dtor_algorithmSuite).dtor_edkWrapping).is_IntermediateKeyWrapping)) {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _313_valueOrError4 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
        _313_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((encryptionMaterials).dtor_algorithmSuite).dtor_commitment).is_HKDF, software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Invalid algorithm suite: suites with intermediate key wrapping must use key commitment.")));
        if ((_313_valueOrError4).IsFailure()) {
          ret = (_313_valueOrError4).PropagateFailure<EdkWrapping_Compile._IWrapEdkMaterialOutput<__T>>();
          return ret;
        }
        IntermediateKeyWrapping_Compile._IIntermediateGenerateAndWrapOutput<__T> _314_intermediateOutput;
        Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IIntermediateGenerateAndWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _315_valueOrError5 = default(Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IIntermediateGenerateAndWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IIntermediateGenerateAndWrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out34;
        _out34 = IntermediateKeyWrapping_Compile.__default.IntermediateGenerateAndWrap<__T>(generateAndWrap, (encryptionMaterials).dtor_algorithmSuite, (encryptionMaterials).dtor_encryptionContext);
        _315_valueOrError5 = _out34;
        if ((_315_valueOrError5).IsFailure()) {
          ret = (_315_valueOrError5).PropagateFailure<EdkWrapping_Compile._IWrapEdkMaterialOutput<__T>>();
          return ret;
        }
        _314_intermediateOutput = (_315_valueOrError5).Extract();
        ret = Wrappers_Compile.Result<EdkWrapping_Compile._IWrapEdkMaterialOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(EdkWrapping_Compile.WrapEdkMaterialOutput<__T>.create_GenerateAndWrapEdkMaterialOutput((_314_intermediateOutput).dtor_plaintextDataKey, (_314_intermediateOutput).dtor_wrappedMaterial, Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some((_314_intermediateOutput).dtor_symmetricSigningKey), (_314_intermediateOutput).dtor_wrapInfo));
        return ret;
      } else {
      }
      return ret;
    }
    public static Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> UnwrapEdkMaterial<__T>(Dafny.ISequence<byte> wrappedMaterial, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials decryptionMaterials, MaterialWrapping_Compile.UnwrapMaterial<__T> unwrap)
    {
      Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> ret = default(Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _316_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _316_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.ValidDecryptionMaterials(decryptionMaterials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Invalid materials for decryption.")));
      if ((_316_valueOrError0).IsFailure()) {
        ret = (_316_valueOrError0).PropagateFailure<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<__T>>();
        return ret;
      }
      if ((((decryptionMaterials).dtor_algorithmSuite).dtor_edkWrapping).is_DIRECT__KEY__WRAPPING) {
        MaterialWrapping_Compile._IUnwrapOutput<__T> _317_directOutput;
        Wrappers_Compile._IResult<MaterialWrapping_Compile._IUnwrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _318_valueOrError1 = default(Wrappers_Compile._IResult<MaterialWrapping_Compile._IUnwrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        Wrappers_Compile._IResult<MaterialWrapping_Compile._IUnwrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out35;
        _out35 = (unwrap).Invoke(MaterialWrapping_Compile.UnwrapInput.create(wrappedMaterial, (decryptionMaterials).dtor_algorithmSuite, (decryptionMaterials).dtor_encryptionContext));
        _318_valueOrError1 = _out35;
        if ((_318_valueOrError1).IsFailure()) {
          ret = (_318_valueOrError1).PropagateFailure<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<__T>>();
          return ret;
        }
        _317_directOutput = (_318_valueOrError1).Extract();
        ret = Wrappers_Compile.Result<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(EdkWrapping_Compile.UnwrapEdkMaterialOutput<__T>.create((_317_directOutput).dtor_unwrappedMaterial, Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), (_317_directOutput).dtor_unwrapInfo));
        return ret;
      } else if ((((decryptionMaterials).dtor_algorithmSuite).dtor_edkWrapping).is_IntermediateKeyWrapping) {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _319_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
        _319_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger((wrappedMaterial).Count)) >= (new BigInteger((((((decryptionMaterials).dtor_algorithmSuite).dtor_encrypt).dtor_AES__GCM).dtor_keyLength) + (((((decryptionMaterials).dtor_algorithmSuite).dtor_encrypt).dtor_AES__GCM).dtor_tagLength))), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Invalid material for Intermediate Unwrapping")));
        if ((_319_valueOrError2).IsFailure()) {
          ret = (_319_valueOrError2).PropagateFailure<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<__T>>();
          return ret;
        }
        IntermediateKeyWrapping_Compile._IIntermediateUnwrapOutput<__T> _320_intermediateOutput;
        Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IIntermediateUnwrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _321_valueOrError3 = default(Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IIntermediateUnwrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IIntermediateUnwrapOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out36;
        _out36 = IntermediateKeyWrapping_Compile.__default.IntermediateUnwrap<__T>(unwrap, wrappedMaterial, (decryptionMaterials).dtor_algorithmSuite, (decryptionMaterials).dtor_encryptionContext);
        _321_valueOrError3 = _out36;
        if ((_321_valueOrError3).IsFailure()) {
          ret = (_321_valueOrError3).PropagateFailure<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<__T>>();
          return ret;
        }
        _320_intermediateOutput = (_321_valueOrError3).Extract();
        ret = Wrappers_Compile.Result<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<__T>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(EdkWrapping_Compile.UnwrapEdkMaterialOutput<__T>.create((_320_intermediateOutput).dtor_plaintextDataKey, Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some((_320_intermediateOutput).dtor_symmetricSigningKey), (_320_intermediateOutput).dtor_unwrapInfo));
        return ret;
      } else {
      }
      return ret;
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetProviderWrappedMaterial(Dafny.ISequence<byte> material, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo algSuite)
    {
      if (((algSuite).dtor_edkWrapping).is_DIRECT__KEY__WRAPPING) {
        return Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(material);
      } else {
        Wrappers_Compile._IResult<IntermediateKeyWrapping_Compile._IDeserializedIntermediateWrappedMaterial, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _322_deserializedWrappedRes = IntermediateKeyWrapping_Compile.__default.DeserializeIntermediateWrappedMaterial(material, algSuite);
        if ((_322_deserializedWrappedRes).is_Failure) {
          return Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Unable to deserialize Intermediate Key Wrapped material.")));
        } else {
          return Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(((_322_deserializedWrappedRes).dtor_value).dtor_providerWrappedIkm);
        }
      }
    }
  }
} // end of namespace EdkWrapping_Compile
namespace AwsKmsKeyring_Compile {

  public partial class AwsKmsKeyring : Keyring_Compile.VerifiableInterface, software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring {
    public AwsKmsKeyring() {
      this._client = default(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient);
      this._awsKmsKey = default(Dafny.ISequence<char>);
      this._grantTokens = default(Dafny.ISequence<Dafny.ISequence<char>>);
      this._awsKmsArn = default(AwsArnParsing_Compile._IAwsKmsIdentifier);
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnEncrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out37;
      _out37 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_IKeyring.OnEncrypt(this, input);
      return _out37;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnDecrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out38;
      _out38 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_IKeyring.OnDecrypt(this, input);
      return _out38;
    }
    public void __ctor(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client, Dafny.ISequence<char> awsKmsKey, Dafny.ISequence<Dafny.ISequence<char>> grantTokens)
    {
      Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsKmsIdentifier, Dafny.ISequence<char>> _323_parsedAwsKmsId;
      _323_parsedAwsKmsId = AwsArnParsing_Compile.__default.ParseAwsKmsIdentifier(awsKmsKey);
      (this)._client = client;
      (this)._awsKmsKey = awsKmsKey;
      (this)._awsKmsArn = (_323_parsedAwsKmsId).dtor_value;
      (this)._grantTokens = grantTokens;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnEncrypt_k(software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _324_materials;
      _324_materials = (input).dtor_materials;
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _325_suite;
      _325_suite = ((input).dtor_materials).dtor_algorithmSuite;
      Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _326_stringifiedEncCtx;
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _327_valueOrError0 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Empty);
      _327_valueOrError0 = AwsKmsUtils_Compile.__default.StringifyEncryptionContext(((input).dtor_materials).dtor_encryptionContext);
      if ((_327_valueOrError0).IsFailure()) {
        res = (_327_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
        return res;
      }
      _326_stringifiedEncCtx = (_327_valueOrError0).Extract();
      AwsKmsKeyring_Compile.KmsGenerateAndWrapKeyMaterial _328_kmsGenerateAndWrap;
      AwsKmsKeyring_Compile.KmsGenerateAndWrapKeyMaterial _nw0 = new AwsKmsKeyring_Compile.KmsGenerateAndWrapKeyMaterial();
      _nw0.__ctor((this).client, (this).awsKmsKey, (this).grantTokens);
      _328_kmsGenerateAndWrap = _nw0;
      AwsKmsKeyring_Compile.KmsWrapKeyMaterial _329_kmsWrap;
      AwsKmsKeyring_Compile.KmsWrapKeyMaterial _nw1 = new AwsKmsKeyring_Compile.KmsWrapKeyMaterial();
      _nw1.__ctor((this).client, (this).awsKmsKey, (this).grantTokens);
      _329_kmsWrap = _nw1;
      EdkWrapping_Compile._IWrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsWrapInfo> _330_wrapOutput;
      Wrappers_Compile._IResult<EdkWrapping_Compile._IWrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _331_valueOrError1 = Wrappers_Compile.Result<EdkWrapping_Compile._IWrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(EdkWrapping_Compile.WrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>.Default(AwsKmsKeyring_Compile.KmsWrapInfo.Default()));
      Wrappers_Compile._IResult<EdkWrapping_Compile._IWrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out39;
      _out39 = EdkWrapping_Compile.__default.WrapEdkMaterial<AwsKmsKeyring_Compile._IKmsWrapInfo>(_324_materials, _329_kmsWrap, _328_kmsGenerateAndWrap);
      _331_valueOrError1 = _out39;
      if ((_331_valueOrError1).IsFailure()) {
        res = (_331_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
        return res;
      }
      _330_wrapOutput = (_331_valueOrError1).Extract();
      Dafny.ISequence<char> _332_kmsKeyArn;
      _332_kmsKeyArn = ((_330_wrapOutput).dtor_wrapInfo).dtor_kmsKeyArn;
      Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>> _333_symmetricSigningKeyList;
      _333_symmetricSigningKeyList = ((((_330_wrapOutput).dtor_symmetricSigningKey).is_Some) ? (Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.create_Some(Dafny.Sequence<Dafny.ISequence<byte>>.FromElements(((_330_wrapOutput).dtor_symmetricSigningKey).dtor_value))) : (Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.create_None()));
      Dafny.ISequence<byte> _334_providerInfo;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _335_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(UTF8.ValidUTF8Bytes.Default());
      _335_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.Encode(_332_kmsKeyArn), AwsKmsUtils_Compile.__default.WrapStringToError);
      if ((_335_valueOrError2).IsFailure()) {
        res = (_335_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
        return res;
      }
      _334_providerInfo = (_335_valueOrError2).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _336_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _336_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger((_334_providerInfo).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Invalid response from AWS KMS GenerateDataKey: Key ID too long.")));
      if ((_336_valueOrError3).IsFailure()) {
        res = (_336_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
        return res;
      }
      software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey _337_edk;
      _337_edk = software.amazon.cryptography.materialproviders.internaldafny.types.EncryptedDataKey.create(Constants_Compile.__default.PROVIDER__ID, _334_providerInfo, (_330_wrapOutput).dtor_wrappedMaterial);
      if ((_330_wrapOutput).is_GenerateAndWrapEdkMaterialOutput) {
        software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _338_result;
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _339_valueOrError4 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        _339_valueOrError4 = Materials_Compile.__default.EncryptionMaterialAddDataKey(_324_materials, (_330_wrapOutput).dtor_plaintextDataKey, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.FromElements(_337_edk), _333_symmetricSigningKeyList);
        if ((_339_valueOrError4).IsFailure()) {
          res = (_339_valueOrError4).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
          return res;
        }
        _338_result = (_339_valueOrError4).Extract();
        res = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.OnEncryptOutput.create(_338_result));
        return res;
      } else if ((_330_wrapOutput).is_WrapOnlyEdkMaterialOutput) {
        software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _340_result;
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _341_valueOrError5 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        _341_valueOrError5 = Materials_Compile.__default.EncryptionMaterialAddEncryptedDataKeys(_324_materials, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.FromElements(_337_edk), _333_symmetricSigningKeyList);
        if ((_341_valueOrError5).IsFailure()) {
          res = (_341_valueOrError5).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
          return res;
        }
        _340_result = (_341_valueOrError5).Extract();
        res = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.OnEncryptOutput.create(_340_result));
        return res;
      }
      return res;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnDecrypt_k(software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _342_materials;
      _342_materials = (input).dtor_materials;
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _343_suite;
      _343_suite = ((input).dtor_materials).dtor_algorithmSuite;
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _344_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _344_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.DecryptionMaterialsWithoutPlaintextDataKey(_342_materials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Keyring received decryption materials that already contain a plaintext data key.")));
      if ((_344_valueOrError0).IsFailure()) {
        res = (_344_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return res;
      }
      AwsKmsKeyring_Compile.OnDecryptEncryptedDataKeyFilter _345_filter;
      AwsKmsKeyring_Compile.OnDecryptEncryptedDataKeyFilter _nw2 = new AwsKmsKeyring_Compile.OnDecryptEncryptedDataKeyFilter();
      _nw2.__ctor((this).awsKmsKey);
      _345_filter = _nw2;
      Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _346_edksToAttempt;
      Wrappers_Compile._IResult<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _347_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out40;
      _out40 = Actions_Compile.__default.FilterWithResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_345_filter, (input).dtor_encryptedDataKeys);
      _347_valueOrError1 = _out40;
      if ((_347_valueOrError1).IsFailure()) {
        res = (_347_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return res;
      }
      _346_edksToAttempt = (_347_valueOrError1).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _348_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _348_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger((_346_edksToAttempt).Count)).Sign == 1, software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Unable to decrypt data key: No Encrypted Data Keys found to match.")));
      if ((_348_valueOrError2).IsFailure()) {
        res = (_348_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return res;
      }
      Actions_Compile.ActionWithResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _349_decryptClosure;
      AwsKmsKeyring_Compile.DecryptSingleEncryptedDataKey _nw3 = new AwsKmsKeyring_Compile.DecryptSingleEncryptedDataKey();
      _nw3.__ctor(_342_materials, (this).client, (this).awsKmsKey, (this).grantTokens);
      _349_decryptClosure = _nw3;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>> _350_outcome;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>> _out41;
      _out41 = Actions_Compile.__default.ReduceToSuccess<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_349_decryptClosure, _346_edksToAttempt);
      _350_outcome = _out41;
      software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _351_SealedDecryptionMaterials;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _352_valueOrError3 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      _352_valueOrError3 = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_350_outcome, ((System.Func<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_353_errors) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_CollectionOfErrors(_353_errors, Dafny.Sequence<char>.FromString("No Configured KMS Key was able to decrypt the Data Key. The list of encountered Exceptions is available via `list`."));
      })));
      if ((_352_valueOrError3).IsFailure()) {
        res = (_352_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return res;
      }
      _351_SealedDecryptionMaterials = (_352_valueOrError3).Extract();
      res = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.OnDecryptOutput.create(_351_SealedDecryptionMaterials));
      return res;
      return res;
    }
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _client {get; set;}
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client { get {
      return this._client;
    } }
    public Dafny.ISequence<char> _awsKmsKey {get; set;}
    public Dafny.ISequence<char> awsKmsKey { get {
      return this._awsKmsKey;
    } }
    public Dafny.ISequence<Dafny.ISequence<char>> _grantTokens {get; set;}
    public Dafny.ISequence<Dafny.ISequence<char>> grantTokens { get {
      return this._grantTokens;
    } }
    public AwsArnParsing_Compile._IAwsKmsIdentifier _awsKmsArn {get; set;}
    public AwsArnParsing_Compile._IAwsKmsIdentifier awsKmsArn { get {
      return this._awsKmsArn;
    } }
  }

  public partial class OnDecryptEncryptedDataKeyFilter : Actions_Compile.DeterministicActionWithResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.DeterministicAction<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, Wrappers_Compile._IResult<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public OnDecryptEncryptedDataKeyFilter() {
      this._awsKmsKey = default(Dafny.ISequence<char>);
    }
    public void __ctor(Dafny.ISequence<char> awsKmsKey)
    {
      (this)._awsKmsKey = awsKmsKey;
    }
    public Wrappers_Compile._IResult<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey edk)
    {
      Wrappers_Compile._IResult<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = Wrappers_Compile.Result<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(false);
      if (!((edk).dtor_keyProviderId).Equals(Constants_Compile.__default.PROVIDER__ID)) {
        res = Wrappers_Compile.Result<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(false);
        return res;
      }
      if (!(UTF8.__default.ValidUTF8Seq((edk).dtor_keyProviderInfo))) {
        res = Wrappers_Compile.Result<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Invalid AWS KMS encoding, provider info is not UTF8.")));
        return res;
      }
      Dafny.ISequence<char> _354_keyId;
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _355_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<char>.Empty);
      _355_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.Decode((edk).dtor_keyProviderInfo), AwsKmsUtils_Compile.__default.WrapStringToError);
      if ((_355_valueOrError0).IsFailure()) {
        res = (_355_valueOrError0).PropagateFailure<bool>();
        return res;
      }
      _354_keyId = (_355_valueOrError0).Extract();
      AwsArnParsing_Compile._IAwsArn _356___v0;
      Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsArn, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _357_valueOrError1 = default(Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsArn, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      _357_valueOrError1 = Wrappers_Compile.Result<AwsArnParsing_Compile._IAwsArn, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(AwsArnParsing_Compile.__default.ParseAwsKmsArn(_354_keyId), AwsKmsUtils_Compile.__default.WrapStringToError);
      if ((_357_valueOrError1).IsFailure()) {
        res = (_357_valueOrError1).PropagateFailure<bool>();
        return res;
      }
      _356___v0 = (_357_valueOrError1).Extract();
      res = Wrappers_Compile.Result<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(((this).awsKmsKey).Equals(_354_keyId));
      return res;
      return res;
    }
    public Dafny.ISequence<char> _awsKmsKey {get; set;}
    public Dafny.ISequence<char> awsKmsKey { get {
      return this._awsKmsKey;
    } }
  }

  public partial class DecryptSingleEncryptedDataKey : Actions_Compile.ActionWithResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public DecryptSingleEncryptedDataKey() {
      this._materials = default(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials);
      this._client = default(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient);
      this._awsKmsKey = default(Dafny.ISequence<char>);
      this._grantTokens = default(Dafny.ISequence<Dafny.ISequence<char>>);
    }
    public void __ctor(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials materials, software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client, Dafny.ISequence<char> awsKmsKey, Dafny.ISequence<Dafny.ISequence<char>> grantTokens)
    {
      (this)._materials = materials;
      (this)._client = client;
      (this)._awsKmsKey = awsKmsKey;
      (this)._grantTokens = grantTokens;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey edk)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      AwsKmsKeyring_Compile.KmsUnwrapKeyMaterial _358_kmsUnwrap;
      AwsKmsKeyring_Compile.KmsUnwrapKeyMaterial _nw4 = new AwsKmsKeyring_Compile.KmsUnwrapKeyMaterial();
      _nw4.__ctor((this).client, (this).awsKmsKey, (this).grantTokens);
      _358_kmsUnwrap = _nw4;
      Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _359_unwrapOutputRes;
      Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out42;
      _out42 = EdkWrapping_Compile.__default.UnwrapEdkMaterial<AwsKmsKeyring_Compile._IKmsUnwrapInfo>((edk).dtor_ciphertext, (this).materials, _358_kmsUnwrap);
      _359_unwrapOutputRes = _out42;
      EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo> _360_unwrapOutput;
      Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _361_valueOrError0 = Wrappers_Compile.Result<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(EdkWrapping_Compile.UnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>.Default(AwsKmsKeyring_Compile.KmsUnwrapInfo.Default()));
      _361_valueOrError0 = _359_unwrapOutputRes;
      if ((_361_valueOrError0).IsFailure()) {
        res = (_361_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        return res;
      }
      _360_unwrapOutput = (_361_valueOrError0).Extract();
      software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _362_result;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _363_valueOrError1 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      _363_valueOrError1 = Materials_Compile.__default.DecryptionMaterialsAddDataKey((this).materials, (_360_unwrapOutput).dtor_plaintextDataKey, (_360_unwrapOutput).dtor_symmetricSigningKey);
      if ((_363_valueOrError1).IsFailure()) {
        res = (_363_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        return res;
      }
      _362_result = (_363_valueOrError1).Extract();
      res = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_362_result);
      return res;
      return res;
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _materials {get; set;}
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials materials { get {
      return this._materials;
    } }
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _client {get; set;}
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client { get {
      return this._client;
    } }
    public Dafny.ISequence<char> _awsKmsKey {get; set;}
    public Dafny.ISequence<char> awsKmsKey { get {
      return this._awsKmsKey;
    } }
    public Dafny.ISequence<Dafny.ISequence<char>> _grantTokens {get; set;}
    public Dafny.ISequence<Dafny.ISequence<char>> grantTokens { get {
      return this._grantTokens;
    } }
  }

  public interface _IKmsUnwrapInfo {
    bool is_KmsUnwrapInfo { get; }
    _IKmsUnwrapInfo DowncastClone();
  }
  public class KmsUnwrapInfo : _IKmsUnwrapInfo {
    public KmsUnwrapInfo() {
    }
    public _IKmsUnwrapInfo DowncastClone() {
      if (this is _IKmsUnwrapInfo dt) { return dt; }
      return new KmsUnwrapInfo();
    }
    public override bool Equals(object other) {
      var oth = other as AwsKmsKeyring_Compile.KmsUnwrapInfo;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsKmsKeyring_Compile.KmsUnwrapInfo.KmsUnwrapInfo";
      return s;
    }
    private static readonly AwsKmsKeyring_Compile._IKmsUnwrapInfo theDefault = create();
    public static AwsKmsKeyring_Compile._IKmsUnwrapInfo Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AwsKmsKeyring_Compile._IKmsUnwrapInfo> _TYPE = new Dafny.TypeDescriptor<AwsKmsKeyring_Compile._IKmsUnwrapInfo>(AwsKmsKeyring_Compile.KmsUnwrapInfo.Default());
    public static Dafny.TypeDescriptor<AwsKmsKeyring_Compile._IKmsUnwrapInfo> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IKmsUnwrapInfo create() {
      return new KmsUnwrapInfo();
    }
    public static _IKmsUnwrapInfo create_KmsUnwrapInfo() {
      return create();
    }
    public bool is_KmsUnwrapInfo { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_IKmsUnwrapInfo> AllSingletonConstructors {
      get {
        yield return KmsUnwrapInfo.create();
      }
    }
  }

  public interface _IKmsWrapInfo {
    bool is_KmsWrapInfo { get; }
    Dafny.ISequence<char> dtor_kmsKeyArn { get; }
    _IKmsWrapInfo DowncastClone();
  }
  public class KmsWrapInfo : _IKmsWrapInfo {
    public readonly Dafny.ISequence<char> _kmsKeyArn;
    public KmsWrapInfo(Dafny.ISequence<char> kmsKeyArn) {
      this._kmsKeyArn = kmsKeyArn;
    }
    public _IKmsWrapInfo DowncastClone() {
      if (this is _IKmsWrapInfo dt) { return dt; }
      return new KmsWrapInfo(_kmsKeyArn);
    }
    public override bool Equals(object other) {
      var oth = other as AwsKmsKeyring_Compile.KmsWrapInfo;
      return oth != null && object.Equals(this._kmsKeyArn, oth._kmsKeyArn);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._kmsKeyArn));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsKmsKeyring_Compile.KmsWrapInfo.KmsWrapInfo";
      s += "(";
      s += Dafny.Helpers.ToString(this._kmsKeyArn);
      s += ")";
      return s;
    }
    private static readonly AwsKmsKeyring_Compile._IKmsWrapInfo theDefault = create(Dafny.Sequence<char>.Empty);
    public static AwsKmsKeyring_Compile._IKmsWrapInfo Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AwsKmsKeyring_Compile._IKmsWrapInfo> _TYPE = new Dafny.TypeDescriptor<AwsKmsKeyring_Compile._IKmsWrapInfo>(AwsKmsKeyring_Compile.KmsWrapInfo.Default());
    public static Dafny.TypeDescriptor<AwsKmsKeyring_Compile._IKmsWrapInfo> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IKmsWrapInfo create(Dafny.ISequence<char> kmsKeyArn) {
      return new KmsWrapInfo(kmsKeyArn);
    }
    public static _IKmsWrapInfo create_KmsWrapInfo(Dafny.ISequence<char> kmsKeyArn) {
      return create(kmsKeyArn);
    }
    public bool is_KmsWrapInfo { get { return true; } }
    public Dafny.ISequence<char> dtor_kmsKeyArn {
      get {
        return this._kmsKeyArn;
      }
    }
  }

  public partial class KmsUnwrapKeyMaterial : MaterialWrapping_Compile.UnwrapMaterial<AwsKmsKeyring_Compile._IKmsUnwrapInfo>, Actions_Compile.ActionWithResult<MaterialWrapping_Compile._IUnwrapInput, MaterialWrapping_Compile._IUnwrapOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<MaterialWrapping_Compile._IUnwrapInput, Wrappers_Compile._IResult<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public KmsUnwrapKeyMaterial() {
      this._client = default(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient);
      this._grantTokens = default(Dafny.ISequence<Dafny.ISequence<char>>);
      this._awsKmsKey = default(Dafny.ISequence<char>);
    }
    public void __ctor(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client, Dafny.ISequence<char> awsKmsKey, Dafny.ISequence<Dafny.ISequence<char>> grantTokens)
    {
      (this)._client = client;
      (this)._awsKmsKey = awsKmsKey;
      (this)._grantTokens = grantTokens;
    }
    public Wrappers_Compile._IResult<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(MaterialWrapping_Compile._IUnwrapInput input)
    {
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = Wrappers_Compile.Result<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(MaterialWrapping_Compile.UnwrapOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>.Default(AwsKmsKeyring_Compile.KmsUnwrapInfo.Default()));
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _364_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _364_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(software.amazon.cryptography.services.kms.internaldafny.types.__default.IsValid__CiphertextType((input).dtor_wrappedMaterial), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Ciphertext length invalid")));
      if ((_364_valueOrError0).IsFailure()) {
        res = (_364_valueOrError0).PropagateFailure<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>>();
        return res;
      }
      Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _365_stringifiedEncCtx;
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _366_valueOrError1 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Empty);
      _366_valueOrError1 = AwsKmsUtils_Compile.__default.StringifyEncryptionContext((input).dtor_encryptionContext);
      if ((_366_valueOrError1).IsFailure()) {
        res = (_366_valueOrError1).PropagateFailure<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>>();
        return res;
      }
      _365_stringifiedEncCtx = (_366_valueOrError1).Extract();
      software.amazon.cryptography.services.kms.internaldafny.types._IDecryptRequest _367_decryptRequest;
      _367_decryptRequest = software.amazon.cryptography.services.kms.internaldafny.types.DecryptRequest.create((input).dtor_wrappedMaterial, Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>.create_Some(_365_stringifiedEncCtx), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.create_Some((this).grantTokens), Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some((this).awsKmsKey), Wrappers_Compile.Option<software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec>.create_None());
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.services.kms.internaldafny.types._IError> _368_maybeDecryptResponse;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.services.kms.internaldafny.types._IError> _out43;
      _out43 = ((this).client).Decrypt(_367_decryptRequest);
      _368_maybeDecryptResponse = _out43;
      software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse _369_decryptResponse;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _370_valueOrError2 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(software.amazon.cryptography.services.kms.internaldafny.types.DecryptResponse.Default());
      _370_valueOrError2 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.services.kms.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_368_maybeDecryptResponse, ((System.Func<software.amazon.cryptography.services.kms.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_371_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_ComAmazonawsKms(_371_e);
      })));
      if ((_370_valueOrError2).IsFailure()) {
        res = (_370_valueOrError2).PropagateFailure<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>>();
        return res;
      }
      _369_decryptResponse = (_370_valueOrError2).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _372_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _372_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((((_369_decryptResponse).dtor_KeyId).is_Some) && ((((_369_decryptResponse).dtor_KeyId).dtor_value).Equals((this).awsKmsKey))) && (((_369_decryptResponse).dtor_Plaintext).is_Some)) && ((new BigInteger(AlgorithmSuites_Compile.__default.GetEncryptKeyLength((input).dtor_algorithmSuite))) == (new BigInteger((((_369_decryptResponse).dtor_Plaintext).dtor_value).Count))), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Invalid response from KMS Decrypt")));
      if ((_372_valueOrError3).IsFailure()) {
        res = (_372_valueOrError3).PropagateFailure<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>>();
        return res;
      }
      MaterialWrapping_Compile._IUnwrapOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo> _373_output;
      _373_output = MaterialWrapping_Compile.UnwrapOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>.create(((_369_decryptResponse).dtor_Plaintext).dtor_value, AwsKmsKeyring_Compile.KmsUnwrapInfo.create());
      res = Wrappers_Compile.Result<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_373_output);
      return res;
      return res;
    }
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _client {get; set;}
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client { get {
      return this._client;
    } }
    public Dafny.ISequence<Dafny.ISequence<char>> _grantTokens {get; set;}
    public Dafny.ISequence<Dafny.ISequence<char>> grantTokens { get {
      return this._grantTokens;
    } }
    public Dafny.ISequence<char> _awsKmsKey {get; set;}
    public Dafny.ISequence<char> awsKmsKey { get {
      return this._awsKmsKey;
    } }
  }

  public partial class KmsGenerateAndWrapKeyMaterial : MaterialWrapping_Compile.GenerateAndWrapMaterial<AwsKmsKeyring_Compile._IKmsWrapInfo>, Actions_Compile.ActionWithResult<MaterialWrapping_Compile._IGenerateAndWrapInput, MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<MaterialWrapping_Compile._IGenerateAndWrapInput, Wrappers_Compile._IResult<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public KmsGenerateAndWrapKeyMaterial() {
      this._client = default(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient);
      this._awsKmsKey = default(Dafny.ISequence<char>);
      this._grantTokens = default(Dafny.ISequence<Dafny.ISequence<char>>);
    }
    public void __ctor(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client, Dafny.ISequence<char> awsKmsKey, Dafny.ISequence<Dafny.ISequence<char>> grantTokens)
    {
      (this)._client = client;
      (this)._awsKmsKey = awsKmsKey;
      (this)._grantTokens = grantTokens;
    }
    public Wrappers_Compile._IResult<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(MaterialWrapping_Compile._IGenerateAndWrapInput input)
    {
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = Wrappers_Compile.Result<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(MaterialWrapping_Compile.GenerateAndWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>.Default(AwsKmsKeyring_Compile.KmsWrapInfo.Default()));
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _374_suite;
      _374_suite = (input).dtor_algorithmSuite;
      Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _375_stringifiedEncCtx;
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _376_valueOrError0 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Empty);
      _376_valueOrError0 = AwsKmsUtils_Compile.__default.StringifyEncryptionContext((input).dtor_encryptionContext);
      if ((_376_valueOrError0).IsFailure()) {
        res = (_376_valueOrError0).PropagateFailure<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>>();
        return res;
      }
      _375_stringifiedEncCtx = (_376_valueOrError0).Extract();
      software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyRequest _377_generatorRequest;
      _377_generatorRequest = software.amazon.cryptography.services.kms.internaldafny.types.GenerateDataKeyRequest.create((this).awsKmsKey, Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>.create_Some(_375_stringifiedEncCtx), Wrappers_Compile.Option<int>.create_Some(AlgorithmSuites_Compile.__default.GetEncryptKeyLength(_374_suite)), Wrappers_Compile.Option<software.amazon.cryptography.services.kms.internaldafny.types._IDataKeySpec>.create_None(), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.create_Some((this).grantTokens));
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyResponse, software.amazon.cryptography.services.kms.internaldafny.types._IError> _378_maybeGenerateResponse;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyResponse, software.amazon.cryptography.services.kms.internaldafny.types._IError> _out44;
      _out44 = ((this).client).GenerateDataKey(_377_generatorRequest);
      _378_maybeGenerateResponse = _out44;
      software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyResponse _379_generateResponse;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyResponse, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _380_valueOrError1 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyResponse, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(software.amazon.cryptography.services.kms.internaldafny.types.GenerateDataKeyResponse.Default());
      _380_valueOrError1 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyResponse, software.amazon.cryptography.services.kms.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_378_maybeGenerateResponse, ((System.Func<software.amazon.cryptography.services.kms.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_381_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_ComAmazonawsKms(_381_e);
      })));
      if ((_380_valueOrError1).IsFailure()) {
        res = (_380_valueOrError1).PropagateFailure<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>>();
        return res;
      }
      _379_generateResponse = (_380_valueOrError1).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _382_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _382_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((_379_generateResponse).dtor_KeyId).is_Some) && ((AwsArnParsing_Compile.__default.ParseAwsKmsIdentifier(((_379_generateResponse).dtor_KeyId).dtor_value)).is_Success), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Invalid response from KMS GenerateDataKey:: Invalid Key Id")));
      if ((_382_valueOrError2).IsFailure()) {
        res = (_382_valueOrError2).PropagateFailure<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>>();
        return res;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _383_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _383_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((_379_generateResponse).dtor_Plaintext).is_Some) && ((new BigInteger(AlgorithmSuites_Compile.__default.GetEncryptKeyLength(_374_suite))) == (new BigInteger((((_379_generateResponse).dtor_Plaintext).dtor_value).Count))), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Invalid response from AWS KMS GenerateDataKey: Invalid data key")));
      if ((_383_valueOrError3).IsFailure()) {
        res = (_383_valueOrError3).PropagateFailure<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>>();
        return res;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _384_valueOrError4 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _384_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((_379_generateResponse).dtor_CiphertextBlob).is_Some) && (software.amazon.cryptography.services.kms.internaldafny.types.__default.IsValid__CiphertextType(((_379_generateResponse).dtor_CiphertextBlob).dtor_value)), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Invalid response from AWS KMS GeneratedDataKey: Invalid ciphertext")));
      if ((_384_valueOrError4).IsFailure()) {
        res = (_384_valueOrError4).PropagateFailure<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>>();
        return res;
      }
      MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo> _385_output;
      _385_output = MaterialWrapping_Compile.GenerateAndWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>.create(((_379_generateResponse).dtor_Plaintext).dtor_value, ((_379_generateResponse).dtor_CiphertextBlob).dtor_value, AwsKmsKeyring_Compile.KmsWrapInfo.create(((_379_generateResponse).dtor_KeyId).dtor_value));
      res = Wrappers_Compile.Result<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_385_output);
      return res;
      return res;
    }
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _client {get; set;}
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client { get {
      return this._client;
    } }
    public Dafny.ISequence<char> _awsKmsKey {get; set;}
    public Dafny.ISequence<char> awsKmsKey { get {
      return this._awsKmsKey;
    } }
    public Dafny.ISequence<Dafny.ISequence<char>> _grantTokens {get; set;}
    public Dafny.ISequence<Dafny.ISequence<char>> grantTokens { get {
      return this._grantTokens;
    } }
  }

  public partial class KmsWrapKeyMaterial : MaterialWrapping_Compile.WrapMaterial<AwsKmsKeyring_Compile._IKmsWrapInfo>, Actions_Compile.ActionWithResult<MaterialWrapping_Compile._IWrapInput, MaterialWrapping_Compile._IWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<MaterialWrapping_Compile._IWrapInput, Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public KmsWrapKeyMaterial() {
      this._client = default(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient);
      this._awsKmsKey = default(Dafny.ISequence<char>);
      this._grantTokens = default(Dafny.ISequence<Dafny.ISequence<char>>);
    }
    public void __ctor(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client, Dafny.ISequence<char> awsKmsKey, Dafny.ISequence<Dafny.ISequence<char>> grantTokens)
    {
      (this)._client = client;
      (this)._awsKmsKey = awsKmsKey;
      (this)._grantTokens = grantTokens;
    }
    public Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(MaterialWrapping_Compile._IWrapInput input)
    {
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = Wrappers_Compile.Result<MaterialWrapping_Compile._IWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(MaterialWrapping_Compile.WrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>.Default(AwsKmsKeyring_Compile.KmsWrapInfo.Default()));
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _386_suite;
      _386_suite = (input).dtor_algorithmSuite;
      Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _387_stringifiedEncCtx;
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _388_valueOrError0 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Empty);
      _388_valueOrError0 = AwsKmsUtils_Compile.__default.StringifyEncryptionContext((input).dtor_encryptionContext);
      if ((_388_valueOrError0).IsFailure()) {
        res = (_388_valueOrError0).PropagateFailure<MaterialWrapping_Compile._IWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>>();
        return res;
      }
      _387_stringifiedEncCtx = (_388_valueOrError0).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _389_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _389_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(software.amazon.cryptography.services.kms.internaldafny.types.__default.IsValid__PlaintextType((input).dtor_plaintextMaterial), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Invalid Plaintext on KMS Encrypt")));
      if ((_389_valueOrError1).IsFailure()) {
        res = (_389_valueOrError1).PropagateFailure<MaterialWrapping_Compile._IWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>>();
        return res;
      }
      software.amazon.cryptography.services.kms.internaldafny.types._IEncryptRequest _390_encryptRequest;
      _390_encryptRequest = software.amazon.cryptography.services.kms.internaldafny.types.EncryptRequest.create((this).awsKmsKey, (input).dtor_plaintextMaterial, Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>.create_Some(_387_stringifiedEncCtx), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.create_Some((this).grantTokens), Wrappers_Compile.Option<software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec>.create_None());
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IEncryptResponse, software.amazon.cryptography.services.kms.internaldafny.types._IError> _391_maybeEncryptResponse;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IEncryptResponse, software.amazon.cryptography.services.kms.internaldafny.types._IError> _out45;
      _out45 = ((this).client).Encrypt(_390_encryptRequest);
      _391_maybeEncryptResponse = _out45;
      software.amazon.cryptography.services.kms.internaldafny.types._IEncryptResponse _392_encryptResponse;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IEncryptResponse, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _393_valueOrError2 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IEncryptResponse, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(software.amazon.cryptography.services.kms.internaldafny.types.EncryptResponse.Default());
      _393_valueOrError2 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IEncryptResponse, software.amazon.cryptography.services.kms.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_391_maybeEncryptResponse, ((System.Func<software.amazon.cryptography.services.kms.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_394_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_ComAmazonawsKms(_394_e);
      })));
      if ((_393_valueOrError2).IsFailure()) {
        res = (_393_valueOrError2).PropagateFailure<MaterialWrapping_Compile._IWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>>();
        return res;
      }
      _392_encryptResponse = (_393_valueOrError2).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _395_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _395_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((_392_encryptResponse).dtor_KeyId).is_Some) && ((AwsArnParsing_Compile.__default.ParseAwsKmsIdentifier(((_392_encryptResponse).dtor_KeyId).dtor_value)).is_Success), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Invalid response from AWS KMS Encrypt:: Invalid Key Id")));
      if ((_395_valueOrError3).IsFailure()) {
        res = (_395_valueOrError3).PropagateFailure<MaterialWrapping_Compile._IWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>>();
        return res;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _396_valueOrError4 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _396_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((_392_encryptResponse).dtor_CiphertextBlob).is_Some, software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Invalid response from AWS KMS Encrypt: Invalid Ciphertext Blob")));
      if ((_396_valueOrError4).IsFailure()) {
        res = (_396_valueOrError4).PropagateFailure<MaterialWrapping_Compile._IWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>>();
        return res;
      }
      MaterialWrapping_Compile._IWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo> _397_output;
      _397_output = MaterialWrapping_Compile.WrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>.create(((_392_encryptResponse).dtor_CiphertextBlob).dtor_value, AwsKmsKeyring_Compile.KmsWrapInfo.create(((_392_encryptResponse).dtor_KeyId).dtor_value));
      res = Wrappers_Compile.Result<MaterialWrapping_Compile._IWrapOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_397_output);
      return res;
      return res;
    }
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _client {get; set;}
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client { get {
      return this._client;
    } }
    public Dafny.ISequence<char> _awsKmsKey {get; set;}
    public Dafny.ISequence<char> awsKmsKey { get {
      return this._awsKmsKey;
    } }
    public Dafny.ISequence<Dafny.ISequence<char>> _grantTokens {get; set;}
    public Dafny.ISequence<Dafny.ISequence<char>> grantTokens { get {
      return this._grantTokens;
    } }
  }

} // end of namespace AwsKmsKeyring_Compile
namespace StrictMultiKeyring_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<MultiKeyring_Compile.MultiKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> StrictMultiKeyring(Wrappers_Compile._IOption<Dafny.ISequence<char>> generator, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> awsKmsKeys, software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier clientSupplier, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens)
    {
      Wrappers_Compile._IResult<MultiKeyring_Compile.MultiKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<MultiKeyring_Compile.MultiKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      var _pat_let_tv26 = awsKmsKeys;
      Dafny.ISequence<Dafny.ISequence<char>> _398_allStrings;
      _398_allStrings = ((System.Func<Wrappers_Compile._IOption<Dafny.ISequence<char>>, Dafny.ISequence<Dafny.ISequence<char>>>)((_source17) => {
        if (_source17.is_None) {
          return Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.UnwrapOr(awsKmsKeys, Dafny.Sequence<Dafny.ISequence<char>>.FromElements());
        } else {
          Dafny.ISequence<char> _399___mcc_h0 = _source17.dtor_value;
          return Dafny.Helpers.Let<Dafny.ISequence<char>, Dafny.ISequence<Dafny.ISequence<char>>>(_399___mcc_h0, _pat_let10_0 => Dafny.Helpers.Let<Dafny.ISequence<char>, Dafny.ISequence<Dafny.ISequence<char>>>(_pat_let10_0, _400_g => Dafny.Sequence<Dafny.ISequence<char>>.Concat(Dafny.Sequence<Dafny.ISequence<char>>.FromElements(_400_g), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.UnwrapOr(_pat_let_tv26, Dafny.Sequence<Dafny.ISequence<char>>.FromElements()))));
        }
      }))(generator);
      Dafny.ISequence<AwsArnParsing_Compile._IAwsKmsIdentifier> _401_allIdentifiers;
      Wrappers_Compile._IResult<Dafny.ISequence<AwsArnParsing_Compile._IAwsKmsIdentifier>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _402_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<AwsArnParsing_Compile._IAwsKmsIdentifier>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<AwsArnParsing_Compile._IAwsKmsIdentifier>.Empty);
      _402_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<AwsArnParsing_Compile._IAwsKmsIdentifier>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Seq_Compile.__default.MapWithResult<Dafny.ISequence<char>, AwsArnParsing_Compile._IAwsKmsIdentifier, Dafny.ISequence<char>>(AwsArnParsing_Compile.__default.IsAwsKmsIdentifierString, _398_allStrings), AwsKmsUtils_Compile.__default.WrapStringToError);
      if ((_402_valueOrError0).IsFailure()) {
        output = (_402_valueOrError0).PropagateFailure<MultiKeyring_Compile.MultiKeyring>();
        return output;
      }
      _401_allIdentifiers = (_402_valueOrError0).Extract();
      Wrappers_Compile._IOption<AwsKmsKeyring_Compile.AwsKmsKeyring> _403_generatorKeyring = Wrappers_Compile.Option<AwsKmsKeyring_Compile.AwsKmsKeyring>.Default();
      Wrappers_Compile._IOption<Dafny.ISequence<char>> _source18 = generator;
      if (_source18.is_None) {
        _403_generatorKeyring = Wrappers_Compile.Option<AwsKmsKeyring_Compile.AwsKmsKeyring>.create_None();
      } else {
        Dafny.ISequence<char> _404___mcc_h1 = _source18.dtor_value;
        Dafny.ISequence<char> _405_generatorIdentifier = _404___mcc_h1;
        AwsArnParsing_Compile._IAwsKmsIdentifier _406_arn;
        Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsKmsIdentifier, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _407_valueOrError1 = default(Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsKmsIdentifier, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        _407_valueOrError1 = Wrappers_Compile.Result<AwsArnParsing_Compile._IAwsKmsIdentifier, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(AwsArnParsing_Compile.__default.IsAwsKmsIdentifierString(_405_generatorIdentifier), AwsKmsUtils_Compile.__default.WrapStringToError);
        if ((_407_valueOrError1).IsFailure()) {
          output = (_407_valueOrError1).PropagateFailure<MultiKeyring_Compile.MultiKeyring>();
          return output;
        }
        _406_arn = (_407_valueOrError1).Extract();
        Wrappers_Compile._IOption<Dafny.ISequence<char>> _408_region;
        _408_region = AwsArnParsing_Compile.__default.GetRegion(_406_arn);
        software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _409_client;
        Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _410_valueOrError2 = default(Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out46;
        _out46 = (clientSupplier).GetClient(software.amazon.cryptography.materialproviders.internaldafny.types.GetClientInput.create(Wrappers_Compile.Option<Dafny.ISequence<char>>.UnwrapOr(_408_region, Dafny.Sequence<char>.FromString(""))));
        _410_valueOrError2 = _out46;
        if ((_410_valueOrError2).IsFailure()) {
          output = (_410_valueOrError2).PropagateFailure<MultiKeyring_Compile.MultiKeyring>();
          return output;
        }
        _409_client = (_410_valueOrError2).Extract();
        AwsKmsKeyring_Compile.AwsKmsKeyring _411_g;
        AwsKmsKeyring_Compile.AwsKmsKeyring _nw5 = new AwsKmsKeyring_Compile.AwsKmsKeyring();
        _nw5.__ctor(_409_client, _405_generatorIdentifier, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.UnwrapOr(grantTokens, Dafny.Sequence<Dafny.ISequence<char>>.FromElements()));
        _411_g = _nw5;
        _403_generatorKeyring = Wrappers_Compile.Option<AwsKmsKeyring_Compile.AwsKmsKeyring>.create_Some(_411_g);
      }
      Dafny.ISequence<AwsKmsKeyring_Compile.AwsKmsKeyring> _412_children;
      _412_children = Dafny.Sequence<AwsKmsKeyring_Compile.AwsKmsKeyring>.FromElements();
      Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> _source19 = awsKmsKeys;
      if (_source19.is_None) {
        _412_children = Dafny.Sequence<AwsKmsKeyring_Compile.AwsKmsKeyring>.FromElements();
      } else {
        Dafny.ISequence<Dafny.ISequence<char>> _413___mcc_h2 = _source19.dtor_value;
        Dafny.ISequence<Dafny.ISequence<char>> _414_childIdentifiers = _413___mcc_h2;
        BigInteger _hi2 = new BigInteger((_414_childIdentifiers).Count);
        for (BigInteger _415_index = BigInteger.Zero; _415_index < _hi2; _415_index++) {
          Dafny.ISequence<char> _416_childIdentifier;
          _416_childIdentifier = (_414_childIdentifiers).Select(_415_index);
          AwsArnParsing_Compile._IAwsKmsIdentifier _417_info;
          Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsKmsIdentifier, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _418_valueOrError3 = default(Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsKmsIdentifier, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
          _418_valueOrError3 = Wrappers_Compile.Result<AwsArnParsing_Compile._IAwsKmsIdentifier, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(AwsArnParsing_Compile.__default.IsAwsKmsIdentifierString(_416_childIdentifier), AwsKmsUtils_Compile.__default.WrapStringToError);
          if ((_418_valueOrError3).IsFailure()) {
            output = (_418_valueOrError3).PropagateFailure<MultiKeyring_Compile.MultiKeyring>();
            return output;
          }
          _417_info = (_418_valueOrError3).Extract();
          Wrappers_Compile._IOption<Dafny.ISequence<char>> _419_region;
          _419_region = AwsArnParsing_Compile.__default.GetRegion(_417_info);
          software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _420_client;
          Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _421_valueOrError4 = default(Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
          Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out47;
          _out47 = (clientSupplier).GetClient(software.amazon.cryptography.materialproviders.internaldafny.types.GetClientInput.create(Wrappers_Compile.Option<Dafny.ISequence<char>>.UnwrapOr(_419_region, Dafny.Sequence<char>.FromString(""))));
          _421_valueOrError4 = _out47;
          if ((_421_valueOrError4).IsFailure()) {
            output = (_421_valueOrError4).PropagateFailure<MultiKeyring_Compile.MultiKeyring>();
            return output;
          }
          _420_client = (_421_valueOrError4).Extract();
          AwsKmsKeyring_Compile.AwsKmsKeyring _422_keyring;
          AwsKmsKeyring_Compile.AwsKmsKeyring _nw6 = new AwsKmsKeyring_Compile.AwsKmsKeyring();
          _nw6.__ctor(_420_client, _416_childIdentifier, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.UnwrapOr(grantTokens, Dafny.Sequence<Dafny.ISequence<char>>.FromElements()));
          _422_keyring = _nw6;
          _412_children = Dafny.Sequence<AwsKmsKeyring_Compile.AwsKmsKeyring>.Concat(_412_children, Dafny.Sequence<AwsKmsKeyring_Compile.AwsKmsKeyring>.FromElements(_422_keyring));
        }
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _423_valueOrError5 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _423_valueOrError5 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((_403_generatorKeyring).is_Some) || ((new BigInteger((_412_children).Count)).Sign == 1), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("generatorKeyring or child Keryings needed to create a multi keyring")));
      if ((_423_valueOrError5).IsFailure()) {
        output = (_423_valueOrError5).PropagateFailure<MultiKeyring_Compile.MultiKeyring>();
        return output;
      }
      MultiKeyring_Compile.MultiKeyring _424_keyring;
      MultiKeyring_Compile.MultiKeyring _nw7 = new MultiKeyring_Compile.MultiKeyring();
      _nw7.__ctor(_403_generatorKeyring, _412_children);
      _424_keyring = _nw7;
      output = Wrappers_Compile.Result<MultiKeyring_Compile.MultiKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_424_keyring);
      return output;
      return output;
    }
  }
} // end of namespace StrictMultiKeyring_Compile
namespace AwsKmsDiscoveryKeyring_Compile {

  public partial class AwsKmsDiscoveryKeyring : Keyring_Compile.VerifiableInterface, software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring {
    public AwsKmsDiscoveryKeyring() {
      this._client = default(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient);
      this._discoveryFilter = Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter>.Default();
      this._grantTokens = default(Dafny.ISequence<Dafny.ISequence<char>>);
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnEncrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out48;
      _out48 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_IKeyring.OnEncrypt(this, input);
      return _out48;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnDecrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out49;
      _out49 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_IKeyring.OnDecrypt(this, input);
      return _out49;
    }
    public void __ctor(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter, Dafny.ISequence<Dafny.ISequence<char>> grantTokens)
    {
      (this)._client = client;
      (this)._discoveryFilter = discoveryFilter;
      (this)._grantTokens = grantTokens;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnEncrypt_k(software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Encryption is not supported with a Discovery Keyring.")));
      return output;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnDecrypt_k(software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _425_materials;
      _425_materials = (input).dtor_materials;
      Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _426_encryptedDataKeys;
      _426_encryptedDataKeys = (input).dtor_encryptedDataKeys;
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _427_suite;
      _427_suite = ((input).dtor_materials).dtor_algorithmSuite;
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _428_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _428_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.DecryptionMaterialsWithoutPlaintextDataKey(_425_materials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Keyring received decryption materials that already contain a plaintext data key.")));
      if ((_428_valueOrError0).IsFailure()) {
        res = (_428_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return res;
      }
      AwsKmsDiscoveryKeyring_Compile.AwsKmsEncryptedDataKeyFilter _429_edkFilter;
      AwsKmsDiscoveryKeyring_Compile.AwsKmsEncryptedDataKeyFilter _nw8 = new AwsKmsDiscoveryKeyring_Compile.AwsKmsEncryptedDataKeyFilter();
      _nw8.__ctor((this).discoveryFilter);
      _429_edkFilter = _nw8;
      Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _430_matchingEdks;
      Wrappers_Compile._IResult<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _431_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out50;
      _out50 = Actions_Compile.__default.FilterWithResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_429_edkFilter, _426_encryptedDataKeys);
      _431_valueOrError1 = _out50;
      if ((_431_valueOrError1).IsFailure()) {
        res = (_431_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return res;
      }
      _430_matchingEdks = (_431_valueOrError1).Extract();
      AwsKmsDiscoveryKeyring_Compile.AwsKmsEncryptedDataKeyTransformer _432_edkTransform;
      AwsKmsDiscoveryKeyring_Compile.AwsKmsEncryptedDataKeyTransformer _nw9 = new AwsKmsDiscoveryKeyring_Compile.AwsKmsEncryptedDataKeyTransformer();
      _nw9.__ctor();
      _432_edkTransform = _nw9;
      Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper> _433_edksToAttempt;
      Wrappers_Compile._IResult<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _434_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<Constants_Compile._IAwsKmsEdkHelper>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out51;
      _out51 = Actions_Compile.__default.DeterministicFlatMapWithResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, Constants_Compile._IAwsKmsEdkHelper, software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_432_edkTransform, _430_matchingEdks);
      _434_valueOrError2 = _out51;
      if ((_434_valueOrError2).IsFailure()) {
        res = (_434_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return res;
      }
      _433_edksToAttempt = (_434_valueOrError2).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _435_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _435_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger((_433_edksToAttempt).Count)).Sign == 1, software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Unable to decrypt data key: No Encrypted Data Keys found to match.")));
      if ((_435_valueOrError3).IsFailure()) {
        res = (_435_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return res;
      }
      AwsKmsDiscoveryKeyring_Compile.AwsKmsEncryptedDataKeyDecryptor _436_decryptAction;
      AwsKmsDiscoveryKeyring_Compile.AwsKmsEncryptedDataKeyDecryptor _nw10 = new AwsKmsDiscoveryKeyring_Compile.AwsKmsEncryptedDataKeyDecryptor();
      _nw10.__ctor(_425_materials, (this).client, (this).grantTokens);
      _436_decryptAction = _nw10;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>> _437_outcome;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>> _out52;
      _out52 = Actions_Compile.__default.ReduceToSuccess<Constants_Compile._IAwsKmsEdkHelper, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_436_decryptAction, _433_edksToAttempt);
      _437_outcome = _out52;
      res = ((System.Func<Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>>, Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>)((_source20) => {
        if (_source20.is_Success) {
          software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _438___mcc_h0 = _source20.dtor_value;
          return Dafny.Helpers.Let<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>(_438___mcc_h0, _pat_let11_0 => Dafny.Helpers.Let<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>(_pat_let11_0, _439_mat => Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.OnDecryptOutput.create(_439_mat))));
        } else {
          Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _440___mcc_h1 = _source20.dtor_error;
          return Dafny.Helpers.Let<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>(_440___mcc_h1, _pat_let12_0 => Dafny.Helpers.Let<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>(_pat_let12_0, _441_errors => Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_CollectionOfErrors(_441_errors, Dafny.Sequence<char>.FromString("No Configured KMS Key was able to decrypt the Data Key. The list of encountered Exceptions is available via `list`.")))));
        }
      }))(_437_outcome);
      return res;
      return res;
    }
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _client {get; set;}
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client { get {
      return this._client;
    } }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> _discoveryFilter {get; set;}
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter { get {
      return this._discoveryFilter;
    } }
    public Dafny.ISequence<Dafny.ISequence<char>> _grantTokens {get; set;}
    public Dafny.ISequence<Dafny.ISequence<char>> grantTokens { get {
      return this._grantTokens;
    } }
  }

  public partial class AwsKmsEncryptedDataKeyFilter : Actions_Compile.DeterministicActionWithResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.DeterministicAction<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, Wrappers_Compile._IResult<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public AwsKmsEncryptedDataKeyFilter() {
      this._discoveryFilter = Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter>.Default();
    }
    public void __ctor(Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter)
    {
      (this)._discoveryFilter = discoveryFilter;
    }
    public Wrappers_Compile._IResult<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey edk)
    {
      Wrappers_Compile._IResult<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = Wrappers_Compile.Result<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(false);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _442_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _442_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.ValidUTF8Seq((edk).dtor_keyProviderInfo), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Invalid AWS KMS encoding, provider info is not UTF8.")));
      if ((_442_valueOrError0).IsFailure()) {
        output = (_442_valueOrError0).PropagateFailure<bool>();
        return output;
      }
      Dafny.ISequence<char> _443_keyId;
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _444_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<char>.Empty);
      _444_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.Decode((edk).dtor_keyProviderInfo), AwsKmsUtils_Compile.__default.WrapStringToError);
      if ((_444_valueOrError1).IsFailure()) {
        output = (_444_valueOrError1).PropagateFailure<bool>();
        return output;
      }
      _443_keyId = (_444_valueOrError1).Extract();
      AwsArnParsing_Compile._IAwsArn _445_arn;
      Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsArn, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _446_valueOrError2 = default(Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsArn, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      _446_valueOrError2 = Wrappers_Compile.Result<AwsArnParsing_Compile._IAwsArn, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(AwsArnParsing_Compile.__default.ParseAwsKmsArn(_443_keyId), AwsKmsUtils_Compile.__default.WrapStringToError);
      if ((_446_valueOrError2).IsFailure()) {
        output = (_446_valueOrError2).PropagateFailure<bool>();
        return output;
      }
      _445_arn = (_446_valueOrError2).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _447_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _447_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((_445_arn).dtor_resource).dtor_resourceType).Equals(Dafny.Sequence<char>.FromString("key")), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Only AWS KMS Keys supported")));
      if ((_447_valueOrError3).IsFailure()) {
        output = (_447_valueOrError3).PropagateFailure<bool>();
        return output;
      }
      if (!((edk).dtor_keyProviderId).Equals(Constants_Compile.__default.PROVIDER__ID)) {
        output = Wrappers_Compile.Result<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(false);
        return output;
      }
      if (!(AwsKmsDiscoveryKeyring_Compile.__default.DiscoveryMatch(_445_arn, (this).discoveryFilter))) {
        output = Wrappers_Compile.Result<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(false);
        return output;
      }
      output = Wrappers_Compile.Result<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(true);
      return output;
      return output;
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> _discoveryFilter {get; set;}
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter { get {
      return this._discoveryFilter;
    } }
  }

  public partial class AwsKmsEncryptedDataKeyTransformer : Actions_Compile.DeterministicActionWithResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.DeterministicAction<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, Wrappers_Compile._IResult<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public AwsKmsEncryptedDataKeyTransformer() {
    }
    public void __ctor()
    {
    }
    public Wrappers_Compile._IResult<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey edk)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = Wrappers_Compile.Result<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<Constants_Compile._IAwsKmsEdkHelper>.Empty);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _448_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _448_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((edk).dtor_keyProviderId).Equals(Constants_Compile.__default.PROVIDER__ID), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Encrypted data key was not generated by KMS")));
      if ((_448_valueOrError0).IsFailure()) {
        res = (_448_valueOrError0).PropagateFailure<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>>();
        return res;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _449_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _449_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.ValidUTF8Seq((edk).dtor_keyProviderInfo), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Invalid AWS KMS encoding, provider info is not UTF8.")));
      if ((_449_valueOrError1).IsFailure()) {
        res = (_449_valueOrError1).PropagateFailure<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>>();
        return res;
      }
      Dafny.ISequence<char> _450_keyId;
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _451_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<char>.Empty);
      _451_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.Decode((edk).dtor_keyProviderInfo), AwsKmsUtils_Compile.__default.WrapStringToError);
      if ((_451_valueOrError2).IsFailure()) {
        res = (_451_valueOrError2).PropagateFailure<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>>();
        return res;
      }
      _450_keyId = (_451_valueOrError2).Extract();
      AwsArnParsing_Compile._IAwsArn _452_arn;
      Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsArn, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _453_valueOrError3 = default(Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsArn, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      _453_valueOrError3 = Wrappers_Compile.Result<AwsArnParsing_Compile._IAwsArn, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(AwsArnParsing_Compile.__default.ParseAwsKmsArn(_450_keyId), AwsKmsUtils_Compile.__default.WrapStringToError);
      if ((_453_valueOrError3).IsFailure()) {
        res = (_453_valueOrError3).PropagateFailure<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>>();
        return res;
      }
      _452_arn = (_453_valueOrError3).Extract();
      res = Wrappers_Compile.Result<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(Dafny.Sequence<Constants_Compile._IAwsKmsEdkHelper>.FromElements(Constants_Compile.AwsKmsEdkHelper.create(edk, _452_arn)));
      return res;
      return res;
    }
  }

  public partial class AwsKmsEncryptedDataKeyDecryptor : Actions_Compile.ActionWithResult<Constants_Compile._IAwsKmsEdkHelper, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<Constants_Compile._IAwsKmsEdkHelper, Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public AwsKmsEncryptedDataKeyDecryptor() {
      this._materials = default(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials);
      this._client = default(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient);
      this._grantTokens = default(Dafny.ISequence<Dafny.ISequence<char>>);
    }
    public void __ctor(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials materials, software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client, Dafny.ISequence<Dafny.ISequence<char>> grantTokens)
    {
      (this)._materials = materials;
      (this)._client = client;
      (this)._grantTokens = grantTokens;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(Constants_Compile._IAwsKmsEdkHelper helper)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Dafny.ISequence<char> _454_awsKmsKey;
      _454_awsKmsKey = ((helper).dtor_arn)._ToString();
      _System._ITuple0 _455___v0;
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _456_valueOrError0 = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
      _456_valueOrError0 = AwsKmsUtils_Compile.__default.ValidateKmsKeyId(((helper).dtor_arn)._ToString());
      if ((_456_valueOrError0).IsFailure()) {
        res = (_456_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        return res;
      }
      _455___v0 = (_456_valueOrError0).Extract();
      AwsKmsKeyring_Compile.KmsUnwrapKeyMaterial _457_kmsUnwrap;
      AwsKmsKeyring_Compile.KmsUnwrapKeyMaterial _nw11 = new AwsKmsKeyring_Compile.KmsUnwrapKeyMaterial();
      _nw11.__ctor((this).client, _454_awsKmsKey, (this).grantTokens);
      _457_kmsUnwrap = _nw11;
      Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _458_unwrapOutputRes;
      Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out53;
      _out53 = EdkWrapping_Compile.__default.UnwrapEdkMaterial<AwsKmsKeyring_Compile._IKmsUnwrapInfo>(((helper).dtor_edk).dtor_ciphertext, (this).materials, _457_kmsUnwrap);
      _458_unwrapOutputRes = _out53;
      EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo> _459_unwrapOutput;
      Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _460_valueOrError1 = Wrappers_Compile.Result<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(EdkWrapping_Compile.UnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>.Default(AwsKmsKeyring_Compile.KmsUnwrapInfo.Default()));
      _460_valueOrError1 = _458_unwrapOutputRes;
      if ((_460_valueOrError1).IsFailure()) {
        res = (_460_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        return res;
      }
      _459_unwrapOutput = (_460_valueOrError1).Extract();
      software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _461_result;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _462_valueOrError2 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      _462_valueOrError2 = Materials_Compile.__default.DecryptionMaterialsAddDataKey((this).materials, (_459_unwrapOutput).dtor_plaintextDataKey, (_459_unwrapOutput).dtor_symmetricSigningKey);
      if ((_462_valueOrError2).IsFailure()) {
        res = (_462_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        return res;
      }
      _461_result = (_462_valueOrError2).Extract();
      res = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_461_result);
      return res;
      return res;
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _materials {get; set;}
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials materials { get {
      return this._materials;
    } }
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _client {get; set;}
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client { get {
      return this._client;
    } }
    public Dafny.ISequence<Dafny.ISequence<char>> _grantTokens {get; set;}
    public Dafny.ISequence<Dafny.ISequence<char>> grantTokens { get {
      return this._grantTokens;
    } }
  }

  public partial class __default {
    public static bool DiscoveryMatch(AwsArnParsing_Compile._IAwsArn arn, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter)
    {
      var _pat_let_tv27 = arn;
      var _pat_let_tv28 = arn;
      return (true) && (((System.Func<Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter>, bool>)((_source21) => {
        if (_source21.is_None) {
          return true;
        } else {
          software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter _463___mcc_h0 = _source21.dtor_value;
          return Dafny.Helpers.Let<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter, bool>(_463___mcc_h0, _pat_let13_0 => Dafny.Helpers.Let<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter, bool>(_pat_let13_0, _464_filter => (((_464_filter).dtor_partition).Equals((_pat_let_tv27).dtor_partition)) && (Dafny.Sequence<Dafny.ISequence<char>>.IsPrefixOf((_464_filter).dtor_accountIds, Dafny.Sequence<Dafny.ISequence<char>>.FromElements((_pat_let_tv28).dtor_account)))));
        }
      }))(discoveryFilter));
    }
  }
} // end of namespace AwsKmsDiscoveryKeyring_Compile
namespace Com_mAmazonaws_Compile {

} // end of namespace Com_mAmazonaws_Compile
namespace Com_Compile {

} // end of namespace Com_Compile
namespace DiscoveryMultiKeyring_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<MultiKeyring_Compile.MultiKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> DiscoveryMultiKeyring(Dafny.ISequence<Dafny.ISequence<char>> regions, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter, software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier clientSupplier, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens)
    {
      Wrappers_Compile._IResult<MultiKeyring_Compile.MultiKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<MultiKeyring_Compile.MultiKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _465_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _465_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger((regions).Count)).Sign == 1, software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("No regions passed.")));
      if ((_465_valueOrError0).IsFailure()) {
        output = (_465_valueOrError0).PropagateFailure<MultiKeyring_Compile.MultiKeyring>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _466_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _466_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((Seq_Compile.__default.IndexOfOption<Dafny.ISequence<char>>(regions, Dafny.Sequence<char>.FromString(""))).is_None, software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Empty string is not a valid region.")));
      if ((_466_valueOrError1).IsFailure()) {
        output = (_466_valueOrError1).PropagateFailure<MultiKeyring_Compile.MultiKeyring>();
        return output;
      }
      Dafny.ISequence<AwsKmsDiscoveryKeyring_Compile.AwsKmsDiscoveryKeyring> _467_children;
      _467_children = Dafny.Sequence<AwsKmsDiscoveryKeyring_Compile.AwsKmsDiscoveryKeyring>.FromElements();
      BigInteger _hi3 = new BigInteger((regions).Count);
      for (BigInteger _468_i = BigInteger.Zero; _468_i < _hi3; _468_i++) {
        Dafny.ISequence<char> _469_region;
        _469_region = (regions).Select(_468_i);
        software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _470_client;
        Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _471_valueOrError2 = default(Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out54;
        _out54 = (clientSupplier).GetClient(software.amazon.cryptography.materialproviders.internaldafny.types.GetClientInput.create(_469_region));
        _471_valueOrError2 = _out54;
        if ((_471_valueOrError2).IsFailure()) {
          output = (_471_valueOrError2).PropagateFailure<MultiKeyring_Compile.MultiKeyring>();
          return output;
        }
        _470_client = (_471_valueOrError2).Extract();
        AwsKmsDiscoveryKeyring_Compile.AwsKmsDiscoveryKeyring _472_keyring;
        AwsKmsDiscoveryKeyring_Compile.AwsKmsDiscoveryKeyring _nw12 = new AwsKmsDiscoveryKeyring_Compile.AwsKmsDiscoveryKeyring();
        _nw12.__ctor(_470_client, discoveryFilter, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.UnwrapOr(grantTokens, Dafny.Sequence<Dafny.ISequence<char>>.FromElements()));
        _472_keyring = _nw12;
        _467_children = Dafny.Sequence<AwsKmsDiscoveryKeyring_Compile.AwsKmsDiscoveryKeyring>.Concat(_467_children, Dafny.Sequence<AwsKmsDiscoveryKeyring_Compile.AwsKmsDiscoveryKeyring>.FromElements(_472_keyring));
      }
      MultiKeyring_Compile.MultiKeyring _473_keyring;
      MultiKeyring_Compile.MultiKeyring _nw13 = new MultiKeyring_Compile.MultiKeyring();
      _nw13.__ctor(Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>.create_None(), _467_children);
      _473_keyring = _nw13;
      output = Wrappers_Compile.Result<MultiKeyring_Compile.MultiKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_473_keyring);
      return output;
      return output;
    }
  }
} // end of namespace DiscoveryMultiKeyring_Compile
namespace AwsKmsMrkDiscoveryKeyring_Compile {

  public partial class AwsKmsMrkDiscoveryKeyring : Keyring_Compile.VerifiableInterface, software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring {
    public AwsKmsMrkDiscoveryKeyring() {
      this._client = default(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient);
      this._region = Dafny.Sequence<char>.Empty;
      this._discoveryFilter = Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter>.Default();
      this._grantTokens = default(Dafny.ISequence<Dafny.ISequence<char>>);
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnEncrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out55;
      _out55 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_IKeyring.OnEncrypt(this, input);
      return _out55;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnDecrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out56;
      _out56 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_IKeyring.OnDecrypt(this, input);
      return _out56;
    }
    public void __ctor(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client, Dafny.ISequence<char> region, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter, Dafny.ISequence<Dafny.ISequence<char>> grantTokens)
    {
      (this)._client = client;
      (this)._region = region;
      (this)._discoveryFilter = discoveryFilter;
      (this)._grantTokens = grantTokens;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnEncrypt_k(software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Encryption is not supported with a Discovery Keyring.")));
      return output;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnDecrypt_k(software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _474_materials;
      _474_materials = (input).dtor_materials;
      Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _475_encryptedDataKeys;
      _475_encryptedDataKeys = (input).dtor_encryptedDataKeys;
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _476_suite;
      _476_suite = ((input).dtor_materials).dtor_algorithmSuite;
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _477_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _477_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.DecryptionMaterialsWithoutPlaintextDataKey(_474_materials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Keyring received decryption materials that already contain a plaintext data key.")));
      if ((_477_valueOrError0).IsFailure()) {
        output = (_477_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return output;
      }
      AwsKmsMrkDiscoveryKeyring_Compile.AwsKmsEncryptedDataKeyFilterTransform _478_edkFilterTransform;
      AwsKmsMrkDiscoveryKeyring_Compile.AwsKmsEncryptedDataKeyFilterTransform _nw14 = new AwsKmsMrkDiscoveryKeyring_Compile.AwsKmsEncryptedDataKeyFilterTransform();
      _nw14.__ctor((this).region, (this).discoveryFilter);
      _478_edkFilterTransform = _nw14;
      Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper> _479_edksToAttempt;
      Wrappers_Compile._IResult<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _480_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<Constants_Compile._IAwsKmsEdkHelper>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out57;
      _out57 = Actions_Compile.__default.DeterministicFlatMapWithResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, Constants_Compile._IAwsKmsEdkHelper, software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_478_edkFilterTransform, _475_encryptedDataKeys);
      _480_valueOrError1 = _out57;
      if ((_480_valueOrError1).IsFailure()) {
        output = (_480_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return output;
      }
      _479_edksToAttempt = (_480_valueOrError1).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _481_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _481_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger((_479_edksToAttempt).Count)).Sign == 1, software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Unable to decrypt data key: No Encrypted Data Keys found to match.")));
      if ((_481_valueOrError2).IsFailure()) {
        output = (_481_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return output;
      }
      AwsKmsMrkDiscoveryKeyring_Compile.AwsKmsEncryptedDataKeyDecryptor _482_decryptAction;
      AwsKmsMrkDiscoveryKeyring_Compile.AwsKmsEncryptedDataKeyDecryptor _nw15 = new AwsKmsMrkDiscoveryKeyring_Compile.AwsKmsEncryptedDataKeyDecryptor();
      _nw15.__ctor(_474_materials, (this).client, (this).region, (this).grantTokens);
      _482_decryptAction = _nw15;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>> _483_outcome;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>> _out58;
      _out58 = Actions_Compile.__default.ReduceToSuccess<Constants_Compile._IAwsKmsEdkHelper, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_482_decryptAction, _479_edksToAttempt);
      _483_outcome = _out58;
      output = ((System.Func<Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>>, Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>)((_source22) => {
        if (_source22.is_Success) {
          software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _484___mcc_h0 = _source22.dtor_value;
          return Dafny.Helpers.Let<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>(_484___mcc_h0, _pat_let14_0 => Dafny.Helpers.Let<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>(_pat_let14_0, _485_mat => Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.OnDecryptOutput.create(_485_mat))));
        } else {
          Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _486___mcc_h1 = _source22.dtor_error;
          return Dafny.Helpers.Let<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>(_486___mcc_h1, _pat_let15_0 => Dafny.Helpers.Let<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>>(_pat_let15_0, _487_errors => Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_CollectionOfErrors(_487_errors, Dafny.Sequence<char>.FromString("No Configured KMS Key was able to decrypt the Data Key. The list of encountered Exceptions is available via `list`.")))));
        }
      }))(_483_outcome);
      return output;
      return output;
    }
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _client {get; set;}
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client { get {
      return this._client;
    } }
    public Dafny.ISequence<char> _region {get; set;}
    public Dafny.ISequence<char> region { get {
      return this._region;
    } }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> _discoveryFilter {get; set;}
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter { get {
      return this._discoveryFilter;
    } }
    public Dafny.ISequence<Dafny.ISequence<char>> _grantTokens {get; set;}
    public Dafny.ISequence<Dafny.ISequence<char>> grantTokens { get {
      return this._grantTokens;
    } }
  }

  public partial class AwsKmsEncryptedDataKeyFilterTransform : Actions_Compile.DeterministicActionWithResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.DeterministicAction<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, Wrappers_Compile._IResult<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public AwsKmsEncryptedDataKeyFilterTransform() {
      this._region = Dafny.Sequence<char>.Empty;
      this._discoveryFilter = Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter>.Default();
    }
    public void __ctor(Dafny.ISequence<char> region, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter)
    {
      (this)._region = region;
      (this)._discoveryFilter = discoveryFilter;
    }
    public Wrappers_Compile._IResult<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey edk)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = Wrappers_Compile.Result<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<Constants_Compile._IAwsKmsEdkHelper>.Empty);
      if (!((edk).dtor_keyProviderId).Equals(Constants_Compile.__default.PROVIDER__ID)) {
        res = Wrappers_Compile.Result<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(Dafny.Sequence<Constants_Compile._IAwsKmsEdkHelper>.FromElements());
        return res;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _488_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _488_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.ValidUTF8Seq((edk).dtor_keyProviderInfo), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Invalid AWS KMS encoding, provider info is not UTF8.")));
      if ((_488_valueOrError0).IsFailure()) {
        res = (_488_valueOrError0).PropagateFailure<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>>();
        return res;
      }
      Dafny.ISequence<char> _489_keyId;
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _490_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<char>.Empty);
      _490_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.Decode((edk).dtor_keyProviderInfo), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_491_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(_491_e);
      })));
      if ((_490_valueOrError1).IsFailure()) {
        res = (_490_valueOrError1).PropagateFailure<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>>();
        return res;
      }
      _489_keyId = (_490_valueOrError1).Extract();
      AwsArnParsing_Compile._IAwsArn _492_arn;
      Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsArn, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _493_valueOrError2 = default(Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsArn, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      _493_valueOrError2 = Wrappers_Compile.Result<AwsArnParsing_Compile._IAwsArn, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(AwsArnParsing_Compile.__default.ParseAwsKmsArn(_489_keyId), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_494_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(_494_e);
      })));
      if ((_493_valueOrError2).IsFailure()) {
        res = (_493_valueOrError2).PropagateFailure<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>>();
        return res;
      }
      _492_arn = (_493_valueOrError2).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _495_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _495_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((_492_arn).dtor_resource).dtor_resourceType).Equals(Dafny.Sequence<char>.FromString("key")), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Only AWS KMS Keys supported")));
      if ((_495_valueOrError3).IsFailure()) {
        res = (_495_valueOrError3).PropagateFailure<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>>();
        return res;
      }
      if (!(AwsKmsMrkDiscoveryKeyring_Compile.__default.DiscoveryMatch(_492_arn, (this).discoveryFilter, (this).region))) {
        res = Wrappers_Compile.Result<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(Dafny.Sequence<Constants_Compile._IAwsKmsEdkHelper>.FromElements());
        return res;
      }
      res = Wrappers_Compile.Result<Dafny.ISequence<Constants_Compile._IAwsKmsEdkHelper>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(Dafny.Sequence<Constants_Compile._IAwsKmsEdkHelper>.FromElements(Constants_Compile.AwsKmsEdkHelper.create(edk, _492_arn)));
      return res;
      return res;
    }
    public Dafny.ISequence<char> _region {get; set;}
    public Dafny.ISequence<char> region { get {
      return this._region;
    } }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> _discoveryFilter {get; set;}
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter { get {
      return this._discoveryFilter;
    } }
  }

  public partial class AwsKmsEncryptedDataKeyDecryptor : Actions_Compile.ActionWithResult<Constants_Compile._IAwsKmsEdkHelper, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<Constants_Compile._IAwsKmsEdkHelper, Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public AwsKmsEncryptedDataKeyDecryptor() {
      this._materials = default(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials);
      this._client = default(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient);
      this._region = Dafny.Sequence<char>.Empty;
      this._grantTokens = default(Dafny.ISequence<Dafny.ISequence<char>>);
    }
    public void __ctor(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials materials, software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client, Dafny.ISequence<char> region, Dafny.ISequence<Dafny.ISequence<char>> grantTokens)
    {
      (this)._materials = materials;
      (this)._client = client;
      (this)._region = region;
      (this)._grantTokens = grantTokens;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(Constants_Compile._IAwsKmsEdkHelper helper)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Dafny.ISequence<char> _496_awsKmsKey;
      _496_awsKmsKey = AwsKmsMrkDiscoveryKeyring_Compile.__default.ToStringForRegion((helper).dtor_arn, (this).region);
      _System._ITuple0 _497___v0;
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _498_valueOrError0 = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
      _498_valueOrError0 = AwsKmsUtils_Compile.__default.ValidateKmsKeyId(_496_awsKmsKey);
      if ((_498_valueOrError0).IsFailure()) {
        res = (_498_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        return res;
      }
      _497___v0 = (_498_valueOrError0).Extract();
      AwsKmsKeyring_Compile.KmsUnwrapKeyMaterial _499_kmsUnwrap;
      AwsKmsKeyring_Compile.KmsUnwrapKeyMaterial _nw16 = new AwsKmsKeyring_Compile.KmsUnwrapKeyMaterial();
      _nw16.__ctor((this).client, _496_awsKmsKey, (this).grantTokens);
      _499_kmsUnwrap = _nw16;
      Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _500_unwrapOutputRes;
      Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out59;
      _out59 = EdkWrapping_Compile.__default.UnwrapEdkMaterial<AwsKmsKeyring_Compile._IKmsUnwrapInfo>(((helper).dtor_edk).dtor_ciphertext, (this).materials, _499_kmsUnwrap);
      _500_unwrapOutputRes = _out59;
      EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo> _501_unwrapOutput;
      Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _502_valueOrError1 = Wrappers_Compile.Result<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(EdkWrapping_Compile.UnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>.Default(AwsKmsKeyring_Compile.KmsUnwrapInfo.Default()));
      _502_valueOrError1 = _500_unwrapOutputRes;
      if ((_502_valueOrError1).IsFailure()) {
        res = (_502_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        return res;
      }
      _501_unwrapOutput = (_502_valueOrError1).Extract();
      res = Materials_Compile.__default.DecryptionMaterialsAddDataKey((this).materials, (_501_unwrapOutput).dtor_plaintextDataKey, (_501_unwrapOutput).dtor_symmetricSigningKey);
      return res;
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _materials {get; set;}
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials materials { get {
      return this._materials;
    } }
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _client {get; set;}
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client { get {
      return this._client;
    } }
    public Dafny.ISequence<char> _region {get; set;}
    public Dafny.ISequence<char> region { get {
      return this._region;
    } }
    public Dafny.ISequence<Dafny.ISequence<char>> _grantTokens {get; set;}
    public Dafny.ISequence<Dafny.ISequence<char>> grantTokens { get {
      return this._grantTokens;
    } }
  }

  public partial class __default {
    public static Dafny.ISequence<char> ToStringForRegion(AwsArnParsing_Compile._IAwsArn arn, Dafny.ISequence<char> region)
    {
      if (AwsArnParsing_Compile.__default.IsMultiRegionAwsKmsArn(arn)) {
        return (arn).ToArnString(Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some(region));
      } else {
        return (arn)._ToString();
      }
    }
    public static bool DiscoveryMatch(AwsArnParsing_Compile._IAwsArn arn, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter, Dafny.ISequence<char> region)
    {
      var _pat_let_tv29 = arn;
      var _pat_let_tv30 = arn;
      return (((System.Func<Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter>, bool>)((_source23) => {
        if (_source23.is_None) {
          return true;
        } else {
          software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter _503___mcc_h0 = _source23.dtor_value;
          return Dafny.Helpers.Let<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter, bool>(_503___mcc_h0, _pat_let16_0 => Dafny.Helpers.Let<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter, bool>(_pat_let16_0, _504_filter => (((_504_filter).dtor_partition).Equals((_pat_let_tv29).dtor_partition)) && (((_504_filter).dtor_accountIds).Contains((_pat_let_tv30).dtor_account))));
        }
      }))(discoveryFilter)) && (((!(AwsArnParsing_Compile.__default.IsMultiRegionAwsKmsArn(arn))) ? ((region).Equals((arn).dtor_region)) : (true)));
    }
  }
} // end of namespace AwsKmsMrkDiscoveryKeyring_Compile
namespace MrkAwareDiscoveryMultiKeyring_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<MultiKeyring_Compile.MultiKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> MrkAwareDiscoveryMultiKeyring(Dafny.ISequence<Dafny.ISequence<char>> regions, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDiscoveryFilter> discoveryFilter, software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier clientSupplier, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens)
    {
      Wrappers_Compile._IResult<MultiKeyring_Compile.MultiKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<MultiKeyring_Compile.MultiKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _505_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _505_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger((regions).Count)).Sign == 1, software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("No regions passed.")));
      if ((_505_valueOrError0).IsFailure()) {
        output = (_505_valueOrError0).PropagateFailure<MultiKeyring_Compile.MultiKeyring>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _506_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _506_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((Seq_Compile.__default.IndexOfOption<Dafny.ISequence<char>>(regions, Dafny.Sequence<char>.FromString(""))).is_None, software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Empty string is not a valid region.")));
      if ((_506_valueOrError1).IsFailure()) {
        output = (_506_valueOrError1).PropagateFailure<MultiKeyring_Compile.MultiKeyring>();
        return output;
      }
      Dafny.ISequence<AwsKmsMrkDiscoveryKeyring_Compile.AwsKmsMrkDiscoveryKeyring> _507_children;
      _507_children = Dafny.Sequence<AwsKmsMrkDiscoveryKeyring_Compile.AwsKmsMrkDiscoveryKeyring>.FromElements();
      BigInteger _hi4 = new BigInteger((regions).Count);
      for (BigInteger _508_i = BigInteger.Zero; _508_i < _hi4; _508_i++) {
        Dafny.ISequence<char> _509_region;
        _509_region = (regions).Select(_508_i);
        software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _510_client;
        Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _511_valueOrError2 = default(Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out60;
        _out60 = (clientSupplier).GetClient(software.amazon.cryptography.materialproviders.internaldafny.types.GetClientInput.create(_509_region));
        _511_valueOrError2 = _out60;
        if ((_511_valueOrError2).IsFailure()) {
          output = (_511_valueOrError2).PropagateFailure<MultiKeyring_Compile.MultiKeyring>();
          return output;
        }
        _510_client = (_511_valueOrError2).Extract();
        AwsKmsMrkDiscoveryKeyring_Compile.AwsKmsMrkDiscoveryKeyring _512_keyring;
        AwsKmsMrkDiscoveryKeyring_Compile.AwsKmsMrkDiscoveryKeyring _nw17 = new AwsKmsMrkDiscoveryKeyring_Compile.AwsKmsMrkDiscoveryKeyring();
        _nw17.__ctor(_510_client, _509_region, discoveryFilter, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.UnwrapOr(grantTokens, Dafny.Sequence<Dafny.ISequence<char>>.FromElements()));
        _512_keyring = _nw17;
        _507_children = Dafny.Sequence<AwsKmsMrkDiscoveryKeyring_Compile.AwsKmsMrkDiscoveryKeyring>.Concat(_507_children, Dafny.Sequence<AwsKmsMrkDiscoveryKeyring_Compile.AwsKmsMrkDiscoveryKeyring>.FromElements(_512_keyring));
      }
      MultiKeyring_Compile.MultiKeyring _513_keyring;
      MultiKeyring_Compile.MultiKeyring _nw18 = new MultiKeyring_Compile.MultiKeyring();
      _nw18.__ctor(Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>.create_None(), _507_children);
      _513_keyring = _nw18;
      output = Wrappers_Compile.Result<MultiKeyring_Compile.MultiKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_513_keyring);
      return output;
      return output;
    }
  }
} // end of namespace MrkAwareDiscoveryMultiKeyring_Compile
namespace AwsKmsMrkKeyring_Compile {

  public partial class AwsKmsMrkKeyring : Keyring_Compile.VerifiableInterface, software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring {
    public AwsKmsMrkKeyring() {
      this._client = default(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient);
      this._awsKmsKey = default(Dafny.ISequence<char>);
      this._grantTokens = default(Dafny.ISequence<Dafny.ISequence<char>>);
      this._awsKmsArn = default(AwsArnParsing_Compile._IAwsKmsIdentifier);
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnEncrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out61;
      _out61 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_IKeyring.OnEncrypt(this, input);
      return _out61;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnDecrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out62;
      _out62 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_IKeyring.OnDecrypt(this, input);
      return _out62;
    }
    public void __ctor(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client, Dafny.ISequence<char> awsKmsKey, Dafny.ISequence<Dafny.ISequence<char>> grantTokens)
    {
      Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsKmsIdentifier, Dafny.ISequence<char>> _514_parsedAwsKmsId;
      _514_parsedAwsKmsId = AwsArnParsing_Compile.__default.ParseAwsKmsIdentifier(awsKmsKey);
      (this)._client = client;
      (this)._awsKmsKey = awsKmsKey;
      (this)._awsKmsArn = (_514_parsedAwsKmsId).dtor_value;
      (this)._grantTokens = grantTokens;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnEncrypt_k(software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _515_materials;
      _515_materials = (input).dtor_materials;
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _516_suite;
      _516_suite = ((input).dtor_materials).dtor_algorithmSuite;
      Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _517_stringifiedEncCtx;
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _518_valueOrError0 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Empty);
      _518_valueOrError0 = AwsKmsUtils_Compile.__default.StringifyEncryptionContext(((input).dtor_materials).dtor_encryptionContext);
      if ((_518_valueOrError0).IsFailure()) {
        output = (_518_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
        return output;
      }
      _517_stringifiedEncCtx = (_518_valueOrError0).Extract();
      AwsKmsKeyring_Compile.KmsGenerateAndWrapKeyMaterial _519_kmsGenerateAndWrap;
      AwsKmsKeyring_Compile.KmsGenerateAndWrapKeyMaterial _nw19 = new AwsKmsKeyring_Compile.KmsGenerateAndWrapKeyMaterial();
      _nw19.__ctor((this).client, (this).awsKmsKey, (this).grantTokens);
      _519_kmsGenerateAndWrap = _nw19;
      AwsKmsKeyring_Compile.KmsWrapKeyMaterial _520_kmsWrap;
      AwsKmsKeyring_Compile.KmsWrapKeyMaterial _nw20 = new AwsKmsKeyring_Compile.KmsWrapKeyMaterial();
      _nw20.__ctor((this).client, (this).awsKmsKey, (this).grantTokens);
      _520_kmsWrap = _nw20;
      EdkWrapping_Compile._IWrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsWrapInfo> _521_wrapOutput;
      Wrappers_Compile._IResult<EdkWrapping_Compile._IWrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _522_valueOrError1 = Wrappers_Compile.Result<EdkWrapping_Compile._IWrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(EdkWrapping_Compile.WrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>.Default(AwsKmsKeyring_Compile.KmsWrapInfo.Default()));
      Wrappers_Compile._IResult<EdkWrapping_Compile._IWrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out63;
      _out63 = EdkWrapping_Compile.__default.WrapEdkMaterial<AwsKmsKeyring_Compile._IKmsWrapInfo>(_515_materials, _520_kmsWrap, _519_kmsGenerateAndWrap);
      _522_valueOrError1 = _out63;
      if ((_522_valueOrError1).IsFailure()) {
        output = (_522_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
        return output;
      }
      _521_wrapOutput = (_522_valueOrError1).Extract();
      Dafny.ISequence<char> _523_kmsKeyArn;
      _523_kmsKeyArn = ((_521_wrapOutput).dtor_wrapInfo).dtor_kmsKeyArn;
      Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>> _524_symmetricSigningKeyList;
      _524_symmetricSigningKeyList = ((((_521_wrapOutput).dtor_symmetricSigningKey).is_Some) ? (Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.create_Some(Dafny.Sequence<Dafny.ISequence<byte>>.FromElements(((_521_wrapOutput).dtor_symmetricSigningKey).dtor_value))) : (Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.create_None()));
      Dafny.ISequence<byte> _525_providerInfo;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _526_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(UTF8.ValidUTF8Bytes.Default());
      _526_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.Encode(_523_kmsKeyArn), AwsKmsUtils_Compile.__default.WrapStringToError);
      if ((_526_valueOrError2).IsFailure()) {
        output = (_526_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
        return output;
      }
      _525_providerInfo = (_526_valueOrError2).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _527_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _527_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger((_525_providerInfo).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Invalid response from AWS KMS GenerateDataKey: Key ID too long.")));
      if ((_527_valueOrError3).IsFailure()) {
        output = (_527_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
        return output;
      }
      software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey _528_edk;
      _528_edk = software.amazon.cryptography.materialproviders.internaldafny.types.EncryptedDataKey.create(Constants_Compile.__default.PROVIDER__ID, _525_providerInfo, (_521_wrapOutput).dtor_wrappedMaterial);
      if ((_521_wrapOutput).is_GenerateAndWrapEdkMaterialOutput) {
        software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _529_result;
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _530_valueOrError4 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        _530_valueOrError4 = Materials_Compile.__default.EncryptionMaterialAddDataKey(_515_materials, (_521_wrapOutput).dtor_plaintextDataKey, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.FromElements(_528_edk), _524_symmetricSigningKeyList);
        if ((_530_valueOrError4).IsFailure()) {
          output = (_530_valueOrError4).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
          return output;
        }
        _529_result = (_530_valueOrError4).Extract();
        output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.OnEncryptOutput.create(_529_result));
        return output;
      } else if ((_521_wrapOutput).is_WrapOnlyEdkMaterialOutput) {
        software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _531_result;
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _532_valueOrError5 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        _532_valueOrError5 = Materials_Compile.__default.EncryptionMaterialAddEncryptedDataKeys(_515_materials, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.FromElements(_528_edk), _524_symmetricSigningKeyList);
        if ((_532_valueOrError5).IsFailure()) {
          output = (_532_valueOrError5).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
          return output;
        }
        _531_result = (_532_valueOrError5).Extract();
        output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.OnEncryptOutput.create(_531_result));
        return output;
      }
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnDecrypt_k(software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _533_materials;
      _533_materials = (input).dtor_materials;
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _534_suite;
      _534_suite = ((input).dtor_materials).dtor_algorithmSuite;
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _535_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _535_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.DecryptionMaterialsWithoutPlaintextDataKey(_533_materials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Keyring received decryption materials that already contain a plaintext data key.")));
      if ((_535_valueOrError0).IsFailure()) {
        output = (_535_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return output;
      }
      AwsKmsUtils_Compile.OnDecryptMrkAwareEncryptedDataKeyFilter _536_filter;
      AwsKmsUtils_Compile.OnDecryptMrkAwareEncryptedDataKeyFilter _nw21 = new AwsKmsUtils_Compile.OnDecryptMrkAwareEncryptedDataKeyFilter();
      _nw21.__ctor((this).awsKmsArn, Constants_Compile.__default.PROVIDER__ID);
      _536_filter = _nw21;
      Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _537_edksToAttempt;
      Wrappers_Compile._IResult<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _538_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out64;
      _out64 = Actions_Compile.__default.FilterWithResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_536_filter, (input).dtor_encryptedDataKeys);
      _538_valueOrError1 = _out64;
      if ((_538_valueOrError1).IsFailure()) {
        output = (_538_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return output;
      }
      _537_edksToAttempt = (_538_valueOrError1).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _539_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _539_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger((_537_edksToAttempt).Count)).Sign == 1, software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Unable to decrypt data key: No Encrypted Data Keys found to match.")));
      if ((_539_valueOrError2).IsFailure()) {
        output = (_539_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return output;
      }
      AwsKmsMrkKeyring_Compile.DecryptSingleEncryptedDataKey _540_decryptClosure;
      AwsKmsMrkKeyring_Compile.DecryptSingleEncryptedDataKey _nw22 = new AwsKmsMrkKeyring_Compile.DecryptSingleEncryptedDataKey();
      _nw22.__ctor(_533_materials, (this).client, (this).awsKmsKey, (this).grantTokens);
      _540_decryptClosure = _nw22;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>> _541_outcome;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>> _out65;
      _out65 = Actions_Compile.__default.ReduceToSuccess<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_540_decryptClosure, _537_edksToAttempt);
      _541_outcome = _out65;
      software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _542_SealedDecryptionMaterials;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _543_valueOrError3 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      _543_valueOrError3 = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_541_outcome, ((System.Func<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_544_errors) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_CollectionOfErrors(_544_errors, Dafny.Sequence<char>.FromString("No Configured KMS Key was able to decrypt the Data Key. The list of encountered Exceptions is available via `list`."));
      })));
      if ((_543_valueOrError3).IsFailure()) {
        output = (_543_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return output;
      }
      _542_SealedDecryptionMaterials = (_543_valueOrError3).Extract();
      output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.OnDecryptOutput.create(_542_SealedDecryptionMaterials));
      return output;
      return output;
    }
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _client {get; set;}
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client { get {
      return this._client;
    } }
    public Dafny.ISequence<char> _awsKmsKey {get; set;}
    public Dafny.ISequence<char> awsKmsKey { get {
      return this._awsKmsKey;
    } }
    public Dafny.ISequence<Dafny.ISequence<char>> _grantTokens {get; set;}
    public Dafny.ISequence<Dafny.ISequence<char>> grantTokens { get {
      return this._grantTokens;
    } }
    public AwsArnParsing_Compile._IAwsKmsIdentifier _awsKmsArn {get; set;}
    public AwsArnParsing_Compile._IAwsKmsIdentifier awsKmsArn { get {
      return this._awsKmsArn;
    } }
  }

  public partial class DecryptSingleEncryptedDataKey : Actions_Compile.ActionWithResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public DecryptSingleEncryptedDataKey() {
      this._materials = default(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials);
      this._client = default(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient);
      this._awsKmsKey = default(Dafny.ISequence<char>);
      this._grantTokens = default(Dafny.ISequence<Dafny.ISequence<char>>);
    }
    public void __ctor(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials materials, software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client, Dafny.ISequence<char> awsKmsKey, Dafny.ISequence<Dafny.ISequence<char>> grantTokens)
    {
      (this)._materials = materials;
      (this)._client = client;
      (this)._awsKmsKey = awsKmsKey;
      (this)._grantTokens = grantTokens;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey edk)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      AwsKmsKeyring_Compile.KmsUnwrapKeyMaterial _545_kmsUnwrap;
      AwsKmsKeyring_Compile.KmsUnwrapKeyMaterial _nw23 = new AwsKmsKeyring_Compile.KmsUnwrapKeyMaterial();
      _nw23.__ctor((this).client, (this).awsKmsKey, (this).grantTokens);
      _545_kmsUnwrap = _nw23;
      Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _546_unwrapOutputRes;
      Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out66;
      _out66 = EdkWrapping_Compile.__default.UnwrapEdkMaterial<AwsKmsKeyring_Compile._IKmsUnwrapInfo>((edk).dtor_ciphertext, (this).materials, _545_kmsUnwrap);
      _546_unwrapOutputRes = _out66;
      EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo> _547_unwrapOutput;
      Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _548_valueOrError0 = Wrappers_Compile.Result<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(EdkWrapping_Compile.UnwrapEdkMaterialOutput<AwsKmsKeyring_Compile._IKmsUnwrapInfo>.Default(AwsKmsKeyring_Compile.KmsUnwrapInfo.Default()));
      _548_valueOrError0 = _546_unwrapOutputRes;
      if ((_548_valueOrError0).IsFailure()) {
        res = (_548_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        return res;
      }
      _547_unwrapOutput = (_548_valueOrError0).Extract();
      software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _549_result;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _550_valueOrError1 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      _550_valueOrError1 = Materials_Compile.__default.DecryptionMaterialsAddDataKey((this).materials, (_547_unwrapOutput).dtor_plaintextDataKey, (_547_unwrapOutput).dtor_symmetricSigningKey);
      if ((_550_valueOrError1).IsFailure()) {
        res = (_550_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        return res;
      }
      _549_result = (_550_valueOrError1).Extract();
      res = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_549_result);
      return res;
      return res;
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _materials {get; set;}
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials materials { get {
      return this._materials;
    } }
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _client {get; set;}
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client { get {
      return this._client;
    } }
    public Dafny.ISequence<char> _awsKmsKey {get; set;}
    public Dafny.ISequence<char> awsKmsKey { get {
      return this._awsKmsKey;
    } }
    public Dafny.ISequence<Dafny.ISequence<char>> _grantTokens {get; set;}
    public Dafny.ISequence<Dafny.ISequence<char>> grantTokens { get {
      return this._grantTokens;
    } }
  }

} // end of namespace AwsKmsMrkKeyring_Compile
namespace MrkAwareStrictMultiKeyring_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<MultiKeyring_Compile.MultiKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> MrkAwareStrictMultiKeyring(Wrappers_Compile._IOption<Dafny.ISequence<char>> generator, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> awsKmsKeys, software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier clientSupplier, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> grantTokens)
    {
      Wrappers_Compile._IResult<MultiKeyring_Compile.MultiKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<MultiKeyring_Compile.MultiKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      var _pat_let_tv31 = awsKmsKeys;
      Dafny.ISequence<Dafny.ISequence<char>> _551_allStrings;
      _551_allStrings = ((System.Func<Wrappers_Compile._IOption<Dafny.ISequence<char>>, Dafny.ISequence<Dafny.ISequence<char>>>)((_source24) => {
        if (_source24.is_None) {
          return Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.UnwrapOr(awsKmsKeys, Dafny.Sequence<Dafny.ISequence<char>>.FromElements());
        } else {
          Dafny.ISequence<char> _552___mcc_h0 = _source24.dtor_value;
          return Dafny.Helpers.Let<Dafny.ISequence<char>, Dafny.ISequence<Dafny.ISequence<char>>>(_552___mcc_h0, _pat_let17_0 => Dafny.Helpers.Let<Dafny.ISequence<char>, Dafny.ISequence<Dafny.ISequence<char>>>(_pat_let17_0, _553_g => Dafny.Sequence<Dafny.ISequence<char>>.Concat(Dafny.Sequence<Dafny.ISequence<char>>.FromElements(_553_g), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.UnwrapOr(_pat_let_tv31, Dafny.Sequence<Dafny.ISequence<char>>.FromElements()))));
        }
      }))(generator);
      Dafny.ISequence<AwsArnParsing_Compile._IAwsKmsIdentifier> _554_allIdentifiers;
      Wrappers_Compile._IResult<Dafny.ISequence<AwsArnParsing_Compile._IAwsKmsIdentifier>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _555_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<AwsArnParsing_Compile._IAwsKmsIdentifier>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<AwsArnParsing_Compile._IAwsKmsIdentifier>.Empty);
      _555_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<AwsArnParsing_Compile._IAwsKmsIdentifier>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Seq_Compile.__default.MapWithResult<Dafny.ISequence<char>, AwsArnParsing_Compile._IAwsKmsIdentifier, Dafny.ISequence<char>>(AwsArnParsing_Compile.__default.IsAwsKmsIdentifierString, _551_allStrings), AwsKmsUtils_Compile.__default.WrapStringToError);
      if ((_555_valueOrError0).IsFailure()) {
        output = (_555_valueOrError0).PropagateFailure<MultiKeyring_Compile.MultiKeyring>();
        return output;
      }
      _554_allIdentifiers = (_555_valueOrError0).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _556_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _556_valueOrError1 = AwsKmsMrkAreUnique_Compile.__default.AwsKmsMrkAreUnique(_554_allIdentifiers);
      if ((_556_valueOrError1).IsFailure()) {
        output = (_556_valueOrError1).PropagateFailure<MultiKeyring_Compile.MultiKeyring>();
        return output;
      }
      Wrappers_Compile._IOption<AwsKmsMrkKeyring_Compile.AwsKmsMrkKeyring> _557_generatorKeyring = Wrappers_Compile.Option<AwsKmsMrkKeyring_Compile.AwsKmsMrkKeyring>.Default();
      Wrappers_Compile._IOption<Dafny.ISequence<char>> _source25 = generator;
      if (_source25.is_None) {
        _557_generatorKeyring = Wrappers_Compile.Option<AwsKmsMrkKeyring_Compile.AwsKmsMrkKeyring>.create_None();
      } else {
        Dafny.ISequence<char> _558___mcc_h1 = _source25.dtor_value;
        Dafny.ISequence<char> _559_generatorIdentifier = _558___mcc_h1;
        AwsArnParsing_Compile._IAwsKmsIdentifier _560_arn;
        Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsKmsIdentifier, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _561_valueOrError2 = default(Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsKmsIdentifier, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        _561_valueOrError2 = Wrappers_Compile.Result<AwsArnParsing_Compile._IAwsKmsIdentifier, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(AwsArnParsing_Compile.__default.IsAwsKmsIdentifierString(_559_generatorIdentifier), AwsKmsUtils_Compile.__default.WrapStringToError);
        if ((_561_valueOrError2).IsFailure()) {
          output = (_561_valueOrError2).PropagateFailure<MultiKeyring_Compile.MultiKeyring>();
          return output;
        }
        _560_arn = (_561_valueOrError2).Extract();
        Wrappers_Compile._IOption<Dafny.ISequence<char>> _562_region;
        _562_region = AwsArnParsing_Compile.__default.GetRegion(_560_arn);
        software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _563_client;
        Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _564_valueOrError3 = default(Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out67;
        _out67 = (clientSupplier).GetClient(software.amazon.cryptography.materialproviders.internaldafny.types.GetClientInput.create(Wrappers_Compile.Option<Dafny.ISequence<char>>.UnwrapOr(_562_region, Dafny.Sequence<char>.FromString(""))));
        _564_valueOrError3 = _out67;
        if ((_564_valueOrError3).IsFailure()) {
          output = (_564_valueOrError3).PropagateFailure<MultiKeyring_Compile.MultiKeyring>();
          return output;
        }
        _563_client = (_564_valueOrError3).Extract();
        AwsKmsMrkKeyring_Compile.AwsKmsMrkKeyring _565_g;
        AwsKmsMrkKeyring_Compile.AwsKmsMrkKeyring _nw24 = new AwsKmsMrkKeyring_Compile.AwsKmsMrkKeyring();
        _nw24.__ctor(_563_client, _559_generatorIdentifier, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.UnwrapOr(grantTokens, Dafny.Sequence<Dafny.ISequence<char>>.FromElements()));
        _565_g = _nw24;
        _557_generatorKeyring = Wrappers_Compile.Option<AwsKmsMrkKeyring_Compile.AwsKmsMrkKeyring>.create_Some(_565_g);
      }
      Dafny.ISequence<AwsKmsMrkKeyring_Compile.AwsKmsMrkKeyring> _566_children;
      _566_children = Dafny.Sequence<AwsKmsMrkKeyring_Compile.AwsKmsMrkKeyring>.FromElements();
      Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> _source26 = awsKmsKeys;
      if (_source26.is_None) {
        _566_children = Dafny.Sequence<AwsKmsMrkKeyring_Compile.AwsKmsMrkKeyring>.FromElements();
      } else {
        Dafny.ISequence<Dafny.ISequence<char>> _567___mcc_h2 = _source26.dtor_value;
        Dafny.ISequence<Dafny.ISequence<char>> _568_childIdentifiers = _567___mcc_h2;
        BigInteger _hi5 = new BigInteger((_568_childIdentifiers).Count);
        for (BigInteger _569_index = BigInteger.Zero; _569_index < _hi5; _569_index++) {
          Dafny.ISequence<char> _570_childIdentifier;
          _570_childIdentifier = (_568_childIdentifiers).Select(_569_index);
          AwsArnParsing_Compile._IAwsKmsIdentifier _571_info;
          Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsKmsIdentifier, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _572_valueOrError4 = default(Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsKmsIdentifier, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
          _572_valueOrError4 = Wrappers_Compile.Result<AwsArnParsing_Compile._IAwsKmsIdentifier, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(AwsArnParsing_Compile.__default.IsAwsKmsIdentifierString(_570_childIdentifier), AwsKmsUtils_Compile.__default.WrapStringToError);
          if ((_572_valueOrError4).IsFailure()) {
            output = (_572_valueOrError4).PropagateFailure<MultiKeyring_Compile.MultiKeyring>();
            return output;
          }
          _571_info = (_572_valueOrError4).Extract();
          Wrappers_Compile._IOption<Dafny.ISequence<char>> _573_region;
          _573_region = AwsArnParsing_Compile.__default.GetRegion(_571_info);
          software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _574_client;
          Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _575_valueOrError5 = default(Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
          Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out68;
          _out68 = (clientSupplier).GetClient(software.amazon.cryptography.materialproviders.internaldafny.types.GetClientInput.create(Wrappers_Compile.Option<Dafny.ISequence<char>>.UnwrapOr(_573_region, Dafny.Sequence<char>.FromString(""))));
          _575_valueOrError5 = _out68;
          if ((_575_valueOrError5).IsFailure()) {
            output = (_575_valueOrError5).PropagateFailure<MultiKeyring_Compile.MultiKeyring>();
            return output;
          }
          _574_client = (_575_valueOrError5).Extract();
          AwsKmsMrkKeyring_Compile.AwsKmsMrkKeyring _576_keyring;
          AwsKmsMrkKeyring_Compile.AwsKmsMrkKeyring _nw25 = new AwsKmsMrkKeyring_Compile.AwsKmsMrkKeyring();
          _nw25.__ctor(_574_client, _570_childIdentifier, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.UnwrapOr(grantTokens, Dafny.Sequence<Dafny.ISequence<char>>.FromElements()));
          _576_keyring = _nw25;
          _566_children = Dafny.Sequence<AwsKmsMrkKeyring_Compile.AwsKmsMrkKeyring>.Concat(_566_children, Dafny.Sequence<AwsKmsMrkKeyring_Compile.AwsKmsMrkKeyring>.FromElements(_576_keyring));
        }
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _577_valueOrError6 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _577_valueOrError6 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((_557_generatorKeyring).is_Some) || ((new BigInteger((_566_children).Count)).Sign == 1), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("generatorKeyring or child Keyrings needed to create a multi keyring")));
      if ((_577_valueOrError6).IsFailure()) {
        output = (_577_valueOrError6).PropagateFailure<MultiKeyring_Compile.MultiKeyring>();
        return output;
      }
      MultiKeyring_Compile.MultiKeyring _578_keyring;
      MultiKeyring_Compile.MultiKeyring _nw26 = new MultiKeyring_Compile.MultiKeyring();
      _nw26.__ctor(_557_generatorKeyring, _566_children);
      _578_keyring = _nw26;
      output = Wrappers_Compile.Result<MultiKeyring_Compile.MultiKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_578_keyring);
      return output;
      return output;
    }
  }
} // end of namespace MrkAwareStrictMultiKeyring_Compile
namespace LocalCMC_Compile {

  public interface _IRef<T> {
    bool is_Ptr { get; }
    bool is_Null { get; }
    T dtor_deref { get; }
    _IRef<__T> DowncastClone<__T>(Func<T, __T> converter0);
  }
  public abstract class Ref<T> : _IRef<T> {
    public Ref() { }
    public static LocalCMC_Compile._IRef<T> Default() {
      return create_Null();
    }
    public static Dafny.TypeDescriptor<LocalCMC_Compile._IRef<T>> _TypeDescriptor() {
      return new Dafny.TypeDescriptor<LocalCMC_Compile._IRef<T>>(LocalCMC_Compile.Ref<T>.Default());
    }
    public static _IRef<T> create_Ptr(T deref) {
      return new Ref_Ptr<T>(deref);
    }
    public static _IRef<T> create_Null() {
      return new Ref_Null<T>();
    }
    public bool is_Ptr { get { return this is Ref_Ptr<T>; } }
    public bool is_Null { get { return this is Ref_Null<T>; } }
    public T dtor_deref {
      get {
        var d = this;
        return ((Ref_Ptr<T>)d)._deref;
      }
    }
    public abstract _IRef<__T> DowncastClone<__T>(Func<T, __T> converter0);
  }
  public class Ref_Ptr<T> : Ref<T> {
    public readonly T _deref;
    public Ref_Ptr(T deref) {
      this._deref = deref;
    }
    public override _IRef<__T> DowncastClone<__T>(Func<T, __T> converter0) {
      if (this is _IRef<__T> dt) { return dt; }
      return new Ref_Ptr<__T>(converter0(_deref));
    }
    public override bool Equals(object other) {
      var oth = other as LocalCMC_Compile.Ref_Ptr<T>;
      return oth != null && object.Equals(this._deref, oth._deref);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._deref));
      return (int) hash;
    }
    public override string ToString() {
      string s = "LocalCMC_Compile.Ref.Ptr";
      s += "(";
      s += Dafny.Helpers.ToString(this._deref);
      s += ")";
      return s;
    }
  }
  public class Ref_Null<T> : Ref<T> {
    public Ref_Null() {
    }
    public override _IRef<__T> DowncastClone<__T>(Func<T, __T> converter0) {
      if (this is _IRef<__T> dt) { return dt; }
      return new Ref_Null<__T>();
    }
    public override bool Equals(object other) {
      var oth = other as LocalCMC_Compile.Ref_Null<T>;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "LocalCMC_Compile.Ref.Null";
      return s;
    }
  }

  public partial class CacheEntry {
    public CacheEntry() {
      this.prev = LocalCMC_Compile.Ref<LocalCMC_Compile.CacheEntry>.Default();
      this.next = LocalCMC_Compile.Ref<LocalCMC_Compile.CacheEntry>.Default();
      this.messagesUsed = default(int);
      this.bytesUsed = default(int);
      this._identifier = Dafny.Sequence<byte>.Empty;
      this._materials = default(software.amazon.cryptography.materialproviders.internaldafny.types._IMaterials);
      this._creationTime = default(long);
      this._expiryTime = default(long);
    }
    public LocalCMC_Compile._IRef<LocalCMC_Compile.CacheEntry> prev {get; set;}
    public LocalCMC_Compile._IRef<LocalCMC_Compile.CacheEntry> next {get; set;}
    public int messagesUsed {get; set;}
    public int bytesUsed {get; set;}
    public void __ctor(software.amazon.cryptography.materialproviders.internaldafny.types._IMaterials materials_k, Dafny.ISequence<byte> identifier_k, long creationTime_k, long expiryTime_k, int messagesUsed_k, int bytesUsed_k)
    {
      (this)._materials = materials_k;
      (this)._identifier = identifier_k;
      (this)._creationTime = creationTime_k;
      (this)._expiryTime = expiryTime_k;
      (this).messagesUsed = messagesUsed_k;
      (this).bytesUsed = bytesUsed_k;
      (this).prev = LocalCMC_Compile.__default.NULL;
      (this).next = LocalCMC_Compile.__default.NULL;
    }
    public Dafny.ISequence<byte> _identifier {get; set;}
    public Dafny.ISequence<byte> identifier { get {
      return this._identifier;
    } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IMaterials _materials {get; set;}
    public software.amazon.cryptography.materialproviders.internaldafny.types._IMaterials materials { get {
      return this._materials;
    } }
    public long _creationTime {get; set;}
    public long creationTime { get {
      return this._creationTime;
    } }
    public long _expiryTime {get; set;}
    public long expiryTime { get {
      return this._expiryTime;
    } }
  }

  public partial class DoublyLinkedCacheEntryList {
    public DoublyLinkedCacheEntryList() {
      this.head = LocalCMC_Compile.Ref<LocalCMC_Compile.CacheEntry>.Default();
      this.tail = LocalCMC_Compile.Ref<LocalCMC_Compile.CacheEntry>.Default();
    }
    public void __ctor()
    {
      (this).head = LocalCMC_Compile.Ref<LocalCMC_Compile.CacheEntry>.create_Null();
      (this).tail = LocalCMC_Compile.Ref<LocalCMC_Compile.CacheEntry>.create_Null();
    }
    public LocalCMC_Compile._IRef<LocalCMC_Compile.CacheEntry> head {get; set;}
    public LocalCMC_Compile._IRef<LocalCMC_Compile.CacheEntry> tail {get; set;}
    public void pushCell(LocalCMC_Compile.CacheEntry toPush)
    {
      LocalCMC_Compile._IRef<LocalCMC_Compile.CacheEntry> _579_cRef;
      _579_cRef = LocalCMC_Compile.Ref<LocalCMC_Compile.CacheEntry>.create_Ptr(toPush);
      if ((this.head).is_Ptr) {
        var _obj0 = (this.head).dtor_deref;
        _obj0.prev = _579_cRef;
        (toPush).next = this.head;
        (this).head = _579_cRef;
      } else {
        (this).head = _579_cRef;
        (this).tail = this.head;
      }
    }
    public void moveToFront(LocalCMC_Compile.CacheEntry c)
    {
      if (((this.head).dtor_deref) != (object) (c)) {
        LocalCMC_Compile._IRef<LocalCMC_Compile.CacheEntry> _580_toPush;
        _580_toPush = LocalCMC_Compile.Ref<LocalCMC_Compile.CacheEntry>.create_Ptr(c);
        (this).@remove(c);
        if ((this.head).is_Ptr) {
          var _obj1 = (this.head).dtor_deref;
          _obj1.prev = _580_toPush;
          var _obj2 = (_580_toPush).dtor_deref;
          _obj2.next = this.head;
          (this).head = _580_toPush;
        } else {
          (this).head = _580_toPush;
          (this).tail = this.head;
        }
      }
    }
    public void @remove(LocalCMC_Compile.CacheEntry toRemove)
    {
      if ((toRemove.prev).is_Null) {
        (this).head = toRemove.next;
      } else {
        var _obj3 = (toRemove.prev).dtor_deref;
        _obj3.next = toRemove.next;
      }
      if ((toRemove.next).is_Null) {
        (this).tail = toRemove.prev;
      } else {
        var _obj4 = (toRemove.next).dtor_deref;
        _obj4.prev = toRemove.prev;
      }
    after_0: ;
      (toRemove).next = LocalCMC_Compile.__default.NULL;
      (toRemove).prev = LocalCMC_Compile.__default.NULL;
    }
  }

  public partial class LocalCMC : software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache {
    public LocalCMC() {
      this.queue = default(LocalCMC_Compile.DoublyLinkedCacheEntryList);
      this.cache = default(DafnyLibraries.MutableMap<Dafny.ISequence<byte>, LocalCMC_Compile.CacheEntry>);
      this._entryCapacity = BigInteger.Zero;
      this._entryPruningTailSize = BigInteger.Zero;
    }
    public Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> PutCacheEntry(software.amazon.cryptography.materialproviders.internaldafny.types._IPutCacheEntryInput input)
    {
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out69;
      _out69 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_ICryptographicMaterialsCache.PutCacheEntry(this, input);
      return _out69;
    }
    public Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> UpdateUsageMetadata(software.amazon.cryptography.materialproviders.internaldafny.types._IUpdateUsageMetadataInput input)
    {
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out70;
      _out70 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_ICryptographicMaterialsCache.UpdateUsageMetadata(this, input);
      return _out70;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetCacheEntry(software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out71;
      _out71 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_ICryptographicMaterialsCache.GetCacheEntry(this, input);
      return _out71;
    }
    public Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> DeleteCacheEntry(software.amazon.cryptography.materialproviders.internaldafny.types._IDeleteCacheEntryInput input)
    {
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out72;
      _out72 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_ICryptographicMaterialsCache.DeleteCacheEntry(this, input);
      return _out72;
    }
    public LocalCMC_Compile.DoublyLinkedCacheEntryList queue {get; set;}
    public DafnyLibraries.MutableMap<Dafny.ISequence<byte>, LocalCMC_Compile.CacheEntry> cache {get; set;}
    public void __ctor(BigInteger entryCapacity_k, BigInteger entryPruningTailSize_k)
    {
      (this)._entryCapacity = entryCapacity_k;
      (this)._entryPruningTailSize = entryPruningTailSize_k;
      DafnyLibraries.MutableMap<Dafny.ISequence<byte>, LocalCMC_Compile.CacheEntry> _nw27 = new DafnyLibraries.MutableMap<Dafny.ISequence<byte>, LocalCMC_Compile.CacheEntry>();
      (this).cache = _nw27;
      LocalCMC_Compile.DoublyLinkedCacheEntryList _nw28 = new LocalCMC_Compile.DoublyLinkedCacheEntryList();
      _nw28.__ctor();
      (this).queue = _nw28;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetCacheEntry_k(software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      long _581_now;
      long _out73;
      _out73 = Time.__default.CurrentRelativeTime();
      _581_now = _out73;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out74;
      _out74 = (this).GetCacheEntryWithTime(input, _581_now);
      output = _out74;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetCacheEntryWithTime(software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryInput input, long now)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      if ((this.cache).HasKey((input).dtor_identifier)) {
        LocalCMC_Compile.CacheEntry _582_entry;
        _582_entry = (this.cache).Select((input).dtor_identifier);
        if ((now) <= ((_582_entry).expiryTime)) {
          (this.queue).moveToFront(_582_entry);
          output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.GetCacheEntryOutput.create((_582_entry).materials, (_582_entry).creationTime, (_582_entry).expiryTime, _582_entry.messagesUsed, _582_entry.bytesUsed));
          _System._ITuple0 _583___v0;
          Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _584_valueOrError0 = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
          Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out75;
          _out75 = (this).pruning(now);
          _584_valueOrError0 = _out75;
          if ((_584_valueOrError0).IsFailure()) {
            output = (_584_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput>();
            return output;
          }
          _583___v0 = (_584_valueOrError0).Extract();
        } else {
          _System._ITuple0 _585___v1;
          Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _586_valueOrError1 = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
          Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out76;
          _out76 = (this).DeleteCacheEntry_k(software.amazon.cryptography.materialproviders.internaldafny.types.DeleteCacheEntryInput.create((input).dtor_identifier));
          _586_valueOrError1 = _out76;
          if ((_586_valueOrError1).IsFailure()) {
            output = (_586_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput>();
            return output;
          }
          _585___v1 = (_586_valueOrError1).Extract();
          output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_EntryDoesNotExist(Dafny.Sequence<char>.FromString("Entry past TTL")));
        }
      } else {
        output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_EntryDoesNotExist(Dafny.Sequence<char>.FromString("Entry does not exist")));
      }
      return output;
    }
    public Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> PutCacheEntry_k(software.amazon.cryptography.materialproviders.internaldafny.types._IPutCacheEntryInput input)
    {
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
      if (((this).entryCapacity).Sign == 0) {
        output = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_System.Tuple0.create());
        return output;
      }
      if ((this.cache).HasKey((input).dtor_identifier)) {
        _System._ITuple0 _587___v2;
        Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _588_valueOrError0 = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
        Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out77;
        _out77 = (this).DeleteCacheEntry_k(software.amazon.cryptography.materialproviders.internaldafny.types.DeleteCacheEntryInput.create((input).dtor_identifier));
        _588_valueOrError0 = _out77;
        if ((_588_valueOrError0).IsFailure()) {
          output = (_588_valueOrError0).PropagateFailure<_System._ITuple0>();
          return output;
        }
        _587___v2 = (_588_valueOrError0).Extract();
      }
      if (((this).entryCapacity) == ((this.cache).Size())) {
        _System._ITuple0 _589___v3;
        Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _590_valueOrError1 = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
        Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out78;
        _out78 = (this).DeleteCacheEntry_k(software.amazon.cryptography.materialproviders.internaldafny.types.DeleteCacheEntryInput.create(((this.queue.tail).dtor_deref).identifier));
        _590_valueOrError1 = _out78;
        if ((_590_valueOrError1).IsFailure()) {
          output = (_590_valueOrError1).PropagateFailure<_System._ITuple0>();
          return output;
        }
        _589___v3 = (_590_valueOrError1).Extract();
      }
      LocalCMC_Compile.CacheEntry _591_cell;
      LocalCMC_Compile.CacheEntry _nw29 = new LocalCMC_Compile.CacheEntry();
      _nw29.__ctor((input).dtor_materials, (input).dtor_identifier, (input).dtor_creationTime, (input).dtor_expiryTime, Wrappers_Compile.Option<int>.UnwrapOr((input).dtor_messagesUsed, 0), Wrappers_Compile.Option<int>.UnwrapOr((input).dtor_bytesUsed, 0));
      _591_cell = _nw29;
      (this.queue).pushCell(_591_cell);
      (this.cache).Put((input).dtor_identifier, _591_cell);
      output = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_System.Tuple0.create());
      return output;
    }
    public Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> DeleteCacheEntry_k(software.amazon.cryptography.materialproviders.internaldafny.types._IDeleteCacheEntryInput input)
    {
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
      if ((this.cache).HasKey((input).dtor_identifier)) {
        LocalCMC_Compile.CacheEntry _592_cell;
        _592_cell = (this.cache).Select((input).dtor_identifier);
        (this.cache).Remove((input).dtor_identifier);
      after_1: ;
        (this.queue).@remove(_592_cell);
      }
      output = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_System.Tuple0.create());
      return output;
    }
    public Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> UpdateUsageMetadata_k(software.amazon.cryptography.materialproviders.internaldafny.types._IUpdateUsageMetadataInput input)
    {
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
      if ((this.cache).HasKey((input).dtor_identifier)) {
        LocalCMC_Compile.CacheEntry _593_cell;
        _593_cell = (this.cache).Select((input).dtor_identifier);
        if (((_593_cell.messagesUsed) <= ((LocalCMC_Compile.__default.INT32__MAX__VALUE) - (1))) && ((_593_cell.bytesUsed) <= ((LocalCMC_Compile.__default.INT32__MAX__VALUE) - ((input).dtor_bytesUsed)))) {
          int _rhs0 = (_593_cell.messagesUsed) + (1);
          int _rhs1 = (_593_cell.bytesUsed) + ((input).dtor_bytesUsed);
          LocalCMC_Compile.CacheEntry _lhs0 = _593_cell;
          LocalCMC_Compile.CacheEntry _lhs1 = _593_cell;
          _lhs0.messagesUsed = _rhs0;
          _lhs1.bytesUsed = _rhs1;
        } else {
          _System._ITuple0 _594___v4;
          Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _595_valueOrError0 = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
          Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out79;
          _out79 = (this).DeleteCacheEntry_k(software.amazon.cryptography.materialproviders.internaldafny.types.DeleteCacheEntryInput.create((input).dtor_identifier));
          _595_valueOrError0 = _out79;
          if ((_595_valueOrError0).IsFailure()) {
            output = (_595_valueOrError0).PropagateFailure<_System._ITuple0>();
            return output;
          }
          _594___v4 = (_595_valueOrError0).Extract();
        }
      }
      output = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_System.Tuple0.create());
      return output;
      return output;
    }
    public Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> pruning(long now)
    {
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
      BigInteger _hi6 = (this).entryPruningTailSize;
      for (BigInteger _596_i = BigInteger.Zero; _596_i < _hi6; _596_i++) {
        if ((this.queue.tail).is_Ptr) {
          if ((((this.queue.tail).dtor_deref).expiryTime) < (now)) {
            _System._ITuple0 _597___v5;
            Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _598_valueOrError0 = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
            Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out80;
            _out80 = (this).DeleteCacheEntry_k(software.amazon.cryptography.materialproviders.internaldafny.types.DeleteCacheEntryInput.create(((this.queue.tail).dtor_deref).identifier));
            _598_valueOrError0 = _out80;
            if ((_598_valueOrError0).IsFailure()) {
              output = (_598_valueOrError0).PropagateFailure<_System._ITuple0>();
              return output;
            }
            _597___v5 = (_598_valueOrError0).Extract();
          } else {
            output = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_System.Tuple0.create());
            return output;
          }
        } else {
          output = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_System.Tuple0.create());
          return output;
        }
      }
      output = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_System.Tuple0.create());
      return output;
      return output;
    }
    public BigInteger _entryCapacity {get; set;}
    public BigInteger entryCapacity { get {
      return this._entryCapacity;
    } }
    public BigInteger _entryPruningTailSize {get; set;}
    public BigInteger entryPruningTailSize { get {
      return this._entryPruningTailSize;
    } }
  }

  public partial class __default {
    public static void RemoveValue<__K, __V>(__K k0, Dafny.IMap<__K,__V> m)
    {
      Dafny.IMap<__K,__V> _599_m_k;
      _599_m_k = Dafny.Map<__K, __V>.Subtract(m, Dafny.Set<__K>.FromElements(k0));
    }
    public static LocalCMC_Compile._IRef<LocalCMC_Compile.CacheEntry> NULL { get {
      return LocalCMC_Compile.Ref<LocalCMC_Compile.CacheEntry>.create_Null();
    } }
    public static int INT32__MAX__VALUE { get {
      return 2040109465;
    } }
    public static long INT64__MAX__VALUE { get {
      return 8762203435012037017L;
    } }
  }
} // end of namespace LocalCMC_Compile
namespace software.amazon.cryptography.internaldafny.SynchronizedLocalCMC {


} // end of namespace software.amazon.cryptography.internaldafny.SynchronizedLocalCMC
namespace StormTracker_Compile {

  public interface _ICacheState {
    bool is_EmptyWait { get; }
    bool is_EmptyFetch { get; }
    bool is_Full { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput dtor_data { get; }
    _ICacheState DowncastClone();
  }
  public abstract class CacheState : _ICacheState {
    public CacheState() { }
    private static readonly StormTracker_Compile._ICacheState theDefault = create_EmptyWait();
    public static StormTracker_Compile._ICacheState Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<StormTracker_Compile._ICacheState> _TYPE = new Dafny.TypeDescriptor<StormTracker_Compile._ICacheState>(StormTracker_Compile.CacheState.Default());
    public static Dafny.TypeDescriptor<StormTracker_Compile._ICacheState> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICacheState create_EmptyWait() {
      return new CacheState_EmptyWait();
    }
    public static _ICacheState create_EmptyFetch() {
      return new CacheState_EmptyFetch();
    }
    public static _ICacheState create_Full(software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput data) {
      return new CacheState_Full(data);
    }
    public bool is_EmptyWait { get { return this is CacheState_EmptyWait; } }
    public bool is_EmptyFetch { get { return this is CacheState_EmptyFetch; } }
    public bool is_Full { get { return this is CacheState_Full; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput dtor_data {
      get {
        var d = this;
        return ((CacheState_Full)d)._data;
      }
    }
    public abstract _ICacheState DowncastClone();
  }
  public class CacheState_EmptyWait : CacheState {
    public CacheState_EmptyWait() {
    }
    public override _ICacheState DowncastClone() {
      if (this is _ICacheState dt) { return dt; }
      return new CacheState_EmptyWait();
    }
    public override bool Equals(object other) {
      var oth = other as StormTracker_Compile.CacheState_EmptyWait;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "StormTracker_Compile.CacheState.EmptyWait";
      return s;
    }
  }
  public class CacheState_EmptyFetch : CacheState {
    public CacheState_EmptyFetch() {
    }
    public override _ICacheState DowncastClone() {
      if (this is _ICacheState dt) { return dt; }
      return new CacheState_EmptyFetch();
    }
    public override bool Equals(object other) {
      var oth = other as StormTracker_Compile.CacheState_EmptyFetch;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "StormTracker_Compile.CacheState.EmptyFetch";
      return s;
    }
  }
  public class CacheState_Full : CacheState {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput _data;
    public CacheState_Full(software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput data) {
      this._data = data;
    }
    public override _ICacheState DowncastClone() {
      if (this is _ICacheState dt) { return dt; }
      return new CacheState_Full(_data);
    }
    public override bool Equals(object other) {
      var oth = other as StormTracker_Compile.CacheState_Full;
      return oth != null && object.Equals(this._data, oth._data);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._data));
      return (int) hash;
    }
    public override string ToString() {
      string s = "StormTracker_Compile.CacheState.Full";
      s += "(";
      s += Dafny.Helpers.ToString(this._data);
      s += ")";
      return s;
    }
  }

  public partial class StormTracker {
    public StormTracker() {
      this.wrapped = default(LocalCMC_Compile.LocalCMC);
      this.inFlight = default(DafnyLibraries.MutableMap<Dafny.ISequence<byte>, long>);
      this.gracePeriod = default(long);
      this.graceInterval = default(long);
      this.fanOut = default(long);
      this.inFlightTTL = default(long);
      this.lastPrune = default(long);
      this.sleepMilli = default(long);
    }
    public LocalCMC_Compile.LocalCMC wrapped {get; set;}
    public DafnyLibraries.MutableMap<Dafny.ISequence<byte>, long> inFlight {get; set;}
    public long gracePeriod {get; set;}
    public long graceInterval {get; set;}
    public long fanOut {get; set;}
    public long inFlightTTL {get; set;}
    public long lastPrune {get; set;}
    public long sleepMilli {get; set;}
    public void __ctor(software.amazon.cryptography.materialproviders.internaldafny.types._IStormTrackingCache cache)
    {
      LocalCMC_Compile.LocalCMC _nw30 = new LocalCMC_Compile.LocalCMC();
      _nw30.__ctor(new BigInteger((cache).dtor_entryCapacity), new BigInteger(Wrappers_Compile.Option<int>.UnwrapOr((cache).dtor_entryPruningTailSize, 1)));
      (this).wrapped = _nw30;
      DafnyLibraries.MutableMap<Dafny.ISequence<byte>, long> _nw31 = new DafnyLibraries.MutableMap<Dafny.ISequence<byte>, long>();
      (this).inFlight = _nw31;
      (this).gracePeriod = (long)((cache).dtor_gracePeriod);
      (this).graceInterval = (long)((cache).dtor_graceInterval);
      (this).fanOut = (long)((cache).dtor_fanOut);
      (this).inFlightTTL = (long)((cache).dtor_inFlightTTL);
      (this).sleepMilli = (long)((cache).dtor_sleepMilli);
      (this).lastPrune = 0L;
    }
    public long InFlightSize() {
      BigInteger _600_x = (this.inFlight).Size();
      if ((_600_x) <= (StandardLibrary_mUInt_Compile.__default.INT64__MAX__LIMIT)) {
        return (long)(_600_x);
      } else {
        return (long)(StandardLibrary_mUInt_Compile.__default.INT64__MAX__LIMIT);
      }
    }
    public bool FanOutReached(long now)
    {
      bool res = false;
      (this).PruneInFlight(now);
      res = (this.fanOut) <= ((this).InFlightSize());
      return res;
      return res;
    }
    public long AddLong(long x, long y)
    {
      if ((x) < (((long)(StandardLibrary_mUInt_Compile.__default.INT64__MAX__LIMIT)) - (y))) {
        return (x) + (y);
      } else {
        return (long)(StandardLibrary_mUInt_Compile.__default.INT64__MAX__LIMIT);
      }
    }
    public StormTracker_Compile._ICacheState CheckInFlight(Dafny.ISequence<byte> identifier, software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput result, long now)
    {
      StormTracker_Compile._ICacheState output = StormTracker_Compile.CacheState.Default();
      bool _601_fanOutReached;
      bool _out85;
      _out85 = (this).FanOutReached(now);
      _601_fanOutReached = _out85;
      if (_601_fanOutReached) {
        output = StormTracker_Compile.CacheState.create_Full(result);
        return output;
      } else if (((result).dtor_expiryTime) <= (now)) {
        StormTracker_Compile._ICacheState _out86;
        _out86 = (this).CheckNewEntry(identifier, now);
        output = _out86;
      } else if ((now) < (((result).dtor_expiryTime) - (this.gracePeriod))) {
        output = StormTracker_Compile.CacheState.create_Full(result);
        return output;
      } else {
        if ((this.inFlight).HasKey(identifier)) {
          long _602_entry;
          _602_entry = (this.inFlight).Select(identifier);
          if (((this).AddLong(_602_entry, this.graceInterval)) > (now)) {
            output = StormTracker_Compile.CacheState.create_Full(result);
            return output;
          }
        }
        (this.inFlight).Put(identifier, now);
        output = StormTracker_Compile.CacheState.create_EmptyFetch();
        return output;
      }
      return output;
    }
    public void PruneInFlight(long now)
    {
      if ((this.fanOut) > ((this).InFlightSize())) {
        return ;
      }
      if ((this.lastPrune) == (now)) {
        return ;
      }
      (this).lastPrune = now;
      Dafny.ISet<Dafny.ISequence<byte>> _603_keySet;
      _603_keySet = (this.inFlight).Keys();
      Dafny.ISequence<Dafny.ISequence<byte>> _604_keys;
      _604_keys = SortedSets.__default.SetToSequence<Dafny.ISequence<byte>>(_603_keySet);
      BigInteger _hi7 = new BigInteger((_604_keys).Count);
      for (BigInteger _605_i = BigInteger.Zero; _605_i < _hi7; _605_i++) {
        long _606_v;
        _606_v = (this.inFlight).Select((_604_keys).Select(_605_i));
        if ((now) >= ((this).AddLong(_606_v, this.inFlightTTL))) {
          (this.inFlight).Remove((_604_keys).Select(_605_i));
        }
      }
    }
    public StormTracker_Compile._ICacheState CheckNewEntry(Dafny.ISequence<byte> identifier, long now)
    {
      StormTracker_Compile._ICacheState output = StormTracker_Compile.CacheState.Default();
      bool _607_fanOutReached;
      bool _out87;
      _out87 = (this).FanOutReached(now);
      _607_fanOutReached = _out87;
      if (_607_fanOutReached) {
        output = StormTracker_Compile.CacheState.create_EmptyWait();
        return output;
      } else if ((this.inFlight).HasKey(identifier)) {
        long _608_entry;
        _608_entry = (this.inFlight).Select(identifier);
        if (((this).AddLong(_608_entry, this.graceInterval)) > (now)) {
          output = StormTracker_Compile.CacheState.create_EmptyWait();
          return output;
        }
      }
      (this.inFlight).Put(identifier, now);
      output = StormTracker_Compile.CacheState.create_EmptyFetch();
      return output;
      return output;
    }
    public Wrappers_Compile._IResult<StormTracker_Compile._ICacheState, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetFromCacheWithTime(software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryInput input, long now)
    {
      Wrappers_Compile._IResult<StormTracker_Compile._ICacheState, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = Wrappers_Compile.Result<StormTracker_Compile._ICacheState, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(StormTracker_Compile.CacheState.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _609_result;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out88;
      _out88 = (this.wrapped).GetCacheEntryWithTime(input, now);
      _609_result = _out88;
      if ((_609_result).is_Success) {
        StormTracker_Compile._ICacheState _610_newResult;
        StormTracker_Compile._ICacheState _out89;
        _out89 = (this).CheckInFlight((input).dtor_identifier, (_609_result).dtor_value, now);
        _610_newResult = _out89;
        output = Wrappers_Compile.Result<StormTracker_Compile._ICacheState, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_610_newResult);
        return output;
      } else if (((_609_result).dtor_error).is_EntryDoesNotExist) {
        StormTracker_Compile._ICacheState _611_newResult;
        StormTracker_Compile._ICacheState _out90;
        _out90 = (this).CheckNewEntry((input).dtor_identifier, now);
        _611_newResult = _out90;
        output = Wrappers_Compile.Result<StormTracker_Compile._ICacheState, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_611_newResult);
        return output;
      } else {
        output = Wrappers_Compile.Result<StormTracker_Compile._ICacheState, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Failure((_609_result).dtor_error);
        return output;
      }
      return output;
    }
    public Wrappers_Compile._IResult<StormTracker_Compile._ICacheState, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetFromCache(software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryInput input)
    {
      Wrappers_Compile._IResult<StormTracker_Compile._ICacheState, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = Wrappers_Compile.Result<StormTracker_Compile._ICacheState, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(StormTracker_Compile.CacheState.Default());
      long _612_now;
      long _out91;
      _out91 = Time.__default.CurrentRelativeTime();
      _612_now = _out91;
      Wrappers_Compile._IResult<StormTracker_Compile._ICacheState, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out92;
      _out92 = (this).GetFromCacheWithTime(input, _612_now);
      output = _out92;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetCacheEntry(software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<StormTracker_Compile._ICacheState, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _613_result;
      Wrappers_Compile._IResult<StormTracker_Compile._ICacheState, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out93;
      _out93 = (this).GetFromCache(input);
      _613_result = _out93;
      if ((_613_result).is_Failure) {
        output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Failure((_613_result).dtor_error);
        return output;
      } else if (((_613_result).dtor_value).is_Full) {
        output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(((_613_result).dtor_value).dtor_data);
        return output;
      } else {
        output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_EntryDoesNotExist(Dafny.Sequence<char>.FromString("Entry does not exist")));
        return output;
      }
      return output;
    }
    public Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> PutCacheEntry(software.amazon.cryptography.materialproviders.internaldafny.types._IPutCacheEntryInput input)
    {
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
      (this.inFlight).Remove((input).dtor_identifier);
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out94;
      _out94 = (this.wrapped).PutCacheEntry_k(input);
      output = _out94;
      return output;
    }
    public Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> DeleteCacheEntry(software.amazon.cryptography.materialproviders.internaldafny.types._IDeleteCacheEntryInput input)
    {
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
      (this.inFlight).Remove((input).dtor_identifier);
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out95;
      _out95 = (this.wrapped).DeleteCacheEntry_k(input);
      output = _out95;
      return output;
    }
    public Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> UpdateUsageMetadata(software.amazon.cryptography.materialproviders.internaldafny.types._IUpdateUsageMetadataInput input)
    {
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out96;
      _out96 = (this.wrapped).UpdateUsageMetadata_k(input);
      output = _out96;
      return output;
    }
  }

  public partial class __default {
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IStormTrackingCache DefaultStorm() {
      return software.amazon.cryptography.materialproviders.internaldafny.types.StormTrackingCache.create(1000, Wrappers_Compile.Option<int>.create_Some(1), 10, 1, 20, 20, 20);
    }
  }
} // end of namespace StormTracker_Compile
namespace software.amazon.cryptography.internaldafny.StormTrackingCMC {


} // end of namespace software.amazon.cryptography.internaldafny.StormTrackingCMC
namespace AwsKmsHierarchicalKeyring_Compile {

  public partial class AwsKmsHierarchicalKeyring : Keyring_Compile.VerifiableInterface, software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring {
    public AwsKmsHierarchicalKeyring() {
      this._keyStore = default(software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient);
      this._cryptoPrimitives = default(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient);
      this._branchKeyIdSupplier = Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.IBranchKeyIdSupplier>.Default();
      this._branchKeyId = Wrappers_Compile.Option<Dafny.ISequence<char>>.Default();
      this._ttlSeconds = default(long);
      this._cache = default(software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache);
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnEncrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out101;
      _out101 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_IKeyring.OnEncrypt(this, input);
      return _out101;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnDecrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out102;
      _out102 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_IKeyring.OnDecrypt(this, input);
      return _out102;
    }
    public void __ctor(software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient keyStore, Wrappers_Compile._IOption<Dafny.ISequence<char>> branchKeyId, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IBranchKeyIdSupplier> branchKeyIdSupplier, long ttlSeconds, software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache cmc, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives)
    {
      (this)._keyStore = keyStore;
      (this)._branchKeyId = branchKeyId;
      (this)._branchKeyIdSupplier = branchKeyIdSupplier;
      (this)._ttlSeconds = ttlSeconds;
      (this)._cryptoPrimitives = cryptoPrimitives;
      (this)._cache = cmc;
    }
    public Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetBranchKeyId(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> context)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> ret = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<char>.Empty);
      if (((this).branchKeyId).is_Some) {
        ret = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(((this).branchKeyId).dtor_value);
        return ret;
      } else {
        software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdOutput _614_GetBranchKeyIdOut;
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _615_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(software.amazon.cryptography.materialproviders.internaldafny.types.GetBranchKeyIdOutput.Default());
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out103;
        _out103 = (((this).branchKeyIdSupplier).dtor_value).GetBranchKeyId(software.amazon.cryptography.materialproviders.internaldafny.types.GetBranchKeyIdInput.create(context));
        _615_valueOrError0 = _out103;
        if ((_615_valueOrError0).IsFailure()) {
          ret = (_615_valueOrError0).PropagateFailure<Dafny.ISequence<char>>();
          return ret;
        }
        _614_GetBranchKeyIdOut = (_615_valueOrError0).Extract();
        ret = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success((_614_GetBranchKeyIdOut).dtor_branchKeyId);
        return ret;
      }
      return ret;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnEncrypt_k(software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _616_materials;
      _616_materials = (input).dtor_materials;
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _617_suite;
      _617_suite = (_616_materials).dtor_algorithmSuite;
      Dafny.ISequence<char> _618_branchKeyIdForEncrypt;
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _619_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out104;
      _out104 = (this).GetBranchKeyId((_616_materials).dtor_encryptionContext);
      _619_valueOrError0 = _out104;
      if ((_619_valueOrError0).IsFailure()) {
        res = (_619_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
        return res;
      }
      _618_branchKeyIdForEncrypt = (_619_valueOrError0).Extract();
      Dafny.ISequence<byte> _620_branchKeyIdUtf8;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _621_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(UTF8.ValidUTF8Bytes.Default());
      _621_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.Encode(_618_branchKeyIdForEncrypt), AwsKmsUtils_Compile.__default.WrapStringToError);
      if ((_621_valueOrError1).IsFailure()) {
        res = (_621_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
        return res;
      }
      _620_branchKeyIdUtf8 = (_621_valueOrError1).Extract();
      Dafny.ISequence<byte> _622_cacheId;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _623_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out105;
      _out105 = (this).GetActiveCacheId(_618_branchKeyIdForEncrypt, _620_branchKeyIdUtf8, (this).cryptoPrimitives);
      _623_valueOrError2 = _out105;
      if ((_623_valueOrError2).IsFailure()) {
        res = (_623_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
        return res;
      }
      _622_cacheId = (_623_valueOrError2).Extract();
      software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials _624_hierarchicalMaterials;
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _625_valueOrError3 = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.BranchKeyMaterials.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out106;
      _out106 = (this).GetActiveHierarchicalMaterials(_618_branchKeyIdForEncrypt, _622_cacheId, (this).keyStore);
      _625_valueOrError3 = _out106;
      if ((_625_valueOrError3).IsFailure()) {
        res = (_625_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
        return res;
      }
      _624_hierarchicalMaterials = (_625_valueOrError3).Extract();
      Dafny.ISequence<byte> _626_branchKey;
      _626_branchKey = (_624_hierarchicalMaterials).dtor_branchKey;
      Dafny.ISequence<byte> _627_branchKeyVersion;
      _627_branchKeyVersion = (_624_hierarchicalMaterials).dtor_branchKeyVersion;
      Dafny.ISequence<char> _628_branchKeyVersionAsString;
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _629_valueOrError4 = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<char>.Empty);
      _629_valueOrError4 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.Decode(_627_branchKeyVersion), AwsKmsUtils_Compile.__default.WrapStringToError);
      if ((_629_valueOrError4).IsFailure()) {
        res = (_629_valueOrError4).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
        return res;
      }
      _628_branchKeyVersionAsString = (_629_valueOrError4).Extract();
      Dafny.ISequence<byte> _630_branchKeyVersionAsBytes;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _631_valueOrError5 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _631_valueOrError5 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UUID.__default.ToByteArray(_628_branchKeyVersionAsString), AwsKmsUtils_Compile.__default.WrapStringToError);
      if ((_631_valueOrError5).IsFailure()) {
        res = (_631_valueOrError5).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
        return res;
      }
      _630_branchKeyVersionAsBytes = (_631_valueOrError5).Extract();
      AwsKmsHierarchicalKeyring_Compile.KmsHierarchyGenerateAndWrapKeyMaterial _632_kmsHierarchyGenerateAndWrap;
      AwsKmsHierarchicalKeyring_Compile.KmsHierarchyGenerateAndWrapKeyMaterial _nw32 = new AwsKmsHierarchicalKeyring_Compile.KmsHierarchyGenerateAndWrapKeyMaterial();
      _nw32.__ctor((_624_hierarchicalMaterials).dtor_branchKey, _620_branchKeyIdUtf8, _630_branchKeyVersionAsBytes, (this).cryptoPrimitives);
      _632_kmsHierarchyGenerateAndWrap = _nw32;
      AwsKmsHierarchicalKeyring_Compile.KmsHierarchyWrapKeyMaterial _633_kmsHierarchyWrap;
      AwsKmsHierarchicalKeyring_Compile.KmsHierarchyWrapKeyMaterial _nw33 = new AwsKmsHierarchicalKeyring_Compile.KmsHierarchyWrapKeyMaterial();
      _nw33.__ctor((_624_hierarchicalMaterials).dtor_branchKey, _620_branchKeyIdUtf8, _630_branchKeyVersionAsBytes, (this).cryptoPrimitives);
      _633_kmsHierarchyWrap = _nw33;
      EdkWrapping_Compile._IWrapEdkMaterialOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo> _634_wrapOutput;
      Wrappers_Compile._IResult<EdkWrapping_Compile._IWrapEdkMaterialOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _635_valueOrError6 = Wrappers_Compile.Result<EdkWrapping_Compile._IWrapEdkMaterialOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(EdkWrapping_Compile.WrapEdkMaterialOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>.Default(AwsKmsHierarchicalKeyring_Compile.HierarchyWrapInfo.Default()));
      Wrappers_Compile._IResult<EdkWrapping_Compile._IWrapEdkMaterialOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out107;
      _out107 = EdkWrapping_Compile.__default.WrapEdkMaterial<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>(_616_materials, _633_kmsHierarchyWrap, _632_kmsHierarchyGenerateAndWrap);
      _635_valueOrError6 = _out107;
      if ((_635_valueOrError6).IsFailure()) {
        res = (_635_valueOrError6).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
        return res;
      }
      _634_wrapOutput = (_635_valueOrError6).Extract();
      Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>> _636_symmetricSigningKeyList;
      _636_symmetricSigningKeyList = ((((_634_wrapOutput).dtor_symmetricSigningKey).is_Some) ? (Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.create_Some(Dafny.Sequence<Dafny.ISequence<byte>>.FromElements(((_634_wrapOutput).dtor_symmetricSigningKey).dtor_value))) : (Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.create_None()));
      software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey _637_edk;
      _637_edk = software.amazon.cryptography.materialproviders.internaldafny.types.EncryptedDataKey.create(Constants_Compile.__default.PROVIDER__ID__HIERARCHY, _620_branchKeyIdUtf8, (_634_wrapOutput).dtor_wrappedMaterial);
      if ((_634_wrapOutput).is_GenerateAndWrapEdkMaterialOutput) {
        software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _638_result;
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _639_valueOrError7 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        _639_valueOrError7 = Materials_Compile.__default.EncryptionMaterialAddDataKey(_616_materials, (_634_wrapOutput).dtor_plaintextDataKey, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.FromElements(_637_edk), _636_symmetricSigningKeyList);
        if ((_639_valueOrError7).IsFailure()) {
          res = (_639_valueOrError7).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
          return res;
        }
        _638_result = (_639_valueOrError7).Extract();
        res = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.OnEncryptOutput.create(_638_result));
        return res;
      } else if ((_634_wrapOutput).is_WrapOnlyEdkMaterialOutput) {
        software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _640_result;
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _641_valueOrError8 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        _641_valueOrError8 = Materials_Compile.__default.EncryptionMaterialAddEncryptedDataKeys(_616_materials, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.FromElements(_637_edk), _636_symmetricSigningKeyList);
        if ((_641_valueOrError8).IsFailure()) {
          res = (_641_valueOrError8).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
          return res;
        }
        _640_result = (_641_valueOrError8).Extract();
        res = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.OnEncryptOutput.create(_640_result));
        return res;
      }
      return res;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnDecrypt_k(software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _642_materials;
      _642_materials = (input).dtor_materials;
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _643_suite;
      _643_suite = ((input).dtor_materials).dtor_algorithmSuite;
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _644_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _644_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.DecryptionMaterialsWithoutPlaintextDataKey(_642_materials), AwsKmsHierarchicalKeyring_Compile.__default.E(Dafny.Sequence<char>.FromString("Keyring received decryption materials that already contain a plaintext data key.")));
      if ((_644_valueOrError0).IsFailure()) {
        res = (_644_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return res;
      }
      Dafny.ISequence<char> _645_branchKeyIdForDecrypt;
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _646_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out108;
      _out108 = (this).GetBranchKeyId((_642_materials).dtor_encryptionContext);
      _646_valueOrError1 = _out108;
      if ((_646_valueOrError1).IsFailure()) {
        res = (_646_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return res;
      }
      _645_branchKeyIdForDecrypt = (_646_valueOrError1).Extract();
      AwsKmsHierarchicalKeyring_Compile.OnDecryptHierarchyEncryptedDataKeyFilter _647_filter;
      AwsKmsHierarchicalKeyring_Compile.OnDecryptHierarchyEncryptedDataKeyFilter _nw34 = new AwsKmsHierarchicalKeyring_Compile.OnDecryptHierarchyEncryptedDataKeyFilter();
      _nw34.__ctor(_645_branchKeyIdForDecrypt);
      _647_filter = _nw34;
      Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _648_edksToAttempt;
      Wrappers_Compile._IResult<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _649_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out109;
      _out109 = Actions_Compile.__default.FilterWithResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_647_filter, (input).dtor_encryptedDataKeys);
      _649_valueOrError2 = _out109;
      if ((_649_valueOrError2).IsFailure()) {
        res = (_649_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return res;
      }
      _648_edksToAttempt = (_649_valueOrError2).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _650_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _650_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger((_648_edksToAttempt).Count)).Sign == 1, AwsKmsHierarchicalKeyring_Compile.__default.E(Dafny.Sequence<char>.FromString("Unable to decrypt data key: No Encrypted Data Keys found to match.")));
      if ((_650_valueOrError3).IsFailure()) {
        res = (_650_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return res;
      }
      Actions_Compile.ActionWithResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _651_decryptClosure;
      AwsKmsHierarchicalKeyring_Compile.DecryptSingleEncryptedDataKey _nw35 = new AwsKmsHierarchicalKeyring_Compile.DecryptSingleEncryptedDataKey();
      _nw35.__ctor(_642_materials, (this).keyStore, (this).cryptoPrimitives, _645_branchKeyIdForDecrypt, (this).ttlSeconds, (this).cache);
      _651_decryptClosure = _nw35;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>> _652_outcome;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>> _out110;
      _out110 = Actions_Compile.__default.ReduceToSuccess<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_651_decryptClosure, _648_edksToAttempt);
      _652_outcome = _out110;
      software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _653_SealedDecryptionMaterials;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _654_valueOrError4 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      _654_valueOrError4 = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_652_outcome, ((System.Func<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_655_errors) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_CollectionOfErrors(_655_errors, Dafny.Sequence<char>.FromString("No Configured KMS Key was able to decrypt the Data Key. The list of encountered Exceptions is available via `list`."));
      })));
      if ((_654_valueOrError4).IsFailure()) {
        res = (_654_valueOrError4).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return res;
      }
      _653_SealedDecryptionMaterials = (_654_valueOrError4).Extract();
      res = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.OnDecryptOutput.create(_653_SealedDecryptionMaterials));
      return res;
      return res;
    }
    public Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetActiveCacheId(Dafny.ISequence<char> branchKeyId, Dafny.ISequence<byte> branchKeyIdUtf8, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> cacheId = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _656_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _656_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.Decode(branchKeyIdUtf8), AwsKmsUtils_Compile.__default.WrapStringToError)).is_Success) && (Dafny.Helpers.Let<Dafny.ISequence<char>, bool>((Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.Decode(branchKeyIdUtf8), AwsKmsUtils_Compile.__default.WrapStringToError)).dtor_value, _pat_let18_0 => Dafny.Helpers.Let<Dafny.ISequence<char>, bool>(_pat_let18_0, _657_branchKeyId => (true) && (((new BigInteger((_657_branchKeyId).Count)).Sign != -1) && ((new BigInteger((_657_branchKeyId).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT32__LIMIT)))))), AwsKmsHierarchicalKeyring_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid Branch Key ID Length")));
      if ((_656_valueOrError0).IsFailure()) {
        cacheId = (_656_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        return cacheId;
      }
      Dafny.ISequence<char> _658_branchKeyId;
      _658_branchKeyId = (UTF8.__default.Decode(branchKeyIdUtf8)).dtor_value;
      Dafny.ISequence<byte> _659_lenBranchKey;
      _659_lenBranchKey = StandardLibrary_mUInt_Compile.__default.UInt32ToSeq((uint)(_658_branchKeyId).LongCount);
      software.amazon.cryptography.primitives.internaldafny.types._IDigestAlgorithm _660_hashAlgorithm;
      _660_hashAlgorithm = software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__512();
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _661_maybeBranchKeyDigest;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out111;
      _out111 = (cryptoPrimitives).Digest(software.amazon.cryptography.primitives.internaldafny.types.DigestInput.create(_660_hashAlgorithm, branchKeyIdUtf8));
      _661_maybeBranchKeyDigest = _out111;
      Dafny.ISequence<byte> _662_branchKeyDigest;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _663_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _663_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_661_maybeBranchKeyDigest, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_664_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_664_e);
      })));
      if ((_663_valueOrError1).IsFailure()) {
        cacheId = (_663_valueOrError1).PropagateFailure<Dafny.ISequence<byte>>();
        return cacheId;
      }
      _662_branchKeyDigest = (_663_valueOrError1).Extract();
      Dafny.ISequence<byte> _665_activeUtf8;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _666_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(UTF8.ValidUTF8Bytes.Default());
      _666_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.Encode(AwsKmsHierarchicalKeyring_Compile.__default.EXPRESSION__ATTRIBUTE__VALUE__STATUS__VALUE), AwsKmsUtils_Compile.__default.WrapStringToError);
      if ((_666_valueOrError2).IsFailure()) {
        cacheId = (_666_valueOrError2).PropagateFailure<Dafny.ISequence<byte>>();
        return cacheId;
      }
      _665_activeUtf8 = (_666_valueOrError2).Extract();
      Dafny.ISequence<byte> _667_identifier;
      _667_identifier = Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(_659_lenBranchKey, _662_branchKeyDigest), Dafny.Sequence<byte>.FromElements((byte)(0))), _665_activeUtf8);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _668_maybeCacheIdDigest;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out112;
      _out112 = (cryptoPrimitives).Digest(software.amazon.cryptography.primitives.internaldafny.types.DigestInput.create(_660_hashAlgorithm, _667_identifier));
      _668_maybeCacheIdDigest = _out112;
      Dafny.ISequence<byte> _669_cacheDigest;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _670_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _670_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_668_maybeCacheIdDigest, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_671_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_671_e);
      })));
      if ((_670_valueOrError3).IsFailure()) {
        cacheId = (_670_valueOrError3).PropagateFailure<Dafny.ISequence<byte>>();
        return cacheId;
      }
      _669_cacheDigest = (_670_valueOrError3).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _672_valueOrError4 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _672_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger((_669_cacheDigest).Count)) == (Digest_Compile.__default.Length(_660_hashAlgorithm)), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Digest generated a message not equal to the expected length.")));
      if ((_672_valueOrError4).IsFailure()) {
        cacheId = (_672_valueOrError4).PropagateFailure<Dafny.ISequence<byte>>();
        return cacheId;
      }
      cacheId = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success((_669_cacheDigest).Subsequence(BigInteger.Zero, new BigInteger(32)));
      return cacheId;
      return cacheId;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetActiveHierarchicalMaterials(Dafny.ISequence<char> branchKeyId, Dafny.ISequence<byte> cacheId, software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient keyStore)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> material = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.BranchKeyMaterials.Default());
      software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryInput _673_getCacheInput;
      _673_getCacheInput = software.amazon.cryptography.materialproviders.internaldafny.types.GetCacheEntryInput.create(cacheId, Wrappers_Compile.Option<long>.create_None());
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _674_getCacheOutput;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out113;
      _out113 = AwsKmsHierarchicalKeyring_Compile.__default.getEntry((this).cache, _673_getCacheInput);
      _674_getCacheOutput = _out113;
      if ((_674_getCacheOutput).is_Failure) {
        Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _675_maybeGetActiveBranchKeyOutput;
        Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _out114;
        _out114 = (keyStore).GetActiveBranchKey(software.amazon.cryptography.keystore.internaldafny.types.GetActiveBranchKeyInput.create(branchKeyId));
        _675_maybeGetActiveBranchKeyOutput = _out114;
        software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput _676_getActiveBranchKeyOutput;
        Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _677_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.GetActiveBranchKeyOutput.Default());
        _677_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_675_maybeGetActiveBranchKeyOutput, ((System.Func<software.amazon.cryptography.keystore.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_678_e) => {
          return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyKeyStore(_678_e);
        })));
        if ((_677_valueOrError0).IsFailure()) {
          material = (_677_valueOrError0).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials>();
          return material;
        }
        _676_getActiveBranchKeyOutput = (_677_valueOrError0).Extract();
        software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials _679_branchKeyMaterials;
        _679_branchKeyMaterials = (_676_getActiveBranchKeyOutput).dtor_branchKeyMaterials;
        long _680_now;
        long _out115;
        _out115 = Time.__default.CurrentRelativeTime();
        _680_now = _out115;
        Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _681_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
        _681_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((new BigInteger(_680_now)) + (new BigInteger((this).ttlSeconds))) < (StandardLibrary_mUInt_Compile.__default.INT64__MAX__LIMIT), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("INT64 Overflow when putting cache entry.")));
        if ((_681_valueOrError1).IsFailure()) {
          material = (_681_valueOrError1).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials>();
          return material;
        }
        software.amazon.cryptography.materialproviders.internaldafny.types._IPutCacheEntryInput _682_putCacheEntryInput;
        _682_putCacheEntryInput = software.amazon.cryptography.materialproviders.internaldafny.types.PutCacheEntryInput.create(cacheId, software.amazon.cryptography.materialproviders.internaldafny.types.Materials.create_BranchKey(_679_branchKeyMaterials), _680_now, ((this).ttlSeconds) + (_680_now), Wrappers_Compile.Option<int>.create_None(), Wrappers_Compile.Option<int>.create_None());
        _System._ITuple0 _683___v0;
        Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _684_valueOrError2 = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
        Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out116;
        _out116 = AwsKmsHierarchicalKeyring_Compile.__default.putEntry((this).cache, _682_putCacheEntryInput);
        _684_valueOrError2 = _out116;
        if ((_684_valueOrError2).IsFailure()) {
          material = (_684_valueOrError2).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials>();
          return material;
        }
        _683___v0 = (_684_valueOrError2).Extract();
        material = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_679_branchKeyMaterials);
        return material;
      } else {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _685_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
        _685_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((((_674_getCacheOutput).dtor_value).dtor_materials).is_BranchKey) && (object.Equals(((_674_getCacheOutput).dtor_value).dtor_materials, software.amazon.cryptography.materialproviders.internaldafny.types.Materials.create_BranchKey((((_674_getCacheOutput).dtor_value).dtor_materials).dtor_BranchKey))), AwsKmsHierarchicalKeyring_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid Material Type.")));
        if ((_685_valueOrError3).IsFailure()) {
          material = (_685_valueOrError3).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials>();
          return material;
        }
        material = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success((((_674_getCacheOutput).dtor_value).dtor_materials).dtor_BranchKey);
        return material;
      }
      return material;
    }
    public software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient _keyStore {get; set;}
    public software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient keyStore { get {
      return this._keyStore;
    } }
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _cryptoPrimitives {get; set;}
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives { get {
      return this._cryptoPrimitives;
    } }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IBranchKeyIdSupplier> _branchKeyIdSupplier {get; set;}
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IBranchKeyIdSupplier> branchKeyIdSupplier { get {
      return this._branchKeyIdSupplier;
    } }
    public Wrappers_Compile._IOption<Dafny.ISequence<char>> _branchKeyId {get; set;}
    public Wrappers_Compile._IOption<Dafny.ISequence<char>> branchKeyId { get {
      return this._branchKeyId;
    } }
    public long _ttlSeconds {get; set;}
    public long ttlSeconds { get {
      return this._ttlSeconds;
    } }
    public software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache _cache {get; set;}
    public software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache cache { get {
      return this._cache;
    } }
  }

  public partial class OnDecryptHierarchyEncryptedDataKeyFilter : Actions_Compile.DeterministicActionWithResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.DeterministicAction<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, Wrappers_Compile._IResult<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public OnDecryptHierarchyEncryptedDataKeyFilter() {
      this._branchKeyId = Dafny.Sequence<char>.Empty;
    }
    public void __ctor(Dafny.ISequence<char> branchKeyId)
    {
      (this)._branchKeyId = branchKeyId;
    }
    public Wrappers_Compile._IResult<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey edk)
    {
      Wrappers_Compile._IResult<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = Wrappers_Compile.Result<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(false);
      Dafny.ISequence<byte> _686_providerInfo;
      _686_providerInfo = (edk).dtor_keyProviderInfo;
      Dafny.ISequence<byte> _687_providerId;
      _687_providerId = (edk).dtor_keyProviderId;
      if (!(_687_providerId).Equals(Constants_Compile.__default.PROVIDER__ID__HIERARCHY)) {
        res = Wrappers_Compile.Result<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(false);
        return res;
      }
      if (!(UTF8.__default.ValidUTF8Seq(_686_providerInfo))) {
        res = Wrappers_Compile.Result<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Failure(AwsKmsHierarchicalKeyring_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid encoding, provider info is not UTF8.")));
        return res;
      }
      Dafny.ISequence<char> _688_branchKeyId;
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _689_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<char>.Empty);
      _689_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.Decode(_686_providerInfo), AwsKmsUtils_Compile.__default.WrapStringToError);
      if ((_689_valueOrError0).IsFailure()) {
        res = (_689_valueOrError0).PropagateFailure<bool>();
        return res;
      }
      _688_branchKeyId = (_689_valueOrError0).Extract();
      res = Wrappers_Compile.Result<bool, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(((this).branchKeyId).Equals(_688_branchKeyId));
      return res;
      return res;
    }
    public Dafny.ISequence<char> _branchKeyId {get; set;}
    public Dafny.ISequence<char> branchKeyId { get {
      return this._branchKeyId;
    } }
  }

  public partial class DecryptSingleEncryptedDataKey : Actions_Compile.ActionWithResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public DecryptSingleEncryptedDataKey() {
      this._materials = default(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials);
      this._keyStore = default(software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient);
      this._cryptoPrimitives = default(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient);
      this._branchKeyId = Dafny.Sequence<char>.Empty;
      this._ttlSeconds = default(long);
      this._cache = default(software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache);
    }
    public void __ctor(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials materials, software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient keyStore, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives, Dafny.ISequence<char> branchKeyId, long ttlSeconds, software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache cache)
    {
      (this)._materials = materials;
      (this)._keyStore = keyStore;
      (this)._cryptoPrimitives = cryptoPrimitives;
      (this)._branchKeyId = branchKeyId;
      (this)._ttlSeconds = ttlSeconds;
      (this)._cache = cache;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey edk)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _690_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _690_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.ValidUTF8Seq((edk).dtor_keyProviderInfo), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Received invalid EDK provider info for Hierarchical Keyring")));
      if ((_690_valueOrError0).IsFailure()) {
        res = (_690_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        return res;
      }
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _691_suite;
      _691_suite = ((this).materials).dtor_algorithmSuite;
      Dafny.ISequence<byte> _692_keyProviderId;
      _692_keyProviderId = (edk).dtor_keyProviderId;
      Dafny.ISequence<byte> _693_branchKeyIdUtf8;
      _693_branchKeyIdUtf8 = (edk).dtor_keyProviderInfo;
      Dafny.ISequence<byte> _694_ciphertext;
      _694_ciphertext = (edk).dtor_ciphertext;
      Dafny.ISequence<byte> _695_providerWrappedMaterial;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _696_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _696_valueOrError1 = EdkWrapping_Compile.__default.GetProviderWrappedMaterial(_694_ciphertext, _691_suite);
      if ((_696_valueOrError1).IsFailure()) {
        res = (_696_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        return res;
      }
      _695_providerWrappedMaterial = (_696_valueOrError1).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _697_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _697_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger((_695_providerWrappedMaterial).Count)) >= (new BigInteger(AwsKmsHierarchicalKeyring_Compile.__default.EDK__CIPHERTEXT__VERSION__INDEX)), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Received EDK Ciphertext of incorrect length.")));
      if ((_697_valueOrError2).IsFailure()) {
        res = (_697_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        return res;
      }
      Dafny.ISequence<byte> _698_branchKeyVersionUuid;
      _698_branchKeyVersionUuid = (_695_providerWrappedMaterial).Subsequence(AwsKmsHierarchicalKeyring_Compile.__default.EDK__CIPHERTEXT__BRANCH__KEY__VERSION__INDEX, AwsKmsHierarchicalKeyring_Compile.__default.EDK__CIPHERTEXT__VERSION__INDEX);
      Dafny.ISequence<char> _699_version;
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _700_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<char>.Empty);
      _700_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UUID.__default.FromByteArray(_698_branchKeyVersionUuid), AwsKmsUtils_Compile.__default.WrapStringToError);
      if ((_700_valueOrError3).IsFailure()) {
        res = (_700_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        return res;
      }
      _699_version = (_700_valueOrError3).Extract();
      Dafny.ISequence<byte> _701_cacheId;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _702_valueOrError4 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out117;
      _out117 = (this).GetVersionCacheId(_693_branchKeyIdUtf8, _699_version, (this).cryptoPrimitives);
      _702_valueOrError4 = _out117;
      if ((_702_valueOrError4).IsFailure()) {
        res = (_702_valueOrError4).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        return res;
      }
      _701_cacheId = (_702_valueOrError4).Extract();
      software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials _703_hierarchicalMaterials;
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _704_valueOrError5 = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.BranchKeyMaterials.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out118;
      _out118 = (this).GetHierarchicalMaterialsVersion((this).branchKeyId, _693_branchKeyIdUtf8, _699_version, _701_cacheId);
      _704_valueOrError5 = _out118;
      if ((_704_valueOrError5).IsFailure()) {
        res = (_704_valueOrError5).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        return res;
      }
      _703_hierarchicalMaterials = (_704_valueOrError5).Extract();
      Dafny.ISequence<byte> _705_branchKey;
      _705_branchKey = (_703_hierarchicalMaterials).dtor_branchKey;
      Dafny.ISequence<byte> _706_branchKeyVersion;
      _706_branchKeyVersion = (_703_hierarchicalMaterials).dtor_branchKeyVersion;
      Dafny.ISequence<char> _707_branchKeyVersionAsString;
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _708_valueOrError6 = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<char>.Empty);
      _708_valueOrError6 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.Decode(_706_branchKeyVersion), AwsKmsUtils_Compile.__default.WrapStringToError);
      if ((_708_valueOrError6).IsFailure()) {
        res = (_708_valueOrError6).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        return res;
      }
      _707_branchKeyVersionAsString = (_708_valueOrError6).Extract();
      Dafny.ISequence<byte> _709_branchKeyVersionAsBytes;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _710_valueOrError7 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _710_valueOrError7 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UUID.__default.ToByteArray(_707_branchKeyVersionAsString), AwsKmsUtils_Compile.__default.WrapStringToError);
      if ((_710_valueOrError7).IsFailure()) {
        res = (_710_valueOrError7).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        return res;
      }
      _709_branchKeyVersionAsBytes = (_710_valueOrError7).Extract();
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.primitives.internaldafny.types._IError> _711_maybeCrypto;
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.primitives.internaldafny.types._IError> _out119;
      _out119 = software.amazon.cryptography.primitives.internaldafny.__default.AtomicPrimitives(software.amazon.cryptography.primitives.internaldafny.__default.DefaultCryptoConfig());
      _711_maybeCrypto = _out119;
      software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _712_crypto;
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _713_valueOrError8 = default(Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      _713_valueOrError8 = Wrappers_Compile.Result<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_711_maybeCrypto, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_714_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_714_e);
      })));
      if ((_713_valueOrError8).IsFailure()) {
        res = (_713_valueOrError8).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        return res;
      }
      _712_crypto = (_713_valueOrError8).Extract();
      AwsKmsHierarchicalKeyring_Compile.KmsHierarchyUnwrapKeyMaterial _715_kmsHierarchyUnwrap;
      AwsKmsHierarchicalKeyring_Compile.KmsHierarchyUnwrapKeyMaterial _nw36 = new AwsKmsHierarchicalKeyring_Compile.KmsHierarchyUnwrapKeyMaterial();
      _nw36.__ctor(_705_branchKey, _693_branchKeyIdUtf8, _709_branchKeyVersionAsBytes, _712_crypto);
      _715_kmsHierarchyUnwrap = _nw36;
      Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _716_unwrapOutputRes;
      Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out120;
      _out120 = EdkWrapping_Compile.__default.UnwrapEdkMaterial<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo>((edk).dtor_ciphertext, (this).materials, _715_kmsHierarchyUnwrap);
      _716_unwrapOutputRes = _out120;
      EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo> _717_unwrapOutput;
      Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _718_valueOrError9 = Wrappers_Compile.Result<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(EdkWrapping_Compile.UnwrapEdkMaterialOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo>.Default(AwsKmsHierarchicalKeyring_Compile.HierarchyUnwrapInfo.Default()));
      _718_valueOrError9 = _716_unwrapOutputRes;
      if ((_718_valueOrError9).IsFailure()) {
        res = (_718_valueOrError9).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        return res;
      }
      _717_unwrapOutput = (_718_valueOrError9).Extract();
      software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _719_result;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _720_valueOrError10 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      _720_valueOrError10 = Materials_Compile.__default.DecryptionMaterialsAddDataKey((this).materials, (_717_unwrapOutput).dtor_plaintextDataKey, (_717_unwrapOutput).dtor_symmetricSigningKey);
      if ((_720_valueOrError10).IsFailure()) {
        res = (_720_valueOrError10).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        return res;
      }
      _719_result = (_720_valueOrError10).Extract();
      res = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_719_result);
      return res;
      return res;
    }
    public Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetVersionCacheId(Dafny.ISequence<byte> branchKeyIdUtf8, Dafny.ISequence<char> branchKeyVersion, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> cacheId = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _721_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _721_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.Decode(branchKeyIdUtf8), AwsKmsUtils_Compile.__default.WrapStringToError)).is_Success) && (Dafny.Helpers.Let<Dafny.ISequence<char>, bool>((Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.Decode(branchKeyIdUtf8), AwsKmsUtils_Compile.__default.WrapStringToError)).dtor_value, _pat_let19_0 => Dafny.Helpers.Let<Dafny.ISequence<char>, bool>(_pat_let19_0, _722_branchKeyId => (true) && (((new BigInteger((_722_branchKeyId).Count)).Sign != -1) && ((new BigInteger((_722_branchKeyId).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT32__LIMIT)))))), AwsKmsHierarchicalKeyring_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid Branch Key ID Length")));
      if ((_721_valueOrError0).IsFailure()) {
        cacheId = (_721_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        return cacheId;
      }
      Dafny.ISequence<char> _723_branchKeyId;
      _723_branchKeyId = (UTF8.__default.Decode(branchKeyIdUtf8)).dtor_value;
      Dafny.ISequence<byte> _724_lenBranchKey;
      _724_lenBranchKey = StandardLibrary_mUInt_Compile.__default.UInt32ToSeq((uint)(_723_branchKeyId).LongCount);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _725_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _725_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(UTF8.__default.IsASCIIString(branchKeyVersion), AwsKmsHierarchicalKeyring_Compile.__default.E(Dafny.Sequence<char>.FromString("Unable to represent as an ASCII string.")));
      if ((_725_valueOrError1).IsFailure()) {
        cacheId = (_725_valueOrError1).PropagateFailure<Dafny.ISequence<byte>>();
        return cacheId;
      }
      Dafny.ISequence<byte> _726_versionBytes;
      _726_versionBytes = UTF8.__default.EncodeAscii(branchKeyVersion);
      Dafny.ISequence<byte> _727_identifier;
      _727_identifier = Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(_724_lenBranchKey, branchKeyIdUtf8), Dafny.Sequence<byte>.FromElements((byte)(0))), _726_versionBytes);
      software.amazon.cryptography.primitives.internaldafny.types._IDigestInput _728_identifierDigestInput;
      _728_identifierDigestInput = software.amazon.cryptography.primitives.internaldafny.types.DigestInput.create(software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__512(), _727_identifier);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _729_maybeCacheDigest;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out121;
      _out121 = Digest_Compile.__default.Digest(_728_identifierDigestInput);
      _729_maybeCacheDigest = _out121;
      Dafny.ISequence<byte> _730_cacheDigest;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _731_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _731_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_729_maybeCacheDigest, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_732_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_732_e);
      })));
      if ((_731_valueOrError2).IsFailure()) {
        cacheId = (_731_valueOrError2).PropagateFailure<Dafny.ISequence<byte>>();
        return cacheId;
      }
      _730_cacheDigest = (_731_valueOrError2).Extract();
      cacheId = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success((_730_cacheDigest).Subsequence(BigInteger.Zero, new BigInteger(32)));
      return cacheId;
      return cacheId;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetHierarchicalMaterialsVersion(Dafny.ISequence<char> branchKeyId, Dafny.ISequence<byte> branchKeyIdUtf8, Dafny.ISequence<char> version, Dafny.ISequence<byte> cacheId)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> material = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.BranchKeyMaterials.Default());
      software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryInput _733_getCacheInput;
      _733_getCacheInput = software.amazon.cryptography.materialproviders.internaldafny.types.GetCacheEntryInput.create(cacheId, Wrappers_Compile.Option<long>.create_None());
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _734_getCacheOutput;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out122;
      _out122 = AwsKmsHierarchicalKeyring_Compile.__default.getEntry((this).cache, _733_getCacheInput);
      _734_getCacheOutput = _out122;
      if ((_734_getCacheOutput).is_Failure) {
        Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _735_maybeGetBranchKeyVersionOutput;
        Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _out123;
        _out123 = ((this).keyStore).GetBranchKeyVersion(software.amazon.cryptography.keystore.internaldafny.types.GetBranchKeyVersionInput.create(branchKeyId, version));
        _735_maybeGetBranchKeyVersionOutput = _out123;
        software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput _736_getBranchKeyVersionOutput;
        Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _737_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.GetBranchKeyVersionOutput.Default());
        _737_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_735_maybeGetBranchKeyVersionOutput, ((System.Func<software.amazon.cryptography.keystore.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_738_e) => {
          return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyKeyStore(_738_e);
        })));
        if ((_737_valueOrError0).IsFailure()) {
          material = (_737_valueOrError0).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials>();
          return material;
        }
        _736_getBranchKeyVersionOutput = (_737_valueOrError0).Extract();
        software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials _739_branchKeyMaterials;
        _739_branchKeyMaterials = (_736_getBranchKeyVersionOutput).dtor_branchKeyMaterials;
        long _740_now;
        long _out124;
        _out124 = Time.__default.CurrentRelativeTime();
        _740_now = _out124;
        Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _741_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
        _741_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((new BigInteger(_740_now)) + (new BigInteger((this).ttlSeconds))) < (StandardLibrary_mUInt_Compile.__default.INT64__MAX__LIMIT), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("INT64 Overflow when putting cache entry.")));
        if ((_741_valueOrError1).IsFailure()) {
          material = (_741_valueOrError1).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials>();
          return material;
        }
        software.amazon.cryptography.materialproviders.internaldafny.types._IPutCacheEntryInput _742_putCacheEntryInput;
        _742_putCacheEntryInput = software.amazon.cryptography.materialproviders.internaldafny.types.PutCacheEntryInput.create(cacheId, software.amazon.cryptography.materialproviders.internaldafny.types.Materials.create_BranchKey(_739_branchKeyMaterials), _740_now, ((this).ttlSeconds) + (_740_now), Wrappers_Compile.Option<int>.create_None(), Wrappers_Compile.Option<int>.create_None());
        _System._ITuple0 _743___v1;
        Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _744_valueOrError2 = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
        Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out125;
        _out125 = AwsKmsHierarchicalKeyring_Compile.__default.putEntry((this).cache, _742_putCacheEntryInput);
        _744_valueOrError2 = _out125;
        if ((_744_valueOrError2).IsFailure()) {
          material = (_744_valueOrError2).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials>();
          return material;
        }
        _743___v1 = (_744_valueOrError2).Extract();
        material = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_739_branchKeyMaterials);
        return material;
      } else {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _745_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
        _745_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((((_734_getCacheOutput).dtor_value).dtor_materials).is_BranchKey) && (object.Equals(((_734_getCacheOutput).dtor_value).dtor_materials, software.amazon.cryptography.materialproviders.internaldafny.types.Materials.create_BranchKey((((_734_getCacheOutput).dtor_value).dtor_materials).dtor_BranchKey))), AwsKmsHierarchicalKeyring_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid Material Type.")));
        if ((_745_valueOrError3).IsFailure()) {
          material = (_745_valueOrError3).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials>();
          return material;
        }
        material = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success((((_734_getCacheOutput).dtor_value).dtor_materials).dtor_BranchKey);
        return material;
      }
      return material;
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _materials {get; set;}
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials materials { get {
      return this._materials;
    } }
    public software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient _keyStore {get; set;}
    public software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient keyStore { get {
      return this._keyStore;
    } }
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _cryptoPrimitives {get; set;}
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives { get {
      return this._cryptoPrimitives;
    } }
    public Dafny.ISequence<char> _branchKeyId {get; set;}
    public Dafny.ISequence<char> branchKeyId { get {
      return this._branchKeyId;
    } }
    public long _ttlSeconds {get; set;}
    public long ttlSeconds { get {
      return this._ttlSeconds;
    } }
    public software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache _cache {get; set;}
    public software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache cache { get {
      return this._cache;
    } }
  }

  public interface _IHierarchyUnwrapInfo {
    bool is_HierarchyUnwrapInfo { get; }
    _IHierarchyUnwrapInfo DowncastClone();
  }
  public class HierarchyUnwrapInfo : _IHierarchyUnwrapInfo {
    public HierarchyUnwrapInfo() {
    }
    public _IHierarchyUnwrapInfo DowncastClone() {
      if (this is _IHierarchyUnwrapInfo dt) { return dt; }
      return new HierarchyUnwrapInfo();
    }
    public override bool Equals(object other) {
      var oth = other as AwsKmsHierarchicalKeyring_Compile.HierarchyUnwrapInfo;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsKmsHierarchicalKeyring_Compile.HierarchyUnwrapInfo.HierarchyUnwrapInfo";
      return s;
    }
    private static readonly AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo theDefault = create();
    public static AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo> _TYPE = new Dafny.TypeDescriptor<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo>(AwsKmsHierarchicalKeyring_Compile.HierarchyUnwrapInfo.Default());
    public static Dafny.TypeDescriptor<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IHierarchyUnwrapInfo create() {
      return new HierarchyUnwrapInfo();
    }
    public static _IHierarchyUnwrapInfo create_HierarchyUnwrapInfo() {
      return create();
    }
    public bool is_HierarchyUnwrapInfo { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_IHierarchyUnwrapInfo> AllSingletonConstructors {
      get {
        yield return HierarchyUnwrapInfo.create();
      }
    }
  }

  public interface _IHierarchyWrapInfo {
    bool is_HierarchyWrapInfo { get; }
    _IHierarchyWrapInfo DowncastClone();
  }
  public class HierarchyWrapInfo : _IHierarchyWrapInfo {
    public HierarchyWrapInfo() {
    }
    public _IHierarchyWrapInfo DowncastClone() {
      if (this is _IHierarchyWrapInfo dt) { return dt; }
      return new HierarchyWrapInfo();
    }
    public override bool Equals(object other) {
      var oth = other as AwsKmsHierarchicalKeyring_Compile.HierarchyWrapInfo;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsKmsHierarchicalKeyring_Compile.HierarchyWrapInfo.HierarchyWrapInfo";
      return s;
    }
    private static readonly AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo theDefault = create();
    public static AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo> _TYPE = new Dafny.TypeDescriptor<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>(AwsKmsHierarchicalKeyring_Compile.HierarchyWrapInfo.Default());
    public static Dafny.TypeDescriptor<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IHierarchyWrapInfo create() {
      return new HierarchyWrapInfo();
    }
    public static _IHierarchyWrapInfo create_HierarchyWrapInfo() {
      return create();
    }
    public bool is_HierarchyWrapInfo { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_IHierarchyWrapInfo> AllSingletonConstructors {
      get {
        yield return HierarchyWrapInfo.create();
      }
    }
  }

  public partial class KmsHierarchyUnwrapKeyMaterial : MaterialWrapping_Compile.UnwrapMaterial<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo>, Actions_Compile.ActionWithResult<MaterialWrapping_Compile._IUnwrapInput, MaterialWrapping_Compile._IUnwrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<MaterialWrapping_Compile._IUnwrapInput, Wrappers_Compile._IResult<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public KmsHierarchyUnwrapKeyMaterial() {
      this._crypto = default(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient);
      this._branchKeyIdUtf8 = UTF8.ValidUTF8Bytes.Default();
      this._branchKeyVersionAsBytes = Dafny.Sequence<byte>.Empty;
      this._branchKey = Dafny.Sequence<byte>.Empty;
    }
    public void __ctor(Dafny.ISequence<byte> branchKey, Dafny.ISequence<byte> branchKeyIdUtf8, Dafny.ISequence<byte> branchKeyVersionAsBytes, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient crypto)
    {
      (this)._branchKey = branchKey;
      (this)._branchKeyIdUtf8 = branchKeyIdUtf8;
      (this)._branchKeyVersionAsBytes = branchKeyVersionAsBytes;
      (this)._crypto = crypto;
    }
    public Wrappers_Compile._IResult<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(MaterialWrapping_Compile._IUnwrapInput input)
    {
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = Wrappers_Compile.Result<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(MaterialWrapping_Compile.UnwrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo>.Default(AwsKmsHierarchicalKeyring_Compile.HierarchyUnwrapInfo.Default()));
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _746_suite;
      _746_suite = (input).dtor_algorithmSuite;
      Dafny.ISequence<byte> _747_wrappedMaterial;
      _747_wrappedMaterial = (input).dtor_wrappedMaterial;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _748_aad;
      _748_aad = (input).dtor_encryptionContext;
      int _749_KeyLength;
      _749_KeyLength = AlgorithmSuites_Compile.__default.GetEncryptKeyLength(_746_suite);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _750_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _750_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger((_747_wrappedMaterial).Count)) == ((new BigInteger(AwsKmsHierarchicalKeyring_Compile.__default.EXPECTED__EDK__CIPHERTEXT__OVERHEAD)) + (new BigInteger(_749_KeyLength))), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Received EDK Ciphertext of incorrect length2.")));
      if ((_750_valueOrError0).IsFailure()) {
        res = (_750_valueOrError0).PropagateFailure<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo>>();
        return res;
      }
      Dafny.ISequence<byte> _751_salt;
      _751_salt = (_747_wrappedMaterial).Subsequence(BigInteger.Zero, AwsKmsHierarchicalKeyring_Compile.__default.H__WRAP__SALT__LEN);
      Dafny.ISequence<byte> _752_iv;
      _752_iv = (_747_wrappedMaterial).Subsequence(AwsKmsHierarchicalKeyring_Compile.__default.H__WRAP__SALT__LEN, AwsKmsHierarchicalKeyring_Compile.__default.EDK__CIPHERTEXT__BRANCH__KEY__VERSION__INDEX);
      Dafny.ISequence<byte> _753_branchKeyVersionUuid;
      _753_branchKeyVersionUuid = (_747_wrappedMaterial).Subsequence(AwsKmsHierarchicalKeyring_Compile.__default.EDK__CIPHERTEXT__BRANCH__KEY__VERSION__INDEX, AwsKmsHierarchicalKeyring_Compile.__default.EDK__CIPHERTEXT__VERSION__INDEX);
      Dafny.ISequence<byte> _754_wrappedKey;
      _754_wrappedKey = (_747_wrappedMaterial).Subsequence(AwsKmsHierarchicalKeyring_Compile.__default.EDK__CIPHERTEXT__VERSION__INDEX, (AwsKmsHierarchicalKeyring_Compile.__default.EDK__CIPHERTEXT__VERSION__INDEX) + (_749_KeyLength));
      Dafny.ISequence<byte> _755_authTag;
      _755_authTag = (_747_wrappedMaterial).Drop((AwsKmsHierarchicalKeyring_Compile.__default.EDK__CIPHERTEXT__VERSION__INDEX) + (_749_KeyLength));
      Dafny.ISequence<byte> _756_serializedEC;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _757_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _757_valueOrError1 = CanonicalEncryptionContext_Compile.__default.EncryptionContextToAAD((input).dtor_encryptionContext);
      if ((_757_valueOrError1).IsFailure()) {
        res = (_757_valueOrError1).PropagateFailure<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo>>();
        return res;
      }
      _756_serializedEC = (_757_valueOrError1).Extract();
      Dafny.ISequence<byte> _758_wrappingAad;
      _758_wrappingAad = AwsKmsHierarchicalKeyring_Compile.__default.WrappingAad((this).branchKeyIdUtf8, (this).branchKeyVersionAsBytes, _756_serializedEC);
      Dafny.ISequence<byte> _759_derivedBranchKey;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _760_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out126;
      _out126 = AwsKmsHierarchicalKeyring_Compile.__default.DeriveEncryptionKeyFromBranchKey((this).branchKey, _751_salt, Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(Constants_Compile.__default.PROVIDER__ID__HIERARCHY), (this).crypto);
      _760_valueOrError2 = _out126;
      if ((_760_valueOrError2).IsFailure()) {
        res = (_760_valueOrError2).PropagateFailure<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo>>();
        return res;
      }
      _759_derivedBranchKey = (_760_valueOrError2).Extract();
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _761_maybeUnwrappedPdk;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out127;
      _out127 = ((this).crypto).AESDecrypt(software.amazon.cryptography.primitives.internaldafny.types.AESDecryptInput.create(AwsKmsHierarchicalKeyring_Compile.__default.AES__256__ENC__ALG, _759_derivedBranchKey, _754_wrappedKey, _755_authTag, _752_iv, _758_wrappingAad));
      _761_maybeUnwrappedPdk = _out127;
      Dafny.ISequence<byte> _762_unwrappedPdk;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _763_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _763_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_761_maybeUnwrappedPdk, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_764_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_764_e);
      })));
      if ((_763_valueOrError3).IsFailure()) {
        res = (_763_valueOrError3).PropagateFailure<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo>>();
        return res;
      }
      _762_unwrappedPdk = (_763_valueOrError3).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _765_valueOrError4 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _765_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger((_762_unwrappedPdk).Count)) == (new BigInteger(AlgorithmSuites_Compile.__default.GetEncryptKeyLength((input).dtor_algorithmSuite))), AwsKmsHierarchicalKeyring_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid Key Length")));
      if ((_765_valueOrError4).IsFailure()) {
        res = (_765_valueOrError4).PropagateFailure<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo>>();
        return res;
      }
      MaterialWrapping_Compile._IUnwrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo> _766_output;
      _766_output = MaterialWrapping_Compile.UnwrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo>.create(_762_unwrappedPdk, AwsKmsHierarchicalKeyring_Compile.HierarchyUnwrapInfo.create());
      res = Wrappers_Compile.Result<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_766_output);
      return res;
      return res;
    }
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _crypto {get; set;}
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient crypto { get {
      return this._crypto;
    } }
    public Dafny.ISequence<byte> _branchKeyIdUtf8 {get; set;}
    public Dafny.ISequence<byte> branchKeyIdUtf8 { get {
      return this._branchKeyIdUtf8;
    } }
    public Dafny.ISequence<byte> _branchKeyVersionAsBytes {get; set;}
    public Dafny.ISequence<byte> branchKeyVersionAsBytes { get {
      return this._branchKeyVersionAsBytes;
    } }
    public Dafny.ISequence<byte> _branchKey {get; set;}
    public Dafny.ISequence<byte> branchKey { get {
      return this._branchKey;
    } }
  }

  public partial class KmsHierarchyGenerateAndWrapKeyMaterial : MaterialWrapping_Compile.GenerateAndWrapMaterial<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>, Actions_Compile.ActionWithResult<MaterialWrapping_Compile._IGenerateAndWrapInput, MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<MaterialWrapping_Compile._IGenerateAndWrapInput, Wrappers_Compile._IResult<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public KmsHierarchyGenerateAndWrapKeyMaterial() {
      this._branchKey = Dafny.Sequence<byte>.Empty;
      this._branchKeyIdUtf8 = UTF8.ValidUTF8Bytes.Default();
      this._branchKeyVersionAsBytes = Dafny.Sequence<byte>.Empty;
      this._crypto = default(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient);
    }
    public void __ctor(Dafny.ISequence<byte> branchKey, Dafny.ISequence<byte> branchKeyIdUtf8, Dafny.ISequence<byte> branchKeyVersionAsBytes, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient crypto)
    {
      (this)._branchKey = branchKey;
      (this)._branchKeyIdUtf8 = branchKeyIdUtf8;
      (this)._branchKeyVersionAsBytes = branchKeyVersionAsBytes;
      (this)._crypto = crypto;
    }
    public Wrappers_Compile._IResult<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(MaterialWrapping_Compile._IGenerateAndWrapInput input)
    {
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = Wrappers_Compile.Result<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(MaterialWrapping_Compile.GenerateAndWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>.Default(AwsKmsHierarchicalKeyring_Compile.HierarchyWrapInfo.Default()));
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _767_suite;
      _767_suite = (input).dtor_algorithmSuite;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _768_pdkResult;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out128;
      _out128 = ((this).crypto).GenerateRandomBytes(software.amazon.cryptography.primitives.internaldafny.types.GenerateRandomBytesInput.create(AlgorithmSuites_Compile.__default.GetEncryptKeyLength(_767_suite)));
      _768_pdkResult = _out128;
      Dafny.ISequence<byte> _769_pdk;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _770_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _770_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_768_pdkResult, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_771_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_771_e);
      })));
      if ((_770_valueOrError0).IsFailure()) {
        res = (_770_valueOrError0).PropagateFailure<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>>();
        return res;
      }
      _769_pdk = (_770_valueOrError0).Extract();
      AwsKmsHierarchicalKeyring_Compile.KmsHierarchyWrapKeyMaterial _772_wrap;
      AwsKmsHierarchicalKeyring_Compile.KmsHierarchyWrapKeyMaterial _nw37 = new AwsKmsHierarchicalKeyring_Compile.KmsHierarchyWrapKeyMaterial();
      _nw37.__ctor((this).branchKey, (this).branchKeyIdUtf8, (this).branchKeyVersionAsBytes, (this).crypto);
      _772_wrap = _nw37;
      MaterialWrapping_Compile._IWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo> _773_wrapOutput;
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _774_valueOrError1 = Wrappers_Compile.Result<MaterialWrapping_Compile._IWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(MaterialWrapping_Compile.WrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>.Default(AwsKmsHierarchicalKeyring_Compile.HierarchyWrapInfo.Default()));
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out129;
      _out129 = (_772_wrap).Invoke(MaterialWrapping_Compile.WrapInput.create(_769_pdk, (input).dtor_algorithmSuite, (input).dtor_encryptionContext));
      _774_valueOrError1 = _out129;
      if ((_774_valueOrError1).IsFailure()) {
        res = (_774_valueOrError1).PropagateFailure<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>>();
        return res;
      }
      _773_wrapOutput = (_774_valueOrError1).Extract();
      MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo> _775_output;
      _775_output = MaterialWrapping_Compile.GenerateAndWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>.create(_769_pdk, (_773_wrapOutput).dtor_wrappedMaterial, AwsKmsHierarchicalKeyring_Compile.HierarchyWrapInfo.create());
      res = Wrappers_Compile.Result<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_775_output);
      return res;
      return res;
    }
    public Dafny.ISequence<byte> _branchKey {get; set;}
    public Dafny.ISequence<byte> branchKey { get {
      return this._branchKey;
    } }
    public Dafny.ISequence<byte> _branchKeyIdUtf8 {get; set;}
    public Dafny.ISequence<byte> branchKeyIdUtf8 { get {
      return this._branchKeyIdUtf8;
    } }
    public Dafny.ISequence<byte> _branchKeyVersionAsBytes {get; set;}
    public Dafny.ISequence<byte> branchKeyVersionAsBytes { get {
      return this._branchKeyVersionAsBytes;
    } }
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _crypto {get; set;}
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient crypto { get {
      return this._crypto;
    } }
  }

  public partial class KmsHierarchyWrapKeyMaterial : MaterialWrapping_Compile.WrapMaterial<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>, Actions_Compile.ActionWithResult<MaterialWrapping_Compile._IWrapInput, MaterialWrapping_Compile._IWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<MaterialWrapping_Compile._IWrapInput, Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public KmsHierarchyWrapKeyMaterial() {
      this._branchKey = Dafny.Sequence<byte>.Empty;
      this._branchKeyIdUtf8 = UTF8.ValidUTF8Bytes.Default();
      this._branchKeyVersionAsBytes = Dafny.Sequence<byte>.Empty;
      this._crypto = default(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient);
    }
    public void __ctor(Dafny.ISequence<byte> branchKey, Dafny.ISequence<byte> branchKeyIdUtf8, Dafny.ISequence<byte> branchKeyVersionAsBytes, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient crypto)
    {
      (this)._branchKey = branchKey;
      (this)._branchKeyIdUtf8 = branchKeyIdUtf8;
      (this)._branchKeyVersionAsBytes = branchKeyVersionAsBytes;
      (this)._crypto = crypto;
    }
    public Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(MaterialWrapping_Compile._IWrapInput input)
    {
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = Wrappers_Compile.Result<MaterialWrapping_Compile._IWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(MaterialWrapping_Compile.WrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>.Default(AwsKmsHierarchicalKeyring_Compile.HierarchyWrapInfo.Default()));
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _776_suite;
      _776_suite = (input).dtor_algorithmSuite;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _777_maybeNonceSalt;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out130;
      _out130 = ((this).crypto).GenerateRandomBytes(software.amazon.cryptography.primitives.internaldafny.types.GenerateRandomBytesInput.create((AwsKmsHierarchicalKeyring_Compile.__default.H__WRAP__SALT__LEN) + (AwsKmsHierarchicalKeyring_Compile.__default.H__WRAP__NONCE__LEN)));
      _777_maybeNonceSalt = _out130;
      Dafny.ISequence<byte> _778_saltAndNonce;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _779_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _779_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_777_maybeNonceSalt, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_780_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_780_e);
      })));
      if ((_779_valueOrError0).IsFailure()) {
        res = (_779_valueOrError0).PropagateFailure<MaterialWrapping_Compile._IWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>>();
        return res;
      }
      _778_saltAndNonce = (_779_valueOrError0).Extract();
      Dafny.ISequence<byte> _781_salt;
      _781_salt = (_778_saltAndNonce).Subsequence(BigInteger.Zero, AwsKmsHierarchicalKeyring_Compile.__default.H__WRAP__SALT__LEN);
      Dafny.ISequence<byte> _782_nonce;
      _782_nonce = (_778_saltAndNonce).Drop(AwsKmsHierarchicalKeyring_Compile.__default.H__WRAP__SALT__LEN);
      Dafny.ISequence<byte> _783_serializedEC;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _784_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _784_valueOrError1 = CanonicalEncryptionContext_Compile.__default.EncryptionContextToAAD((input).dtor_encryptionContext);
      if ((_784_valueOrError1).IsFailure()) {
        res = (_784_valueOrError1).PropagateFailure<MaterialWrapping_Compile._IWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>>();
        return res;
      }
      _783_serializedEC = (_784_valueOrError1).Extract();
      Dafny.ISequence<byte> _785_wrappingAad;
      _785_wrappingAad = AwsKmsHierarchicalKeyring_Compile.__default.WrappingAad((this).branchKeyIdUtf8, (this).branchKeyVersionAsBytes, _783_serializedEC);
      Dafny.ISequence<byte> _786_derivedBranchKey;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _787_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out131;
      _out131 = AwsKmsHierarchicalKeyring_Compile.__default.DeriveEncryptionKeyFromBranchKey((this).branchKey, _781_salt, Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(Constants_Compile.__default.PROVIDER__ID__HIERARCHY), (this).crypto);
      _787_valueOrError2 = _out131;
      if ((_787_valueOrError2).IsFailure()) {
        res = (_787_valueOrError2).PropagateFailure<MaterialWrapping_Compile._IWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>>();
        return res;
      }
      _786_derivedBranchKey = (_787_valueOrError2).Extract();
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput, software.amazon.cryptography.primitives.internaldafny.types._IError> _788_maybeWrappedPdk;
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput, software.amazon.cryptography.primitives.internaldafny.types._IError> _out132;
      _out132 = ((this).crypto).AESEncrypt(software.amazon.cryptography.primitives.internaldafny.types.AESEncryptInput.create(AwsKmsHierarchicalKeyring_Compile.__default.AES__256__ENC__ALG, _782_nonce, _786_derivedBranchKey, (input).dtor_plaintextMaterial, _785_wrappingAad));
      _788_maybeWrappedPdk = _out132;
      software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput _789_wrappedPdk;
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _790_valueOrError3 = Wrappers_Compile.Result<software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(software.amazon.cryptography.primitives.internaldafny.types.AESEncryptOutput.Default());
      _790_valueOrError3 = Wrappers_Compile.Result<software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_788_maybeWrappedPdk, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_791_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_791_e);
      })));
      if ((_790_valueOrError3).IsFailure()) {
        res = (_790_valueOrError3).PropagateFailure<MaterialWrapping_Compile._IWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>>();
        return res;
      }
      _789_wrappedPdk = (_790_valueOrError3).Extract();
      MaterialWrapping_Compile._IWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo> _792_output;
      _792_output = MaterialWrapping_Compile.WrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>.create(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(_781_salt, _782_nonce), (this).branchKeyVersionAsBytes), (_789_wrappedPdk).dtor_cipherText), (_789_wrappedPdk).dtor_authTag), AwsKmsHierarchicalKeyring_Compile.HierarchyWrapInfo.create());
      res = Wrappers_Compile.Result<MaterialWrapping_Compile._IWrapOutput<AwsKmsHierarchicalKeyring_Compile._IHierarchyWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_792_output);
      return res;
      return res;
    }
    public Dafny.ISequence<byte> _branchKey {get; set;}
    public Dafny.ISequence<byte> branchKey { get {
      return this._branchKey;
    } }
    public Dafny.ISequence<byte> _branchKeyIdUtf8 {get; set;}
    public Dafny.ISequence<byte> branchKeyIdUtf8 { get {
      return this._branchKeyIdUtf8;
    } }
    public Dafny.ISequence<byte> _branchKeyVersionAsBytes {get; set;}
    public Dafny.ISequence<byte> branchKeyVersionAsBytes { get {
      return this._branchKeyVersionAsBytes;
    } }
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _crypto {get; set;}
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient crypto { get {
      return this._crypto;
    } }
  }

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> getEntry(software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache cmc, software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out133;
      _out133 = (cmc).GetCacheEntry(input);
      res = _out133;
      return res;
    }
    public static Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> putEntry(software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache cmc, software.amazon.cryptography.materialproviders.internaldafny.types._IPutCacheEntryInput input)
    {
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out134;
      _out134 = (cmc).PutCacheEntry(input);
      res = _out134;
      return res;
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> DeriveEncryptionKeyFromBranchKey(Dafny.ISequence<byte> branchKey, Dafny.ISequence<byte> salt, Wrappers_Compile._IOption<Dafny.ISequence<byte>> purpose, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _793_maybeDerivedBranchKey;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out135;
      _out135 = (cryptoPrimitives).KdfCounterMode(software.amazon.cryptography.primitives.internaldafny.types.KdfCtrInput.create(software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__256(), branchKey, AwsKmsHierarchicalKeyring_Compile.__default.DERIVED__BRANCH__KEY__EXPECTED__LENGTH, purpose, Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(salt)));
      _793_maybeDerivedBranchKey = _out135;
      Dafny.ISequence<byte> _794_derivedBranchKey;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _795_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _795_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_793_maybeDerivedBranchKey, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_796_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_796_e);
      })));
      if ((_795_valueOrError0).IsFailure()) {
        output = (_795_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        return output;
      }
      _794_derivedBranchKey = (_795_valueOrError0).Extract();
      output = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_794_derivedBranchKey);
      return output;
    }
    public static Dafny.ISequence<byte> WrappingAad(Dafny.ISequence<byte> branchKeyId, Dafny.ISequence<byte> branchKeyVersion, Dafny.ISequence<byte> aad)
    {
      return Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Constants_Compile.__default.PROVIDER__ID__HIERARCHY, branchKeyId), branchKeyVersion), aad);
    }
    public static Dafny.ISequence<byte> SerializeEDKCiphertext(software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput encOutput) {
      return Dafny.Sequence<byte>.Concat((encOutput).dtor_cipherText, (encOutput).dtor_authTag);
    }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IError E(Dafny.ISequence<char> s) {
      return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(s);
    }
    public static Dafny.ISequence<char> EXPRESSION__ATTRIBUTE__VALUE__STATUS__VALUE { get {
      return Dafny.Sequence<char>.FromString("ACTIVE");
    } }
    public static int H__WRAP__SALT__LEN { get {
      return 16;
    } }
    public static int H__WRAP__NONCE__LEN { get {
      return 12;
    } }
    public static int EDK__CIPHERTEXT__BRANCH__KEY__VERSION__INDEX { get {
      return (AwsKmsHierarchicalKeyring_Compile.__default.H__WRAP__SALT__LEN) + (AwsKmsHierarchicalKeyring_Compile.__default.H__WRAP__NONCE__LEN);
    } }
    public static int EDK__CIPHERTEXT__VERSION__LENGTH { get {
      return 16;
    } }
    public static int EDK__CIPHERTEXT__VERSION__INDEX { get {
      return (AwsKmsHierarchicalKeyring_Compile.__default.EDK__CIPHERTEXT__BRANCH__KEY__VERSION__INDEX) + (AwsKmsHierarchicalKeyring_Compile.__default.EDK__CIPHERTEXT__VERSION__LENGTH);
    } }
    public static int AES__256__ENC__TAG__LENGTH { get {
      return 16;
    } }
    public static int EXPECTED__EDK__CIPHERTEXT__OVERHEAD { get {
      return (AwsKmsHierarchicalKeyring_Compile.__default.EDK__CIPHERTEXT__VERSION__INDEX) + (AwsKmsHierarchicalKeyring_Compile.__default.AES__256__ENC__TAG__LENGTH);
    } }
    public static int AES__256__ENC__KEY__LENGTH { get {
      return 32;
    } }
    public static int AES__256__ENC__IV__LENGTH { get {
      return 12;
    } }
    public static software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM AES__256__ENC__ALG { get {
      return software.amazon.cryptography.primitives.internaldafny.types.AES__GCM.create(AwsKmsHierarchicalKeyring_Compile.__default.AES__256__ENC__KEY__LENGTH, AwsKmsHierarchicalKeyring_Compile.__default.AES__256__ENC__TAG__LENGTH, AwsKmsHierarchicalKeyring_Compile.__default.AES__256__ENC__IV__LENGTH);
    } }
    public static int DERIVED__BRANCH__KEY__EXPECTED__LENGTH { get {
      return 32;
    } }
    public static Dafny.ISequence<char> BRANCH__KEY__STORE__GSI { get {
      return Dafny.Sequence<char>.FromString("Active-Keys");
    } }
    public static Dafny.ISequence<char> BRANCH__KEY__FIELD { get {
      return Dafny.Sequence<char>.FromString("enc");
    } }
    public static Dafny.ISequence<char> VERSION__FIELD { get {
      return Dafny.Sequence<char>.FromString("version");
    } }
    public static Dafny.ISequence<char> BRANCH__KEY__IDENTIFIER__FIELD { get {
      return Dafny.Sequence<char>.FromString("branch-key-id");
    } }
    public static Dafny.ISequence<char> KEY__CONDITION__EXPRESSION { get {
      return Dafny.Sequence<char>.FromString("#status = :status and #branch_key_id = :branch_key_id");
    } }
    public static Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> EXPRESSION__ATTRIBUTE__NAMES { get {
      return Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.FromElements(new Dafny.Pair<Dafny.ISequence<char>, Dafny.ISequence<char>>(Dafny.Sequence<char>.FromString("#status"), Dafny.Sequence<char>.FromString("status")), new Dafny.Pair<Dafny.ISequence<char>, Dafny.ISequence<char>>(Dafny.Sequence<char>.FromString("#branch_key_id"), Dafny.Sequence<char>.FromString("branch-key-id")));
    } }
    public static Dafny.ISequence<char> EXPRESSION__ATTRIBUTE__VALUE__STATUS__KEY { get {
      return Dafny.Sequence<char>.FromString(":status");
    } }
    public static Dafny.ISequence<char> EXPRESSION__ATTRIBUTE__VALUE__BRANCH__KEY { get {
      return Dafny.Sequence<char>.FromString(":branch_key_id");
    } }
  }
} // end of namespace AwsKmsHierarchicalKeyring_Compile
namespace AwsKmsRsaKeyring_Compile {

  public partial class AwsKmsRsaKeyring : Keyring_Compile.VerifiableInterface, software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring {
    public AwsKmsRsaKeyring() {
      this._cryptoPrimitives = default(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient);
      this._client = Wrappers_Compile.Option<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient>.Default();
      this._paddingScheme = software.amazon.cryptography.services.kms.internaldafny.types.EncryptionAlgorithmSpec.Default();
      this._awsKmsKey = default(Dafny.ISequence<char>);
      this._publicKey = Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default();
      this._awsKmsArn = default(AwsArnParsing_Compile._IAwsKmsIdentifier);
      this._grantTokens = default(Dafny.ISequence<Dafny.ISequence<char>>);
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnEncrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out136;
      _out136 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_IKeyring.OnEncrypt(this, input);
      return _out136;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnDecrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out137;
      _out137 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_IKeyring.OnDecrypt(this, input);
      return _out137;
    }
    public void __ctor(Wrappers_Compile._IOption<Dafny.ISequence<byte>> publicKey, Dafny.ISequence<char> awsKmsKey, software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec paddingScheme, Wrappers_Compile._IOption<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient> client, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives, Dafny.ISequence<Dafny.ISequence<char>> grantTokens)
    {
      Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsKmsIdentifier, Dafny.ISequence<char>> _797_parsedAwsKmsId;
      _797_parsedAwsKmsId = AwsArnParsing_Compile.__default.ParseAwsKmsIdentifier(awsKmsKey);
      (this)._publicKey = publicKey;
      (this)._awsKmsKey = awsKmsKey;
      (this)._awsKmsArn = (_797_parsedAwsKmsId).dtor_value;
      (this)._paddingScheme = paddingScheme;
      (this)._client = client;
      (this)._cryptoPrimitives = cryptoPrimitives;
      (this)._grantTokens = grantTokens;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnEncrypt_k(software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _798_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _798_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((this).publicKey).is_Some) && ((new BigInteger((((this).publicKey).Extract()).Count)).Sign == 1), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("A AwsKmsRsaKeyring without a public key cannot provide OnEncrypt")));
      if ((_798_valueOrError0).IsFailure()) {
        res = (_798_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
        return res;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _799_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _799_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((((input).dtor_materials).dtor_algorithmSuite).dtor_signature).is_None, software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("AwsKmsRsaKeyring cannot be used with an Algorithm Suite with asymmetric signing."), Dafny.Sequence<char>.FromString(" Please specify an algorithm suite without asymmetric signing."))));
      if ((_799_valueOrError1).IsFailure()) {
        res = (_799_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
        return res;
      }
      AwsKmsRsaKeyring_Compile.KmsRsaWrapKeyMaterial _800_wrap;
      AwsKmsRsaKeyring_Compile.KmsRsaWrapKeyMaterial _nw38 = new AwsKmsRsaKeyring_Compile.KmsRsaWrapKeyMaterial();
      _nw38.__ctor(((this).publicKey).dtor_value, (this).paddingScheme, (this).cryptoPrimitives);
      _800_wrap = _nw38;
      AwsKmsRsaKeyring_Compile.KmsRsaGenerateAndWrapKeyMaterial _801_generateAndWrap;
      AwsKmsRsaKeyring_Compile.KmsRsaGenerateAndWrapKeyMaterial _nw39 = new AwsKmsRsaKeyring_Compile.KmsRsaGenerateAndWrapKeyMaterial();
      _nw39.__ctor(((this).publicKey).dtor_value, (this).paddingScheme, (this).cryptoPrimitives);
      _801_generateAndWrap = _nw39;
      EdkWrapping_Compile._IWrapEdkMaterialOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo> _802_wrapOutput;
      Wrappers_Compile._IResult<EdkWrapping_Compile._IWrapEdkMaterialOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _803_valueOrError2 = Wrappers_Compile.Result<EdkWrapping_Compile._IWrapEdkMaterialOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(EdkWrapping_Compile.WrapEdkMaterialOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>.Default(AwsKmsRsaKeyring_Compile.KmsRsaWrapInfo.Default()));
      Wrappers_Compile._IResult<EdkWrapping_Compile._IWrapEdkMaterialOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out138;
      _out138 = EdkWrapping_Compile.__default.WrapEdkMaterial<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>((input).dtor_materials, _800_wrap, _801_generateAndWrap);
      _803_valueOrError2 = _out138;
      if ((_803_valueOrError2).IsFailure()) {
        res = (_803_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
        return res;
      }
      _802_wrapOutput = (_803_valueOrError2).Extract();
      Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>> _804_symmetricSigningKeyList;
      _804_symmetricSigningKeyList = ((((_802_wrapOutput).dtor_symmetricSigningKey).is_Some) ? (Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.create_Some(Dafny.Sequence<Dafny.ISequence<byte>>.FromElements(((_802_wrapOutput).dtor_symmetricSigningKey).dtor_value))) : (Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.create_None()));
      software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey _805_edk;
      _805_edk = software.amazon.cryptography.materialproviders.internaldafny.types.EncryptedDataKey.create(Constants_Compile.__default.RSA__PROVIDER__ID, (UTF8.__default.Encode((this).awsKmsKey)).dtor_value, (_802_wrapOutput).dtor_wrappedMaterial);
      software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _806_returnMaterials = default(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials);
      if ((_802_wrapOutput).is_GenerateAndWrapEdkMaterialOutput) {
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _807_valueOrError3 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        _807_valueOrError3 = Materials_Compile.__default.EncryptionMaterialAddDataKey((input).dtor_materials, (_802_wrapOutput).dtor_plaintextDataKey, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.FromElements(_805_edk), _804_symmetricSigningKeyList);
        if ((_807_valueOrError3).IsFailure()) {
          res = (_807_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
          return res;
        }
        _806_returnMaterials = (_807_valueOrError3).Extract();
      } else if ((_802_wrapOutput).is_WrapOnlyEdkMaterialOutput) {
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _808_valueOrError4 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        _808_valueOrError4 = Materials_Compile.__default.EncryptionMaterialAddEncryptedDataKeys((input).dtor_materials, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.FromElements(_805_edk), _804_symmetricSigningKeyList);
        if ((_808_valueOrError4).IsFailure()) {
          res = (_808_valueOrError4).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
          return res;
        }
        _806_returnMaterials = (_808_valueOrError4).Extract();
      }
      res = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.OnEncryptOutput.create(_806_returnMaterials));
      return res;
      return res;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnDecrypt_k(software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _809_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _809_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((this).client).is_Some, software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("An AwsKmsRsaKeyring without an AWS KMS client cannot provide OnDecrypt")));
      if ((_809_valueOrError0).IsFailure()) {
        res = (_809_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return res;
      }
      software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _810_materials;
      _810_materials = (input).dtor_materials;
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _811_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _811_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.DecryptionMaterialsWithoutPlaintextDataKey(_810_materials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Keyring received decryption materials that already contain a plaintext data key.")));
      if ((_811_valueOrError1).IsFailure()) {
        res = (_811_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return res;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _812_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _812_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((((input).dtor_materials).dtor_algorithmSuite).dtor_signature).is_None, software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("AwsKmsRsaKeyring cannot be used with an Algorithm Suite with asymmetric signing."), Dafny.Sequence<char>.FromString(" Please specify an algorithm suite without asymmetric signing."))));
      if ((_812_valueOrError2).IsFailure()) {
        res = (_812_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return res;
      }
      AwsKmsUtils_Compile.OnDecryptMrkAwareEncryptedDataKeyFilter _813_filter;
      AwsKmsUtils_Compile.OnDecryptMrkAwareEncryptedDataKeyFilter _nw40 = new AwsKmsUtils_Compile.OnDecryptMrkAwareEncryptedDataKeyFilter();
      _nw40.__ctor((this).awsKmsArn, Constants_Compile.__default.RSA__PROVIDER__ID);
      _813_filter = _nw40;
      Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _814_edksToAttempt;
      Wrappers_Compile._IResult<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _815_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out139;
      _out139 = Actions_Compile.__default.FilterWithResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_813_filter, (input).dtor_encryptedDataKeys);
      _815_valueOrError3 = _out139;
      if ((_815_valueOrError3).IsFailure()) {
        res = (_815_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return res;
      }
      _814_edksToAttempt = (_815_valueOrError3).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _816_valueOrError4 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _816_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger((_814_edksToAttempt).Count)).Sign == 1, software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Unable to decrypt data key: No Encrypted Data Keys found to match.")));
      if ((_816_valueOrError4).IsFailure()) {
        res = (_816_valueOrError4).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return res;
      }
      Dafny.ISequence<byte> _817_encryptionContextDigest;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _818_valueOrError5 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out140;
      _out140 = AwsKmsRsaKeyring_Compile.__default.EncryptionContextDigest((this).cryptoPrimitives, (_810_materials).dtor_encryptionContext);
      _818_valueOrError5 = _out140;
      if ((_818_valueOrError5).IsFailure()) {
        res = (_818_valueOrError5).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return res;
      }
      _817_encryptionContextDigest = (_818_valueOrError5).Extract();
      Actions_Compile.ActionWithResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _819_decryptClosure;
      AwsKmsRsaKeyring_Compile.DecryptSingleAWSRSAEncryptedDataKey _nw41 = new AwsKmsRsaKeyring_Compile.DecryptSingleAWSRSAEncryptedDataKey();
      _nw41.__ctor(_810_materials, ((this).client).dtor_value, (this).awsKmsKey, (this).paddingScheme, _817_encryptionContextDigest, (this).grantTokens);
      _819_decryptClosure = _nw41;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>> _820_outcome;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>> _out141;
      _out141 = Actions_Compile.__default.ReduceToSuccess<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_819_decryptClosure, _814_edksToAttempt);
      _820_outcome = _out141;
      software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _821_SealedDecryptionMaterials;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _822_valueOrError6 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      _822_valueOrError6 = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_820_outcome, ((System.Func<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_823_errors) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_CollectionOfErrors(_823_errors, Dafny.Sequence<char>.FromString("No Configured KMS Key was able to decrypt the Data Key. The list of encountered Exceptions is available via `list`."));
      })));
      if ((_822_valueOrError6).IsFailure()) {
        res = (_822_valueOrError6).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return res;
      }
      _821_SealedDecryptionMaterials = (_822_valueOrError6).Extract();
      res = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.OnDecryptOutput.create(_821_SealedDecryptionMaterials));
      return res;
      return res;
    }
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _cryptoPrimitives {get; set;}
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives { get {
      return this._cryptoPrimitives;
    } }
    public Wrappers_Compile._IOption<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient> _client {get; set;}
    public Wrappers_Compile._IOption<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient> client { get {
      return this._client;
    } }
    public software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec _paddingScheme {get; set;}
    public software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec paddingScheme { get {
      return this._paddingScheme;
    } }
    public Dafny.ISequence<char> _awsKmsKey {get; set;}
    public Dafny.ISequence<char> awsKmsKey { get {
      return this._awsKmsKey;
    } }
    public Wrappers_Compile._IOption<Dafny.ISequence<byte>> _publicKey {get; set;}
    public Wrappers_Compile._IOption<Dafny.ISequence<byte>> publicKey { get {
      return this._publicKey;
    } }
    public AwsArnParsing_Compile._IAwsKmsIdentifier _awsKmsArn {get; set;}
    public AwsArnParsing_Compile._IAwsKmsIdentifier awsKmsArn { get {
      return this._awsKmsArn;
    } }
    public Dafny.ISequence<Dafny.ISequence<char>> _grantTokens {get; set;}
    public Dafny.ISequence<Dafny.ISequence<char>> grantTokens { get {
      return this._grantTokens;
    } }
  }

  public partial class DecryptSingleAWSRSAEncryptedDataKey : Actions_Compile.ActionWithResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public DecryptSingleAWSRSAEncryptedDataKey() {
      this._materials = default(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials);
      this._client = default(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient);
      this._awsKmsKey = default(Dafny.ISequence<char>);
      this._paddingScheme = software.amazon.cryptography.services.kms.internaldafny.types.EncryptionAlgorithmSpec.Default();
      this._encryptionContextDigest = Dafny.Sequence<byte>.Empty;
      this._grantTokens = default(Dafny.ISequence<Dafny.ISequence<char>>);
    }
    public void __ctor(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials materials, software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client, Dafny.ISequence<char> awsKmsKey, software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec paddingScheme, Dafny.ISequence<byte> encryptionContextDigest, Dafny.ISequence<Dafny.ISequence<char>> grantTokens)
    {
      (this)._materials = materials;
      (this)._client = client;
      (this)._awsKmsKey = awsKmsKey;
      (this)._paddingScheme = paddingScheme;
      (this)._encryptionContextDigest = encryptionContextDigest;
      (this)._grantTokens = grantTokens;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey edk)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      AwsKmsRsaKeyring_Compile.KmsRsaUnwrapKeyMaterial _824_unwrap;
      AwsKmsRsaKeyring_Compile.KmsRsaUnwrapKeyMaterial _nw42 = new AwsKmsRsaKeyring_Compile.KmsRsaUnwrapKeyMaterial();
      _nw42.__ctor((this).client, (this).awsKmsKey, (this).paddingScheme, (this).encryptionContextDigest, (this).grantTokens);
      _824_unwrap = _nw42;
      EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo> _825_unwrapOutput;
      Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _826_valueOrError0 = Wrappers_Compile.Result<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(EdkWrapping_Compile.UnwrapEdkMaterialOutput<AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo>.Default(AwsKmsRsaKeyring_Compile.KmsRsaUnwrapInfo.Default()));
      Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out142;
      _out142 = EdkWrapping_Compile.__default.UnwrapEdkMaterial<AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo>((edk).dtor_ciphertext, (this).materials, _824_unwrap);
      _826_valueOrError0 = _out142;
      if ((_826_valueOrError0).IsFailure()) {
        res = (_826_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        return res;
      }
      _825_unwrapOutput = (_826_valueOrError0).Extract();
      software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _827_result;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _828_valueOrError1 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      _828_valueOrError1 = Materials_Compile.__default.DecryptionMaterialsAddDataKey((this).materials, (_825_unwrapOutput).dtor_plaintextDataKey, (_825_unwrapOutput).dtor_symmetricSigningKey);
      if ((_828_valueOrError1).IsFailure()) {
        res = (_828_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials>();
        return res;
      }
      _827_result = (_828_valueOrError1).Extract();
      res = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_827_result);
      return res;
      return res;
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _materials {get; set;}
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials materials { get {
      return this._materials;
    } }
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _client {get; set;}
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client { get {
      return this._client;
    } }
    public Dafny.ISequence<char> _awsKmsKey {get; set;}
    public Dafny.ISequence<char> awsKmsKey { get {
      return this._awsKmsKey;
    } }
    public software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec _paddingScheme {get; set;}
    public software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec paddingScheme { get {
      return this._paddingScheme;
    } }
    public Dafny.ISequence<byte> _encryptionContextDigest {get; set;}
    public Dafny.ISequence<byte> encryptionContextDigest { get {
      return this._encryptionContextDigest;
    } }
    public Dafny.ISequence<Dafny.ISequence<char>> _grantTokens {get; set;}
    public Dafny.ISequence<Dafny.ISequence<char>> grantTokens { get {
      return this._grantTokens;
    } }
  }

  public interface _IKmsRsaUnwrapInfo {
    bool is_KmsRsaUnwrapInfo { get; }
    _IKmsRsaUnwrapInfo DowncastClone();
  }
  public class KmsRsaUnwrapInfo : _IKmsRsaUnwrapInfo {
    public KmsRsaUnwrapInfo() {
    }
    public _IKmsRsaUnwrapInfo DowncastClone() {
      if (this is _IKmsRsaUnwrapInfo dt) { return dt; }
      return new KmsRsaUnwrapInfo();
    }
    public override bool Equals(object other) {
      var oth = other as AwsKmsRsaKeyring_Compile.KmsRsaUnwrapInfo;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsKmsRsaKeyring_Compile.KmsRsaUnwrapInfo.KmsRsaUnwrapInfo";
      return s;
    }
    private static readonly AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo theDefault = create();
    public static AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo> _TYPE = new Dafny.TypeDescriptor<AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo>(AwsKmsRsaKeyring_Compile.KmsRsaUnwrapInfo.Default());
    public static Dafny.TypeDescriptor<AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IKmsRsaUnwrapInfo create() {
      return new KmsRsaUnwrapInfo();
    }
    public static _IKmsRsaUnwrapInfo create_KmsRsaUnwrapInfo() {
      return create();
    }
    public bool is_KmsRsaUnwrapInfo { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_IKmsRsaUnwrapInfo> AllSingletonConstructors {
      get {
        yield return KmsRsaUnwrapInfo.create();
      }
    }
  }

  public interface _IKmsRsaWrapInfo {
    bool is_KmsRsaWrapInfo { get; }
    _IKmsRsaWrapInfo DowncastClone();
  }
  public class KmsRsaWrapInfo : _IKmsRsaWrapInfo {
    public KmsRsaWrapInfo() {
    }
    public _IKmsRsaWrapInfo DowncastClone() {
      if (this is _IKmsRsaWrapInfo dt) { return dt; }
      return new KmsRsaWrapInfo();
    }
    public override bool Equals(object other) {
      var oth = other as AwsKmsRsaKeyring_Compile.KmsRsaWrapInfo;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsKmsRsaKeyring_Compile.KmsRsaWrapInfo.KmsRsaWrapInfo";
      return s;
    }
    private static readonly AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo theDefault = create();
    public static AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo> _TYPE = new Dafny.TypeDescriptor<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>(AwsKmsRsaKeyring_Compile.KmsRsaWrapInfo.Default());
    public static Dafny.TypeDescriptor<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IKmsRsaWrapInfo create() {
      return new KmsRsaWrapInfo();
    }
    public static _IKmsRsaWrapInfo create_KmsRsaWrapInfo() {
      return create();
    }
    public bool is_KmsRsaWrapInfo { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_IKmsRsaWrapInfo> AllSingletonConstructors {
      get {
        yield return KmsRsaWrapInfo.create();
      }
    }
  }

  public partial class KmsRsaGenerateAndWrapKeyMaterial : MaterialWrapping_Compile.GenerateAndWrapMaterial<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>, Actions_Compile.ActionWithResult<MaterialWrapping_Compile._IGenerateAndWrapInput, MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<MaterialWrapping_Compile._IGenerateAndWrapInput, Wrappers_Compile._IResult<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public KmsRsaGenerateAndWrapKeyMaterial() {
      this._publicKey = Dafny.Sequence<byte>.Empty;
      this._cryptoPrimitives = default(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient);
      this._paddingScheme = software.amazon.cryptography.services.kms.internaldafny.types.EncryptionAlgorithmSpec.Default();
    }
    public void __ctor(Dafny.ISequence<byte> publicKey, software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec paddingScheme, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives)
    {
      (this)._publicKey = publicKey;
      (this)._cryptoPrimitives = cryptoPrimitives;
      (this)._paddingScheme = paddingScheme;
    }
    public Wrappers_Compile._IResult<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(MaterialWrapping_Compile._IGenerateAndWrapInput input)
    {
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = Wrappers_Compile.Result<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(MaterialWrapping_Compile.GenerateAndWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>.Default(AwsKmsRsaKeyring_Compile.KmsRsaWrapInfo.Default()));
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _829_generateBytesResult;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out143;
      _out143 = ((this).cryptoPrimitives).GenerateRandomBytes(software.amazon.cryptography.primitives.internaldafny.types.GenerateRandomBytesInput.create(AlgorithmSuites_Compile.__default.GetEncryptKeyLength((input).dtor_algorithmSuite)));
      _829_generateBytesResult = _out143;
      Dafny.ISequence<byte> _830_plaintextMaterial;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _831_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _831_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_829_generateBytesResult, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_832_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_832_e);
      })));
      if ((_831_valueOrError0).IsFailure()) {
        res = (_831_valueOrError0).PropagateFailure<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>>();
        return res;
      }
      _830_plaintextMaterial = (_831_valueOrError0).Extract();
      AwsKmsRsaKeyring_Compile.KmsRsaWrapKeyMaterial _833_wrap;
      AwsKmsRsaKeyring_Compile.KmsRsaWrapKeyMaterial _nw43 = new AwsKmsRsaKeyring_Compile.KmsRsaWrapKeyMaterial();
      _nw43.__ctor((this).publicKey, (this).paddingScheme, (this).cryptoPrimitives);
      _833_wrap = _nw43;
      MaterialWrapping_Compile._IWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo> _834_wrapOutput;
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _835_valueOrError1 = Wrappers_Compile.Result<MaterialWrapping_Compile._IWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(MaterialWrapping_Compile.WrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>.Default(AwsKmsRsaKeyring_Compile.KmsRsaWrapInfo.Default()));
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out144;
      _out144 = (_833_wrap).Invoke(MaterialWrapping_Compile.WrapInput.create(_830_plaintextMaterial, (input).dtor_algorithmSuite, (input).dtor_encryptionContext));
      _835_valueOrError1 = _out144;
      if ((_835_valueOrError1).IsFailure()) {
        res = (_835_valueOrError1).PropagateFailure<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>>();
        return res;
      }
      _834_wrapOutput = (_835_valueOrError1).Extract();
      MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo> _836_output;
      _836_output = MaterialWrapping_Compile.GenerateAndWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>.create(_830_plaintextMaterial, (_834_wrapOutput).dtor_wrappedMaterial, AwsKmsRsaKeyring_Compile.KmsRsaWrapInfo.create());
      res = Wrappers_Compile.Result<MaterialWrapping_Compile._IGenerateAndWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_836_output);
      return res;
      return res;
    }
    public Dafny.ISequence<byte> _publicKey {get; set;}
    public Dafny.ISequence<byte> publicKey { get {
      return this._publicKey;
    } }
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _cryptoPrimitives {get; set;}
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives { get {
      return this._cryptoPrimitives;
    } }
    public software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec _paddingScheme {get; set;}
    public software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec paddingScheme { get {
      return this._paddingScheme;
    } }
  }

  public partial class KmsRsaWrapKeyMaterial : MaterialWrapping_Compile.WrapMaterial<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>, Actions_Compile.ActionWithResult<MaterialWrapping_Compile._IWrapInput, MaterialWrapping_Compile._IWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<MaterialWrapping_Compile._IWrapInput, Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public KmsRsaWrapKeyMaterial() {
      this._publicKey = Dafny.Sequence<byte>.Empty;
      this._cryptoPrimitives = default(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient);
      this._paddingScheme = software.amazon.cryptography.services.kms.internaldafny.types.EncryptionAlgorithmSpec.Default();
    }
    public void __ctor(Dafny.ISequence<byte> publicKey, software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec paddingScheme, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives)
    {
      (this)._publicKey = publicKey;
      (this)._cryptoPrimitives = cryptoPrimitives;
      (this)._paddingScheme = paddingScheme;
    }
    public Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(MaterialWrapping_Compile._IWrapInput input)
    {
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = Wrappers_Compile.Result<MaterialWrapping_Compile._IWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(MaterialWrapping_Compile.WrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>.Default(AwsKmsRsaKeyring_Compile.KmsRsaWrapInfo.Default()));
      Dafny.ISequence<byte> _837_encryptionContextDigest;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _838_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out145;
      _out145 = AwsKmsRsaKeyring_Compile.__default.EncryptionContextDigest((this).cryptoPrimitives, (input).dtor_encryptionContext);
      _838_valueOrError0 = _out145;
      if ((_838_valueOrError0).IsFailure()) {
        res = (_838_valueOrError0).PropagateFailure<MaterialWrapping_Compile._IWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>>();
        return res;
      }
      _837_encryptionContextDigest = (_838_valueOrError0).Extract();
      software.amazon.cryptography.primitives.internaldafny.types._IRSAPaddingMode _839_padding;
      _839_padding = ((System.Func<software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec, software.amazon.cryptography.primitives.internaldafny.types._IRSAPaddingMode>)((_source27) => {
        if (_source27.is_RSAES__OAEP__SHA__1) {
          return software.amazon.cryptography.primitives.internaldafny.types.RSAPaddingMode.create_OAEP__SHA1();
        } else {
          return software.amazon.cryptography.primitives.internaldafny.types.RSAPaddingMode.create_OAEP__SHA256();
        }
      }))((this).paddingScheme);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _840_RSAEncryptOutput;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out146;
      _out146 = ((this).cryptoPrimitives).RSAEncrypt(software.amazon.cryptography.primitives.internaldafny.types.RSAEncryptInput.create(_839_padding, (this).publicKey, Dafny.Sequence<byte>.Concat(_837_encryptionContextDigest, (input).dtor_plaintextMaterial)));
      _840_RSAEncryptOutput = _out146;
      Dafny.ISequence<byte> _841_ciphertext;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _842_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _842_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_840_RSAEncryptOutput, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_843_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_843_e);
      })));
      if ((_842_valueOrError1).IsFailure()) {
        res = (_842_valueOrError1).PropagateFailure<MaterialWrapping_Compile._IWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>>();
        return res;
      }
      _841_ciphertext = (_842_valueOrError1).Extract();
      MaterialWrapping_Compile._IWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo> _844_output;
      _844_output = MaterialWrapping_Compile.WrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>.create(_841_ciphertext, AwsKmsRsaKeyring_Compile.KmsRsaWrapInfo.create());
      res = Wrappers_Compile.Result<MaterialWrapping_Compile._IWrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_844_output);
      return res;
      return res;
    }
    public Dafny.ISequence<byte> _publicKey {get; set;}
    public Dafny.ISequence<byte> publicKey { get {
      return this._publicKey;
    } }
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _cryptoPrimitives {get; set;}
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives { get {
      return this._cryptoPrimitives;
    } }
    public software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec _paddingScheme {get; set;}
    public software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec paddingScheme { get {
      return this._paddingScheme;
    } }
  }

  public partial class KmsRsaUnwrapKeyMaterial : MaterialWrapping_Compile.UnwrapMaterial<AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo>, Actions_Compile.ActionWithResult<MaterialWrapping_Compile._IUnwrapInput, MaterialWrapping_Compile._IUnwrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<MaterialWrapping_Compile._IUnwrapInput, Wrappers_Compile._IResult<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public KmsRsaUnwrapKeyMaterial() {
      this._client = default(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient);
      this._grantTokens = default(Dafny.ISequence<Dafny.ISequence<char>>);
      this._awsKmsKey = default(Dafny.ISequence<char>);
      this._paddingScheme = software.amazon.cryptography.services.kms.internaldafny.types.EncryptionAlgorithmSpec.Default();
      this._encryptionContextDigest = Dafny.Sequence<byte>.Empty;
    }
    public void __ctor(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client, Dafny.ISequence<char> awsKmsKey, software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec paddingScheme, Dafny.ISequence<byte> encryptionContextDigest, Dafny.ISequence<Dafny.ISequence<char>> grantTokens)
    {
      (this)._client = client;
      (this)._awsKmsKey = awsKmsKey;
      (this)._paddingScheme = paddingScheme;
      (this)._encryptionContextDigest = encryptionContextDigest;
      (this)._grantTokens = grantTokens;
    }
    public Wrappers_Compile._IResult<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(MaterialWrapping_Compile._IUnwrapInput input)
    {
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = Wrappers_Compile.Result<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(MaterialWrapping_Compile.UnwrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo>.Default(AwsKmsRsaKeyring_Compile.KmsRsaUnwrapInfo.Default()));
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _845_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _845_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(software.amazon.cryptography.services.kms.internaldafny.types.__default.IsValid__CiphertextType((input).dtor_wrappedMaterial), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Ciphertext length invalid")));
      if ((_845_valueOrError0).IsFailure()) {
        res = (_845_valueOrError0).PropagateFailure<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo>>();
        return res;
      }
      software.amazon.cryptography.services.kms.internaldafny.types._IDecryptRequest _846_decryptRequest;
      _846_decryptRequest = software.amazon.cryptography.services.kms.internaldafny.types.DecryptRequest.create((input).dtor_wrappedMaterial, Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>.create_None(), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.create_Some((this).grantTokens), Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some((this).awsKmsKey), Wrappers_Compile.Option<software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec>.create_Some((this).paddingScheme));
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.services.kms.internaldafny.types._IError> _847_maybeDecryptResponse;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.services.kms.internaldafny.types._IError> _out147;
      _out147 = ((this).client).Decrypt(_846_decryptRequest);
      _847_maybeDecryptResponse = _out147;
      software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse _848_decryptResponse;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _849_valueOrError1 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(software.amazon.cryptography.services.kms.internaldafny.types.DecryptResponse.Default());
      _849_valueOrError1 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.services.kms.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_847_maybeDecryptResponse, ((System.Func<software.amazon.cryptography.services.kms.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_850_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_ComAmazonawsKms(_850_e);
      })));
      if ((_849_valueOrError1).IsFailure()) {
        res = (_849_valueOrError1).PropagateFailure<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo>>();
        return res;
      }
      _848_decryptResponse = (_849_valueOrError1).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _851_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _851_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((((_848_decryptResponse).dtor_KeyId).is_Some) && ((((_848_decryptResponse).dtor_KeyId).dtor_value).Equals((this).awsKmsKey))) && (((_848_decryptResponse).dtor_Plaintext).is_Some), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Invalid response from KMS Decrypt")));
      if ((_851_valueOrError2).IsFailure()) {
        res = (_851_valueOrError2).PropagateFailure<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo>>();
        return res;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _852_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _852_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((Dafny.Sequence<byte>.IsPrefixOf((this).encryptionContextDigest, ((_848_decryptResponse).dtor_Plaintext).dtor_value)) && (((new BigInteger(AlgorithmSuites_Compile.__default.GetEncryptKeyLength((input).dtor_algorithmSuite))) + (new BigInteger(((this).encryptionContextDigest).Count))) == (new BigInteger((((_848_decryptResponse).dtor_Plaintext).dtor_value).Count))), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Encryption context digest does not match expected value.")));
      if ((_852_valueOrError3).IsFailure()) {
        res = (_852_valueOrError3).PropagateFailure<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo>>();
        return res;
      }
      MaterialWrapping_Compile._IUnwrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo> _853_output;
      _853_output = MaterialWrapping_Compile.UnwrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo>.create((((_848_decryptResponse).dtor_Plaintext).dtor_value).Drop(new BigInteger(((this).encryptionContextDigest).Count)), AwsKmsRsaKeyring_Compile.KmsRsaUnwrapInfo.create());
      res = Wrappers_Compile.Result<MaterialWrapping_Compile._IUnwrapOutput<AwsKmsRsaKeyring_Compile._IKmsRsaUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_853_output);
      return res;
      return res;
    }
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _client {get; set;}
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient client { get {
      return this._client;
    } }
    public Dafny.ISequence<Dafny.ISequence<char>> _grantTokens {get; set;}
    public Dafny.ISequence<Dafny.ISequence<char>> grantTokens { get {
      return this._grantTokens;
    } }
    public Dafny.ISequence<char> _awsKmsKey {get; set;}
    public Dafny.ISequence<char> awsKmsKey { get {
      return this._awsKmsKey;
    } }
    public software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec _paddingScheme {get; set;}
    public software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec paddingScheme { get {
      return this._paddingScheme;
    } }
    public Dafny.ISequence<byte> _encryptionContextDigest {get; set;}
    public Dafny.ISequence<byte> encryptionContextDigest { get {
      return this._encryptionContextDigest;
    } }
  }

  public partial class __default {
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> EncryptionContextDigest(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      Dafny.ISequence<byte> _854_canonicalEC;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _855_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _855_valueOrError0 = CanonicalEncryptionContext_Compile.__default.EncryptionContextToAAD(encryptionContext);
      if ((_855_valueOrError0).IsFailure()) {
        output = (_855_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        return output;
      }
      _854_canonicalEC = (_855_valueOrError0).Extract();
      software.amazon.cryptography.primitives.internaldafny.types._IDigestInput _856_DigestInput;
      _856_DigestInput = software.amazon.cryptography.primitives.internaldafny.types.DigestInput.create(software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__384(), _854_canonicalEC);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _857_maybeDigest;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out148;
      _out148 = (cryptoPrimitives).Digest(_856_DigestInput);
      _857_maybeDigest = _out148;
      Dafny.ISequence<byte> _858_digest;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _859_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _859_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_857_maybeDigest, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_860_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_860_e);
      })));
      if ((_859_valueOrError1).IsFailure()) {
        output = (_859_valueOrError1).PropagateFailure<Dafny.ISequence<byte>>();
        return output;
      }
      _858_digest = (_859_valueOrError1).Extract();
      output = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_858_digest);
      return output;
      return output;
    }
    public static int MIN__KMS__RSA__KEY__LEN { get {
      return 2048;
    } }
  }
} // end of namespace AwsKmsRsaKeyring_Compile
namespace RawAESKeyring_Compile {

  public partial class RawAESKeyring : Keyring_Compile.VerifiableInterface, software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring {
    public RawAESKeyring() {
      this._cryptoPrimitives = default(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient);
      this._wrappingKey = Dafny.Sequence<byte>.Empty;
      this._wrappingAlgorithm = default(software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM);
      this._keyNamespace = UTF8.ValidUTF8Bytes.Default();
      this._keyName = UTF8.ValidUTF8Bytes.Default();
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnEncrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out149;
      _out149 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_IKeyring.OnEncrypt(this, input);
      return _out149;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnDecrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out150;
      _out150 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_IKeyring.OnDecrypt(this, input);
      return _out150;
    }
    public void __ctor(Dafny.ISequence<byte> @namespace, Dafny.ISequence<byte> name, Dafny.ISequence<byte> key, software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM wrappingAlgorithm, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives)
    {
      (this)._keyNamespace = @namespace;
      (this)._keyName = name;
      (this)._wrappingKey = key;
      (this)._wrappingAlgorithm = wrappingAlgorithm;
      (this)._cryptoPrimitives = cryptoPrimitives;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnEncrypt_k(software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _861_materials;
      _861_materials = (input).dtor_materials;
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _862_suite;
      _862_suite = (_861_materials).dtor_algorithmSuite;
      RawAESKeyring_Compile.AesWrapKeyMaterial _863_wrap;
      RawAESKeyring_Compile.AesWrapKeyMaterial _nw44 = new RawAESKeyring_Compile.AesWrapKeyMaterial();
      _nw44.__ctor((this).wrappingKey, (this).wrappingAlgorithm, (this).cryptoPrimitives);
      _863_wrap = _nw44;
      RawAESKeyring_Compile.AesGenerateAndWrapKeyMaterial _864_generateAndWrap;
      RawAESKeyring_Compile.AesGenerateAndWrapKeyMaterial _nw45 = new RawAESKeyring_Compile.AesGenerateAndWrapKeyMaterial();
      _nw45.__ctor(_863_wrap);
      _864_generateAndWrap = _nw45;
      EdkWrapping_Compile._IWrapEdkMaterialOutput<RawAESKeyring_Compile._IAesWrapInfo> _865_wrapOutput;
      Wrappers_Compile._IResult<EdkWrapping_Compile._IWrapEdkMaterialOutput<RawAESKeyring_Compile._IAesWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _866_valueOrError0 = Wrappers_Compile.Result<EdkWrapping_Compile._IWrapEdkMaterialOutput<RawAESKeyring_Compile._IAesWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(EdkWrapping_Compile.WrapEdkMaterialOutput<RawAESKeyring_Compile._IAesWrapInfo>.Default(RawAESKeyring_Compile.AesWrapInfo.Default()));
      Wrappers_Compile._IResult<EdkWrapping_Compile._IWrapEdkMaterialOutput<RawAESKeyring_Compile._IAesWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out151;
      _out151 = EdkWrapping_Compile.__default.WrapEdkMaterial<RawAESKeyring_Compile._IAesWrapInfo>(_861_materials, _863_wrap, _864_generateAndWrap);
      _866_valueOrError0 = _out151;
      if ((_866_valueOrError0).IsFailure()) {
        output = (_866_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
        return output;
      }
      _865_wrapOutput = (_866_valueOrError0).Extract();
      Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>> _867_symmetricSigningKeyList;
      _867_symmetricSigningKeyList = ((((_865_wrapOutput).dtor_symmetricSigningKey).is_Some) ? (Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.create_Some(Dafny.Sequence<Dafny.ISequence<byte>>.FromElements(((_865_wrapOutput).dtor_symmetricSigningKey).dtor_value))) : (Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.create_None()));
      software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey _868_edk;
      _868_edk = software.amazon.cryptography.materialproviders.internaldafny.types.EncryptedDataKey.create((this).keyNamespace, (this).SerializeProviderInfo(((_865_wrapOutput).dtor_wrapInfo).dtor_iv), (_865_wrapOutput).dtor_wrappedMaterial);
      if ((_865_wrapOutput).is_GenerateAndWrapEdkMaterialOutput) {
        software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _869_result;
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _870_valueOrError1 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        _870_valueOrError1 = Materials_Compile.__default.EncryptionMaterialAddDataKey(_861_materials, (_865_wrapOutput).dtor_plaintextDataKey, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.FromElements(_868_edk), _867_symmetricSigningKeyList);
        if ((_870_valueOrError1).IsFailure()) {
          output = (_870_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
          return output;
        }
        _869_result = (_870_valueOrError1).Extract();
        output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.OnEncryptOutput.create(_869_result));
        return output;
      } else if ((_865_wrapOutput).is_WrapOnlyEdkMaterialOutput) {
        software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _871_result;
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _872_valueOrError2 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        _872_valueOrError2 = Materials_Compile.__default.EncryptionMaterialAddEncryptedDataKeys(_861_materials, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.FromElements(_868_edk), _867_symmetricSigningKeyList);
        if ((_872_valueOrError2).IsFailure()) {
          output = (_872_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
          return output;
        }
        _871_result = (_872_valueOrError2).Extract();
        output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.OnEncryptOutput.create(_871_result));
        return output;
      }
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnDecrypt_k(software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _873_materials;
      _873_materials = (input).dtor_materials;
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _874_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _874_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.DecryptionMaterialsWithoutPlaintextDataKey(_873_materials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Keyring received decryption materials that already contain a plaintext data key.")));
      if ((_874_valueOrError0).IsFailure()) {
        output = (_874_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return output;
      }
      Dafny.ISequence<byte> _875_aad;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _876_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _876_valueOrError1 = CanonicalEncryptionContext_Compile.__default.EncryptionContextToAAD(((input).dtor_materials).dtor_encryptionContext);
      if ((_876_valueOrError1).IsFailure()) {
        output = (_876_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return output;
      }
      _875_aad = (_876_valueOrError1).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _877_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _877_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger(((this).wrappingKey).Count)) == (new BigInteger(((this).wrappingAlgorithm).dtor_keyLength)), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("The wrapping key does not match the wrapping algorithm")));
      if ((_877_valueOrError2).IsFailure()) {
        output = (_877_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return output;
      }
      Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _878_errors;
      _878_errors = Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.FromElements();
      BigInteger _hi8 = new BigInteger(((input).dtor_encryptedDataKeys).Count);
      for (BigInteger _879_i = BigInteger.Zero; _879_i < _hi8; _879_i++) {
        if ((this).ShouldDecryptEDK(((input).dtor_encryptedDataKeys).Select(_879_i))) {
          software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey _880_edk;
          _880_edk = ((input).dtor_encryptedDataKeys).Select(_879_i);
          Dafny.ISequence<byte> _881_iv;
          _881_iv = (this).GetIvFromProvInfo((_880_edk).dtor_keyProviderInfo);
          RawAESKeyring_Compile.AesUnwrapKeyMaterial _882_unwrap;
          RawAESKeyring_Compile.AesUnwrapKeyMaterial _nw46 = new RawAESKeyring_Compile.AesUnwrapKeyMaterial();
          _nw46.__ctor((this).wrappingKey, (this).wrappingAlgorithm, _881_iv, (this).cryptoPrimitives);
          _882_unwrap = _nw46;
          Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<RawAESKeyring_Compile._IAesUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _883_unwrapOutput;
          Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<RawAESKeyring_Compile._IAesUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out152;
          _out152 = EdkWrapping_Compile.__default.UnwrapEdkMaterial<RawAESKeyring_Compile._IAesUnwrapInfo>((_880_edk).dtor_ciphertext, _873_materials, _882_unwrap);
          _883_unwrapOutput = _out152;
          if ((_883_unwrapOutput).is_Success) {
            software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _884_result;
            Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _885_valueOrError3 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
            _885_valueOrError3 = Materials_Compile.__default.DecryptionMaterialsAddDataKey(_873_materials, ((_883_unwrapOutput).dtor_value).dtor_plaintextDataKey, ((_883_unwrapOutput).dtor_value).dtor_symmetricSigningKey);
            if ((_885_valueOrError3).IsFailure()) {
              output = (_885_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
              return output;
            }
            _884_result = (_885_valueOrError3).Extract();
            software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput _886_value;
            _886_value = software.amazon.cryptography.materialproviders.internaldafny.types.OnDecryptOutput.create(_884_result);
            output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_886_value);
            return output;
          } else {
            _878_errors = Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Concat(_878_errors, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.FromElements((_883_unwrapOutput).dtor_error));
          }
        } else {
          _878_errors = Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Concat(_878_errors, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.FromElements(software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("EncrypedDataKey "), String_Compile.__default.Base10Int2String(_879_i)), Dafny.Sequence<char>.FromString(" did not match AESKeyring. ")))));
        }
      }
      output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_CollectionOfErrors(_878_errors, Dafny.Sequence<char>.FromString("Raw AES Keyring was unable to decrypt any encrypted data key. The list of encountered Exceptions is avaible via `list`.")));
      return output;
      return output;
    }
    public Dafny.ISequence<byte> SerializeProviderInfo(Dafny.ISequence<byte> iv) {
      return Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat((this).keyName, StandardLibrary_mUInt_Compile.__default.UInt32ToSeq((uint)((((this).wrappingAlgorithm).dtor_tagLength) * (8)))), StandardLibrary_mUInt_Compile.__default.UInt32ToSeq((uint)(((this).wrappingAlgorithm).dtor_ivLength))), iv);
    }
    public bool ShouldDecryptEDK(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey edk) {
      return (((edk).dtor_keyProviderId).Equals((this).keyNamespace)) && ((this).ValidProviderInfo((edk).dtor_keyProviderInfo));
    }
    public bool ValidProviderInfo(Dafny.ISequence<byte> info) {
      return ((((((new BigInteger((info).Count)) == ((((new BigInteger(((this).keyName).Count)) + (RawAESKeyring_Compile.__default.AUTH__TAG__LEN__LEN)) + (RawAESKeyring_Compile.__default.IV__LEN__LEN)) + (new BigInteger(((this).wrappingAlgorithm).dtor_ivLength)))) && (((info).Subsequence(BigInteger.Zero, new BigInteger(((this).keyName).Count))).Equals((this).keyName))) && ((StandardLibrary_mUInt_Compile.__default.SeqToUInt32((info).Subsequence(new BigInteger(((this).keyName).Count), (new BigInteger(((this).keyName).Count)) + (RawAESKeyring_Compile.__default.AUTH__TAG__LEN__LEN)))) == (128U))) && ((StandardLibrary_mUInt_Compile.__default.SeqToUInt32((info).Subsequence(new BigInteger(((this).keyName).Count), (new BigInteger(((this).keyName).Count)) + (RawAESKeyring_Compile.__default.AUTH__TAG__LEN__LEN)))) == (((uint)(((this).wrappingAlgorithm).dtor_tagLength)) * (8U)))) && ((StandardLibrary_mUInt_Compile.__default.SeqToUInt32((info).Subsequence((new BigInteger(((this).keyName).Count)) + (RawAESKeyring_Compile.__default.AUTH__TAG__LEN__LEN), ((new BigInteger(((this).keyName).Count)) + (RawAESKeyring_Compile.__default.AUTH__TAG__LEN__LEN)) + (RawAESKeyring_Compile.__default.IV__LEN__LEN)))) == ((uint)(((this).wrappingAlgorithm).dtor_ivLength)))) && ((StandardLibrary_mUInt_Compile.__default.SeqToUInt32((info).Subsequence((new BigInteger(((this).keyName).Count)) + (RawAESKeyring_Compile.__default.AUTH__TAG__LEN__LEN), ((new BigInteger(((this).keyName).Count)) + (RawAESKeyring_Compile.__default.AUTH__TAG__LEN__LEN)) + (RawAESKeyring_Compile.__default.IV__LEN__LEN)))) == (12U));
    }
    public Dafny.ISequence<byte> GetIvFromProvInfo(Dafny.ISequence<byte> info) {
      return (info).Drop(((new BigInteger(((this).keyName).Count)) + (RawAESKeyring_Compile.__default.AUTH__TAG__LEN__LEN)) + (RawAESKeyring_Compile.__default.IV__LEN__LEN));
    }
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _cryptoPrimitives {get; set;}
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives { get {
      return this._cryptoPrimitives;
    } }
    public Dafny.ISequence<byte> _wrappingKey {get; set;}
    public Dafny.ISequence<byte> wrappingKey { get {
      return this._wrappingKey;
    } }
    public software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM _wrappingAlgorithm {get; set;}
    public software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM wrappingAlgorithm { get {
      return this._wrappingAlgorithm;
    } }
    public Dafny.ISequence<byte> _keyNamespace {get; set;}
    public Dafny.ISequence<byte> keyNamespace { get {
      return this._keyNamespace;
    } }
    public Dafny.ISequence<byte> _keyName {get; set;}
    public Dafny.ISequence<byte> keyName { get {
      return this._keyName;
    } }
  }

  public interface _IAesUnwrapInfo {
    bool is_AesUnwrapInfo { get; }
    _IAesUnwrapInfo DowncastClone();
  }
  public class AesUnwrapInfo : _IAesUnwrapInfo {
    public AesUnwrapInfo() {
    }
    public _IAesUnwrapInfo DowncastClone() {
      if (this is _IAesUnwrapInfo dt) { return dt; }
      return new AesUnwrapInfo();
    }
    public override bool Equals(object other) {
      var oth = other as RawAESKeyring_Compile.AesUnwrapInfo;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "RawAESKeyring_Compile.AesUnwrapInfo.AesUnwrapInfo";
      return s;
    }
    private static readonly RawAESKeyring_Compile._IAesUnwrapInfo theDefault = create();
    public static RawAESKeyring_Compile._IAesUnwrapInfo Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<RawAESKeyring_Compile._IAesUnwrapInfo> _TYPE = new Dafny.TypeDescriptor<RawAESKeyring_Compile._IAesUnwrapInfo>(RawAESKeyring_Compile.AesUnwrapInfo.Default());
    public static Dafny.TypeDescriptor<RawAESKeyring_Compile._IAesUnwrapInfo> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IAesUnwrapInfo create() {
      return new AesUnwrapInfo();
    }
    public static _IAesUnwrapInfo create_AesUnwrapInfo() {
      return create();
    }
    public bool is_AesUnwrapInfo { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_IAesUnwrapInfo> AllSingletonConstructors {
      get {
        yield return AesUnwrapInfo.create();
      }
    }
  }

  public interface _IAesWrapInfo {
    bool is_AesWrapInfo { get; }
    Dafny.ISequence<byte> dtor_iv { get; }
    _IAesWrapInfo DowncastClone();
  }
  public class AesWrapInfo : _IAesWrapInfo {
    public readonly Dafny.ISequence<byte> _iv;
    public AesWrapInfo(Dafny.ISequence<byte> iv) {
      this._iv = iv;
    }
    public _IAesWrapInfo DowncastClone() {
      if (this is _IAesWrapInfo dt) { return dt; }
      return new AesWrapInfo(_iv);
    }
    public override bool Equals(object other) {
      var oth = other as RawAESKeyring_Compile.AesWrapInfo;
      return oth != null && object.Equals(this._iv, oth._iv);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._iv));
      return (int) hash;
    }
    public override string ToString() {
      string s = "RawAESKeyring_Compile.AesWrapInfo.AesWrapInfo";
      s += "(";
      s += Dafny.Helpers.ToString(this._iv);
      s += ")";
      return s;
    }
    private static readonly RawAESKeyring_Compile._IAesWrapInfo theDefault = create(Dafny.Sequence<byte>.Empty);
    public static RawAESKeyring_Compile._IAesWrapInfo Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<RawAESKeyring_Compile._IAesWrapInfo> _TYPE = new Dafny.TypeDescriptor<RawAESKeyring_Compile._IAesWrapInfo>(RawAESKeyring_Compile.AesWrapInfo.Default());
    public static Dafny.TypeDescriptor<RawAESKeyring_Compile._IAesWrapInfo> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IAesWrapInfo create(Dafny.ISequence<byte> iv) {
      return new AesWrapInfo(iv);
    }
    public static _IAesWrapInfo create_AesWrapInfo(Dafny.ISequence<byte> iv) {
      return create(iv);
    }
    public bool is_AesWrapInfo { get { return true; } }
    public Dafny.ISequence<byte> dtor_iv {
      get {
        return this._iv;
      }
    }
  }

  public partial class AesGenerateAndWrapKeyMaterial : MaterialWrapping_Compile.GenerateAndWrapMaterial<RawAESKeyring_Compile._IAesWrapInfo>, Actions_Compile.ActionWithResult<MaterialWrapping_Compile._IGenerateAndWrapInput, MaterialWrapping_Compile._IGenerateAndWrapOutput<RawAESKeyring_Compile._IAesWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<MaterialWrapping_Compile._IGenerateAndWrapInput, Wrappers_Compile._IResult<MaterialWrapping_Compile._IGenerateAndWrapOutput<RawAESKeyring_Compile._IAesWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public AesGenerateAndWrapKeyMaterial() {
      this._wrap = default(RawAESKeyring_Compile.AesWrapKeyMaterial);
    }
    public void __ctor(RawAESKeyring_Compile.AesWrapKeyMaterial wrap)
    {
      (this)._wrap = wrap;
    }
    public Wrappers_Compile._IResult<MaterialWrapping_Compile._IGenerateAndWrapOutput<RawAESKeyring_Compile._IAesWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(MaterialWrapping_Compile._IGenerateAndWrapInput input)
    {
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IGenerateAndWrapOutput<RawAESKeyring_Compile._IAesWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = Wrappers_Compile.Result<MaterialWrapping_Compile._IGenerateAndWrapOutput<RawAESKeyring_Compile._IAesWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(MaterialWrapping_Compile.GenerateAndWrapOutput<RawAESKeyring_Compile._IAesWrapInfo>.Default(RawAESKeyring_Compile.AesWrapInfo.Default()));
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _887_generateBytesResult;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out153;
      _out153 = (((this).wrap).cryptoPrimitives).GenerateRandomBytes(software.amazon.cryptography.primitives.internaldafny.types.GenerateRandomBytesInput.create(AlgorithmSuites_Compile.__default.GetEncryptKeyLength((input).dtor_algorithmSuite)));
      _887_generateBytesResult = _out153;
      Dafny.ISequence<byte> _888_plaintextMaterial;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _889_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _889_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_887_generateBytesResult, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_890_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_890_e);
      })));
      if ((_889_valueOrError0).IsFailure()) {
        res = (_889_valueOrError0).PropagateFailure<MaterialWrapping_Compile._IGenerateAndWrapOutput<RawAESKeyring_Compile._IAesWrapInfo>>();
        return res;
      }
      _888_plaintextMaterial = (_889_valueOrError0).Extract();
      MaterialWrapping_Compile._IWrapOutput<RawAESKeyring_Compile._IAesWrapInfo> _891_wrapOutput;
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<RawAESKeyring_Compile._IAesWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _892_valueOrError1 = Wrappers_Compile.Result<MaterialWrapping_Compile._IWrapOutput<RawAESKeyring_Compile._IAesWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(MaterialWrapping_Compile.WrapOutput<RawAESKeyring_Compile._IAesWrapInfo>.Default(RawAESKeyring_Compile.AesWrapInfo.Default()));
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<RawAESKeyring_Compile._IAesWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out154;
      _out154 = ((this).wrap).Invoke(MaterialWrapping_Compile.WrapInput.create(_888_plaintextMaterial, (input).dtor_algorithmSuite, (input).dtor_encryptionContext));
      _892_valueOrError1 = _out154;
      if ((_892_valueOrError1).IsFailure()) {
        res = (_892_valueOrError1).PropagateFailure<MaterialWrapping_Compile._IGenerateAndWrapOutput<RawAESKeyring_Compile._IAesWrapInfo>>();
        return res;
      }
      _891_wrapOutput = (_892_valueOrError1).Extract();
      res = Wrappers_Compile.Result<MaterialWrapping_Compile._IGenerateAndWrapOutput<RawAESKeyring_Compile._IAesWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(MaterialWrapping_Compile.GenerateAndWrapOutput<RawAESKeyring_Compile._IAesWrapInfo>.create(_888_plaintextMaterial, (_891_wrapOutput).dtor_wrappedMaterial, (_891_wrapOutput).dtor_wrapInfo));
      return res;
    }
    public RawAESKeyring_Compile.AesWrapKeyMaterial _wrap {get; set;}
    public RawAESKeyring_Compile.AesWrapKeyMaterial wrap { get {
      return this._wrap;
    } }
  }

  public partial class AesWrapKeyMaterial : MaterialWrapping_Compile.WrapMaterial<RawAESKeyring_Compile._IAesWrapInfo>, Actions_Compile.ActionWithResult<MaterialWrapping_Compile._IWrapInput, MaterialWrapping_Compile._IWrapOutput<RawAESKeyring_Compile._IAesWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<MaterialWrapping_Compile._IWrapInput, Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<RawAESKeyring_Compile._IAesWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public AesWrapKeyMaterial() {
      this._wrappingKey = Dafny.Sequence<byte>.Empty;
      this._wrappingAlgorithm = default(software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM);
      this._cryptoPrimitives = default(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient);
    }
    public void __ctor(Dafny.ISequence<byte> wrappingKey, software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM wrappingAlgorithm, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives)
    {
      (this)._wrappingKey = wrappingKey;
      (this)._wrappingAlgorithm = wrappingAlgorithm;
      (this)._cryptoPrimitives = cryptoPrimitives;
    }
    public Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<RawAESKeyring_Compile._IAesWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(MaterialWrapping_Compile._IWrapInput input)
    {
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<RawAESKeyring_Compile._IAesWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = Wrappers_Compile.Result<MaterialWrapping_Compile._IWrapOutput<RawAESKeyring_Compile._IAesWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(MaterialWrapping_Compile.WrapOutput<RawAESKeyring_Compile._IAesWrapInfo>.Default(RawAESKeyring_Compile.AesWrapInfo.Default()));
      Dafny.ISequence<byte> _893_aad;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _894_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _894_valueOrError0 = CanonicalEncryptionContext_Compile.__default.EncryptionContextToAAD((input).dtor_encryptionContext);
      if ((_894_valueOrError0).IsFailure()) {
        res = (_894_valueOrError0).PropagateFailure<MaterialWrapping_Compile._IWrapOutput<RawAESKeyring_Compile._IAesWrapInfo>>();
        return res;
      }
      _893_aad = (_894_valueOrError0).Extract();
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _895_randomIvResult;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out155;
      _out155 = ((this).cryptoPrimitives).GenerateRandomBytes(software.amazon.cryptography.primitives.internaldafny.types.GenerateRandomBytesInput.create(((this).wrappingAlgorithm).dtor_ivLength));
      _895_randomIvResult = _out155;
      Dafny.ISequence<byte> _896_iv;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _897_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _897_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_895_randomIvResult, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_898_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_898_e);
      })));
      if ((_897_valueOrError1).IsFailure()) {
        res = (_897_valueOrError1).PropagateFailure<MaterialWrapping_Compile._IWrapOutput<RawAESKeyring_Compile._IAesWrapInfo>>();
        return res;
      }
      _896_iv = (_897_valueOrError1).Extract();
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput, software.amazon.cryptography.primitives.internaldafny.types._IError> _899_aesEncryptResult;
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput, software.amazon.cryptography.primitives.internaldafny.types._IError> _out156;
      _out156 = ((this).cryptoPrimitives).AESEncrypt(software.amazon.cryptography.primitives.internaldafny.types.AESEncryptInput.create((this).wrappingAlgorithm, _896_iv, (this).wrappingKey, (input).dtor_plaintextMaterial, _893_aad));
      _899_aesEncryptResult = _out156;
      software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput _900_wrappedMaterialResult;
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _901_valueOrError2 = Wrappers_Compile.Result<software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(software.amazon.cryptography.primitives.internaldafny.types.AESEncryptOutput.Default());
      _901_valueOrError2 = Wrappers_Compile.Result<software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_899_aesEncryptResult, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_902_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_902_e);
      })));
      if ((_901_valueOrError2).IsFailure()) {
        res = (_901_valueOrError2).PropagateFailure<MaterialWrapping_Compile._IWrapOutput<RawAESKeyring_Compile._IAesWrapInfo>>();
        return res;
      }
      _900_wrappedMaterialResult = (_901_valueOrError2).Extract();
      Dafny.ISequence<byte> _903_wrappedMaterial;
      _903_wrappedMaterial = RawAESKeyring_Compile.__default.SerializeEDKCiphertext(_900_wrappedMaterialResult);
      res = Wrappers_Compile.Result<MaterialWrapping_Compile._IWrapOutput<RawAESKeyring_Compile._IAesWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(MaterialWrapping_Compile.WrapOutput<RawAESKeyring_Compile._IAesWrapInfo>.create(_903_wrappedMaterial, RawAESKeyring_Compile.AesWrapInfo.create(_896_iv)));
      return res;
      return res;
    }
    public Dafny.ISequence<byte> _wrappingKey {get; set;}
    public Dafny.ISequence<byte> wrappingKey { get {
      return this._wrappingKey;
    } }
    public software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM _wrappingAlgorithm {get; set;}
    public software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM wrappingAlgorithm { get {
      return this._wrappingAlgorithm;
    } }
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _cryptoPrimitives {get; set;}
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives { get {
      return this._cryptoPrimitives;
    } }
  }

  public partial class AesUnwrapKeyMaterial : MaterialWrapping_Compile.UnwrapMaterial<RawAESKeyring_Compile._IAesUnwrapInfo>, Actions_Compile.ActionWithResult<MaterialWrapping_Compile._IUnwrapInput, MaterialWrapping_Compile._IUnwrapOutput<RawAESKeyring_Compile._IAesUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<MaterialWrapping_Compile._IUnwrapInput, Wrappers_Compile._IResult<MaterialWrapping_Compile._IUnwrapOutput<RawAESKeyring_Compile._IAesUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public AesUnwrapKeyMaterial() {
      this._wrappingKey = Dafny.Sequence<byte>.Empty;
      this._iv = Dafny.Sequence<byte>.Empty;
      this._wrappingAlgorithm = default(software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM);
      this._cryptoPrimitives = default(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient);
    }
    public void __ctor(Dafny.ISequence<byte> wrappingKey, software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM wrappingAlgorithm, Dafny.ISequence<byte> iv, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives)
    {
      (this)._wrappingKey = wrappingKey;
      (this)._iv = iv;
      (this)._wrappingAlgorithm = wrappingAlgorithm;
      (this)._cryptoPrimitives = cryptoPrimitives;
    }
    public Wrappers_Compile._IResult<MaterialWrapping_Compile._IUnwrapOutput<RawAESKeyring_Compile._IAesUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(MaterialWrapping_Compile._IUnwrapInput input)
    {
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IUnwrapOutput<RawAESKeyring_Compile._IAesUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = Wrappers_Compile.Result<MaterialWrapping_Compile._IUnwrapOutput<RawAESKeyring_Compile._IAesUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(MaterialWrapping_Compile.UnwrapOutput<RawAESKeyring_Compile._IAesUnwrapInfo>.Default(RawAESKeyring_Compile.AesUnwrapInfo.Default()));
      Dafny.ISequence<byte> _904_aad;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _905_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _905_valueOrError0 = CanonicalEncryptionContext_Compile.__default.EncryptionContextToAAD((input).dtor_encryptionContext);
      if ((_905_valueOrError0).IsFailure()) {
        res = (_905_valueOrError0).PropagateFailure<MaterialWrapping_Compile._IUnwrapOutput<RawAESKeyring_Compile._IAesUnwrapInfo>>();
        return res;
      }
      _904_aad = (_905_valueOrError0).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _906_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _906_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger(((this).wrappingAlgorithm).dtor_tagLength)) <= (new BigInteger(((input).dtor_wrappedMaterial).Count)), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Insufficient data to decrypt.")));
      if ((_906_valueOrError1).IsFailure()) {
        res = (_906_valueOrError1).PropagateFailure<MaterialWrapping_Compile._IUnwrapOutput<RawAESKeyring_Compile._IAesUnwrapInfo>>();
        return res;
      }
      software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput _907_encryptionOutput;
      _907_encryptionOutput = RawAESKeyring_Compile.__default.DeserializeEDKCiphertext((input).dtor_wrappedMaterial, new BigInteger(((this).wrappingAlgorithm).dtor_tagLength));
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _908_maybePtKey;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out157;
      _out157 = ((this).cryptoPrimitives).AESDecrypt(software.amazon.cryptography.primitives.internaldafny.types.AESDecryptInput.create((this).wrappingAlgorithm, (this).wrappingKey, (_907_encryptionOutput).dtor_cipherText, (_907_encryptionOutput).dtor_authTag, (this).iv, _904_aad));
      _908_maybePtKey = _out157;
      Dafny.ISequence<byte> _909_ptKey;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _910_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _910_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_908_maybePtKey, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_911_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_911_e);
      })));
      if ((_910_valueOrError2).IsFailure()) {
        res = (_910_valueOrError2).PropagateFailure<MaterialWrapping_Compile._IUnwrapOutput<RawAESKeyring_Compile._IAesUnwrapInfo>>();
        return res;
      }
      _909_ptKey = (_910_valueOrError2).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _912_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _912_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger(AlgorithmSuites_Compile.__default.GetEncryptKeyLength((input).dtor_algorithmSuite))) == (new BigInteger((_909_ptKey).Count)), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Plaintext Data Key is not the expected length")));
      if ((_912_valueOrError3).IsFailure()) {
        res = (_912_valueOrError3).PropagateFailure<MaterialWrapping_Compile._IUnwrapOutput<RawAESKeyring_Compile._IAesUnwrapInfo>>();
        return res;
      }
      res = Wrappers_Compile.Result<MaterialWrapping_Compile._IUnwrapOutput<RawAESKeyring_Compile._IAesUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(MaterialWrapping_Compile.UnwrapOutput<RawAESKeyring_Compile._IAesUnwrapInfo>.create(_909_ptKey, RawAESKeyring_Compile.AesUnwrapInfo.create()));
      return res;
      return res;
    }
    public Dafny.ISequence<byte> _wrappingKey {get; set;}
    public Dafny.ISequence<byte> wrappingKey { get {
      return this._wrappingKey;
    } }
    public Dafny.ISequence<byte> _iv {get; set;}
    public Dafny.ISequence<byte> iv { get {
      return this._iv;
    } }
    public software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM _wrappingAlgorithm {get; set;}
    public software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM wrappingAlgorithm { get {
      return this._wrappingAlgorithm;
    } }
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _cryptoPrimitives {get; set;}
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives { get {
      return this._cryptoPrimitives;
    } }
  }

  public partial class __default {
    public static software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput DeserializeEDKCiphertext(Dafny.ISequence<byte> ciphertext, BigInteger tagLen)
    {
      BigInteger _913_encryptedKeyLength = (new BigInteger((ciphertext).Count)) - (tagLen);
      return software.amazon.cryptography.primitives.internaldafny.types.AESEncryptOutput.create((ciphertext).Take(_913_encryptedKeyLength), (ciphertext).Drop(_913_encryptedKeyLength));
    }
    public static Dafny.ISequence<byte> SerializeEDKCiphertext(software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput encOutput) {
      return Dafny.Sequence<byte>.Concat((encOutput).dtor_cipherText, (encOutput).dtor_authTag);
    }
    public static BigInteger AUTH__TAG__LEN__LEN { get {
      return new BigInteger(4);
    } }
    public static BigInteger IV__LEN__LEN { get {
      return new BigInteger(4);
    } }
  }
} // end of namespace RawAESKeyring_Compile
namespace RawRSAKeyring_Compile {

  public partial class RawRSAKeyring : Keyring_Compile.VerifiableInterface, software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring {
    public RawRSAKeyring() {
      this._cryptoPrimitives = default(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient);
      this._keyNamespace = UTF8.ValidUTF8Bytes.Default();
      this._keyName = UTF8.ValidUTF8Bytes.Default();
      this._paddingScheme = software.amazon.cryptography.primitives.internaldafny.types.RSAPaddingMode.Default();
      this._publicKey = Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default();
      this._privateKey = Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default();
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnEncrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out158;
      _out158 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_IKeyring.OnEncrypt(this, input);
      return _out158;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnDecrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out159;
      _out159 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_IKeyring.OnDecrypt(this, input);
      return _out159;
    }
    public void __ctor(Dafny.ISequence<byte> @namespace, Dafny.ISequence<byte> name, Wrappers_Compile._IOption<Dafny.ISequence<byte>> publicKey, Wrappers_Compile._IOption<Dafny.ISequence<byte>> privateKey, software.amazon.cryptography.primitives.internaldafny.types._IRSAPaddingMode paddingScheme, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives)
    {
      (this)._keyNamespace = @namespace;
      (this)._keyName = name;
      (this)._paddingScheme = paddingScheme;
      (this)._publicKey = publicKey;
      (this)._privateKey = privateKey;
      (this)._cryptoPrimitives = cryptoPrimitives;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnEncrypt_k(software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _914_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _914_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((this).publicKey).is_Some) && ((new BigInteger((((this).publicKey).Extract()).Count)).Sign == 1), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("A RawRSAKeyring without a public key cannot provide OnEncrypt")));
      if ((_914_valueOrError0).IsFailure()) {
        output = (_914_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
        return output;
      }
      software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _915_materials;
      _915_materials = (input).dtor_materials;
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _916_suite;
      _916_suite = (_915_materials).dtor_algorithmSuite;
      RawRSAKeyring_Compile.RsaWrapKeyMaterial _917_wrap;
      RawRSAKeyring_Compile.RsaWrapKeyMaterial _nw47 = new RawRSAKeyring_Compile.RsaWrapKeyMaterial();
      _nw47.__ctor(((this).publicKey).dtor_value, (this).paddingScheme, (this).cryptoPrimitives);
      _917_wrap = _nw47;
      RawRSAKeyring_Compile.RsaGenerateAndWrapKeyMaterial _918_generateAndWrap;
      RawRSAKeyring_Compile.RsaGenerateAndWrapKeyMaterial _nw48 = new RawRSAKeyring_Compile.RsaGenerateAndWrapKeyMaterial();
      _nw48.__ctor(((this).publicKey).dtor_value, (this).paddingScheme, (this).cryptoPrimitives);
      _918_generateAndWrap = _nw48;
      EdkWrapping_Compile._IWrapEdkMaterialOutput<RawRSAKeyring_Compile._IRsaWrapInfo> _919_wrapOutput;
      Wrappers_Compile._IResult<EdkWrapping_Compile._IWrapEdkMaterialOutput<RawRSAKeyring_Compile._IRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _920_valueOrError1 = Wrappers_Compile.Result<EdkWrapping_Compile._IWrapEdkMaterialOutput<RawRSAKeyring_Compile._IRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(EdkWrapping_Compile.WrapEdkMaterialOutput<RawRSAKeyring_Compile._IRsaWrapInfo>.Default(RawRSAKeyring_Compile.RsaWrapInfo.Default()));
      Wrappers_Compile._IResult<EdkWrapping_Compile._IWrapEdkMaterialOutput<RawRSAKeyring_Compile._IRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out160;
      _out160 = EdkWrapping_Compile.__default.WrapEdkMaterial<RawRSAKeyring_Compile._IRsaWrapInfo>(_915_materials, _917_wrap, _918_generateAndWrap);
      _920_valueOrError1 = _out160;
      if ((_920_valueOrError1).IsFailure()) {
        output = (_920_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
        return output;
      }
      _919_wrapOutput = (_920_valueOrError1).Extract();
      Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>> _921_symmetricSigningKeyList;
      _921_symmetricSigningKeyList = ((((_919_wrapOutput).dtor_symmetricSigningKey).is_Some) ? (Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.create_Some(Dafny.Sequence<Dafny.ISequence<byte>>.FromElements(((_919_wrapOutput).dtor_symmetricSigningKey).dtor_value))) : (Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.create_None()));
      software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey _922_edk;
      _922_edk = software.amazon.cryptography.materialproviders.internaldafny.types.EncryptedDataKey.create((this).keyNamespace, (this).keyName, (_919_wrapOutput).dtor_wrappedMaterial);
      if ((_919_wrapOutput).is_GenerateAndWrapEdkMaterialOutput) {
        software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _923_result;
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _924_valueOrError2 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        _924_valueOrError2 = Materials_Compile.__default.EncryptionMaterialAddDataKey(_915_materials, (_919_wrapOutput).dtor_plaintextDataKey, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.FromElements(_922_edk), _921_symmetricSigningKeyList);
        if ((_924_valueOrError2).IsFailure()) {
          output = (_924_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
          return output;
        }
        _923_result = (_924_valueOrError2).Extract();
        output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.OnEncryptOutput.create(_923_result));
        return output;
      } else if ((_919_wrapOutput).is_WrapOnlyEdkMaterialOutput) {
        software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _925_result;
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _926_valueOrError3 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        _926_valueOrError3 = Materials_Compile.__default.EncryptionMaterialAddEncryptedDataKeys(_915_materials, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.FromElements(_922_edk), _921_symmetricSigningKeyList);
        if ((_926_valueOrError3).IsFailure()) {
          output = (_926_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput>();
          return output;
        }
        _925_result = (_926_valueOrError3).Extract();
        output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.OnEncryptOutput.create(_925_result));
        return output;
      }
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> OnDecrypt_k(software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _927_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _927_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((this).privateKey).is_Some) && ((new BigInteger((((this).privateKey).Extract()).Count)).Sign == 1), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("A RawRSAKeyring without a private key cannot provide OnEncrypt")));
      if ((_927_valueOrError0).IsFailure()) {
        output = (_927_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return output;
      }
      software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _928_materials;
      _928_materials = (input).dtor_materials;
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _929_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _929_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.DecryptionMaterialsWithoutPlaintextDataKey(_928_materials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Keyring received decryption materials that already contain a plaintext data key.")));
      if ((_929_valueOrError1).IsFailure()) {
        output = (_929_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
        return output;
      }
      Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _930_errors;
      _930_errors = Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.FromElements();
      BigInteger _hi9 = new BigInteger(((input).dtor_encryptedDataKeys).Count);
      for (BigInteger _931_i = BigInteger.Zero; _931_i < _hi9; _931_i++) {
        if ((this).ShouldDecryptEDK(((input).dtor_encryptedDataKeys).Select(_931_i))) {
          software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey _932_edk;
          _932_edk = ((input).dtor_encryptedDataKeys).Select(_931_i);
          RawRSAKeyring_Compile.RsaUnwrapKeyMaterial _933_unwrap;
          RawRSAKeyring_Compile.RsaUnwrapKeyMaterial _nw49 = new RawRSAKeyring_Compile.RsaUnwrapKeyMaterial();
          _nw49.__ctor(((this).privateKey).Extract(), (this).paddingScheme, (this).cryptoPrimitives);
          _933_unwrap = _nw49;
          Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<RawRSAKeyring_Compile._IRsaUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _934_unwrapOutput;
          Wrappers_Compile._IResult<EdkWrapping_Compile._IUnwrapEdkMaterialOutput<RawRSAKeyring_Compile._IRsaUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out161;
          _out161 = EdkWrapping_Compile.__default.UnwrapEdkMaterial<RawRSAKeyring_Compile._IRsaUnwrapInfo>((_932_edk).dtor_ciphertext, _928_materials, _933_unwrap);
          _934_unwrapOutput = _out161;
          if ((_934_unwrapOutput).is_Success) {
            software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _935_returnMaterials;
            Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _936_valueOrError2 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
            _936_valueOrError2 = Materials_Compile.__default.DecryptionMaterialsAddDataKey(_928_materials, ((_934_unwrapOutput).dtor_value).dtor_plaintextDataKey, ((_934_unwrapOutput).dtor_value).dtor_symmetricSigningKey);
            if ((_936_valueOrError2).IsFailure()) {
              output = (_936_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput>();
              return output;
            }
            _935_returnMaterials = (_936_valueOrError2).Extract();
            output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.OnDecryptOutput.create(_935_returnMaterials));
            return output;
          } else {
            _930_errors = Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Concat(_930_errors, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.FromElements((_934_unwrapOutput).dtor_error));
          }
        } else {
          _930_errors = Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Concat(_930_errors, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.FromElements(software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("EncryptedDataKey "), String_Compile.__default.Base10Int2String(_931_i)), Dafny.Sequence<char>.FromString(" did not match RSAKeyring. ")))));
        }
      }
      output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_CollectionOfErrors(_930_errors, Dafny.Sequence<char>.FromString("Raw RSA Key was unable to decrypt any encrypted data key. The list of encountered Exceptions is avaible via `list`.")));
      return output;
      return output;
    }
    public bool ShouldDecryptEDK(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey edk) {
      return (((UTF8.__default.ValidUTF8Seq((edk).dtor_keyProviderInfo)) && (((edk).dtor_keyProviderInfo).Equals((this).keyName))) && (((edk).dtor_keyProviderId).Equals((this).keyNamespace))) && ((new BigInteger(((edk).dtor_ciphertext).Count)).Sign == 1);
    }
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _cryptoPrimitives {get; set;}
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives { get {
      return this._cryptoPrimitives;
    } }
    public Dafny.ISequence<byte> _keyNamespace {get; set;}
    public Dafny.ISequence<byte> keyNamespace { get {
      return this._keyNamespace;
    } }
    public Dafny.ISequence<byte> _keyName {get; set;}
    public Dafny.ISequence<byte> keyName { get {
      return this._keyName;
    } }
    public software.amazon.cryptography.primitives.internaldafny.types._IRSAPaddingMode _paddingScheme {get; set;}
    public software.amazon.cryptography.primitives.internaldafny.types._IRSAPaddingMode paddingScheme { get {
      return this._paddingScheme;
    } }
    public Wrappers_Compile._IOption<Dafny.ISequence<byte>> _publicKey {get; set;}
    public Wrappers_Compile._IOption<Dafny.ISequence<byte>> publicKey { get {
      return this._publicKey;
    } }
    public Wrappers_Compile._IOption<Dafny.ISequence<byte>> _privateKey {get; set;}
    public Wrappers_Compile._IOption<Dafny.ISequence<byte>> privateKey { get {
      return this._privateKey;
    } }
  }

  public interface _IRsaUnwrapInfo {
    bool is_RsaUnwrapInfo { get; }
    _IRsaUnwrapInfo DowncastClone();
  }
  public class RsaUnwrapInfo : _IRsaUnwrapInfo {
    public RsaUnwrapInfo() {
    }
    public _IRsaUnwrapInfo DowncastClone() {
      if (this is _IRsaUnwrapInfo dt) { return dt; }
      return new RsaUnwrapInfo();
    }
    public override bool Equals(object other) {
      var oth = other as RawRSAKeyring_Compile.RsaUnwrapInfo;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "RawRSAKeyring_Compile.RsaUnwrapInfo.RsaUnwrapInfo";
      return s;
    }
    private static readonly RawRSAKeyring_Compile._IRsaUnwrapInfo theDefault = create();
    public static RawRSAKeyring_Compile._IRsaUnwrapInfo Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<RawRSAKeyring_Compile._IRsaUnwrapInfo> _TYPE = new Dafny.TypeDescriptor<RawRSAKeyring_Compile._IRsaUnwrapInfo>(RawRSAKeyring_Compile.RsaUnwrapInfo.Default());
    public static Dafny.TypeDescriptor<RawRSAKeyring_Compile._IRsaUnwrapInfo> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IRsaUnwrapInfo create() {
      return new RsaUnwrapInfo();
    }
    public static _IRsaUnwrapInfo create_RsaUnwrapInfo() {
      return create();
    }
    public bool is_RsaUnwrapInfo { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_IRsaUnwrapInfo> AllSingletonConstructors {
      get {
        yield return RsaUnwrapInfo.create();
      }
    }
  }

  public interface _IRsaWrapInfo {
    bool is_RsaWrapInfo { get; }
    _IRsaWrapInfo DowncastClone();
  }
  public class RsaWrapInfo : _IRsaWrapInfo {
    public RsaWrapInfo() {
    }
    public _IRsaWrapInfo DowncastClone() {
      if (this is _IRsaWrapInfo dt) { return dt; }
      return new RsaWrapInfo();
    }
    public override bool Equals(object other) {
      var oth = other as RawRSAKeyring_Compile.RsaWrapInfo;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "RawRSAKeyring_Compile.RsaWrapInfo.RsaWrapInfo";
      return s;
    }
    private static readonly RawRSAKeyring_Compile._IRsaWrapInfo theDefault = create();
    public static RawRSAKeyring_Compile._IRsaWrapInfo Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<RawRSAKeyring_Compile._IRsaWrapInfo> _TYPE = new Dafny.TypeDescriptor<RawRSAKeyring_Compile._IRsaWrapInfo>(RawRSAKeyring_Compile.RsaWrapInfo.Default());
    public static Dafny.TypeDescriptor<RawRSAKeyring_Compile._IRsaWrapInfo> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IRsaWrapInfo create() {
      return new RsaWrapInfo();
    }
    public static _IRsaWrapInfo create_RsaWrapInfo() {
      return create();
    }
    public bool is_RsaWrapInfo { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_IRsaWrapInfo> AllSingletonConstructors {
      get {
        yield return RsaWrapInfo.create();
      }
    }
  }

  public partial class RsaGenerateAndWrapKeyMaterial : MaterialWrapping_Compile.GenerateAndWrapMaterial<RawRSAKeyring_Compile._IRsaWrapInfo>, Actions_Compile.ActionWithResult<MaterialWrapping_Compile._IGenerateAndWrapInput, MaterialWrapping_Compile._IGenerateAndWrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<MaterialWrapping_Compile._IGenerateAndWrapInput, Wrappers_Compile._IResult<MaterialWrapping_Compile._IGenerateAndWrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public RsaGenerateAndWrapKeyMaterial() {
      this._publicKey = Dafny.Sequence<byte>.Empty;
      this._paddingScheme = software.amazon.cryptography.primitives.internaldafny.types.RSAPaddingMode.Default();
      this._cryptoPrimitives = default(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient);
    }
    public void __ctor(Dafny.ISequence<byte> publicKey, software.amazon.cryptography.primitives.internaldafny.types._IRSAPaddingMode paddingScheme, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives)
    {
      (this)._publicKey = publicKey;
      (this)._paddingScheme = paddingScheme;
      (this)._cryptoPrimitives = cryptoPrimitives;
    }
    public Wrappers_Compile._IResult<MaterialWrapping_Compile._IGenerateAndWrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(MaterialWrapping_Compile._IGenerateAndWrapInput input)
    {
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IGenerateAndWrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = Wrappers_Compile.Result<MaterialWrapping_Compile._IGenerateAndWrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(MaterialWrapping_Compile.GenerateAndWrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo>.Default(RawRSAKeyring_Compile.RsaWrapInfo.Default()));
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _937_generateBytesResult;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out162;
      _out162 = ((this).cryptoPrimitives).GenerateRandomBytes(software.amazon.cryptography.primitives.internaldafny.types.GenerateRandomBytesInput.create(AlgorithmSuites_Compile.__default.GetEncryptKeyLength((input).dtor_algorithmSuite)));
      _937_generateBytesResult = _out162;
      Dafny.ISequence<byte> _938_plaintextMaterial;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _939_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _939_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_937_generateBytesResult, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_940_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_940_e);
      })));
      if ((_939_valueOrError0).IsFailure()) {
        res = (_939_valueOrError0).PropagateFailure<MaterialWrapping_Compile._IGenerateAndWrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo>>();
        return res;
      }
      _938_plaintextMaterial = (_939_valueOrError0).Extract();
      RawRSAKeyring_Compile.RsaWrapKeyMaterial _941_wrap;
      RawRSAKeyring_Compile.RsaWrapKeyMaterial _nw50 = new RawRSAKeyring_Compile.RsaWrapKeyMaterial();
      _nw50.__ctor((this).publicKey, (this).paddingScheme, (this).cryptoPrimitives);
      _941_wrap = _nw50;
      MaterialWrapping_Compile._IWrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo> _942_wrapOutput;
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _943_valueOrError1 = Wrappers_Compile.Result<MaterialWrapping_Compile._IWrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(MaterialWrapping_Compile.WrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo>.Default(RawRSAKeyring_Compile.RsaWrapInfo.Default()));
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out163;
      _out163 = (_941_wrap).Invoke(MaterialWrapping_Compile.WrapInput.create(_938_plaintextMaterial, (input).dtor_algorithmSuite, (input).dtor_encryptionContext));
      _943_valueOrError1 = _out163;
      if ((_943_valueOrError1).IsFailure()) {
        res = (_943_valueOrError1).PropagateFailure<MaterialWrapping_Compile._IGenerateAndWrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo>>();
        return res;
      }
      _942_wrapOutput = (_943_valueOrError1).Extract();
      MaterialWrapping_Compile._IGenerateAndWrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo> _944_output;
      _944_output = MaterialWrapping_Compile.GenerateAndWrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo>.create(_938_plaintextMaterial, (_942_wrapOutput).dtor_wrappedMaterial, RawRSAKeyring_Compile.RsaWrapInfo.create());
      res = Wrappers_Compile.Result<MaterialWrapping_Compile._IGenerateAndWrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_944_output);
      return res;
      return res;
    }
    public Dafny.ISequence<byte> _publicKey {get; set;}
    public Dafny.ISequence<byte> publicKey { get {
      return this._publicKey;
    } }
    public software.amazon.cryptography.primitives.internaldafny.types._IRSAPaddingMode _paddingScheme {get; set;}
    public software.amazon.cryptography.primitives.internaldafny.types._IRSAPaddingMode paddingScheme { get {
      return this._paddingScheme;
    } }
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _cryptoPrimitives {get; set;}
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives { get {
      return this._cryptoPrimitives;
    } }
  }

  public partial class RsaWrapKeyMaterial : MaterialWrapping_Compile.WrapMaterial<RawRSAKeyring_Compile._IRsaWrapInfo>, Actions_Compile.ActionWithResult<MaterialWrapping_Compile._IWrapInput, MaterialWrapping_Compile._IWrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<MaterialWrapping_Compile._IWrapInput, Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public RsaWrapKeyMaterial() {
      this._publicKey = Dafny.Sequence<byte>.Empty;
      this._paddingScheme = software.amazon.cryptography.primitives.internaldafny.types.RSAPaddingMode.Default();
      this._cryptoPrimitives = default(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient);
    }
    public void __ctor(Dafny.ISequence<byte> publicKey, software.amazon.cryptography.primitives.internaldafny.types._IRSAPaddingMode paddingScheme, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives)
    {
      (this)._publicKey = publicKey;
      (this)._paddingScheme = paddingScheme;
      (this)._cryptoPrimitives = cryptoPrimitives;
    }
    public Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(MaterialWrapping_Compile._IWrapInput input)
    {
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IWrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = Wrappers_Compile.Result<MaterialWrapping_Compile._IWrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(MaterialWrapping_Compile.WrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo>.Default(RawRSAKeyring_Compile.RsaWrapInfo.Default()));
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _945_RSAEncryptOutput;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out164;
      _out164 = ((this).cryptoPrimitives).RSAEncrypt(software.amazon.cryptography.primitives.internaldafny.types.RSAEncryptInput.create((this).paddingScheme, (this).publicKey, (input).dtor_plaintextMaterial));
      _945_RSAEncryptOutput = _out164;
      Dafny.ISequence<byte> _946_ciphertext;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _947_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _947_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_945_RSAEncryptOutput, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_948_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_948_e);
      })));
      if ((_947_valueOrError0).IsFailure()) {
        res = (_947_valueOrError0).PropagateFailure<MaterialWrapping_Compile._IWrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo>>();
        return res;
      }
      _946_ciphertext = (_947_valueOrError0).Extract();
      MaterialWrapping_Compile._IWrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo> _949_output;
      _949_output = MaterialWrapping_Compile.WrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo>.create(_946_ciphertext, RawRSAKeyring_Compile.RsaWrapInfo.create());
      res = Wrappers_Compile.Result<MaterialWrapping_Compile._IWrapOutput<RawRSAKeyring_Compile._IRsaWrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_949_output);
      return res;
      return res;
    }
    public Dafny.ISequence<byte> _publicKey {get; set;}
    public Dafny.ISequence<byte> publicKey { get {
      return this._publicKey;
    } }
    public software.amazon.cryptography.primitives.internaldafny.types._IRSAPaddingMode _paddingScheme {get; set;}
    public software.amazon.cryptography.primitives.internaldafny.types._IRSAPaddingMode paddingScheme { get {
      return this._paddingScheme;
    } }
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _cryptoPrimitives {get; set;}
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives { get {
      return this._cryptoPrimitives;
    } }
  }

  public partial class RsaUnwrapKeyMaterial : MaterialWrapping_Compile.UnwrapMaterial<RawRSAKeyring_Compile._IRsaUnwrapInfo>, Actions_Compile.ActionWithResult<MaterialWrapping_Compile._IUnwrapInput, MaterialWrapping_Compile._IUnwrapOutput<RawRSAKeyring_Compile._IRsaUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>, Actions_Compile.Action<MaterialWrapping_Compile._IUnwrapInput, Wrappers_Compile._IResult<MaterialWrapping_Compile._IUnwrapOutput<RawRSAKeyring_Compile._IRsaUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>> {
    public RsaUnwrapKeyMaterial() {
      this._privateKey = Dafny.Sequence<byte>.Empty;
      this._paddingScheme = software.amazon.cryptography.primitives.internaldafny.types.RSAPaddingMode.Default();
      this._cryptoPrimitives = default(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient);
    }
    public void __ctor(Dafny.ISequence<byte> privateKey, software.amazon.cryptography.primitives.internaldafny.types._IRSAPaddingMode paddingScheme, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives)
    {
      (this)._privateKey = privateKey;
      (this)._paddingScheme = paddingScheme;
      (this)._cryptoPrimitives = cryptoPrimitives;
    }
    public Wrappers_Compile._IResult<MaterialWrapping_Compile._IUnwrapOutput<RawRSAKeyring_Compile._IRsaUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> Invoke(MaterialWrapping_Compile._IUnwrapInput input)
    {
      Wrappers_Compile._IResult<MaterialWrapping_Compile._IUnwrapOutput<RawRSAKeyring_Compile._IRsaUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = Wrappers_Compile.Result<MaterialWrapping_Compile._IUnwrapOutput<RawRSAKeyring_Compile._IRsaUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(MaterialWrapping_Compile.UnwrapOutput<RawRSAKeyring_Compile._IRsaUnwrapInfo>.Default(RawRSAKeyring_Compile.RsaUnwrapInfo.Default()));
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _950_suite;
      _950_suite = (input).dtor_algorithmSuite;
      Dafny.ISequence<byte> _951_wrappedMaterial;
      _951_wrappedMaterial = (input).dtor_wrappedMaterial;
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _952_aad;
      _952_aad = (input).dtor_encryptionContext;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _953_maybeDecryptResult;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out165;
      _out165 = ((this).cryptoPrimitives).RSADecrypt(software.amazon.cryptography.primitives.internaldafny.types.RSADecryptInput.create((this).paddingScheme, (this).privateKey, _951_wrappedMaterial));
      _953_maybeDecryptResult = _out165;
      Dafny.ISequence<byte> _954_decryptResult;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _955_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _955_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_953_maybeDecryptResult, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_956_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_956_e);
      })));
      if ((_955_valueOrError0).IsFailure()) {
        res = (_955_valueOrError0).PropagateFailure<MaterialWrapping_Compile._IUnwrapOutput<RawRSAKeyring_Compile._IRsaUnwrapInfo>>();
        return res;
      }
      _954_decryptResult = (_955_valueOrError0).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _957_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _957_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger((_954_decryptResult).Count)) == (new BigInteger(AlgorithmSuites_Compile.__default.GetEncryptKeyLength(_950_suite))), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Invalid plaintext length.")));
      if ((_957_valueOrError1).IsFailure()) {
        res = (_957_valueOrError1).PropagateFailure<MaterialWrapping_Compile._IUnwrapOutput<RawRSAKeyring_Compile._IRsaUnwrapInfo>>();
        return res;
      }
      MaterialWrapping_Compile._IUnwrapOutput<RawRSAKeyring_Compile._IRsaUnwrapInfo> _958_output;
      _958_output = MaterialWrapping_Compile.UnwrapOutput<RawRSAKeyring_Compile._IRsaUnwrapInfo>.create(_954_decryptResult, RawRSAKeyring_Compile.RsaUnwrapInfo.create());
      res = Wrappers_Compile.Result<MaterialWrapping_Compile._IUnwrapOutput<RawRSAKeyring_Compile._IRsaUnwrapInfo>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_958_output);
      return res;
      return res;
    }
    public Dafny.ISequence<byte> _privateKey {get; set;}
    public Dafny.ISequence<byte> privateKey { get {
      return this._privateKey;
    } }
    public software.amazon.cryptography.primitives.internaldafny.types._IRSAPaddingMode _paddingScheme {get; set;}
    public software.amazon.cryptography.primitives.internaldafny.types._IRSAPaddingMode paddingScheme { get {
      return this._paddingScheme;
    } }
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _cryptoPrimitives {get; set;}
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives { get {
      return this._cryptoPrimitives;
    } }
  }

} // end of namespace RawRSAKeyring_Compile
namespace CMM_Compile {

  public interface VerifiableInterface : software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager {
  }
  public class _Companion_VerifiableInterface {
  }

  public partial class __default {
    public static bool RequiredEncryptionContextKeys_q(Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>> requiredEncryptionContextKeys, software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials encryptionMaterials)
    {
      return Dafny.Helpers.Id<Func<Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>>, software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, bool>>((_959_requiredEncryptionContextKeys, _960_encryptionMaterials) => Dafny.Helpers.Quantifier<Dafny.ISequence<byte>>((Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.UnwrapOr(_959_requiredEncryptionContextKeys, Dafny.Sequence<Dafny.ISequence<byte>>.FromElements())).UniqueElements, true, (((_forall_var_8) => {
        Dafny.ISequence<byte> _961_k = (Dafny.ISequence<byte>)_forall_var_8;
        return !((Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.UnwrapOr(_959_requiredEncryptionContextKeys, Dafny.Sequence<Dafny.ISequence<byte>>.FromElements())).Contains(_961_k)) || (((_960_encryptionMaterials).dtor_requiredEncryptionContextKeys).Contains(_961_k));
      }))))(requiredEncryptionContextKeys, encryptionMaterials);
    }
    public static bool EncryptionContextComplete(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsInput input, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials decryptionMaterials)
    {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _962_reproducedEncryptionContext = Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>.UnwrapOr((input).dtor_reproducedEncryptionContext, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements());
      return Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, bool>>((_963_reproducedEncryptionContext, _964_decryptionMaterials) => Dafny.Helpers.Quantifier<Dafny.ISequence<byte>>(((_963_reproducedEncryptionContext).Keys).Elements, true, (((_forall_var_9) => {
        Dafny.ISequence<byte> _965_k = (Dafny.ISequence<byte>)_forall_var_9;
        return !(((_963_reproducedEncryptionContext).Keys).Contains(_965_k)) || ((((_964_decryptionMaterials).dtor_encryptionContext).Contains(_965_k)) && ((Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select((_964_decryptionMaterials).dtor_encryptionContext,_965_k)).Equals(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(_963_reproducedEncryptionContext,_965_k))));
      }))))(_962_reproducedEncryptionContext, decryptionMaterials);
    }
    public static bool ReproducedEncryptionContext_q(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsInput input) {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _966_reproducedEncryptionContext = Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>.UnwrapOr((input).dtor_reproducedEncryptionContext, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements());
      return Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsInput, bool>>((_967_reproducedEncryptionContext, _968_input) => Dafny.Helpers.Quantifier<Dafny.ISequence<byte>>(((_967_reproducedEncryptionContext).Keys).Elements, true, (((_forall_var_10) => {
        Dafny.ISequence<byte> _969_k = (Dafny.ISequence<byte>)_forall_var_10;
        return !((((_967_reproducedEncryptionContext).Keys).Contains(_969_k)) && (((_968_input).dtor_encryptionContext).Contains(_969_k))) || ((Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select((_968_input).dtor_encryptionContext,_969_k)).Equals(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(_967_reproducedEncryptionContext,_969_k)));
      }))))(_966_reproducedEncryptionContext, input);
    }
  }
} // end of namespace CMM_Compile
namespace Defaults_Compile {

  public partial class __default {
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId GetAlgorithmSuiteForCommitmentPolicy(software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy commitmentPolicy) {
      software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy _source28 = commitmentPolicy;
      if (_source28.is_ESDK) {
        software.amazon.cryptography.materialproviders.internaldafny.types._IESDKCommitmentPolicy _970___mcc_h0 = _source28.dtor_ESDK;
        software.amazon.cryptography.materialproviders.internaldafny.types._IESDKCommitmentPolicy _971_c = _970___mcc_h0;
        software.amazon.cryptography.materialproviders.internaldafny.types._IESDKCommitmentPolicy _source29 = _971_c;
        if (_source29.is_FORBID__ENCRYPT__ALLOW__DECRYPT) {
          return software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.create_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__256__GCM__IV12__TAG16__HKDF__SHA384__ECDSA__P384());
        } else if (_source29.is_REQUIRE__ENCRYPT__ALLOW__DECRYPT) {
          return software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.create_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384());
        } else {
          return software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.create_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKAlgorithmSuiteId.create_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384());
        }
      } else {
        software.amazon.cryptography.materialproviders.internaldafny.types._IDBECommitmentPolicy _972___mcc_h1 = _source28.dtor_DBE;
        return software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.create_DBE(software.amazon.cryptography.materialproviders.internaldafny.types.DBEAlgorithmSuiteId.create_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384__SYMSIG__HMAC__SHA384());
      }
    }
  }
} // end of namespace Defaults_Compile
namespace Commitment_Compile {

  public partial class __default {
    public static Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> ValidateCommitmentPolicyOnEncrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId algorithm, software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy commitmentPolicy)
    {
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _973_suite = AlgorithmSuites_Compile.__default.GetSuite(algorithm);
      if ((object.Equals(commitmentPolicy, software.amazon.cryptography.materialproviders.internaldafny.types.CommitmentPolicy.create_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKCommitmentPolicy.create_FORBID__ENCRYPT__ALLOW__DECRYPT()))) && (!(((_973_suite).dtor_commitment).is_None))) {
        return Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Fail(software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_InvalidAlgorithmSuiteInfoOnEncrypt(Dafny.Sequence<char>.FromString("Configuration conflict. Commitment policy requires only non-committing algorithm suites")));
      } else if ((((object.Equals(commitmentPolicy, software.amazon.cryptography.materialproviders.internaldafny.types.CommitmentPolicy.create_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKCommitmentPolicy.create_REQUIRE__ENCRYPT__ALLOW__DECRYPT()))) || (object.Equals(commitmentPolicy, software.amazon.cryptography.materialproviders.internaldafny.types.CommitmentPolicy.create_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKCommitmentPolicy.create_REQUIRE__ENCRYPT__REQUIRE__DECRYPT())))) || (object.Equals(commitmentPolicy, software.amazon.cryptography.materialproviders.internaldafny.types.CommitmentPolicy.create_DBE(software.amazon.cryptography.materialproviders.internaldafny.types.DBECommitmentPolicy.create())))) && (((_973_suite).dtor_commitment).is_None)) {
        return Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Fail(software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_InvalidAlgorithmSuiteInfoOnEncrypt(Dafny.Sequence<char>.FromString("Configuration conflict. Commitment policy requires only committing algorithm suites")));
      } else {
        return Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Pass();
      }
    }
    public static Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> ValidateCommitmentPolicyOnDecrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId algorithm, software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy commitmentPolicy)
    {
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _974_suite = AlgorithmSuites_Compile.__default.GetSuite(algorithm);
      if (((true) && ((object.Equals(commitmentPolicy, software.amazon.cryptography.materialproviders.internaldafny.types.CommitmentPolicy.create_ESDK(software.amazon.cryptography.materialproviders.internaldafny.types.ESDKCommitmentPolicy.create_REQUIRE__ENCRYPT__REQUIRE__DECRYPT()))) || (object.Equals(commitmentPolicy, software.amazon.cryptography.materialproviders.internaldafny.types.CommitmentPolicy.create_DBE(software.amazon.cryptography.materialproviders.internaldafny.types.DBECommitmentPolicy.create()))))) && (((_974_suite).dtor_commitment).is_None)) {
        return Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Fail(software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_InvalidAlgorithmSuiteInfoOnDecrypt(Dafny.Sequence<char>.FromString("Configuration conflict. Commitment policy requires only committing algorithm suites")));
      } else {
        return Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Pass();
      }
    }
  }
} // end of namespace Commitment_Compile
namespace DefaultCMM_Compile {

  public partial class DefaultCMM : CMM_Compile.VerifiableInterface, software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager {
    public DefaultCMM() {
      this._keyring = default(software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring);
      this._cryptoPrimitives = default(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient);
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetEncryptionMaterials(software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out166;
      _out166 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_ICryptographicMaterialsManager.GetEncryptionMaterials(this, input);
      return _out166;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> DecryptMaterials(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out167;
      _out167 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_ICryptographicMaterialsManager.DecryptMaterials(this, input);
      return _out167;
    }
    public void OfKeyring(software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring k, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient c)
    {
      (this)._keyring = k;
      (this)._cryptoPrimitives = c;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetEncryptionMaterials_k(software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _975_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _975_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(!((input).dtor_encryptionContext).Contains(Materials_Compile.__default.EC__PUBLIC__KEY__FIELD), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Reserved Field found in EncryptionContext keys.")));
      if ((_975_valueOrError0).IsFailure()) {
        output = (_975_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput>();
        return output;
      }
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId _976_algorithmId;
      _976_algorithmId = ((((input).dtor_algorithmSuiteId).is_Some) ? (((input).dtor_algorithmSuiteId).dtor_value) : (Defaults_Compile.__default.GetAlgorithmSuiteForCommitmentPolicy((input).dtor_commitmentPolicy)));
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _977_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _977_valueOrError1 = Commitment_Compile.__default.ValidateCommitmentPolicyOnEncrypt(_976_algorithmId, (input).dtor_commitmentPolicy);
      if ((_977_valueOrError1).IsFailure()) {
        output = (_977_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput>();
        return output;
      }
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _978_suite;
      _978_suite = AlgorithmSuites_Compile.__default.GetSuite(_976_algorithmId);
      Wrappers_Compile._IOption<Dafny.ISequence<byte>> _979_signingKey = Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default();
      Wrappers_Compile._IOption<Dafny.ISequence<byte>> _980_verificationKey = Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default();
      if (((_978_suite).dtor_signature).is_ECDSA) {
        Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.types._IGenerateECDSASignatureKeyOutput, software.amazon.cryptography.primitives.internaldafny.types._IError> _981_maybeECDSAPair;
        Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.types._IGenerateECDSASignatureKeyOutput, software.amazon.cryptography.primitives.internaldafny.types._IError> _out168;
        _out168 = ((this).cryptoPrimitives).GenerateECDSASignatureKey(software.amazon.cryptography.primitives.internaldafny.types.GenerateECDSASignatureKeyInput.create((((_978_suite).dtor_signature).dtor_ECDSA).dtor_curve));
        _981_maybeECDSAPair = _out168;
        software.amazon.cryptography.primitives.internaldafny.types._IGenerateECDSASignatureKeyOutput _982_pair;
        Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.types._IGenerateECDSASignatureKeyOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _983_valueOrError2 = Wrappers_Compile.Result<software.amazon.cryptography.primitives.internaldafny.types._IGenerateECDSASignatureKeyOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(software.amazon.cryptography.primitives.internaldafny.types.GenerateECDSASignatureKeyOutput.Default());
        _983_valueOrError2 = Wrappers_Compile.Result<software.amazon.cryptography.primitives.internaldafny.types._IGenerateECDSASignatureKeyOutput, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_981_maybeECDSAPair, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_984_e) => {
          return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_984_e);
        })));
        if ((_983_valueOrError2).IsFailure()) {
          output = (_983_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput>();
          return output;
        }
        _982_pair = (_983_valueOrError2).Extract();
        _979_signingKey = Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some((_982_pair).dtor_signingKey);
        _980_verificationKey = Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some((_982_pair).dtor_verificationKey);
      } else {
        _979_signingKey = Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None();
        _980_verificationKey = Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None();
      }
      software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _985_materials;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _986_valueOrError3 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      _986_valueOrError3 = Materials_Compile.__default.InitializeEncryptionMaterials(software.amazon.cryptography.materialproviders.internaldafny.types.InitializeEncryptionMaterialsInput.create(_976_algorithmId, (input).dtor_encryptionContext, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.UnwrapOr((input).dtor_requiredEncryptionContextKeys, Dafny.Sequence<Dafny.ISequence<byte>>.FromElements()), _979_signingKey, _980_verificationKey));
      if ((_986_valueOrError3).IsFailure()) {
        output = (_986_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput>();
        return output;
      }
      _985_materials = (_986_valueOrError3).Extract();
      software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput _987_result;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _988_valueOrError4 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnEncryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out169;
      _out169 = ((this).keyring).OnEncrypt(software.amazon.cryptography.materialproviders.internaldafny.types.OnEncryptInput.create(_985_materials));
      _988_valueOrError4 = _out169;
      if ((_988_valueOrError4).IsFailure()) {
        output = (_988_valueOrError4).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput>();
        return output;
      }
      _987_result = (_988_valueOrError4).Extract();
      software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput _989_encryptionMaterialsOutput;
      _989_encryptionMaterialsOutput = software.amazon.cryptography.materialproviders.internaldafny.types.GetEncryptionMaterialsOutput.create((_987_result).dtor_materials);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _990_valueOrError5 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _990_valueOrError5 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.EncryptionMaterialsHasPlaintextDataKey((_989_encryptionMaterialsOutput).dtor_encryptionMaterials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Could not retrieve materials required for encryption")));
      if ((_990_valueOrError5).IsFailure()) {
        output = (_990_valueOrError5).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _991_valueOrError6 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _991_valueOrError6 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.ValidEncryptionMaterialsTransition(_985_materials, (_989_encryptionMaterialsOutput).dtor_encryptionMaterials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Keyring returned an invalid response")));
      if ((_991_valueOrError6).IsFailure()) {
        output = (_991_valueOrError6).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput>();
        return output;
      }
      output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_989_encryptionMaterialsOutput);
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> DecryptMaterials_k(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _992_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _992_valueOrError0 = Commitment_Compile.__default.ValidateCommitmentPolicyOnDecrypt((input).dtor_algorithmSuiteId, (input).dtor_commitmentPolicy);
      if ((_992_valueOrError0).IsFailure()) {
        output = (_992_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput>();
        return output;
      }
      Dafny.ISequence<Dafny.ISequence<byte>> _993_requiredEncryptionContextKeys;
      _993_requiredEncryptionContextKeys = Dafny.Sequence<Dafny.ISequence<byte>>.FromElements();
      if (((input).dtor_reproducedEncryptionContext).is_Some) {
        Dafny.ISet<Dafny.ISequence<byte>> _994_keysSet;
        _994_keysSet = (((input).dtor_reproducedEncryptionContext).dtor_value).Keys;
        while (!(_994_keysSet).Equals(Dafny.Set<Dafny.ISequence<byte>>.FromElements())) {
          Dafny.ISequence<byte> _995_key;
          foreach (Dafny.ISequence<byte> _assign_such_that_0 in (_994_keysSet).Elements) {
            _995_key = (Dafny.ISequence<byte>)_assign_such_that_0;
            if ((_994_keysSet).Contains(_995_key)) {
              goto after__ASSIGN_SUCH_THAT_0;
            }
          }
          throw new System.Exception("assign-such-that search produced no value (line 491)");
        after__ASSIGN_SUCH_THAT_0: ;
          if (((input).dtor_encryptionContext).Contains(_995_key)) {
            Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _996_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
            _996_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(((input).dtor_reproducedEncryptionContext).dtor_value,_995_key)).Equals(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select((input).dtor_encryptionContext,_995_key)), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Encryption context does not match reproduced encryption context.")));
            if ((_996_valueOrError1).IsFailure()) {
              output = (_996_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput>();
              return output;
            }
          } else {
            _993_requiredEncryptionContextKeys = Dafny.Sequence<Dafny.ISequence<byte>>.Concat(_993_requiredEncryptionContextKeys, Dafny.Sequence<Dafny.ISequence<byte>>.FromElements(_995_key));
          }
          _994_keysSet = Dafny.Set<Dafny.ISequence<byte>>.Difference(_994_keysSet, Dafny.Set<Dafny.ISequence<byte>>.FromElements(_995_key));
        }
      }
      software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _997_materials;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _998_valueOrError2 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      _998_valueOrError2 = Materials_Compile.__default.InitializeDecryptionMaterials(software.amazon.cryptography.materialproviders.internaldafny.types.InitializeDecryptionMaterialsInput.create((input).dtor_algorithmSuiteId, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Merge((input).dtor_encryptionContext, Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>.UnwrapOr((input).dtor_reproducedEncryptionContext, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements())), _993_requiredEncryptionContextKeys));
      if ((_998_valueOrError2).IsFailure()) {
        output = (_998_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput>();
        return output;
      }
      _997_materials = (_998_valueOrError2).Extract();
      software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput _999_result;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1000_valueOrError3 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IOnDecryptOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out170;
      _out170 = ((this).keyring).OnDecrypt(software.amazon.cryptography.materialproviders.internaldafny.types.OnDecryptInput.create(_997_materials, (input).dtor_encryptedDataKeys));
      _1000_valueOrError3 = _out170;
      if ((_1000_valueOrError3).IsFailure()) {
        output = (_1000_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput>();
        return output;
      }
      _999_result = (_1000_valueOrError3).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1001_valueOrError4 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1001_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.DecryptionMaterialsTransitionIsValid(_997_materials, (_999_result).dtor_materials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Keyring.OnDecrypt failed to decrypt the plaintext data key.")));
      if ((_1001_valueOrError4).IsFailure()) {
        output = (_1001_valueOrError4).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput>();
        return output;
      }
      output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.DecryptMaterialsOutput.create((_999_result).dtor_materials));
      return output;
      return output;
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring _keyring {get; set;}
    public software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring keyring { get {
      return this._keyring;
    } }
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _cryptoPrimitives {get; set;}
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient cryptoPrimitives { get {
      return this._cryptoPrimitives;
    } }
  }

} // end of namespace DefaultCMM_Compile
namespace DefaultClientSupplier_Compile {

  public partial class DefaultClientSupplier : software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier {
    public DefaultClientSupplier() {
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetClient(software.amazon.cryptography.materialproviders.internaldafny.types._IGetClientInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out171;
      _out171 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_IClientSupplier.GetClient(this, input);
      return _out171;
    }
    public void __ctor()
    {
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetClient_k(software.amazon.cryptography.materialproviders.internaldafny.types._IGetClientInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.services.kms.internaldafny.types._IError> _1002_maybeClient;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.services.kms.internaldafny.types._IError> _out172;
      _out172 = software.amazon.cryptography.services.kms.internaldafny.__default.KMSClientForRegion((input).dtor_region);
      _1002_maybeClient = _out172;
      output = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.services.kms.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_1002_maybeClient, ((System.Func<software.amazon.cryptography.services.kms.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_1003_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_ComAmazonawsKms(_1003_e);
      })));
      return output;
      return output;
    }
  }

} // end of namespace DefaultClientSupplier_Compile
namespace RequiredEncryptionContextCMM_Compile {

  public partial class RequiredEncryptionContextCMM : CMM_Compile.VerifiableInterface, software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager {
    public RequiredEncryptionContextCMM() {
      this._underlyingCMM = default(software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager);
      this._requiredEncryptionContextKeys = Dafny.Sequence<Dafny.ISequence<byte>>.Empty;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetEncryptionMaterials(software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out173;
      _out173 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_ICryptographicMaterialsManager.GetEncryptionMaterials(this, input);
      return _out173;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> DecryptMaterials(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out174;
      _out174 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_ICryptographicMaterialsManager.DecryptMaterials(this, input);
      return _out174;
    }
    public void __ctor(software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager inputCMM, Dafny.ISet<Dafny.ISequence<byte>> inputKeys)
    {
      Dafny.ISet<Dafny.ISequence<byte>> _1004_keySet;
      _1004_keySet = inputKeys;
      Dafny.ISequence<Dafny.ISequence<byte>> _1005_keySeq;
      _1005_keySeq = Dafny.Sequence<Dafny.ISequence<byte>>.FromElements();
      while (!(_1004_keySet).Equals(Dafny.Set<Dafny.ISequence<byte>>.FromElements())) {
        Dafny.ISequence<byte> _1006_key;
        foreach (Dafny.ISequence<byte> _assign_such_that_1 in (_1004_keySet).Elements) {
          _1006_key = (Dafny.ISequence<byte>)_assign_such_that_1;
          if ((_1004_keySet).Contains(_1006_key)) {
            goto after__ASSIGN_SUCH_THAT_1;
          }
        }
        throw new System.Exception("assign-such-that search produced no value (line 61)");
      after__ASSIGN_SUCH_THAT_1: ;
        _1005_keySeq = Dafny.Sequence<Dafny.ISequence<byte>>.Concat(_1005_keySeq, Dafny.Sequence<Dafny.ISequence<byte>>.FromElements(_1006_key));
        _1004_keySet = Dafny.Set<Dafny.ISequence<byte>>.Difference(_1004_keySet, Dafny.Set<Dafny.ISequence<byte>>.FromElements(_1006_key));
      }
      (this)._underlyingCMM = inputCMM;
      (this)._requiredEncryptionContextKeys = _1005_keySeq;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetEncryptionMaterials_k(software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1007_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1007_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Dafny.Helpers.Id<Func<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsInput, bool>>((_1008_input) => Dafny.Helpers.Quantifier<Dafny.ISequence<byte>>(((this).requiredEncryptionContextKeys).UniqueElements, true, (((_forall_var_11) => {
        Dafny.ISequence<byte> _1009_k = (Dafny.ISequence<byte>)_forall_var_11;
        return !(((this).requiredEncryptionContextKeys).Contains(_1009_k)) || (((_1008_input).dtor_encryptionContext).Contains(_1009_k));
      }))))(input), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Encryption context does not contain required keys.")));
      if ((_1007_valueOrError0).IsFailure()) {
        output = (_1007_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput>();
        return output;
      }
      software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput _1010_result;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1011_valueOrError1 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      var _pat_let_tv32 = input;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out175;
      _out175 = ((this).underlyingCMM).GetEncryptionMaterials(Dafny.Helpers.Let<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsInput, software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsInput>(input, _pat_let20_0 => Dafny.Helpers.Let<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsInput, software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsInput>(_pat_let20_0, _1012_dt__update__tmp_h0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>>, software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsInput>(Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.create_Some(Dafny.Sequence<Dafny.ISequence<byte>>.Concat(Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.UnwrapOr((_pat_let_tv32).dtor_requiredEncryptionContextKeys, Dafny.Sequence<Dafny.ISequence<byte>>.FromElements()), (this).requiredEncryptionContextKeys)), _pat_let21_0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<byte>>>, software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsInput>(_pat_let21_0, _1013_dt__update_hrequiredEncryptionContextKeys_h0 => software.amazon.cryptography.materialproviders.internaldafny.types.GetEncryptionMaterialsInput.create((_1012_dt__update__tmp_h0).dtor_encryptionContext, (_1012_dt__update__tmp_h0).dtor_commitmentPolicy, (_1012_dt__update__tmp_h0).dtor_algorithmSuiteId, (_1012_dt__update__tmp_h0).dtor_maxPlaintextLength, _1013_dt__update_hrequiredEncryptionContextKeys_h0))))));
      _1011_valueOrError1 = _out175;
      if ((_1011_valueOrError1).IsFailure()) {
        output = (_1011_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput>();
        return output;
      }
      _1010_result = (_1011_valueOrError1).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1014_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1014_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Dafny.Helpers.Id<Func<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, bool>>((_1015_result) => Dafny.Helpers.Quantifier<Dafny.ISequence<byte>>(((this).requiredEncryptionContextKeys).UniqueElements, true, (((_forall_var_12) => {
        Dafny.ISequence<byte> _1016_k = (Dafny.ISequence<byte>)_forall_var_12;
        return !(((this).requiredEncryptionContextKeys).Contains(_1016_k)) || ((((_1015_result).dtor_encryptionMaterials).dtor_requiredEncryptionContextKeys).Contains(_1016_k));
      }))))(_1010_result), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Expected encryption context keys do not exist in keys to only authenticate.")));
      if ((_1014_valueOrError2).IsFailure()) {
        output = (_1014_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1017_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1017_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.EncryptionMaterialsHasPlaintextDataKey((_1010_result).dtor_encryptionMaterials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Could not retrieve materials required for encryption")));
      if ((_1017_valueOrError3).IsFailure()) {
        output = (_1017_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1018_valueOrError4 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1018_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(CMM_Compile.__default.RequiredEncryptionContextKeys_q((input).dtor_requiredEncryptionContextKeys, (_1010_result).dtor_encryptionMaterials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Keyring returned an invalid response")));
      if ((_1018_valueOrError4).IsFailure()) {
        output = (_1018_valueOrError4).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput>();
        return output;
      }
      output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_1010_result);
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> DecryptMaterials_k(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1019_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1019_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((input).dtor_reproducedEncryptionContext).is_Some, software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("No reproduced encryption context on decrypt.")));
      if ((_1019_valueOrError0).IsFailure()) {
        output = (_1019_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1020_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1020_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(CMM_Compile.__default.ReproducedEncryptionContext_q(input), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Encryption context does not match reproduced encryption context.")));
      if ((_1020_valueOrError1).IsFailure()) {
        output = (_1020_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1021_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1021_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Dafny.Helpers.Id<Func<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsInput, bool>>((_1022_input) => Dafny.Helpers.Quantifier<Dafny.ISequence<byte>>(((this).requiredEncryptionContextKeys).UniqueElements, true, (((_forall_var_13) => {
        Dafny.ISequence<byte> _1023_k = (Dafny.ISequence<byte>)_forall_var_13;
        return !(((this).requiredEncryptionContextKeys).Contains(_1023_k)) || ((((_1022_input).dtor_reproducedEncryptionContext).dtor_value).Contains(_1023_k));
      }))))(input), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Reproduced encryption context missing required keys.")));
      if ((_1021_valueOrError2).IsFailure()) {
        output = (_1021_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput>();
        return output;
      }
      software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput _1024_result;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1025_valueOrError3 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out176;
      _out176 = ((this).underlyingCMM).DecryptMaterials(input);
      _1025_valueOrError3 = _out176;
      if ((_1025_valueOrError3).IsFailure()) {
        output = (_1025_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput>();
        return output;
      }
      _1024_result = (_1025_valueOrError3).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1026_valueOrError4 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1026_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Dafny.Helpers.Id<Func<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, bool>>((_1027_result) => Dafny.Helpers.Quantifier<Dafny.ISequence<byte>>(((this).requiredEncryptionContextKeys).UniqueElements, true, (((_forall_var_14) => {
        Dafny.ISequence<byte> _1028_k = (Dafny.ISequence<byte>)_forall_var_14;
        return !(((this).requiredEncryptionContextKeys).Contains(_1028_k)) || ((((_1027_result).dtor_decryptionMaterials).dtor_encryptionContext).Contains(_1028_k));
      }))))(_1024_result), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Final encryption context missing required keys.")));
      if ((_1026_valueOrError4).IsFailure()) {
        output = (_1026_valueOrError4).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1029_valueOrError5 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1029_valueOrError5 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(CMM_Compile.__default.EncryptionContextComplete(input, (_1024_result).dtor_decryptionMaterials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Reproduced encryption context missing from encryption context.")));
      if ((_1029_valueOrError5).IsFailure()) {
        output = (_1029_valueOrError5).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1030_valueOrError6 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1030_valueOrError6 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.DecryptionMaterialsWithPlaintextDataKey((_1024_result).dtor_decryptionMaterials), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Keyring.OnDecrypt failed to decrypt the plaintext data key.")));
      if ((_1030_valueOrError6).IsFailure()) {
        output = (_1030_valueOrError6).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput>();
        return output;
      }
      output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_1024_result);
      return output;
      return output;
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager _underlyingCMM {get; set;}
    public software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager underlyingCMM { get {
      return this._underlyingCMM;
    } }
    public Dafny.ISequence<Dafny.ISequence<byte>> _requiredEncryptionContextKeys {get; set;}
    public Dafny.ISequence<Dafny.ISequence<byte>> requiredEncryptionContextKeys { get {
      return this._requiredEncryptionContextKeys;
    } }
  }

} // end of namespace RequiredEncryptionContextCMM_Compile
namespace AwsCryptographyMaterialProvidersOperations_Compile {

  public interface _IConfig {
    bool is_Config { get; }
    software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient dtor_crypto { get; }
    _IConfig DowncastClone();
  }
  public class Config : _IConfig {
    public readonly software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _crypto;
    public Config(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient crypto) {
      this._crypto = crypto;
    }
    public _IConfig DowncastClone() {
      if (this is _IConfig dt) { return dt; }
      return new Config(_crypto);
    }
    public override bool Equals(object other) {
      var oth = other as AwsCryptographyMaterialProvidersOperations_Compile.Config;
      return oth != null && this._crypto == oth._crypto;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._crypto));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyMaterialProvidersOperations_Compile.Config.Config";
      s += "(";
      s += Dafny.Helpers.ToString(this._crypto);
      s += ")";
      return s;
    }
    private static readonly AwsCryptographyMaterialProvidersOperations_Compile._IConfig theDefault = create(default(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient));
    public static AwsCryptographyMaterialProvidersOperations_Compile._IConfig Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AwsCryptographyMaterialProvidersOperations_Compile._IConfig> _TYPE = new Dafny.TypeDescriptor<AwsCryptographyMaterialProvidersOperations_Compile._IConfig>(AwsCryptographyMaterialProvidersOperations_Compile.Config.Default());
    public static Dafny.TypeDescriptor<AwsCryptographyMaterialProvidersOperations_Compile._IConfig> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IConfig create(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient crypto) {
      return new Config(crypto);
    }
    public static _IConfig create_Config(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient crypto) {
      return create(crypto);
    }
    public bool is_Config { get { return true; } }
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient dtor_crypto {
      get {
        return this._crypto;
      }
    }
  }

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsKeyring(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      _System._ITuple0 _1031___v0;
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1032_valueOrError0 = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
      _1032_valueOrError0 = AwsKmsUtils_Compile.__default.ValidateKmsKeyId((input).dtor_kmsKeyId);
      if ((_1032_valueOrError0).IsFailure()) {
        output = (_1032_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      _1031___v0 = (_1032_valueOrError0).Extract();
      Dafny.ISequence<Dafny.ISequence<char>> _1033_grantTokens;
      Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1034_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<Dafny.ISequence<char>>.Empty);
      _1034_valueOrError1 = AwsKmsUtils_Compile.__default.GetValidGrantTokens((input).dtor_grantTokens);
      if ((_1034_valueOrError1).IsFailure()) {
        output = (_1034_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      _1033_grantTokens = (_1034_valueOrError1).Extract();
      AwsKmsKeyring_Compile.AwsKmsKeyring _1035_keyring;
      AwsKmsKeyring_Compile.AwsKmsKeyring _nw51 = new AwsKmsKeyring_Compile.AwsKmsKeyring();
      _nw51.__ctor((input).dtor_kmsClient, (input).dtor_kmsKeyId, _1033_grantTokens);
      _1035_keyring = _nw51;
      output = Wrappers_Compile.Result<AwsKmsKeyring_Compile.AwsKmsKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_1035_keyring);
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsDiscoveryKeyring(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsDiscoveryKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      if (((input).dtor_discoveryFilter).is_Some) {
        _System._ITuple0 _1036___v1;
        Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1037_valueOrError0 = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
        _1037_valueOrError0 = AwsKmsUtils_Compile.__default.ValidateDiscoveryFilter(((input).dtor_discoveryFilter).dtor_value);
        if ((_1037_valueOrError0).IsFailure()) {
          output = (_1037_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
          return output;
        }
        _1036___v1 = (_1037_valueOrError0).Extract();
      }
      Dafny.ISequence<Dafny.ISequence<char>> _1038_grantTokens;
      Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1039_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<Dafny.ISequence<char>>.Empty);
      _1039_valueOrError1 = AwsKmsUtils_Compile.__default.GetValidGrantTokens((input).dtor_grantTokens);
      if ((_1039_valueOrError1).IsFailure()) {
        output = (_1039_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      _1038_grantTokens = (_1039_valueOrError1).Extract();
      AwsKmsDiscoveryKeyring_Compile.AwsKmsDiscoveryKeyring _1040_keyring;
      AwsKmsDiscoveryKeyring_Compile.AwsKmsDiscoveryKeyring _nw52 = new AwsKmsDiscoveryKeyring_Compile.AwsKmsDiscoveryKeyring();
      _nw52.__ctor((input).dtor_kmsClient, (input).dtor_discoveryFilter, _1038_grantTokens);
      _1040_keyring = _nw52;
      output = Wrappers_Compile.Result<AwsKmsDiscoveryKeyring_Compile.AwsKmsDiscoveryKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_1040_keyring);
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsMultiKeyring(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMultiKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Dafny.ISequence<Dafny.ISequence<char>> _1041_grantTokens;
      Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1042_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<Dafny.ISequence<char>>.Empty);
      _1042_valueOrError0 = AwsKmsUtils_Compile.__default.GetValidGrantTokens((input).dtor_grantTokens);
      if ((_1042_valueOrError0).IsFailure()) {
        output = (_1042_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      _1041_grantTokens = (_1042_valueOrError0).Extract();
      if (((input).dtor_clientSupplier).is_Some) {
        Wrappers_Compile._IResult<MultiKeyring_Compile.MultiKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out177;
        _out177 = StrictMultiKeyring_Compile.__default.StrictMultiKeyring((input).dtor_generator, (input).dtor_kmsKeyIds, ((input).dtor_clientSupplier).dtor_value, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.create_Some(_1041_grantTokens));
        output = _out177;
      } else {
        software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier _1043_clientSupplier;
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1044_valueOrError1 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out178;
        _out178 = AwsCryptographyMaterialProvidersOperations_Compile.__default.CreateDefaultClientSupplier(config, software.amazon.cryptography.materialproviders.internaldafny.types.CreateDefaultClientSupplierInput.create());
        _1044_valueOrError1 = _out178;
        if ((_1044_valueOrError1).IsFailure()) {
          output = (_1044_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
          return output;
        }
        _1043_clientSupplier = (_1044_valueOrError1).Extract();
        Wrappers_Compile._IResult<MultiKeyring_Compile.MultiKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out179;
        _out179 = StrictMultiKeyring_Compile.__default.StrictMultiKeyring((input).dtor_generator, (input).dtor_kmsKeyIds, _1043_clientSupplier, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.create_Some(_1041_grantTokens));
        output = _out179;
      }
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsDiscoveryMultiKeyring(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsDiscoveryMultiKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Dafny.ISequence<Dafny.ISequence<char>> _1045_grantTokens;
      Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1046_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<Dafny.ISequence<char>>.Empty);
      _1046_valueOrError0 = AwsKmsUtils_Compile.__default.GetValidGrantTokens((input).dtor_grantTokens);
      if ((_1046_valueOrError0).IsFailure()) {
        output = (_1046_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      _1045_grantTokens = (_1046_valueOrError0).Extract();
      software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier _1047_clientSupplier = default(software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier);
      if (((input).dtor_clientSupplier).is_None) {
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1048_valueOrError1 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out180;
        _out180 = AwsCryptographyMaterialProvidersOperations_Compile.__default.CreateDefaultClientSupplier(config, software.amazon.cryptography.materialproviders.internaldafny.types.CreateDefaultClientSupplierInput.create());
        _1048_valueOrError1 = _out180;
        if ((_1048_valueOrError1).IsFailure()) {
          output = (_1048_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
          return output;
        }
        _1047_clientSupplier = (_1048_valueOrError1).Extract();
      } else {
        _1047_clientSupplier = ((input).dtor_clientSupplier).dtor_value;
      }
      Wrappers_Compile._IResult<MultiKeyring_Compile.MultiKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out181;
      _out181 = DiscoveryMultiKeyring_Compile.__default.DiscoveryMultiKeyring((input).dtor_regions, (input).dtor_discoveryFilter, _1047_clientSupplier, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.create_Some(_1045_grantTokens));
      output = _out181;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsMrkKeyring(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      _System._ITuple0 _1049___v2;
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1050_valueOrError0 = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
      _1050_valueOrError0 = AwsKmsUtils_Compile.__default.ValidateKmsKeyId((input).dtor_kmsKeyId);
      if ((_1050_valueOrError0).IsFailure()) {
        output = (_1050_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      _1049___v2 = (_1050_valueOrError0).Extract();
      Dafny.ISequence<Dafny.ISequence<char>> _1051_grantTokens;
      Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1052_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<Dafny.ISequence<char>>.Empty);
      _1052_valueOrError1 = AwsKmsUtils_Compile.__default.GetValidGrantTokens((input).dtor_grantTokens);
      if ((_1052_valueOrError1).IsFailure()) {
        output = (_1052_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      _1051_grantTokens = (_1052_valueOrError1).Extract();
      AwsKmsMrkKeyring_Compile.AwsKmsMrkKeyring _1053_keyring;
      AwsKmsMrkKeyring_Compile.AwsKmsMrkKeyring _nw53 = new AwsKmsMrkKeyring_Compile.AwsKmsMrkKeyring();
      _nw53.__ctor((input).dtor_kmsClient, (input).dtor_kmsKeyId, _1051_grantTokens);
      _1053_keyring = _nw53;
      output = Wrappers_Compile.Result<AwsKmsMrkKeyring_Compile.AwsKmsMrkKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_1053_keyring);
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsMrkMultiKeyring(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkMultiKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Dafny.ISequence<Dafny.ISequence<char>> _1054_grantTokens;
      Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1055_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<Dafny.ISequence<char>>.Empty);
      _1055_valueOrError0 = AwsKmsUtils_Compile.__default.GetValidGrantTokens((input).dtor_grantTokens);
      if ((_1055_valueOrError0).IsFailure()) {
        output = (_1055_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      _1054_grantTokens = (_1055_valueOrError0).Extract();
      software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier _1056_clientSupplier = default(software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier);
      if (((input).dtor_clientSupplier).is_None) {
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1057_valueOrError1 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out182;
        _out182 = AwsCryptographyMaterialProvidersOperations_Compile.__default.CreateDefaultClientSupplier(config, software.amazon.cryptography.materialproviders.internaldafny.types.CreateDefaultClientSupplierInput.create());
        _1057_valueOrError1 = _out182;
        if ((_1057_valueOrError1).IsFailure()) {
          output = (_1057_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
          return output;
        }
        _1056_clientSupplier = (_1057_valueOrError1).Extract();
      } else {
        _1056_clientSupplier = ((input).dtor_clientSupplier).dtor_value;
      }
      Wrappers_Compile._IResult<MultiKeyring_Compile.MultiKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out183;
      _out183 = MrkAwareStrictMultiKeyring_Compile.__default.MrkAwareStrictMultiKeyring((input).dtor_generator, (input).dtor_kmsKeyIds, _1056_clientSupplier, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.create_Some(_1054_grantTokens));
      output = _out183;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsMrkDiscoveryKeyring(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkDiscoveryKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      if (((input).dtor_discoveryFilter).is_Some) {
        _System._ITuple0 _1058___v3;
        Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1059_valueOrError0 = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
        _1059_valueOrError0 = AwsKmsUtils_Compile.__default.ValidateDiscoveryFilter(((input).dtor_discoveryFilter).dtor_value);
        if ((_1059_valueOrError0).IsFailure()) {
          output = (_1059_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
          return output;
        }
        _1058___v3 = (_1059_valueOrError0).Extract();
      }
      Wrappers_Compile._IOption<bool> _1060_regionMatch;
      _1060_regionMatch = software.amazon.cryptography.services.kms.internaldafny.__default.RegionMatch((input).dtor_kmsClient, (input).dtor_region);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1061_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1061_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(!object.Equals(_1060_regionMatch, Wrappers_Compile.Option<bool>.create_Some(false)), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Provided client and region do not match")));
      if ((_1061_valueOrError1).IsFailure()) {
        output = (_1061_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      Dafny.ISequence<Dafny.ISequence<char>> _1062_grantTokens;
      Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1063_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<Dafny.ISequence<char>>.Empty);
      _1063_valueOrError2 = AwsKmsUtils_Compile.__default.GetValidGrantTokens((input).dtor_grantTokens);
      if ((_1063_valueOrError2).IsFailure()) {
        output = (_1063_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      _1062_grantTokens = (_1063_valueOrError2).Extract();
      AwsKmsMrkDiscoveryKeyring_Compile.AwsKmsMrkDiscoveryKeyring _1064_keyring;
      AwsKmsMrkDiscoveryKeyring_Compile.AwsKmsMrkDiscoveryKeyring _nw54 = new AwsKmsMrkDiscoveryKeyring_Compile.AwsKmsMrkDiscoveryKeyring();
      _nw54.__ctor((input).dtor_kmsClient, (input).dtor_region, (input).dtor_discoveryFilter, _1062_grantTokens);
      _1064_keyring = _nw54;
      output = Wrappers_Compile.Result<AwsKmsMrkDiscoveryKeyring_Compile.AwsKmsMrkDiscoveryKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_1064_keyring);
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsMrkDiscoveryMultiKeyring(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkDiscoveryMultiKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Dafny.ISequence<Dafny.ISequence<char>> _1065_grantTokens;
      Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1066_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<Dafny.ISequence<char>>.Empty);
      _1066_valueOrError0 = AwsKmsUtils_Compile.__default.GetValidGrantTokens((input).dtor_grantTokens);
      if ((_1066_valueOrError0).IsFailure()) {
        output = (_1066_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      _1065_grantTokens = (_1066_valueOrError0).Extract();
      software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier _1067_clientSupplier = default(software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier);
      if (((input).dtor_clientSupplier).is_None) {
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1068_valueOrError1 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out184;
        _out184 = AwsCryptographyMaterialProvidersOperations_Compile.__default.CreateDefaultClientSupplier(config, software.amazon.cryptography.materialproviders.internaldafny.types.CreateDefaultClientSupplierInput.create());
        _1068_valueOrError1 = _out184;
        if ((_1068_valueOrError1).IsFailure()) {
          output = (_1068_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
          return output;
        }
        _1067_clientSupplier = (_1068_valueOrError1).Extract();
      } else {
        _1067_clientSupplier = ((input).dtor_clientSupplier).dtor_value;
      }
      Wrappers_Compile._IResult<MultiKeyring_Compile.MultiKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out185;
      _out185 = MrkAwareDiscoveryMultiKeyring_Compile.__default.MrkAwareDiscoveryMultiKeyring((input).dtor_regions, (input).dtor_discoveryFilter, _1067_clientSupplier, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.create_Some(_1065_grantTokens));
      output = _out185;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsHierarchicalKeyring(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsHierarchicalKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      int _1069_maxCacheSize = 0;
      software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType _1070_cache;
      _1070_cache = ((((input).dtor_cache).is_Some) ? (((input).dtor_cache).dtor_value) : (software.amazon.cryptography.materialproviders.internaldafny.types.CacheType.create_Default(software.amazon.cryptography.materialproviders.internaldafny.types.DefaultCache.create(1000))));
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1071_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1071_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((input).dtor_branchKeyId).is_None) || (((input).dtor_branchKeyIdSupplier).is_None), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Cannot initialize keyring with both a branchKeyId and BranchKeyIdSupplier.")));
      if ((_1071_valueOrError0).IsFailure()) {
        output = (_1071_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1072_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1072_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((input).dtor_branchKeyId).is_Some) || (((input).dtor_branchKeyIdSupplier).is_Some), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Must initialize keyring with either branchKeyId or BranchKeyIdSupplier.")));
      if ((_1072_valueOrError1).IsFailure()) {
        output = (_1072_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache _1073_cmc;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1074_valueOrError2 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out186;
      _out186 = AwsCryptographyMaterialProvidersOperations_Compile.__default.CreateCryptographicMaterialsCache(config, software.amazon.cryptography.materialproviders.internaldafny.types.CreateCryptographicMaterialsCacheInput.create(_1070_cache));
      _1074_valueOrError2 = _out186;
      if ((_1074_valueOrError2).IsFailure()) {
        output = (_1074_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      _1073_cmc = (_1074_valueOrError2).Extract();
      AwsKmsHierarchicalKeyring_Compile.AwsKmsHierarchicalKeyring _1075_keyring;
      AwsKmsHierarchicalKeyring_Compile.AwsKmsHierarchicalKeyring _nw55 = new AwsKmsHierarchicalKeyring_Compile.AwsKmsHierarchicalKeyring();
      _nw55.__ctor((input).dtor_keyStore, (input).dtor_branchKeyId, (input).dtor_branchKeyIdSupplier, (input).dtor_ttlSeconds, _1073_cmc, (config).dtor_crypto);
      _1075_keyring = _nw55;
      output = Wrappers_Compile.Result<AwsKmsHierarchicalKeyring_Compile.AwsKmsHierarchicalKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_1075_keyring);
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateMultiKeyring(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._ICreateMultiKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1076_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1076_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((input).dtor_generator).is_Some) || ((new BigInteger(((input).dtor_childKeyrings).Count)).Sign == 1), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Must include a generator keyring and/or at least one child keyring")));
      if ((_1076_valueOrError0).IsFailure()) {
        output = (_1076_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      MultiKeyring_Compile.MultiKeyring _1077_keyring;
      MultiKeyring_Compile.MultiKeyring _nw56 = new MultiKeyring_Compile.MultiKeyring();
      _nw56.__ctor((input).dtor_generator, (input).dtor_childKeyrings);
      _1077_keyring = _nw56;
      output = Wrappers_Compile.Result<MultiKeyring_Compile.MultiKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_1077_keyring);
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateRawAesKeyring(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRawAesKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1078_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1078_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(!((input).dtor_keyNamespace).Equals(Dafny.Sequence<char>.FromString("aws-kms")), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("keyNamespace must not be `aws-kms`")));
      if ((_1078_valueOrError0).IsFailure()) {
        output = (_1078_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM _1079_wrappingAlg;
      _1079_wrappingAlg = ((System.Func<software.amazon.cryptography.materialproviders.internaldafny.types._IAesWrappingAlg, software.amazon.cryptography.primitives.internaldafny.types._IAES__GCM>)((_source30) => {
        if (_source30.is_ALG__AES128__GCM__IV12__TAG16) {
          return software.amazon.cryptography.primitives.internaldafny.types.AES__GCM.create(16, 16, 12);
        } else if (_source30.is_ALG__AES192__GCM__IV12__TAG16) {
          return software.amazon.cryptography.primitives.internaldafny.types.AES__GCM.create(24, 16, 12);
        } else {
          return software.amazon.cryptography.primitives.internaldafny.types.AES__GCM.create(32, 16, 12);
        }
      }))((input).dtor_wrappingAlg);
      _System._ITuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>> _1080_namespaceAndName;
      Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1081_valueOrError1 = Wrappers_Compile.Result<_System._ITuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Default(UTF8.ValidUTF8Bytes.Default(), UTF8.ValidUTF8Bytes.Default()));
      _1081_valueOrError1 = AwsKmsUtils_Compile.__default.ParseKeyNamespaceAndName((input).dtor_keyNamespace, (input).dtor_keyName);
      if ((_1081_valueOrError1).IsFailure()) {
        output = (_1081_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      _1080_namespaceAndName = (_1081_valueOrError1).Extract();
      _System._ITuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>> _let_tmp_rhs5 = _1080_namespaceAndName;
      Dafny.ISequence<byte> _1082_namespace = _let_tmp_rhs5.dtor__0;
      Dafny.ISequence<byte> _1083_name = _let_tmp_rhs5.dtor__1;
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1084_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1084_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((new BigInteger(((input).dtor_wrappingKey).Count)) == (new BigInteger(16))) || ((new BigInteger(((input).dtor_wrappingKey).Count)) == (new BigInteger(24)))) || ((new BigInteger(((input).dtor_wrappingKey).Count)) == (new BigInteger(32))), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Invalid wrapping key length")));
      if ((_1084_valueOrError2).IsFailure()) {
        output = (_1084_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1085_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1085_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger(((input).dtor_wrappingKey).Count)) == (new BigInteger((_1079_wrappingAlg).dtor_keyLength)), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Wrapping key length does not match specified wrapping algorithm")));
      if ((_1085_valueOrError3).IsFailure()) {
        output = (_1085_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      RawAESKeyring_Compile.RawAESKeyring _1086_keyring;
      RawAESKeyring_Compile.RawAESKeyring _nw57 = new RawAESKeyring_Compile.RawAESKeyring();
      _nw57.__ctor(_1082_namespace, _1083_name, (input).dtor_wrappingKey, _1079_wrappingAlg, (config).dtor_crypto);
      _1086_keyring = _nw57;
      output = Wrappers_Compile.Result<RawAESKeyring_Compile.RawAESKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_1086_keyring);
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateRawRsaKeyring(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRawRsaKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1087_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1087_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(!((input).dtor_keyNamespace).Equals(Dafny.Sequence<char>.FromString("aws-kms")), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("keyNamespace must not be `aws-kms`")));
      if ((_1087_valueOrError0).IsFailure()) {
        output = (_1087_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1088_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1088_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((input).dtor_publicKey).is_Some) || (((input).dtor_privateKey).is_Some), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("A publicKey or a privateKey is required")));
      if ((_1088_valueOrError1).IsFailure()) {
        output = (_1088_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      software.amazon.cryptography.primitives.internaldafny.types._IRSAPaddingMode _1089_padding;
      _1089_padding = ((System.Func<software.amazon.cryptography.materialproviders.internaldafny.types._IPaddingScheme, software.amazon.cryptography.primitives.internaldafny.types._IRSAPaddingMode>)((_source31) => {
        if (_source31.is_PKCS1) {
          return software.amazon.cryptography.primitives.internaldafny.types.RSAPaddingMode.create_PKCS1();
        } else if (_source31.is_OAEP__SHA1__MGF1) {
          return software.amazon.cryptography.primitives.internaldafny.types.RSAPaddingMode.create_OAEP__SHA1();
        } else if (_source31.is_OAEP__SHA256__MGF1) {
          return software.amazon.cryptography.primitives.internaldafny.types.RSAPaddingMode.create_OAEP__SHA256();
        } else if (_source31.is_OAEP__SHA384__MGF1) {
          return software.amazon.cryptography.primitives.internaldafny.types.RSAPaddingMode.create_OAEP__SHA384();
        } else {
          return software.amazon.cryptography.primitives.internaldafny.types.RSAPaddingMode.create_OAEP__SHA512();
        }
      }))((input).dtor_paddingScheme);
      _System._ITuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>> _1090_namespaceAndName;
      Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1091_valueOrError2 = Wrappers_Compile.Result<_System._ITuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Default(UTF8.ValidUTF8Bytes.Default(), UTF8.ValidUTF8Bytes.Default()));
      _1091_valueOrError2 = AwsKmsUtils_Compile.__default.ParseKeyNamespaceAndName((input).dtor_keyNamespace, (input).dtor_keyName);
      if ((_1091_valueOrError2).IsFailure()) {
        output = (_1091_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      _1090_namespaceAndName = (_1091_valueOrError2).Extract();
      _System._ITuple2<Dafny.ISequence<byte>, Dafny.ISequence<byte>> _let_tmp_rhs6 = _1090_namespaceAndName;
      Dafny.ISequence<byte> _1092_namespace = _let_tmp_rhs6.dtor__0;
      Dafny.ISequence<byte> _1093_name = _let_tmp_rhs6.dtor__1;
      RawRSAKeyring_Compile.RawRSAKeyring _1094_keyring;
      RawRSAKeyring_Compile.RawRSAKeyring _nw58 = new RawRSAKeyring_Compile.RawRSAKeyring();
      _nw58.__ctor(_1092_namespace, _1093_name, (input).dtor_publicKey, (input).dtor_privateKey, _1089_padding, (config).dtor_crypto);
      _1094_keyring = _nw58;
      output = Wrappers_Compile.Result<RawRSAKeyring_Compile.RawRSAKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_1094_keyring);
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsRsaKeyring(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsRsaKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1095_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1095_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((input).dtor_publicKey).is_Some) || (((input).dtor_kmsClient).is_Some), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("A publicKey or a kmsClient is required")));
      if ((_1095_valueOrError0).IsFailure()) {
        output = (_1095_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1096_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1096_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((input).dtor_encryptionAlgorithm).is_RSAES__OAEP__SHA__1) || (((input).dtor_encryptionAlgorithm).is_RSAES__OAEP__SHA__256), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Unsupported EncryptionAlgorithmSpec")));
      if ((_1096_valueOrError1).IsFailure()) {
        output = (_1096_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1097_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1097_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((software.amazon.cryptography.services.kms.internaldafny.types.__default.IsValid__KeyIdType((input).dtor_kmsKeyId)) && ((AwsArnParsing_Compile.__default.ParseAwsKmsArn((input).dtor_kmsKeyId)).is_Success), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Kms Key ID must be a KMS Key ARN")));
      if ((_1097_valueOrError2).IsFailure()) {
        output = (_1097_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      if (((input).dtor_publicKey).is_Some) {
        Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.types._IGetRSAKeyModulusLengthOutput, software.amazon.cryptography.primitives.internaldafny.types._IError> _1098_lengthOutputRes;
        _1098_lengthOutputRes = ((config).dtor_crypto).GetRSAKeyModulusLength(software.amazon.cryptography.primitives.internaldafny.types.GetRSAKeyModulusLengthInput.create(((input).dtor_publicKey).dtor_value));
        software.amazon.cryptography.primitives.internaldafny.types._IGetRSAKeyModulusLengthOutput _1099_lengthOutput;
        Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.types._IGetRSAKeyModulusLengthOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1100_valueOrError3 = default(Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.types._IGetRSAKeyModulusLengthOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        _1100_valueOrError3 = Wrappers_Compile.Result<software.amazon.cryptography.primitives.internaldafny.types._IGetRSAKeyModulusLengthOutput, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_1098_lengthOutputRes, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_1101_e) => {
          return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_1101_e);
        })));
        if ((_1100_valueOrError3).IsFailure()) {
          output = (_1100_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
          return output;
        }
        _1099_lengthOutput = (_1100_valueOrError3).Extract();
        Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1102_valueOrError4 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
        _1102_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(((_1099_lengthOutput).dtor_length) >= (AwsKmsRsaKeyring_Compile.__default.MIN__KMS__RSA__KEY__LEN), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Invalid public key length")));
        if ((_1102_valueOrError4).IsFailure()) {
          output = (_1102_valueOrError4).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
          return output;
        }
      }
      _System._ITuple0 _1103___v4;
      Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1104_valueOrError5 = Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(_System.Tuple0.Default());
      _1104_valueOrError5 = AwsKmsUtils_Compile.__default.ValidateKmsKeyId((input).dtor_kmsKeyId);
      if ((_1104_valueOrError5).IsFailure()) {
        output = (_1104_valueOrError5).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      _1103___v4 = (_1104_valueOrError5).Extract();
      Dafny.ISequence<Dafny.ISequence<char>> _1105_grantTokens;
      Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1106_valueOrError6 = Wrappers_Compile.Result<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Sequence<Dafny.ISequence<char>>.Empty);
      _1106_valueOrError6 = AwsKmsUtils_Compile.__default.GetValidGrantTokens((input).dtor_grantTokens);
      if ((_1106_valueOrError6).IsFailure()) {
        output = (_1106_valueOrError6).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>();
        return output;
      }
      _1105_grantTokens = (_1106_valueOrError6).Extract();
      AwsKmsRsaKeyring_Compile.AwsKmsRsaKeyring _1107_keyring;
      AwsKmsRsaKeyring_Compile.AwsKmsRsaKeyring _nw59 = new AwsKmsRsaKeyring_Compile.AwsKmsRsaKeyring();
      _nw59.__ctor((input).dtor_publicKey, (input).dtor_kmsKeyId, (input).dtor_encryptionAlgorithm, (input).dtor_kmsClient, (config).dtor_crypto, _1105_grantTokens);
      _1107_keyring = _nw59;
      output = Wrappers_Compile.Result<AwsKmsRsaKeyring_Compile.AwsKmsRsaKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_1107_keyring);
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateDefaultCryptographicMaterialsManager(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._ICreateDefaultCryptographicMaterialsManagerInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      DefaultCMM_Compile.DefaultCMM _1108_cmm;
      DefaultCMM_Compile.DefaultCMM _nw60 = new DefaultCMM_Compile.DefaultCMM();
      _nw60.OfKeyring((input).dtor_keyring, (config).dtor_crypto);
      _1108_cmm = _nw60;
      output = Wrappers_Compile.Result<DefaultCMM_Compile.DefaultCMM, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_1108_cmm);
      return output;
      return output;
    }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IError CmpError(Dafny.ISequence<char> s) {
      return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("A publicKey or a kmsClient is required"));
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateRequiredEncryptionContextCMM(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRequiredEncryptionContextCMMInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1109_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1109_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((((input).dtor_underlyingCMM).is_Some) && (((input).dtor_keyring).is_None), AwsCryptographyMaterialProvidersOperations_Compile.__default.CmpError(Dafny.Sequence<char>.FromString("CreateRequiredEncryptionContextCMM currently only supports cmm.")));
      if ((_1109_valueOrError0).IsFailure()) {
        output = (_1109_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager>();
        return output;
      }
      Dafny.ISet<Dafny.ISequence<byte>> _1110_keySet;
      _1110_keySet = Dafny.Helpers.Id<Func<software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRequiredEncryptionContextCMMInput, Dafny.ISet<Dafny.ISequence<byte>>>>((_1111_input) => ((System.Func<Dafny.ISet<Dafny.ISequence<byte>>>)(() => {
        var _coll3 = new System.Collections.Generic.List<Dafny.ISequence<byte>>();
        foreach (Dafny.ISequence<byte> _compr_3 in ((_1111_input).dtor_requiredEncryptionContextKeys).Elements) {
          Dafny.ISequence<byte> _1112_k = (Dafny.ISequence<byte>)_compr_3;
          if (((_1111_input).dtor_requiredEncryptionContextKeys).Contains(_1112_k)) {
            _coll3.Add(_1112_k);
          }
        }
        return Dafny.Set<Dafny.ISequence<byte>>.FromCollection(_coll3);
      }))())(input);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1113_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default();
      _1113_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>((new BigInteger((_1110_keySet).Count)).Sign == 1, AwsCryptographyMaterialProvidersOperations_Compile.__default.CmpError(Dafny.Sequence<char>.FromString("RequiredEncryptionContextCMM needs at least one requiredEncryptionContextKey.")));
      if ((_1113_valueOrError1).IsFailure()) {
        output = (_1113_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager>();
        return output;
      }
      RequiredEncryptionContextCMM_Compile.RequiredEncryptionContextCMM _1114_cmm;
      RequiredEncryptionContextCMM_Compile.RequiredEncryptionContextCMM _nw61 = new RequiredEncryptionContextCMM_Compile.RequiredEncryptionContextCMM();
      _nw61.__ctor(((input).dtor_underlyingCMM).dtor_value, _1110_keySet);
      _1114_cmm = _nw61;
      output = Wrappers_Compile.Result<RequiredEncryptionContextCMM_Compile.RequiredEncryptionContextCMM, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_1114_cmm);
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateCryptographicMaterialsCache(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._ICreateCryptographicMaterialsCacheInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType _source32 = (input).dtor_cache;
      if (_source32.is_Default) {
        software.amazon.cryptography.materialproviders.internaldafny.types._IDefaultCache _1115___mcc_h0 = _source32.dtor_Default;
        software.amazon.cryptography.materialproviders.internaldafny.types._IDefaultCache _1116_c = _1115___mcc_h0;
        var _pat_let_tv33 = _1116_c;
        software.amazon.cryptography.materialproviders.internaldafny.types._IStormTrackingCache _1117_cache;
        _1117_cache = Dafny.Helpers.Let<software.amazon.cryptography.materialproviders.internaldafny.types._IStormTrackingCache, software.amazon.cryptography.materialproviders.internaldafny.types._IStormTrackingCache>(StormTracker_Compile.__default.DefaultStorm(), _pat_let22_0 => Dafny.Helpers.Let<software.amazon.cryptography.materialproviders.internaldafny.types._IStormTrackingCache, software.amazon.cryptography.materialproviders.internaldafny.types._IStormTrackingCache>(_pat_let22_0, _1118_dt__update__tmp_h0 => Dafny.Helpers.Let<int, software.amazon.cryptography.materialproviders.internaldafny.types._IStormTrackingCache>((_pat_let_tv33).dtor_entryCapacity, _pat_let23_0 => Dafny.Helpers.Let<int, software.amazon.cryptography.materialproviders.internaldafny.types._IStormTrackingCache>(_pat_let23_0, _1119_dt__update_hentryCapacity_h0 => software.amazon.cryptography.materialproviders.internaldafny.types.StormTrackingCache.create(_1119_dt__update_hentryCapacity_h0, (_1118_dt__update__tmp_h0).dtor_entryPruningTailSize, (_1118_dt__update__tmp_h0).dtor_gracePeriod, (_1118_dt__update__tmp_h0).dtor_graceInterval, (_1118_dt__update__tmp_h0).dtor_fanOut, (_1118_dt__update__tmp_h0).dtor_inFlightTTL, (_1118_dt__update__tmp_h0).dtor_sleepMilli)))));
        StormTracker_Compile.StormTracker _1120_cmc;
        StormTracker_Compile.StormTracker _nw62 = new StormTracker_Compile.StormTracker();
        _nw62.__ctor(_1117_cache);
        _1120_cmc = _nw62;
        software.amazon.cryptography.internaldafny.StormTrackingCMC.StormTrackingCMC _1121_synCmc;
        software.amazon.cryptography.internaldafny.StormTrackingCMC.StormTrackingCMC _nw63 = new software.amazon.cryptography.internaldafny.StormTrackingCMC.StormTrackingCMC(_1120_cmc);
        _1121_synCmc = _nw63;
        output = Wrappers_Compile.Result<software.amazon.cryptography.internaldafny.StormTrackingCMC.StormTrackingCMC, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_1121_synCmc);
        return output;
      } else if (_source32.is_No) {
        software.amazon.cryptography.materialproviders.internaldafny.types._INoCache _1122___mcc_h1 = _source32.dtor_No;
        LocalCMC_Compile.LocalCMC _1123_cmc;
        LocalCMC_Compile.LocalCMC _nw64 = new LocalCMC_Compile.LocalCMC();
        _nw64.__ctor(BigInteger.Zero, BigInteger.One);
        _1123_cmc = _nw64;
        output = Wrappers_Compile.Result<LocalCMC_Compile.LocalCMC, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_1123_cmc);
        return output;
      } else if (_source32.is_SingleThreaded) {
        software.amazon.cryptography.materialproviders.internaldafny.types._ISingleThreadedCache _1124___mcc_h2 = _source32.dtor_SingleThreaded;
        software.amazon.cryptography.materialproviders.internaldafny.types._ISingleThreadedCache _1125_c = _1124___mcc_h2;
        LocalCMC_Compile.LocalCMC _1126_cmc;
        LocalCMC_Compile.LocalCMC _nw65 = new LocalCMC_Compile.LocalCMC();
        _nw65.__ctor(new BigInteger((_1125_c).dtor_entryCapacity), new BigInteger(Wrappers_Compile.Option<int>.UnwrapOr((_1125_c).dtor_entryPruningTailSize, 1)));
        _1126_cmc = _nw65;
        output = Wrappers_Compile.Result<LocalCMC_Compile.LocalCMC, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_1126_cmc);
        return output;
      } else if (_source32.is_MultiThreaded) {
        software.amazon.cryptography.materialproviders.internaldafny.types._IMultiThreadedCache _1127___mcc_h3 = _source32.dtor_MultiThreaded;
        software.amazon.cryptography.materialproviders.internaldafny.types._IMultiThreadedCache _1128_c = _1127___mcc_h3;
        LocalCMC_Compile.LocalCMC _1129_cmc;
        LocalCMC_Compile.LocalCMC _nw66 = new LocalCMC_Compile.LocalCMC();
        _nw66.__ctor(new BigInteger((_1128_c).dtor_entryCapacity), new BigInteger(Wrappers_Compile.Option<int>.UnwrapOr((_1128_c).dtor_entryPruningTailSize, 1)));
        _1129_cmc = _nw66;
        software.amazon.cryptography.internaldafny.SynchronizedLocalCMC.SynchronizedLocalCMC _1130_synCmc;
        software.amazon.cryptography.internaldafny.SynchronizedLocalCMC.SynchronizedLocalCMC _nw67 = new software.amazon.cryptography.internaldafny.SynchronizedLocalCMC.SynchronizedLocalCMC(_1129_cmc);
        _1130_synCmc = _nw67;
        output = Wrappers_Compile.Result<software.amazon.cryptography.internaldafny.SynchronizedLocalCMC.SynchronizedLocalCMC, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_1130_synCmc);
        return output;
      } else {
        software.amazon.cryptography.materialproviders.internaldafny.types._IStormTrackingCache _1131___mcc_h4 = _source32.dtor_StormTracking;
        software.amazon.cryptography.materialproviders.internaldafny.types._IStormTrackingCache _1132_c = _1131___mcc_h4;
        StormTracker_Compile.StormTracker _1133_cmc;
        StormTracker_Compile.StormTracker _nw68 = new StormTracker_Compile.StormTracker();
        _nw68.__ctor(_1132_c);
        _1133_cmc = _nw68;
        software.amazon.cryptography.internaldafny.StormTrackingCMC.StormTrackingCMC _1134_synCmc;
        software.amazon.cryptography.internaldafny.StormTrackingCMC.StormTrackingCMC _nw69 = new software.amazon.cryptography.internaldafny.StormTrackingCMC.StormTrackingCMC(_1133_cmc);
        _1134_synCmc = _nw69;
        output = Wrappers_Compile.Result<software.amazon.cryptography.internaldafny.StormTrackingCMC.StormTrackingCMC, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_1134_synCmc);
        return output;
      }
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateDefaultClientSupplier(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._ICreateDefaultClientSupplierInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      DefaultClientSupplier_Compile.DefaultClientSupplier _1135_clientSupplier;
      DefaultClientSupplier_Compile.DefaultClientSupplier _nw70 = new DefaultClientSupplier_Compile.DefaultClientSupplier();
      _nw70.__ctor();
      _1135_clientSupplier = _nw70;
      output = Wrappers_Compile.Result<DefaultClientSupplier_Compile.DefaultClientSupplier, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_1135_clientSupplier);
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> InitializeEncryptionMaterials(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._IInitializeEncryptionMaterialsInput input)
    {
      return Materials_Compile.__default.InitializeEncryptionMaterials(input);
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> InitializeDecryptionMaterials(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._IInitializeDecryptionMaterialsInput input)
    {
      return Materials_Compile.__default.InitializeDecryptionMaterials(input);
    }
    public static Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> ValidEncryptionMaterialsTransition(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._IValidEncryptionMaterialsTransitionInput input)
    {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1136_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.ValidEncryptionMaterialsTransition((input).dtor_start, (input).dtor_stop), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_InvalidEncryptionMaterialsTransition(Dafny.Sequence<char>.FromString("Invalid Encryption Materials Transition")));
      if ((_1136_valueOrError0).IsFailure()) {
        return (_1136_valueOrError0).PropagateFailure<_System._ITuple0>();
      } else {
        return Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_System.Tuple0.create());
      }
    }
    public static Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> ValidDecryptionMaterialsTransition(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._IValidDecryptionMaterialsTransitionInput input)
    {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1137_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.DecryptionMaterialsTransitionIsValid((input).dtor_start, (input).dtor_stop), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_InvalidDecryptionMaterialsTransition(Dafny.Sequence<char>.FromString("Invalid Decryption Materials Transition")));
      if ((_1137_valueOrError0).IsFailure()) {
        return (_1137_valueOrError0).PropagateFailure<_System._ITuple0>();
      } else {
        return Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_System.Tuple0.create());
      }
    }
    public static Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> EncryptionMaterialsHasPlaintextDataKey(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials input)
    {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1138_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.EncryptionMaterialsHasPlaintextDataKey(input), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_InvalidDecryptionMaterials(Dafny.Sequence<char>.FromString("Invalid Encryption Materials")));
      if ((_1138_valueOrError0).IsFailure()) {
        return (_1138_valueOrError0).PropagateFailure<_System._ITuple0>();
      } else {
        return Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_System.Tuple0.create());
      }
    }
    public static Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> DecryptionMaterialsWithPlaintextDataKey(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials input)
    {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1139_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(Materials_Compile.__default.DecryptionMaterialsWithPlaintextDataKey(input), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_InvalidDecryptionMaterials(Dafny.Sequence<char>.FromString("Invalid Decryption Materials")));
      if ((_1139_valueOrError0).IsFailure()) {
        return (_1139_valueOrError0).PropagateFailure<_System._ITuple0>();
      } else {
        return Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_System.Tuple0.create());
      }
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetAlgorithmSuiteInfo(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, Dafny.ISequence<byte> input)
    {
      return AlgorithmSuites_Compile.__default.GetAlgorithmSuiteInfo(input);
    }
    public static Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> ValidAlgorithmSuiteInfo(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo input)
    {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1140_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(AlgorithmSuites_Compile.__default.AlgorithmSuite_q(input), software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_InvalidAlgorithmSuiteInfo(Dafny.Sequence<char>.FromString("Invalid AlgorithmSuiteInfo")));
      if ((_1140_valueOrError0).IsFailure()) {
        return (_1140_valueOrError0).PropagateFailure<_System._ITuple0>();
      } else {
        return Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_System.Tuple0.create());
      }
    }
    public static Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> ValidateCommitmentPolicyOnEncrypt(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._IValidateCommitmentPolicyOnEncryptInput input)
    {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1141_valueOrError0 = Commitment_Compile.__default.ValidateCommitmentPolicyOnEncrypt((input).dtor_algorithm, (input).dtor_commitmentPolicy);
      if ((_1141_valueOrError0).IsFailure()) {
        return (_1141_valueOrError0).PropagateFailure<_System._ITuple0>();
      } else {
        return Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_System.Tuple0.create());
      }
    }
    public static Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> ValidateCommitmentPolicyOnDecrypt(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types._IValidateCommitmentPolicyOnDecryptInput input)
    {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1142_valueOrError0 = Commitment_Compile.__default.ValidateCommitmentPolicyOnDecrypt((input).dtor_algorithm, (input).dtor_commitmentPolicy);
      if ((_1142_valueOrError0).IsFailure()) {
        return (_1142_valueOrError0).PropagateFailure<_System._ITuple0>();
      } else {
        return Wrappers_Compile.Result<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_System.Tuple0.create());
      }
    }
  }
} // end of namespace AwsCryptographyMaterialProvidersOperations_Compile
namespace software.amazon.cryptography.materialproviders.internaldafny {

  public partial class MaterialProvidersClient : software.amazon.cryptography.materialproviders.internaldafny.types.IAwsCryptographicMaterialProvidersClient {
    public MaterialProvidersClient() {
      this._config = default(AwsCryptographyMaterialProvidersOperations_Compile._IConfig);
    }
    public void __ctor(AwsCryptographyMaterialProvidersOperations_Compile._IConfig config)
    {
      (this)._config = config;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out187;
      _out187 = AwsCryptographyMaterialProvidersOperations_Compile.__default.CreateAwsKmsKeyring((this).config, input);
      output = _out187;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsDiscoveryKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsDiscoveryKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out188;
      _out188 = AwsCryptographyMaterialProvidersOperations_Compile.__default.CreateAwsKmsDiscoveryKeyring((this).config, input);
      output = _out188;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsMultiKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMultiKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out189;
      _out189 = AwsCryptographyMaterialProvidersOperations_Compile.__default.CreateAwsKmsMultiKeyring((this).config, input);
      output = _out189;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsDiscoveryMultiKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsDiscoveryMultiKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out190;
      _out190 = AwsCryptographyMaterialProvidersOperations_Compile.__default.CreateAwsKmsDiscoveryMultiKeyring((this).config, input);
      output = _out190;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsMrkKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out191;
      _out191 = AwsCryptographyMaterialProvidersOperations_Compile.__default.CreateAwsKmsMrkKeyring((this).config, input);
      output = _out191;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsMrkMultiKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkMultiKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out192;
      _out192 = AwsCryptographyMaterialProvidersOperations_Compile.__default.CreateAwsKmsMrkMultiKeyring((this).config, input);
      output = _out192;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsMrkDiscoveryKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkDiscoveryKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out193;
      _out193 = AwsCryptographyMaterialProvidersOperations_Compile.__default.CreateAwsKmsMrkDiscoveryKeyring((this).config, input);
      output = _out193;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsMrkDiscoveryMultiKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsMrkDiscoveryMultiKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out194;
      _out194 = AwsCryptographyMaterialProvidersOperations_Compile.__default.CreateAwsKmsMrkDiscoveryMultiKeyring((this).config, input);
      output = _out194;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsHierarchicalKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsHierarchicalKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out195;
      _out195 = AwsCryptographyMaterialProvidersOperations_Compile.__default.CreateAwsKmsHierarchicalKeyring((this).config, input);
      output = _out195;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateMultiKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateMultiKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out196;
      _out196 = AwsCryptographyMaterialProvidersOperations_Compile.__default.CreateMultiKeyring((this).config, input);
      output = _out196;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateRawAesKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRawAesKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out197;
      _out197 = AwsCryptographyMaterialProvidersOperations_Compile.__default.CreateRawAesKeyring((this).config, input);
      output = _out197;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateRawRsaKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRawRsaKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out198;
      _out198 = AwsCryptographyMaterialProvidersOperations_Compile.__default.CreateRawRsaKeyring((this).config, input);
      output = _out198;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateAwsKmsRsaKeyring(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateAwsKmsRsaKeyringInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out199;
      _out199 = AwsCryptographyMaterialProvidersOperations_Compile.__default.CreateAwsKmsRsaKeyring((this).config, input);
      output = _out199;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateDefaultCryptographicMaterialsManager(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateDefaultCryptographicMaterialsManagerInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out200;
      _out200 = AwsCryptographyMaterialProvidersOperations_Compile.__default.CreateDefaultCryptographicMaterialsManager((this).config, input);
      output = _out200;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateRequiredEncryptionContextCMM(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateRequiredEncryptionContextCMMInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out201;
      _out201 = AwsCryptographyMaterialProvidersOperations_Compile.__default.CreateRequiredEncryptionContextCMM((this).config, input);
      output = _out201;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateCryptographicMaterialsCache(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateCryptographicMaterialsCacheInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out202;
      _out202 = AwsCryptographyMaterialProvidersOperations_Compile.__default.CreateCryptographicMaterialsCache((this).config, input);
      output = _out202;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier, software.amazon.cryptography.materialproviders.internaldafny.types._IError> CreateDefaultClientSupplier(software.amazon.cryptography.materialproviders.internaldafny.types._ICreateDefaultClientSupplierInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.IClientSupplier, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out203;
      _out203 = AwsCryptographyMaterialProvidersOperations_Compile.__default.CreateDefaultClientSupplier((this).config, input);
      output = _out203;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> InitializeEncryptionMaterials(software.amazon.cryptography.materialproviders.internaldafny.types._IInitializeEncryptionMaterialsInput input) {
      return AwsCryptographyMaterialProvidersOperations_Compile.__default.InitializeEncryptionMaterials((this).config, input);
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials, software.amazon.cryptography.materialproviders.internaldafny.types._IError> InitializeDecryptionMaterials(software.amazon.cryptography.materialproviders.internaldafny.types._IInitializeDecryptionMaterialsInput input) {
      return AwsCryptographyMaterialProvidersOperations_Compile.__default.InitializeDecryptionMaterials((this).config, input);
    }
    public Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> ValidEncryptionMaterialsTransition(software.amazon.cryptography.materialproviders.internaldafny.types._IValidEncryptionMaterialsTransitionInput input) {
      return AwsCryptographyMaterialProvidersOperations_Compile.__default.ValidEncryptionMaterialsTransition((this).config, input);
    }
    public Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> ValidDecryptionMaterialsTransition(software.amazon.cryptography.materialproviders.internaldafny.types._IValidDecryptionMaterialsTransitionInput input) {
      return AwsCryptographyMaterialProvidersOperations_Compile.__default.ValidDecryptionMaterialsTransition((this).config, input);
    }
    public Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> EncryptionMaterialsHasPlaintextDataKey(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials input) {
      return AwsCryptographyMaterialProvidersOperations_Compile.__default.EncryptionMaterialsHasPlaintextDataKey((this).config, input);
    }
    public Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> DecryptionMaterialsWithPlaintextDataKey(software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials input) {
      return AwsCryptographyMaterialProvidersOperations_Compile.__default.DecryptionMaterialsWithPlaintextDataKey((this).config, input);
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetAlgorithmSuiteInfo(Dafny.ISequence<byte> input) {
      return AwsCryptographyMaterialProvidersOperations_Compile.__default.GetAlgorithmSuiteInfo((this).config, input);
    }
    public Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> ValidAlgorithmSuiteInfo(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo input) {
      return AwsCryptographyMaterialProvidersOperations_Compile.__default.ValidAlgorithmSuiteInfo((this).config, input);
    }
    public Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> ValidateCommitmentPolicyOnEncrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IValidateCommitmentPolicyOnEncryptInput input) {
      return AwsCryptographyMaterialProvidersOperations_Compile.__default.ValidateCommitmentPolicyOnEncrypt((this).config, input);
    }
    public Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> ValidateCommitmentPolicyOnDecrypt(software.amazon.cryptography.materialproviders.internaldafny.types._IValidateCommitmentPolicyOnDecryptInput input) {
      return AwsCryptographyMaterialProvidersOperations_Compile.__default.ValidateCommitmentPolicyOnDecrypt((this).config, input);
    }
    public AwsCryptographyMaterialProvidersOperations_Compile._IConfig _config {get; set;}
    public AwsCryptographyMaterialProvidersOperations_Compile._IConfig config { get {
      return this._config;
    } }
  }

  public partial class __default {
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IMaterialProvidersConfig DefaultMaterialProvidersConfig() {
      return software.amazon.cryptography.materialproviders.internaldafny.types.MaterialProvidersConfig.create();
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> MaterialProviders(software.amazon.cryptography.materialproviders.internaldafny.types._IMaterialProvidersConfig config)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.primitives.internaldafny.types._IError> _1143_maybeCrypto;
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.primitives.internaldafny.types._IError> _out204;
      _out204 = software.amazon.cryptography.primitives.internaldafny.__default.AtomicPrimitives(software.amazon.cryptography.primitives.internaldafny.__default.DefaultCryptoConfig());
      _1143_maybeCrypto = _out204;
      software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _1144_crypto;
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1145_valueOrError0 = default(Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
      _1145_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_1143_maybeCrypto, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_1146_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographyPrimitives(_1146_e);
      })));
      if ((_1145_valueOrError0).IsFailure()) {
        res = (_1145_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient>();
        return res;
      }
      _1144_crypto = (_1145_valueOrError0).Extract();
      software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient _1147_client;
      software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient _nw71 = new software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient();
      _nw71.__ctor(AwsCryptographyMaterialProvidersOperations_Compile.Config.create(_1144_crypto));
      _1147_client = _nw71;
      res = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(_1147_client);
      return res;
      return res;
    }
  }
} // end of namespace software.amazon.cryptography.materialproviders.internaldafny
namespace Structure_Compile {

  public partial class BranchKeyContext {
    private static readonly Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _TYPE = new Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Empty);
    public static Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class BranchKeyItem {
    private static readonly Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> _TYPE = new Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
    public static Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class ActiveBranchKeyItem {
    private static readonly Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> _TYPE = new Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
    public static Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class VersionBranchKeyItem {
    private static readonly Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> _TYPE = new Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
    public static Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class BeaconKeyItem {
    private static readonly Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> _TYPE = new Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
    public static Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class __default {
    public static bool BranchKeyContext_q(Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> m) {
      return (((((((((((((m).Contains(Structure_Compile.__default.BRANCH__KEY__IDENTIFIER__FIELD)) && ((m).Contains(Structure_Compile.__default.TYPE__FIELD))) && ((m).Contains(Structure_Compile.__default.KEY__CREATE__TIME))) && ((m).Contains(Structure_Compile.__default.HIERARCHY__VERSION))) && ((m).Contains(Structure_Compile.__default.TABLE__FIELD))) && ((m).Contains(Structure_Compile.__default.KMS__FIELD))) && (!((m).Keys).Contains(Structure_Compile.__default.BRANCH__KEY__FIELD))) && ((new BigInteger((Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select(m,Structure_Compile.__default.BRANCH__KEY__IDENTIFIER__FIELD)).Count)).Sign == 1)) && ((new BigInteger((Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select(m,Structure_Compile.__default.TYPE__FIELD)).Count)).Sign == 1)) && (Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, bool>>((_1148_m) => Dafny.Helpers.Quantifier<Dafny.ISequence<char>>(((_1148_m).Keys).Elements, true, (((_forall_var_15) => {
        Dafny.ISequence<char> _1149_k = (Dafny.ISequence<char>)_forall_var_15;
        return !(((_1148_m).Keys).Contains(_1149_k)) || (software.amazon.cryptography.services.dynamodb.internaldafny.types.__default.IsValid__AttributeName(_1149_k));
      }))))(m))) && (((m).Contains(Structure_Compile.__default.BRANCH__KEY__ACTIVE__VERSION__FIELD)) == ((true) && ((Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select(m,Structure_Compile.__default.TYPE__FIELD)).Equals(Structure_Compile.__default.BRANCH__KEY__ACTIVE__TYPE))))) && (!((m).Contains(Structure_Compile.__default.BRANCH__KEY__ACTIVE__VERSION__FIELD)) || ((true) && (Dafny.Sequence<char>.IsProperPrefixOf(Structure_Compile.__default.BRANCH__KEY__TYPE__PREFIX, Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select(m,Structure_Compile.__default.BRANCH__KEY__ACTIVE__VERSION__FIELD)))))) && ((!(m).Contains(Structure_Compile.__default.BRANCH__KEY__ACTIVE__VERSION__FIELD)) == (((Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select(m,Structure_Compile.__default.TYPE__FIELD)).Equals(Structure_Compile.__default.BEACON__KEY__TYPE__VALUE)) || (Dafny.Sequence<char>.IsProperPrefixOf(Structure_Compile.__default.BRANCH__KEY__TYPE__PREFIX, Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select(m,Structure_Compile.__default.TYPE__FIELD)))));
    }
    public static Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> ToAttributeMap(Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> encryptionContext, Dafny.ISequence<byte> encryptedKey)
    {
      return Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, Dafny.ISequence<byte>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>((_1150_encryptionContext, _1151_encryptedKey) => ((System.Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>)(() => {
        var _coll4 = new System.Collections.Generic.List<Dafny.Pair<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
        foreach (Dafny.ISequence<char> _compr_4 in (Dafny.Set<Dafny.ISequence<char>>.Difference(Dafny.Set<Dafny.ISequence<char>>.Union((_1150_encryptionContext).Keys, Dafny.Set<Dafny.ISequence<char>>.FromElements(Structure_Compile.__default.BRANCH__KEY__FIELD)), Dafny.Set<Dafny.ISequence<char>>.FromElements(Structure_Compile.__default.TABLE__FIELD))).Elements) {
          Dafny.ISequence<char> _1152_k = (Dafny.ISequence<char>)_compr_4;
          if (software.amazon.cryptography.services.dynamodb.internaldafny.types.__default.IsValid__AttributeName(_1152_k)) {
            if ((Dafny.Set<Dafny.ISequence<char>>.Difference(Dafny.Set<Dafny.ISequence<char>>.Union((_1150_encryptionContext).Keys, Dafny.Set<Dafny.ISequence<char>>.FromElements(Structure_Compile.__default.BRANCH__KEY__FIELD)), Dafny.Set<Dafny.ISequence<char>>.FromElements(Structure_Compile.__default.TABLE__FIELD))).Contains(_1152_k)) {
              _coll4.Add(new Dafny.Pair<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>(_1152_k, (((_1152_k).Equals(Structure_Compile.__default.HIERARCHY__VERSION)) ? (software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_N(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select(_1150_encryptionContext,Structure_Compile.__default.HIERARCHY__VERSION))) : ((((_1152_k).Equals(Structure_Compile.__default.BRANCH__KEY__FIELD)) ? (software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_B(_1151_encryptedKey)) : (software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_S(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select(_1150_encryptionContext,_1152_k))))))));
            }
          }
        }
        return Dafny.Map<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.FromCollection(_coll4);
      }))())(encryptionContext, encryptedKey);
    }
    public static Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> ToBranchKeyContext(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.ISequence<char> logicalKeyStoreName)
    {
      return Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISequence<char>, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>>((_1153_item, _1154_logicalKeyStoreName) => ((System.Func<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>)(() => {
        var _coll5 = new System.Collections.Generic.List<Dafny.Pair<Dafny.ISequence<char>,Dafny.ISequence<char>>>();
        foreach (Dafny.ISequence<char> _compr_5 in (Dafny.Set<Dafny.ISequence<char>>.Union(Dafny.Set<Dafny.ISequence<char>>.Difference((_1153_item).Keys, Dafny.Set<Dafny.ISequence<char>>.FromElements(Structure_Compile.__default.BRANCH__KEY__FIELD)), Dafny.Set<Dafny.ISequence<char>>.FromElements(Structure_Compile.__default.TABLE__FIELD))).Elements) {
          Dafny.ISequence<char> _1155_k = (Dafny.ISequence<char>)_compr_5;
          if ((Dafny.Set<Dafny.ISequence<char>>.Union(Dafny.Set<Dafny.ISequence<char>>.Difference((_1153_item).Keys, Dafny.Set<Dafny.ISequence<char>>.FromElements(Structure_Compile.__default.BRANCH__KEY__FIELD)), Dafny.Set<Dafny.ISequence<char>>.FromElements(Structure_Compile.__default.TABLE__FIELD))).Contains(_1155_k)) {
            _coll5.Add(new Dafny.Pair<Dafny.ISequence<char>,Dafny.ISequence<char>>(_1155_k, (((_1155_k).Equals(Structure_Compile.__default.HIERARCHY__VERSION)) ? ((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(_1153_item,_1155_k)).dtor_N) : ((((_1155_k).Equals(Structure_Compile.__default.TABLE__FIELD)) ? (_1154_logicalKeyStoreName) : ((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(_1153_item,_1155_k)).dtor_S))))));
          }
        }
        return Dafny.Map<Dafny.ISequence<char>,Dafny.ISequence<char>>.FromCollection(_coll5);
      }))())(item, logicalKeyStoreName);
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials, software.amazon.cryptography.keystore.internaldafny.types._IError> ToBranchKeyMaterials(Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> encryptionContext, Dafny.ISequence<byte> plaintextKey)
    {
      Dafny.ISequence<char> _1156_versionInformation = (((encryptionContext).Contains(Structure_Compile.__default.BRANCH__KEY__ACTIVE__VERSION__FIELD)) ? (Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select(encryptionContext,Structure_Compile.__default.BRANCH__KEY__ACTIVE__VERSION__FIELD)) : (Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select(encryptionContext,Structure_Compile.__default.TYPE__FIELD)));
      Dafny.ISequence<char> _1157_branchKeyVersion = (_1156_versionInformation).Drop(new BigInteger((Structure_Compile.__default.BRANCH__KEY__TYPE__PREFIX).Count));
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.keystore.internaldafny.types._IError> _1158_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.keystore.internaldafny.types._IError>(UTF8.__default.Encode(_1157_branchKeyVersion), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError>)((_1159_e) => {
        return software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(_1159_e);
      })));
      if ((_1158_valueOrError0).IsFailure()) {
        return (_1158_valueOrError0).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials>();
      } else {
        Dafny.ISequence<byte> _1160_branchKeyVersionUtf8 = (_1158_valueOrError0).Extract();
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.keystore.internaldafny.types._IError> _1161_valueOrError1 = Structure_Compile.__default.ExtractCustomEncryptionContext(encryptionContext);
        if ((_1161_valueOrError1).IsFailure()) {
          return (_1161_valueOrError1).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials>();
        } else {
          Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _1162_customEncryptionContext = (_1161_valueOrError1).Extract();
          return Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials, software.amazon.cryptography.keystore.internaldafny.types._IError>.create_Success(software.amazon.cryptography.keystore.internaldafny.types.BranchKeyMaterials.create(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select(encryptionContext,Structure_Compile.__default.BRANCH__KEY__IDENTIFIER__FIELD), _1160_branchKeyVersionUtf8, _1162_customEncryptionContext, plaintextKey));
        }
      }
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials, software.amazon.cryptography.keystore.internaldafny.types._IError> ToBeaconKeyMaterials(Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> encryptionContext, Dafny.ISequence<byte> plaintextKey)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.keystore.internaldafny.types._IError> _1163_valueOrError0 = Structure_Compile.__default.ExtractCustomEncryptionContext(encryptionContext);
      if ((_1163_valueOrError0).IsFailure()) {
        return (_1163_valueOrError0).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials>();
      } else {
        Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _1164_customEncryptionContext = (_1163_valueOrError0).Extract();
        return Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials, software.amazon.cryptography.keystore.internaldafny.types._IError>.create_Success(software.amazon.cryptography.keystore.internaldafny.types.BeaconKeyMaterials.create(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select(encryptionContext,Structure_Compile.__default.BRANCH__KEY__IDENTIFIER__FIELD), _1164_customEncryptionContext, Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(plaintextKey), Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>>.create_None()));
      }
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.keystore.internaldafny.types._IError> ExtractCustomEncryptionContext(Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> encryptionContext) {
      Dafny.ISet<_System._ITuple2<Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>>> _1165_encodedEncryptionContext = Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, Dafny.ISet<_System._ITuple2<Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>>>>>((_1166_encryptionContext) => ((System.Func<Dafny.ISet<_System._ITuple2<Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>>>>)(() => {
        var _coll6 = new System.Collections.Generic.List<_System._ITuple2<Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>>>();
        foreach (Dafny.ISequence<char> _compr_6 in (_1166_encryptionContext).Keys.Elements) {
          Dafny.ISequence<char> _1167_k = (Dafny.ISequence<char>)_compr_6;
          if (((_1166_encryptionContext).Contains(_1167_k)) && (Dafny.Sequence<char>.IsProperPrefixOf(Structure_Compile.__default.ENCRYPTION__CONTEXT__PREFIX, _1167_k))) {
            _coll6.Add(_System.Tuple2<Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>>.create(UTF8.__default.Encode((_1167_k).Drop(new BigInteger((Structure_Compile.__default.ENCRYPTION__CONTEXT__PREFIX).Count))), UTF8.__default.Encode(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select(_1166_encryptionContext,_1167_k))));
          }
        }
        return Dafny.Set<_System._ITuple2<Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>>>.FromCollection(_coll6);
      }))())(encryptionContext);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1168_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>(Dafny.Helpers.Id<Func<Dafny.ISet<_System._ITuple2<Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>>>, bool>>((_1169_encodedEncryptionContext) => Dafny.Helpers.Quantifier<_System._ITuple2<Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>>>((_1169_encodedEncryptionContext).Elements, true, (((_forall_var_16) => {
        _System._ITuple2<Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>> _1170_i = (_System._ITuple2<Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>>)_forall_var_16;
        return !((_1169_encodedEncryptionContext).Contains(_1170_i)) || ((((_1170_i).dtor__0).is_Success) && (((_1170_i).dtor__1).is_Success));
      }))))(_1165_encodedEncryptionContext), software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("Unable to encode string")));
      if ((_1168_valueOrError0).IsFailure()) {
        return (_1168_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
      } else {
        return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.keystore.internaldafny.types._IError>.create_Success(Dafny.Helpers.Id<Func<Dafny.ISet<_System._ITuple2<Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>>>, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>>((_1171_encodedEncryptionContext) => ((System.Func<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>)(() => {
  var _coll7 = new System.Collections.Generic.List<Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
  foreach (_System._ITuple2<Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>> _compr_7 in (_1171_encodedEncryptionContext).Elements) {
    _System._ITuple2<Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>> _1172_i = (_System._ITuple2<Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>>)_compr_7;
    if ((_1171_encodedEncryptionContext).Contains(_1172_i)) {
      _coll7.Add(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(((_1172_i).dtor__0).dtor_value, ((_1172_i).dtor__1).dtor_value));
    }
  }
  return Dafny.Map<Dafny.ISequence<byte>,Dafny.ISequence<byte>>.FromCollection(_coll7);
}))())(_1165_encodedEncryptionContext));
      }
    }
    public static Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> DecryptOnlyBranchKeyEncryptionContext(Dafny.ISequence<char> branchKeyId, Dafny.ISequence<char> branchKeyVersion, Dafny.ISequence<char> timestamp, Dafny.ISequence<char> logicalKeyStoreName, Dafny.ISequence<char> kmsKeyArn, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> customEncryptionContext)
    {
      return Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Merge(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.FromElements(new Dafny.Pair<Dafny.ISequence<char>, Dafny.ISequence<char>>(Structure_Compile.__default.BRANCH__KEY__IDENTIFIER__FIELD, branchKeyId), new Dafny.Pair<Dafny.ISequence<char>, Dafny.ISequence<char>>(Structure_Compile.__default.TYPE__FIELD, Dafny.Sequence<char>.Concat(Structure_Compile.__default.BRANCH__KEY__TYPE__PREFIX, branchKeyVersion)), new Dafny.Pair<Dafny.ISequence<char>, Dafny.ISequence<char>>(Structure_Compile.__default.KEY__CREATE__TIME, timestamp), new Dafny.Pair<Dafny.ISequence<char>, Dafny.ISequence<char>>(Structure_Compile.__default.TABLE__FIELD, logicalKeyStoreName), new Dafny.Pair<Dafny.ISequence<char>, Dafny.ISequence<char>>(Structure_Compile.__default.KMS__FIELD, kmsKeyArn), new Dafny.Pair<Dafny.ISequence<char>, Dafny.ISequence<char>>(Structure_Compile.__default.HIERARCHY__VERSION, Dafny.Sequence<char>.FromString("1"))), Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>>((_1173_customEncryptionContext) => ((System.Func<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>)(() => {
        var _coll8 = new System.Collections.Generic.List<Dafny.Pair<Dafny.ISequence<char>,Dafny.ISequence<char>>>();
        foreach (Dafny.ISequence<char> _compr_8 in (_1173_customEncryptionContext).Keys.Elements) {
          Dafny.ISequence<char> _1174_k = (Dafny.ISequence<char>)_compr_8;
          if ((_1173_customEncryptionContext).Contains(_1174_k)) {
            _coll8.Add(new Dafny.Pair<Dafny.ISequence<char>,Dafny.ISequence<char>>(Dafny.Sequence<char>.Concat(Structure_Compile.__default.ENCRYPTION__CONTEXT__PREFIX, _1174_k), Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select(_1173_customEncryptionContext,_1174_k)));
          }
        }
        return Dafny.Map<Dafny.ISequence<char>,Dafny.ISequence<char>>.FromCollection(_coll8);
      }))())(customEncryptionContext));
    }
    public static Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> ActiveBranchKeyEncryptionContext(Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> decryptOnlyEncryptionContext) {
      return Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Merge(decryptOnlyEncryptionContext, Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.FromElements(new Dafny.Pair<Dafny.ISequence<char>, Dafny.ISequence<char>>(Structure_Compile.__default.BRANCH__KEY__ACTIVE__VERSION__FIELD, Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select(decryptOnlyEncryptionContext,Structure_Compile.__default.TYPE__FIELD)), new Dafny.Pair<Dafny.ISequence<char>, Dafny.ISequence<char>>(Structure_Compile.__default.TYPE__FIELD, Structure_Compile.__default.BRANCH__KEY__ACTIVE__TYPE)));
    }
    public static Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> BeaconKeyEncryptionContext(Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> decryptOnlyEncryptionContext) {
      return Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Merge(decryptOnlyEncryptionContext, Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.FromElements(new Dafny.Pair<Dafny.ISequence<char>, Dafny.ISequence<char>>(Structure_Compile.__default.TYPE__FIELD, Structure_Compile.__default.BEACON__KEY__TYPE__VALUE)));
    }
    public static Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> NewVersionFromActiveBranchKeyEncryptionContext(Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> activeBranchKeyEncryptionContext, Dafny.ISequence<char> branchKeyVersion, Dafny.ISequence<char> timestamp)
    {
      return Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Subtract(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Merge(activeBranchKeyEncryptionContext, Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.FromElements(new Dafny.Pair<Dafny.ISequence<char>, Dafny.ISequence<char>>(Structure_Compile.__default.TYPE__FIELD, Dafny.Sequence<char>.Concat(Structure_Compile.__default.BRANCH__KEY__TYPE__PREFIX, branchKeyVersion)), new Dafny.Pair<Dafny.ISequence<char>, Dafny.ISequence<char>>(Structure_Compile.__default.KEY__CREATE__TIME, timestamp))), Dafny.Set<Dafny.ISequence<char>>.FromElements(Structure_Compile.__default.BRANCH__KEY__ACTIVE__VERSION__FIELD));
    }
    public static bool BranchKeyItem_q(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> m) {
      return ((((((((((((((((((((m).Contains(Structure_Compile.__default.BRANCH__KEY__IDENTIFIER__FIELD)) && ((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(m,Structure_Compile.__default.BRANCH__KEY__IDENTIFIER__FIELD)).is_S)) && ((m).Contains(Structure_Compile.__default.TYPE__FIELD))) && ((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(m,Structure_Compile.__default.TYPE__FIELD)).is_S)) && ((m).Contains(Structure_Compile.__default.KEY__CREATE__TIME))) && ((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(m,Structure_Compile.__default.KEY__CREATE__TIME)).is_S)) && ((m).Contains(Structure_Compile.__default.HIERARCHY__VERSION))) && ((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(m,Structure_Compile.__default.HIERARCHY__VERSION)).is_N)) && (!(m).Contains(Structure_Compile.__default.TABLE__FIELD))) && ((m).Contains(Structure_Compile.__default.KMS__FIELD))) && ((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(m,Structure_Compile.__default.KMS__FIELD)).is_S)) && ((m).Contains(Structure_Compile.__default.BRANCH__KEY__FIELD))) && ((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(m,Structure_Compile.__default.BRANCH__KEY__FIELD)).is_B)) && ((new BigInteger(((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(m,Structure_Compile.__default.BRANCH__KEY__IDENTIFIER__FIELD)).dtor_S).Count)).Sign == 1)) && ((new BigInteger(((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(m,Structure_Compile.__default.TYPE__FIELD)).dtor_S).Count)).Sign == 1)) && (Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, bool>>((_1175_m) => Dafny.Helpers.Quantifier<Dafny.ISequence<char>>((Dafny.Set<Dafny.ISequence<char>>.Difference((_1175_m).Keys, Dafny.Set<Dafny.ISequence<char>>.FromElements(Structure_Compile.__default.BRANCH__KEY__FIELD, Structure_Compile.__default.HIERARCHY__VERSION))).Elements, true, (((_forall_var_17) => {
        Dafny.ISequence<char> _1176_k = (Dafny.ISequence<char>)_forall_var_17;
        return !((Dafny.Set<Dafny.ISequence<char>>.Difference((_1175_m).Keys, Dafny.Set<Dafny.ISequence<char>>.FromElements(Structure_Compile.__default.BRANCH__KEY__FIELD, Structure_Compile.__default.HIERARCHY__VERSION))).Contains(_1176_k)) || ((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(_1175_m,_1176_k)).is_S);
      }))))(m))) && (((m).Contains(Structure_Compile.__default.BRANCH__KEY__ACTIVE__VERSION__FIELD)) == ((true) && (((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(m,Structure_Compile.__default.TYPE__FIELD)).dtor_S).Equals(Structure_Compile.__default.BRANCH__KEY__ACTIVE__TYPE))))) && (!((m).Contains(Structure_Compile.__default.BRANCH__KEY__ACTIVE__VERSION__FIELD)) || ((true) && (Dafny.Sequence<char>.IsProperPrefixOf(Structure_Compile.__default.BRANCH__KEY__TYPE__PREFIX, (Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(m,Structure_Compile.__default.BRANCH__KEY__ACTIVE__VERSION__FIELD)).dtor_S))))) && ((!(m).Contains(Structure_Compile.__default.BRANCH__KEY__ACTIVE__VERSION__FIELD)) == ((((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(m,Structure_Compile.__default.TYPE__FIELD)).dtor_S).Equals(Structure_Compile.__default.BEACON__KEY__TYPE__VALUE)) || (Dafny.Sequence<char>.IsProperPrefixOf(Structure_Compile.__default.BRANCH__KEY__TYPE__PREFIX, (Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(m,Structure_Compile.__default.TYPE__FIELD)).dtor_S))))) && (software.amazon.cryptography.services.kms.internaldafny.types.__default.IsValid__CiphertextType((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(m,Structure_Compile.__default.BRANCH__KEY__FIELD)).dtor_B));
    }
    public static bool ActiveBranchKeyItem_q(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> m) {
      return ((((Structure_Compile.__default.BranchKeyItem_q(m)) && (((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(m,Structure_Compile.__default.TYPE__FIELD)).dtor_S).Equals(Structure_Compile.__default.BRANCH__KEY__ACTIVE__TYPE))) && ((m).Contains(Structure_Compile.__default.BRANCH__KEY__ACTIVE__VERSION__FIELD))) && ((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(m,Structure_Compile.__default.BRANCH__KEY__ACTIVE__VERSION__FIELD)).is_S)) && (Dafny.Sequence<char>.IsProperPrefixOf(Structure_Compile.__default.BRANCH__KEY__TYPE__PREFIX, (Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(m,Structure_Compile.__default.BRANCH__KEY__ACTIVE__VERSION__FIELD)).dtor_S));
    }
    public static bool VersionBranchKeyItem_q(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> m) {
      return ((Structure_Compile.__default.BranchKeyItem_q(m)) && (!(m).Contains(Structure_Compile.__default.BRANCH__KEY__ACTIVE__VERSION__FIELD))) && (Dafny.Sequence<char>.IsProperPrefixOf(Structure_Compile.__default.BRANCH__KEY__TYPE__PREFIX, (Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(m,Structure_Compile.__default.TYPE__FIELD)).dtor_S));
    }
    public static bool BeaconKeyItem_q(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> m) {
      return ((Structure_Compile.__default.BranchKeyItem_q(m)) && (!(m).Contains(Structure_Compile.__default.BRANCH__KEY__ACTIVE__VERSION__FIELD))) && (((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(m,Structure_Compile.__default.TYPE__FIELD)).dtor_S).Equals(Structure_Compile.__default.BEACON__KEY__TYPE__VALUE));
    }
    public static Dafny.ISequence<char> BRANCH__KEY__IDENTIFIER__FIELD { get {
      return Dafny.Sequence<char>.FromString("branch-key-id");
    } }
    public static Dafny.ISequence<char> TYPE__FIELD { get {
      return Dafny.Sequence<char>.FromString("type");
    } }
    public static Dafny.ISequence<char> KEY__CREATE__TIME { get {
      return Dafny.Sequence<char>.FromString("create-time");
    } }
    public static Dafny.ISequence<char> HIERARCHY__VERSION { get {
      return Dafny.Sequence<char>.FromString("hierarchy-version");
    } }
    public static Dafny.ISequence<char> TABLE__FIELD { get {
      return Dafny.Sequence<char>.FromString("tablename");
    } }
    public static Dafny.ISequence<char> KMS__FIELD { get {
      return Dafny.Sequence<char>.FromString("kms-arn");
    } }
    public static Dafny.ISequence<char> BRANCH__KEY__FIELD { get {
      return Dafny.Sequence<char>.FromString("enc");
    } }
    public static Dafny.ISequence<char> BRANCH__KEY__ACTIVE__VERSION__FIELD { get {
      return Dafny.Sequence<char>.FromString("version");
    } }
    public static Dafny.ISequence<char> BRANCH__KEY__ACTIVE__TYPE { get {
      return Dafny.Sequence<char>.FromString("branch:ACTIVE");
    } }
    public static Dafny.ISequence<char> BRANCH__KEY__TYPE__PREFIX { get {
      return Dafny.Sequence<char>.FromString("branch:version:");
    } }
    public static Dafny.ISequence<char> BEACON__KEY__TYPE__VALUE { get {
      return Dafny.Sequence<char>.FromString("beacon:ACTIVE");
    } }
    public static Dafny.ISequence<char> ENCRYPTION__CONTEXT__PREFIX { get {
      return Dafny.Sequence<char>.FromString("aws-crypto-ec:");
    } }
    public static BigInteger KMS__GEN__KEY__NO__PLAINTEXT__LENGTH__32 { get {
      return new BigInteger(184);
    } }
  }
} // end of namespace Structure_Compile
namespace KMSKeystoreOperations_Compile {

  public partial class __default {
    public static bool AttemptKmsOperation_q(software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration kmsConfiguration, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> encryptionContext)
    {
      software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration _source33 = kmsConfiguration;
      {
        Dafny.ISequence<char> _1177___mcc_h0 = _source33.dtor_kmsKeyArn;
        Dafny.ISequence<char> _1178_arn = _1177___mcc_h0;
        return (_1178_arn).Equals(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select(encryptionContext,Structure_Compile.__default.KMS__FIELD));
      }
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> GenerateKey(Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> encryptionContext, software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration kmsConfiguration, Dafny.ISequence<Dafny.ISequence<char>> grantTokens, software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient kmsClient)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> res = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.kms.internaldafny.types.GenerateDataKeyWithoutPlaintextResponse.Default());
      software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextRequest _1179_generatorRequest;
      _1179_generatorRequest = software.amazon.cryptography.services.kms.internaldafny.types.GenerateDataKeyWithoutPlaintextRequest.create((kmsConfiguration).dtor_kmsKeyArn, Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>.create_Some(encryptionContext), Wrappers_Compile.Option<software.amazon.cryptography.services.kms.internaldafny.types._IDataKeySpec>.create_None(), Wrappers_Compile.Option<int>.create_Some(32), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.create_Some(grantTokens));
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse, software.amazon.cryptography.services.kms.internaldafny.types._IError> _1180_maybeGenerateResponse;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse, software.amazon.cryptography.services.kms.internaldafny.types._IError> _out205;
      _out205 = (kmsClient).GenerateDataKeyWithoutPlaintext(_1179_generatorRequest);
      _1180_maybeGenerateResponse = _out205;
      software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse _1181_generateResponse;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> _1182_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.kms.internaldafny.types.GenerateDataKeyWithoutPlaintextResponse.Default());
      _1182_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse, software.amazon.cryptography.services.kms.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.keystore.internaldafny.types._IError>(_1180_maybeGenerateResponse, ((System.Func<software.amazon.cryptography.services.kms.internaldafny.types._IError, software.amazon.cryptography.keystore.internaldafny.types._IError>)((_1183_e) => {
        return software.amazon.cryptography.keystore.internaldafny.types.Error.create_ComAmazonawsKms(_1183_e);
      })));
      if ((_1182_valueOrError0).IsFailure()) {
        res = (_1182_valueOrError0).PropagateFailure<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse>();
        return res;
      }
      _1181_generateResponse = (_1182_valueOrError0).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1184_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
      _1184_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>((true) && (((_1181_generateResponse).dtor_KeyId).is_Some), software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("Invalid response from KMS GenerateDataKey:: Invalid Key Id")));
      if ((_1184_valueOrError1).IsFailure()) {
        res = (_1184_valueOrError1).PropagateFailure<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse>();
        return res;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1185_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
      _1185_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>(((((_1181_generateResponse).dtor_CiphertextBlob).is_Some) && ((new BigInteger((((_1181_generateResponse).dtor_CiphertextBlob).dtor_value).Count)) == (Structure_Compile.__default.KMS__GEN__KEY__NO__PLAINTEXT__LENGTH__32))) && (software.amazon.cryptography.services.kms.internaldafny.types.__default.IsValid__CiphertextType(((_1181_generateResponse).dtor_CiphertextBlob).dtor_value)), software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("Invalid response from AWS KMS GeneratedDataKey: Invalid ciphertext")));
      if ((_1185_valueOrError2).IsFailure()) {
        res = (_1185_valueOrError2).PropagateFailure<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse>();
        return res;
      }
      res = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse, software.amazon.cryptography.keystore.internaldafny.types._IError>.create_Success(_1181_generateResponse);
      return res;
      return res;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> ReEncryptKey(Dafny.ISequence<byte> ciphertext, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> sourceEncryptionContext, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> destinationEncryptionContext, software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration kmsConfiguration, Dafny.ISequence<Dafny.ISequence<char>> grantTokens, software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient kmsClient)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> res = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.kms.internaldafny.types.ReEncryptResponse.Default());
      software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptRequest _1186_reEncryptRequest;
      _1186_reEncryptRequest = software.amazon.cryptography.services.kms.internaldafny.types.ReEncryptRequest.create(ciphertext, Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>.create_Some(sourceEncryptionContext), Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some((kmsConfiguration).dtor_kmsKeyArn), (kmsConfiguration).dtor_kmsKeyArn, Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>.create_Some(destinationEncryptionContext), Wrappers_Compile.Option<software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec>.create_None(), Wrappers_Compile.Option<software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec>.create_None(), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.create_Some(grantTokens));
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse, software.amazon.cryptography.services.kms.internaldafny.types._IError> _1187_maybeReEncryptResponse;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse, software.amazon.cryptography.services.kms.internaldafny.types._IError> _out206;
      _out206 = (kmsClient).ReEncrypt(_1186_reEncryptRequest);
      _1187_maybeReEncryptResponse = _out206;
      software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse _1188_reEncryptResponse;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> _1189_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.kms.internaldafny.types.ReEncryptResponse.Default());
      _1189_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse, software.amazon.cryptography.services.kms.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.keystore.internaldafny.types._IError>(_1187_maybeReEncryptResponse, ((System.Func<software.amazon.cryptography.services.kms.internaldafny.types._IError, software.amazon.cryptography.keystore.internaldafny.types._IError>)((_1190_e) => {
        return software.amazon.cryptography.keystore.internaldafny.types.Error.create_ComAmazonawsKms(_1190_e);
      })));
      if ((_1189_valueOrError0).IsFailure()) {
        res = (_1189_valueOrError0).PropagateFailure<software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse>();
        return res;
      }
      _1188_reEncryptResponse = (_1189_valueOrError0).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1191_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
      _1191_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>((((((_1188_reEncryptResponse).dtor_SourceKeyId).is_Some) && (((_1188_reEncryptResponse).dtor_KeyId).is_Some)) && ((((_1188_reEncryptResponse).dtor_SourceKeyId).dtor_value).Equals((kmsConfiguration).dtor_kmsKeyArn))) && ((((_1188_reEncryptResponse).dtor_KeyId).dtor_value).Equals((kmsConfiguration).dtor_kmsKeyArn)), software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("Invalid response from KMS GenerateDataKey:: Invalid Key Id")));
      if ((_1191_valueOrError1).IsFailure()) {
        res = (_1191_valueOrError1).PropagateFailure<software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse>();
        return res;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1192_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
      _1192_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>((((_1188_reEncryptResponse).dtor_CiphertextBlob).is_Some) && (software.amazon.cryptography.services.kms.internaldafny.types.__default.IsValid__CiphertextType(((_1188_reEncryptResponse).dtor_CiphertextBlob).dtor_value)), software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("Invalid response from AWS KMS GeneratedDataKey: Invalid ciphertext")));
      if ((_1192_valueOrError2).IsFailure()) {
        res = (_1192_valueOrError2).PropagateFailure<software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse>();
        return res;
      }
      res = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError>.create_Success(_1188_reEncryptResponse);
      return res;
      return res;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> DecryptKey(Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> encryptionContext, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration kmsConfiguration, Dafny.ISequence<Dafny.ISequence<char>> grantTokens, software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient kmsClient)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.kms.internaldafny.types.DecryptResponse.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.services.kms.internaldafny.types._IError> _1193_maybeDecryptResponse;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.services.kms.internaldafny.types._IError> _out207;
      _out207 = (kmsClient).Decrypt(software.amazon.cryptography.services.kms.internaldafny.types.DecryptRequest.create((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(item,Structure_Compile.__default.BRANCH__KEY__FIELD)).dtor_B, Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>.create_Some(encryptionContext), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.create_Some(grantTokens), Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some((kmsConfiguration).dtor_kmsKeyArn), Wrappers_Compile.Option<software.amazon.cryptography.services.kms.internaldafny.types._IEncryptionAlgorithmSpec>.create_None()));
      _1193_maybeDecryptResponse = _out207;
      software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse _1194_decryptResponse;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> _1195_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.kms.internaldafny.types.DecryptResponse.Default());
      _1195_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.services.kms.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.keystore.internaldafny.types._IError>(_1193_maybeDecryptResponse, ((System.Func<software.amazon.cryptography.services.kms.internaldafny.types._IError, software.amazon.cryptography.keystore.internaldafny.types._IError>)((_1196_e) => {
        return software.amazon.cryptography.keystore.internaldafny.types.Error.create_ComAmazonawsKms(_1196_e);
      })));
      if ((_1195_valueOrError0).IsFailure()) {
        output = (_1195_valueOrError0).PropagateFailure<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse>();
        return output;
      }
      _1194_decryptResponse = (_1195_valueOrError0).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1197_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
      _1197_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>((((_1194_decryptResponse).dtor_Plaintext).is_Some) && ((new BigInteger(32)) == (new BigInteger((((_1194_decryptResponse).dtor_Plaintext).dtor_value).Count))), software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("Invalid response from AWS KMS Decrypt: Key is not 32 bytes.")));
      if ((_1197_valueOrError1).IsFailure()) {
        output = (_1197_valueOrError1).PropagateFailure<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse>();
        return output;
      }
      output = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError>.create_Success(_1194_decryptResponse);
      return output;
    }
  }
} // end of namespace KMSKeystoreOperations_Compile
namespace DDBKeystoreOperations_Compile {

  public interface _IConditionExpression {
    bool is_BRANCH__KEY__NOT__EXIST { get; }
    bool is_BRANCH__KEY__EXISTS { get; }
    _IConditionExpression DowncastClone();
  }
  public abstract class ConditionExpression : _IConditionExpression {
    public ConditionExpression() { }
    private static readonly DDBKeystoreOperations_Compile._IConditionExpression theDefault = create_BRANCH__KEY__NOT__EXIST();
    public static DDBKeystoreOperations_Compile._IConditionExpression Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<DDBKeystoreOperations_Compile._IConditionExpression> _TYPE = new Dafny.TypeDescriptor<DDBKeystoreOperations_Compile._IConditionExpression>(DDBKeystoreOperations_Compile.ConditionExpression.Default());
    public static Dafny.TypeDescriptor<DDBKeystoreOperations_Compile._IConditionExpression> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IConditionExpression create_BRANCH__KEY__NOT__EXIST() {
      return new ConditionExpression_BRANCH__KEY__NOT__EXIST();
    }
    public static _IConditionExpression create_BRANCH__KEY__EXISTS() {
      return new ConditionExpression_BRANCH__KEY__EXISTS();
    }
    public bool is_BRANCH__KEY__NOT__EXIST { get { return this is ConditionExpression_BRANCH__KEY__NOT__EXIST; } }
    public bool is_BRANCH__KEY__EXISTS { get { return this is ConditionExpression_BRANCH__KEY__EXISTS; } }
    public static System.Collections.Generic.IEnumerable<_IConditionExpression> AllSingletonConstructors {
      get {
        yield return ConditionExpression.create_BRANCH__KEY__NOT__EXIST();
        yield return ConditionExpression.create_BRANCH__KEY__EXISTS();
      }
    }
    public abstract _IConditionExpression DowncastClone();
  }
  public class ConditionExpression_BRANCH__KEY__NOT__EXIST : ConditionExpression {
    public ConditionExpression_BRANCH__KEY__NOT__EXIST() {
    }
    public override _IConditionExpression DowncastClone() {
      if (this is _IConditionExpression dt) { return dt; }
      return new ConditionExpression_BRANCH__KEY__NOT__EXIST();
    }
    public override bool Equals(object other) {
      var oth = other as DDBKeystoreOperations_Compile.ConditionExpression_BRANCH__KEY__NOT__EXIST;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DDBKeystoreOperations_Compile.ConditionExpression.BRANCH_KEY_NOT_EXIST";
      return s;
    }
  }
  public class ConditionExpression_BRANCH__KEY__EXISTS : ConditionExpression {
    public ConditionExpression_BRANCH__KEY__EXISTS() {
    }
    public override _IConditionExpression DowncastClone() {
      if (this is _IConditionExpression dt) { return dt; }
      return new ConditionExpression_BRANCH__KEY__EXISTS();
    }
    public override bool Equals(object other) {
      var oth = other as DDBKeystoreOperations_Compile.ConditionExpression_BRANCH__KEY__EXISTS;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DDBKeystoreOperations_Compile.ConditionExpression.BRANCH_KEY_EXISTS";
      return s;
    }
  }

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> WriteNewKeyToStore(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> versionBranchKeyItem, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> activeBranchKeyItem, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> beaconKeyItem, Dafny.ISequence<char> tableName, software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient ddbClient)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.dynamodb.internaldafny.types.TransactWriteItemsOutput.Default());
      Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItem> _1198_items;
      _1198_items = Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItem>.FromElements(DDBKeystoreOperations_Compile.__default.CreateTransactWritePutItem(versionBranchKeyItem, tableName, DDBKeystoreOperations_Compile.ConditionExpression.create_BRANCH__KEY__NOT__EXIST()), DDBKeystoreOperations_Compile.__default.CreateTransactWritePutItem(activeBranchKeyItem, tableName, DDBKeystoreOperations_Compile.ConditionExpression.create_BRANCH__KEY__NOT__EXIST()), DDBKeystoreOperations_Compile.__default.CreateTransactWritePutItem(beaconKeyItem, tableName, DDBKeystoreOperations_Compile.ConditionExpression.create_BRANCH__KEY__NOT__EXIST()));
      software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput _1199_transactRequest;
      _1199_transactRequest = software.amazon.cryptography.services.dynamodb.internaldafny.types.TransactWriteItemsInput.create(_1198_items, Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IReturnConsumedCapacity>.create_None(), Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IReturnItemCollectionMetrics>.create_None(), Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None());
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IError> _1200_maybeTransactWriteResponse;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IError> _out208;
      _out208 = (ddbClient).TransactWriteItems(_1199_transactRequest);
      _1200_maybeTransactWriteResponse = _out208;
      software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput _1201_transactWriteItemsResponse;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _1202_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.dynamodb.internaldafny.types.TransactWriteItemsOutput.Default());
      _1202_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.keystore.internaldafny.types._IError>(_1200_maybeTransactWriteResponse, ((System.Func<software.amazon.cryptography.services.dynamodb.internaldafny.types._IError, software.amazon.cryptography.keystore.internaldafny.types._IError>)((_1203_e) => {
        return software.amazon.cryptography.keystore.internaldafny.types.Error.create_ComAmazonawsDynamodb(_1203_e);
      })));
      if ((_1202_valueOrError0).IsFailure()) {
        output = (_1202_valueOrError0).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput>();
        return output;
      }
      _1201_transactWriteItemsResponse = (_1202_valueOrError0).Extract();
      output = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.create_Success(_1201_transactWriteItemsResponse);
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> WriteNewBranchKeyVersionToKeystore(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> versionBranchKeyItem, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> activeBranchKeyItem, Dafny.ISequence<char> tableName, software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient ddbClient)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.dynamodb.internaldafny.types.TransactWriteItemsOutput.Default());
      Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItem> _1204_items;
      _1204_items = Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItem>.FromElements(DDBKeystoreOperations_Compile.__default.CreateTransactWritePutItem(versionBranchKeyItem, tableName, DDBKeystoreOperations_Compile.ConditionExpression.create_BRANCH__KEY__NOT__EXIST()), DDBKeystoreOperations_Compile.__default.CreateTransactWritePutItem(activeBranchKeyItem, tableName, DDBKeystoreOperations_Compile.ConditionExpression.create_BRANCH__KEY__EXISTS()));
      software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput _1205_transactRequest;
      _1205_transactRequest = software.amazon.cryptography.services.dynamodb.internaldafny.types.TransactWriteItemsInput.create(_1204_items, Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IReturnConsumedCapacity>.create_None(), Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IReturnItemCollectionMetrics>.create_None(), Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None());
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IError> _1206_maybeTransactWriteResponse;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IError> _out209;
      _out209 = (ddbClient).TransactWriteItems(_1205_transactRequest);
      _1206_maybeTransactWriteResponse = _out209;
      software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput _1207_transactWriteItemsResponse;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _1208_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.dynamodb.internaldafny.types.TransactWriteItemsOutput.Default());
      _1208_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.keystore.internaldafny.types._IError>(_1206_maybeTransactWriteResponse, ((System.Func<software.amazon.cryptography.services.dynamodb.internaldafny.types._IError, software.amazon.cryptography.keystore.internaldafny.types._IError>)((_1209_e) => {
        return software.amazon.cryptography.keystore.internaldafny.types.Error.create_ComAmazonawsDynamodb(_1209_e);
      })));
      if ((_1208_valueOrError0).IsFailure()) {
        output = (_1208_valueOrError0).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput>();
        return output;
      }
      _1207_transactWriteItemsResponse = (_1208_valueOrError0).Extract();
      output = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.create_Success(_1207_transactWriteItemsResponse);
      return output;
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError> GetActiveBranchKeyItem(Dafny.ISequence<char> branchKeyIdentifier, Dafny.ISequence<char> tableName, software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient ddbClient)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError>);
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _1210_dynamoDbKey;
      _1210_dynamoDbKey = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.FromElements(new Dafny.Pair<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>(Structure_Compile.__default.BRANCH__KEY__IDENTIFIER__FIELD, software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_S(branchKeyIdentifier)), new Dafny.Pair<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>(Structure_Compile.__default.TYPE__FIELD, software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_S(Structure_Compile.__default.BRANCH__KEY__ACTIVE__TYPE)));
      software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemInput _1211_ItemRequest;
      _1211_ItemRequest = software.amazon.cryptography.services.dynamodb.internaldafny.types.GetItemInput.create(tableName, _1210_dynamoDbKey, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.create_None(), Wrappers_Compile.Option<bool>.create_None(), Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IReturnConsumedCapacity>.create_None(), Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None(), Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>.create_None());
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IError> _1212_maybeGetItem;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IError> _out210;
      _out210 = (ddbClient).GetItem(_1211_ItemRequest);
      _1212_maybeGetItem = _out210;
      software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput _1213_getItemResponse;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _1214_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.dynamodb.internaldafny.types.GetItemOutput.Default());
      _1214_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.keystore.internaldafny.types._IError>(_1212_maybeGetItem, ((System.Func<software.amazon.cryptography.services.dynamodb.internaldafny.types._IError, software.amazon.cryptography.keystore.internaldafny.types._IError>)((_1215_e) => {
        return software.amazon.cryptography.keystore.internaldafny.types.Error.create_ComAmazonawsDynamodb(_1215_e);
      })));
      if ((_1214_valueOrError0).IsFailure()) {
        output = (_1214_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
        return output;
      }
      _1213_getItemResponse = (_1214_valueOrError0).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1216_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
      _1216_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>(((_1213_getItemResponse).dtor_Item).is_Some, software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("No item found for corresponding branch key identifier.")));
      if ((_1216_valueOrError1).IsFailure()) {
        output = (_1216_valueOrError1).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1217_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
      _1217_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>((Structure_Compile.__default.ActiveBranchKeyItem_q(((_1213_getItemResponse).dtor_Item).dtor_value)) && (((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(((_1213_getItemResponse).dtor_Item).dtor_value,Structure_Compile.__default.BRANCH__KEY__IDENTIFIER__FIELD)).dtor_S).Equals(branchKeyIdentifier)), software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("Item found is not a valid active branch key.")));
      if ((_1217_valueOrError2).IsFailure()) {
        output = (_1217_valueOrError2).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
        return output;
      }
      output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError>.create_Success(((_1213_getItemResponse).dtor_Item).dtor_value);
      return output;
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError> GetVersionBranchKeyItem(Dafny.ISequence<char> branchKeyIdentifier, Dafny.ISequence<char> branchKeyVersion, Dafny.ISequence<char> tableName, software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient ddbClient)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError>);
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _1218_dynamoDbKey;
      _1218_dynamoDbKey = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.FromElements(new Dafny.Pair<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>(Structure_Compile.__default.BRANCH__KEY__IDENTIFIER__FIELD, software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_S(branchKeyIdentifier)), new Dafny.Pair<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>(Structure_Compile.__default.TYPE__FIELD, software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_S(Dafny.Sequence<char>.Concat(Structure_Compile.__default.BRANCH__KEY__TYPE__PREFIX, branchKeyVersion))));
      software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemInput _1219_ItemRequest;
      _1219_ItemRequest = software.amazon.cryptography.services.dynamodb.internaldafny.types.GetItemInput.create(tableName, _1218_dynamoDbKey, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.create_None(), Wrappers_Compile.Option<bool>.create_None(), Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IReturnConsumedCapacity>.create_None(), Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None(), Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>.create_None());
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IError> _1220_maybeGetItem;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IError> _out211;
      _out211 = (ddbClient).GetItem(_1219_ItemRequest);
      _1220_maybeGetItem = _out211;
      software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput _1221_getItemResponse;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _1222_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.dynamodb.internaldafny.types.GetItemOutput.Default());
      _1222_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.keystore.internaldafny.types._IError>(_1220_maybeGetItem, ((System.Func<software.amazon.cryptography.services.dynamodb.internaldafny.types._IError, software.amazon.cryptography.keystore.internaldafny.types._IError>)((_1223_e) => {
        return software.amazon.cryptography.keystore.internaldafny.types.Error.create_ComAmazonawsDynamodb(_1223_e);
      })));
      if ((_1222_valueOrError0).IsFailure()) {
        output = (_1222_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
        return output;
      }
      _1221_getItemResponse = (_1222_valueOrError0).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1224_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
      _1224_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>(((_1221_getItemResponse).dtor_Item).is_Some, software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("No item found for corresponding branch key identifier.")));
      if ((_1224_valueOrError1).IsFailure()) {
        output = (_1224_valueOrError1).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1225_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
      _1225_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>(((Structure_Compile.__default.VersionBranchKeyItem_q(((_1221_getItemResponse).dtor_Item).dtor_value)) && (((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(((_1221_getItemResponse).dtor_Item).dtor_value,Structure_Compile.__default.BRANCH__KEY__IDENTIFIER__FIELD)).dtor_S).Equals(branchKeyIdentifier))) && (((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(((_1221_getItemResponse).dtor_Item).dtor_value,Structure_Compile.__default.TYPE__FIELD)).dtor_S).Equals(Dafny.Sequence<char>.Concat(Structure_Compile.__default.BRANCH__KEY__TYPE__PREFIX, branchKeyVersion))), software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("Item found is not a valid branch key version.")));
      if ((_1225_valueOrError2).IsFailure()) {
        output = (_1225_valueOrError2).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
        return output;
      }
      output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError>.create_Success(((_1221_getItemResponse).dtor_Item).dtor_value);
      return output;
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError> GetBeaconKeyItem(Dafny.ISequence<char> branchKeyIdentifier, Dafny.ISequence<char> tableName, software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient ddbClient)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError>);
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _1226_dynamoDbKey;
      _1226_dynamoDbKey = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.FromElements(new Dafny.Pair<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>(Structure_Compile.__default.BRANCH__KEY__IDENTIFIER__FIELD, software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_S(branchKeyIdentifier)), new Dafny.Pair<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>(Structure_Compile.__default.TYPE__FIELD, software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_S(Structure_Compile.__default.BEACON__KEY__TYPE__VALUE)));
      software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemInput _1227_ItemRequest;
      _1227_ItemRequest = software.amazon.cryptography.services.dynamodb.internaldafny.types.GetItemInput.create(tableName, _1226_dynamoDbKey, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.create_None(), Wrappers_Compile.Option<bool>.create_None(), Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IReturnConsumedCapacity>.create_None(), Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None(), Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>.create_None());
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IError> _1228_maybeGetItem;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IError> _out212;
      _out212 = (ddbClient).GetItem(_1227_ItemRequest);
      _1228_maybeGetItem = _out212;
      software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput _1229_getItemResponse;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _1230_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.dynamodb.internaldafny.types.GetItemOutput.Default());
      _1230_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.keystore.internaldafny.types._IError>(_1228_maybeGetItem, ((System.Func<software.amazon.cryptography.services.dynamodb.internaldafny.types._IError, software.amazon.cryptography.keystore.internaldafny.types._IError>)((_1231_e) => {
        return software.amazon.cryptography.keystore.internaldafny.types.Error.create_ComAmazonawsDynamodb(_1231_e);
      })));
      if ((_1230_valueOrError0).IsFailure()) {
        output = (_1230_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
        return output;
      }
      _1229_getItemResponse = (_1230_valueOrError0).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1232_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
      _1232_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>(((_1229_getItemResponse).dtor_Item).is_Some, software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("No item found for corresponding branch key identifier.")));
      if ((_1232_valueOrError1).IsFailure()) {
        output = (_1232_valueOrError1).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1233_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
      _1233_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>((Structure_Compile.__default.BeaconKeyItem_q(((_1229_getItemResponse).dtor_Item).dtor_value)) && (((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(((_1229_getItemResponse).dtor_Item).dtor_value,Structure_Compile.__default.BRANCH__KEY__IDENTIFIER__FIELD)).dtor_S).Equals(branchKeyIdentifier)), software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("Item found is not a valid beacon key.")));
      if ((_1233_valueOrError2).IsFailure()) {
        output = (_1233_valueOrError2).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
        return output;
      }
      output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError>.create_Success(((_1229_getItemResponse).dtor_Item).dtor_value);
      return output;
    }
    public static software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItem CreateTransactWritePutItem(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.ISequence<char> tableName, DDBKeystoreOperations_Compile._IConditionExpression ConditionExpression)
    {
      return software.amazon.cryptography.services.dynamodb.internaldafny.types.TransactWriteItem.create(Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IConditionCheck>.create_None(), Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IPut>.create_Some(software.amazon.cryptography.services.dynamodb.internaldafny.types.Put.create(item, tableName, Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some(((System.Func<DDBKeystoreOperations_Compile._IConditionExpression, Dafny.ISequence<char>>)((_source34) => {
  if (_source34.is_BRANCH__KEY__NOT__EXIST) {
    return DDBKeystoreOperations_Compile.__default.BRANCH__KEY__NOT__EXIST__CONDITION;
  } else {
    return DDBKeystoreOperations_Compile.__default.BRANCH__KEY__EXISTS__CONDITION;
  }
}))(ConditionExpression)), Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>.create_Some(DDBKeystoreOperations_Compile.__default.BRANCH__KEY__EXISTS__EXPRESSION__ATTRIBUTE__NAMES), Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.create_None(), Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IReturnValuesOnConditionCheckFailure>.create_None())), Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IDelete>.create_None(), Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdate>.create_None());
    }
    public static Dafny.ISequence<char> BRANCH__KEY__EXISTS__EXPRESSION__ATTRIBUTE__NAME { get {
      return Dafny.Sequence<char>.FromString("#BranchKeyIdentifierField");
    } }
    public static Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> BRANCH__KEY__EXISTS__EXPRESSION__ATTRIBUTE__NAMES { get {
      return Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.FromElements(new Dafny.Pair<Dafny.ISequence<char>, Dafny.ISequence<char>>(DDBKeystoreOperations_Compile.__default.BRANCH__KEY__EXISTS__EXPRESSION__ATTRIBUTE__NAME, Structure_Compile.__default.BRANCH__KEY__IDENTIFIER__FIELD));
    } }
    public static Dafny.ISequence<char> BRANCH__KEY__NOT__EXIST__CONDITION { get {
      return Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("attribute_not_exists("), DDBKeystoreOperations_Compile.__default.BRANCH__KEY__EXISTS__EXPRESSION__ATTRIBUTE__NAME), Dafny.Sequence<char>.FromString(")"));
    } }
    public static Dafny.ISequence<char> BRANCH__KEY__EXISTS__CONDITION { get {
      return Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("attribute_exists("), DDBKeystoreOperations_Compile.__default.BRANCH__KEY__EXISTS__EXPRESSION__ATTRIBUTE__NAME), Dafny.Sequence<char>.FromString(")"));
    } }
  }
} // end of namespace DDBKeystoreOperations_Compile
namespace CreateKeys_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> CreateBranchAndBeaconKeys(Dafny.ISequence<char> branchKeyIdentifier, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> customEncryptionContext, Dafny.ISequence<char> timestamp, Dafny.ISequence<char> branchKeyVersion, Dafny.ISequence<char> ddbTableName, Dafny.ISequence<char> logicalKeyStoreName, software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration kmsConfiguration, Dafny.ISequence<Dafny.ISequence<char>> grantTokens, software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient kmsClient, software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient ddbClient)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.CreateKeyOutput.Default());
      Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _1234_decryptOnlyEncryptionContext;
      _1234_decryptOnlyEncryptionContext = Structure_Compile.__default.DecryptOnlyBranchKeyEncryptionContext(branchKeyIdentifier, branchKeyVersion, timestamp, logicalKeyStoreName, (kmsConfiguration).dtor_kmsKeyArn, customEncryptionContext);
      Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _1235_activeEncryptionContext;
      _1235_activeEncryptionContext = Structure_Compile.__default.ActiveBranchKeyEncryptionContext(_1234_decryptOnlyEncryptionContext);
      Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _1236_beaconEncryptionContext;
      _1236_beaconEncryptionContext = Structure_Compile.__default.BeaconKeyEncryptionContext(_1234_decryptOnlyEncryptionContext);
      software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse _1237_wrappedDecryptOnlyBranchKey;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> _1238_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.kms.internaldafny.types.GenerateDataKeyWithoutPlaintextResponse.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> _out213;
      _out213 = KMSKeystoreOperations_Compile.__default.GenerateKey(_1234_decryptOnlyEncryptionContext, kmsConfiguration, grantTokens, kmsClient);
      _1238_valueOrError0 = _out213;
      if ((_1238_valueOrError0).IsFailure()) {
        output = (_1238_valueOrError0).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput>();
        return output;
      }
      _1237_wrappedDecryptOnlyBranchKey = (_1238_valueOrError0).Extract();
      software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse _1239_wrappedActiveBranchKey;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> _1240_valueOrError1 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.kms.internaldafny.types.ReEncryptResponse.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> _out214;
      _out214 = KMSKeystoreOperations_Compile.__default.ReEncryptKey(((_1237_wrappedDecryptOnlyBranchKey).dtor_CiphertextBlob).dtor_value, _1234_decryptOnlyEncryptionContext, _1235_activeEncryptionContext, kmsConfiguration, grantTokens, kmsClient);
      _1240_valueOrError1 = _out214;
      if ((_1240_valueOrError1).IsFailure()) {
        output = (_1240_valueOrError1).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput>();
        return output;
      }
      _1239_wrappedActiveBranchKey = (_1240_valueOrError1).Extract();
      software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse _1241_wrappedBeaconKey;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> _1242_valueOrError2 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.kms.internaldafny.types.GenerateDataKeyWithoutPlaintextResponse.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> _out215;
      _out215 = KMSKeystoreOperations_Compile.__default.GenerateKey(_1236_beaconEncryptionContext, kmsConfiguration, grantTokens, kmsClient);
      _1242_valueOrError2 = _out215;
      if ((_1242_valueOrError2).IsFailure()) {
        output = (_1242_valueOrError2).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput>();
        return output;
      }
      _1241_wrappedBeaconKey = (_1242_valueOrError2).Extract();
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _1243_decryptOnlyBranchKeyItem;
      _1243_decryptOnlyBranchKeyItem = Structure_Compile.__default.ToAttributeMap(_1234_decryptOnlyEncryptionContext, ((_1237_wrappedDecryptOnlyBranchKey).dtor_CiphertextBlob).dtor_value);
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _1244_activeBranchKeyItem;
      _1244_activeBranchKeyItem = Structure_Compile.__default.ToAttributeMap(_1235_activeEncryptionContext, ((_1239_wrappedActiveBranchKey).dtor_CiphertextBlob).dtor_value);
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _1245_beaconKeyItem;
      _1245_beaconKeyItem = Structure_Compile.__default.ToAttributeMap(_1236_beaconEncryptionContext, ((_1241_wrappedBeaconKey).dtor_CiphertextBlob).dtor_value);
      software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput _1246___v0;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _1247_valueOrError3 = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.dynamodb.internaldafny.types.TransactWriteItemsOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _out216;
      _out216 = DDBKeystoreOperations_Compile.__default.WriteNewKeyToStore(_1243_decryptOnlyBranchKeyItem, _1244_activeBranchKeyItem, _1245_beaconKeyItem, ddbTableName, ddbClient);
      _1247_valueOrError3 = _out216;
      if ((_1247_valueOrError3).IsFailure()) {
        output = (_1247_valueOrError3).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput>();
        return output;
      }
      _1246___v0 = (_1247_valueOrError3).Extract();
      output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.create_Success(software.amazon.cryptography.keystore.internaldafny.types.CreateKeyOutput.create(branchKeyIdentifier));
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> VersionActiveBranchKey(software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyInput input, Dafny.ISequence<char> timestamp, Dafny.ISequence<char> branchKeyVersion, Dafny.ISequence<char> ddbTableName, Dafny.ISequence<char> logicalKeyStoreName, software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration kmsConfiguration, Dafny.ISequence<Dafny.ISequence<char>> grantTokens, software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient kmsClient, software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient ddbClient)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.VersionKeyOutput.Default());
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _1248_oldActiveItem;
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError> _1249_valueOrError0 = default(Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError>);
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError> _out217;
      _out217 = DDBKeystoreOperations_Compile.__default.GetActiveBranchKeyItem((input).dtor_branchKeyIdentifier, ddbTableName, ddbClient);
      _1249_valueOrError0 = _out217;
      if ((_1249_valueOrError0).IsFailure()) {
        output = (_1249_valueOrError0).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput>();
        return output;
      }
      _1248_oldActiveItem = (_1249_valueOrError0).Extract();
      Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _1250_oldActiveEncryptionContext;
      _1250_oldActiveEncryptionContext = Structure_Compile.__default.ToBranchKeyContext(_1248_oldActiveItem, logicalKeyStoreName);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1251_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
      _1251_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>((true) && (KMSKeystoreOperations_Compile.__default.AttemptKmsOperation_q(kmsConfiguration, _1250_oldActiveEncryptionContext)), software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("Wrapping AWS KMS key in dynamodb does not match configured AWS KMS information.")));
      if ((_1251_valueOrError1).IsFailure()) {
        output = (_1251_valueOrError1).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput>();
        return output;
      }
      software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse _1252___v1;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> _1253_valueOrError2 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.kms.internaldafny.types.ReEncryptResponse.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> _out218;
      _out218 = KMSKeystoreOperations_Compile.__default.ReEncryptKey((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(_1248_oldActiveItem,Structure_Compile.__default.BRANCH__KEY__FIELD)).dtor_B, _1250_oldActiveEncryptionContext, _1250_oldActiveEncryptionContext, kmsConfiguration, grantTokens, kmsClient);
      _1253_valueOrError2 = _out218;
      if ((_1253_valueOrError2).IsFailure()) {
        output = (_1253_valueOrError2).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput>();
        return output;
      }
      _1252___v1 = (_1253_valueOrError2).Extract();
      Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _1254_decryptOnlyEncryptionContext;
      _1254_decryptOnlyEncryptionContext = Structure_Compile.__default.NewVersionFromActiveBranchKeyEncryptionContext(_1250_oldActiveEncryptionContext, branchKeyVersion, timestamp);
      Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _1255_activeEncryptionContext;
      _1255_activeEncryptionContext = Structure_Compile.__default.ActiveBranchKeyEncryptionContext(_1254_decryptOnlyEncryptionContext);
      software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse _1256_wrappedDecryptOnlyBranchKey;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> _1257_valueOrError3 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.kms.internaldafny.types.GenerateDataKeyWithoutPlaintextResponse.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IGenerateDataKeyWithoutPlaintextResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> _out219;
      _out219 = KMSKeystoreOperations_Compile.__default.GenerateKey(_1254_decryptOnlyEncryptionContext, kmsConfiguration, grantTokens, kmsClient);
      _1257_valueOrError3 = _out219;
      if ((_1257_valueOrError3).IsFailure()) {
        output = (_1257_valueOrError3).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput>();
        return output;
      }
      _1256_wrappedDecryptOnlyBranchKey = (_1257_valueOrError3).Extract();
      software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse _1258_wrappedActiveBranchKey;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> _1259_valueOrError4 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.kms.internaldafny.types.ReEncryptResponse.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IReEncryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> _out220;
      _out220 = KMSKeystoreOperations_Compile.__default.ReEncryptKey(((_1256_wrappedDecryptOnlyBranchKey).dtor_CiphertextBlob).dtor_value, _1254_decryptOnlyEncryptionContext, _1255_activeEncryptionContext, kmsConfiguration, grantTokens, kmsClient);
      _1259_valueOrError4 = _out220;
      if ((_1259_valueOrError4).IsFailure()) {
        output = (_1259_valueOrError4).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput>();
        return output;
      }
      _1258_wrappedActiveBranchKey = (_1259_valueOrError4).Extract();
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _1260_decryptOnlyBranchKeyItem;
      _1260_decryptOnlyBranchKeyItem = Structure_Compile.__default.ToAttributeMap(_1254_decryptOnlyEncryptionContext, ((_1256_wrappedDecryptOnlyBranchKey).dtor_CiphertextBlob).dtor_value);
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _1261_activeBranchKeyItem;
      _1261_activeBranchKeyItem = Structure_Compile.__default.ToAttributeMap(_1255_activeEncryptionContext, ((_1258_wrappedActiveBranchKey).dtor_CiphertextBlob).dtor_value);
      software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput _1262___v2;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _1263_valueOrError5 = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.dynamodb.internaldafny.types.TransactWriteItemsOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _out221;
      _out221 = DDBKeystoreOperations_Compile.__default.WriteNewBranchKeyVersionToKeystore(_1260_decryptOnlyBranchKeyItem, _1261_activeBranchKeyItem, ddbTableName, ddbClient);
      _1263_valueOrError5 = _out221;
      if ((_1263_valueOrError5).IsFailure()) {
        output = (_1263_valueOrError5).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput>();
        return output;
      }
      _1262___v2 = (_1263_valueOrError5).Extract();
      output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.create_Success(software.amazon.cryptography.keystore.internaldafny.types.VersionKeyOutput.create());
      return output;
    }
  }
} // end of namespace CreateKeys_Compile
namespace CreateKeyStoreTable_Compile {

  public partial class keyStoreDescription {
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITableDescription> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITableDescription>(software.amazon.cryptography.services.dynamodb.internaldafny.types.TableDescription.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITableDescription> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class __default {
    public static bool keyStoreHasExpectedConstruction_q(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITableDescription t) {
      return (((((((t).dtor_AttributeDefinitions).is_Some) && (((t).dtor_KeySchema).is_Some)) && (((t).dtor_TableName).is_Some)) && (((t).dtor_TableArn).is_Some)) && (Dafny.Set<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeDefinition>.IsSubsetOf(Seq_Compile.__default.ToSet<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeDefinition>(CreateKeyStoreTable_Compile.__default.ATTRIBUTE__DEFINITIONS), Seq_Compile.__default.ToSet<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeDefinition>(((t).dtor_AttributeDefinitions).dtor_value)))) && (Dafny.Set<software.amazon.cryptography.services.dynamodb.internaldafny.types._IKeySchemaElement>.IsSubsetOf(Seq_Compile.__default.ToSet<software.amazon.cryptography.services.dynamodb.internaldafny.types._IKeySchemaElement>(CreateKeyStoreTable_Compile.__default.KEY__SCHEMA), Seq_Compile.__default.ToSet<software.amazon.cryptography.services.dynamodb.internaldafny.types._IKeySchemaElement>(((t).dtor_KeySchema).dtor_value)));
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError> CreateKeyStoreTable(Dafny.ISequence<char> tableName, software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient ddbClient)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError> res = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IDescribeTableOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IError> _1264_maybeDescribeTableResponse;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IDescribeTableOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IError> _out222;
      _out222 = (ddbClient).DescribeTable(software.amazon.cryptography.services.dynamodb.internaldafny.types.DescribeTableInput.create(tableName));
      _1264_maybeDescribeTableResponse = _out222;
      if ((_1264_maybeDescribeTableResponse).is_Failure) {
        software.amazon.cryptography.services.dynamodb.internaldafny.types._IError _1265_error;
        _1265_error = (_1264_maybeDescribeTableResponse).dtor_error;
        if ((_1265_error).is_ResourceNotFoundException) {
          Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._ICreateTableOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IError> _1266_maybeCreateTableResponse;
          Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._ICreateTableOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IError> _out223;
          _out223 = (ddbClient).CreateTable(software.amazon.cryptography.services.dynamodb.internaldafny.types.CreateTableInput.create(CreateKeyStoreTable_Compile.__default.ATTRIBUTE__DEFINITIONS, tableName, CreateKeyStoreTable_Compile.__default.KEY__SCHEMA, Wrappers_Compile.Option<Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._ILocalSecondaryIndex>>.create_None(), Wrappers_Compile.Option<Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IGlobalSecondaryIndex>>.create_None(), Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IBillingMode>.create_Some(software.amazon.cryptography.services.dynamodb.internaldafny.types.BillingMode.create_PAY__PER__REQUEST()), Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IProvisionedThroughput>.create_None(), Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IStreamSpecification>.create_None(), Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._ISSESpecification>.create_None(), Wrappers_Compile.Option<Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITag>>.create_None(), Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITableClass>.create_None()));
          _1266_maybeCreateTableResponse = _out223;
          if ((_1266_maybeCreateTableResponse).is_Failure) {
            res = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.keystore.internaldafny.types.Error.create_ComAmazonawsDynamodb((_1266_maybeCreateTableResponse).dtor_error));
          } else {
            Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1267_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
            _1267_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>(((((_1266_maybeCreateTableResponse).dtor_value).dtor_TableDescription).is_Some) && (CreateKeyStoreTable_Compile.__default.keyStoreHasExpectedConstruction_q((((_1266_maybeCreateTableResponse).dtor_value).dtor_TableDescription).dtor_value)), CreateKeyStoreTable_Compile.__default.E(Dafny.Sequence<char>.FromString("Configured table name does not conform to expected Key Store construction.")));
            if ((_1267_valueOrError0).IsFailure()) {
              res = (_1267_valueOrError0).PropagateFailure<Dafny.ISequence<char>>();
              return res;
            }
            res = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError>.create_Success((((((_1266_maybeCreateTableResponse).dtor_value).dtor_TableDescription).dtor_value).dtor_TableArn).dtor_value);
          }
        } else {
          res = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.keystore.internaldafny.types.Error.create_ComAmazonawsDynamodb(_1265_error));
        }
      } else {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1268_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
        _1268_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>(((((_1264_maybeDescribeTableResponse).dtor_value).dtor_Table).is_Some) && (CreateKeyStoreTable_Compile.__default.keyStoreHasExpectedConstruction_q((((_1264_maybeDescribeTableResponse).dtor_value).dtor_Table).dtor_value)), CreateKeyStoreTable_Compile.__default.E(Dafny.Sequence<char>.FromString("Configured table name does not conform to expected Key Store construction.")));
        if ((_1268_valueOrError1).IsFailure()) {
          res = (_1268_valueOrError1).PropagateFailure<Dafny.ISequence<char>>();
          return res;
        }
        res = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError>.create_Success((((((_1264_maybeDescribeTableResponse).dtor_value).dtor_Table).dtor_value).dtor_TableArn).dtor_value);
      }
      return res;
    }
    public static software.amazon.cryptography.keystore.internaldafny.types._IError E(Dafny.ISequence<char> s) {
      return software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(s);
    }
    public static Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeDefinition> ATTRIBUTE__DEFINITIONS { get {
      return Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeDefinition>.FromElements(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeDefinition.create(Structure_Compile.__default.BRANCH__KEY__IDENTIFIER__FIELD, software.amazon.cryptography.services.dynamodb.internaldafny.types.ScalarAttributeType.create_S()), software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeDefinition.create(Structure_Compile.__default.TYPE__FIELD, software.amazon.cryptography.services.dynamodb.internaldafny.types.ScalarAttributeType.create_S()));
    } }
    public static Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IKeySchemaElement> KEY__SCHEMA { get {
      return Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IKeySchemaElement>.FromElements(software.amazon.cryptography.services.dynamodb.internaldafny.types.KeySchemaElement.create(Structure_Compile.__default.BRANCH__KEY__IDENTIFIER__FIELD, software.amazon.cryptography.services.dynamodb.internaldafny.types.KeyType.create_HASH()), software.amazon.cryptography.services.dynamodb.internaldafny.types.KeySchemaElement.create(Structure_Compile.__default.TYPE__FIELD, software.amazon.cryptography.services.dynamodb.internaldafny.types.KeyType.create_RANGE()));
    } }
  }
} // end of namespace CreateKeyStoreTable_Compile
namespace GetKeys_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> GetActiveKeyAndUnwrap(software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyInput input, Dafny.ISequence<char> tableName, Dafny.ISequence<char> logicalKeyStoreName, software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration kmsConfiguration, Dafny.ISequence<Dafny.ISequence<char>> grantTokens, software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient kmsClient, software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient ddbClient)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.GetActiveBranchKeyOutput.Default());
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _1269_branchKeyItem;
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError> _1270_valueOrError0 = default(Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError>);
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError> _out224;
      _out224 = DDBKeystoreOperations_Compile.__default.GetActiveBranchKeyItem((input).dtor_branchKeyIdentifier, tableName, ddbClient);
      _1270_valueOrError0 = _out224;
      if ((_1270_valueOrError0).IsFailure()) {
        output = (_1270_valueOrError0).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput>();
        return output;
      }
      _1269_branchKeyItem = (_1270_valueOrError0).Extract();
      Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _1271_encryptionContext;
      _1271_encryptionContext = Structure_Compile.__default.ToBranchKeyContext(_1269_branchKeyItem, logicalKeyStoreName);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1272_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
      _1272_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>(KMSKeystoreOperations_Compile.__default.AttemptKmsOperation_q(kmsConfiguration, _1271_encryptionContext), software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("AWS KMS Key ARN does not match configured value")));
      if ((_1272_valueOrError1).IsFailure()) {
        output = (_1272_valueOrError1).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput>();
        return output;
      }
      software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse _1273_branchKey;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> _1274_valueOrError2 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.kms.internaldafny.types.DecryptResponse.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> _out225;
      _out225 = KMSKeystoreOperations_Compile.__default.DecryptKey(_1271_encryptionContext, _1269_branchKeyItem, kmsConfiguration, grantTokens, kmsClient);
      _1274_valueOrError2 = _out225;
      if ((_1274_valueOrError2).IsFailure()) {
        output = (_1274_valueOrError2).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput>();
        return output;
      }
      _1273_branchKey = (_1274_valueOrError2).Extract();
      software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials _1275_branchKeyMaterials;
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials, software.amazon.cryptography.keystore.internaldafny.types._IError> _1276_valueOrError3 = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.BranchKeyMaterials.Default());
      _1276_valueOrError3 = Structure_Compile.__default.ToBranchKeyMaterials(_1271_encryptionContext, ((_1273_branchKey).dtor_Plaintext).dtor_value);
      if ((_1276_valueOrError3).IsFailure()) {
        output = (_1276_valueOrError3).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput>();
        return output;
      }
      _1275_branchKeyMaterials = (_1276_valueOrError3).Extract();
      output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.create_Success(software.amazon.cryptography.keystore.internaldafny.types.GetActiveBranchKeyOutput.create(_1275_branchKeyMaterials));
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> GetBranchKeyVersion(software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionInput input, Dafny.ISequence<char> tableName, Dafny.ISequence<char> logicalKeyStoreName, software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration kmsConfiguration, Dafny.ISequence<Dafny.ISequence<char>> grantTokens, software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient kmsClient, software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient ddbClient)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.GetBranchKeyVersionOutput.Default());
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _1277_branchKeyItem;
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError> _1278_valueOrError0 = default(Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError>);
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError> _out226;
      _out226 = DDBKeystoreOperations_Compile.__default.GetVersionBranchKeyItem((input).dtor_branchKeyIdentifier, (input).dtor_branchKeyVersion, tableName, ddbClient);
      _1278_valueOrError0 = _out226;
      if ((_1278_valueOrError0).IsFailure()) {
        output = (_1278_valueOrError0).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput>();
        return output;
      }
      _1277_branchKeyItem = (_1278_valueOrError0).Extract();
      Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _1279_encryptionContext;
      _1279_encryptionContext = Structure_Compile.__default.ToBranchKeyContext(_1277_branchKeyItem, logicalKeyStoreName);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1280_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
      _1280_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>(KMSKeystoreOperations_Compile.__default.AttemptKmsOperation_q(kmsConfiguration, _1279_encryptionContext), software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("AWS KMS Key ARN does not match configured value")));
      if ((_1280_valueOrError1).IsFailure()) {
        output = (_1280_valueOrError1).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput>();
        return output;
      }
      software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse _1281_branchKey;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> _1282_valueOrError2 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.kms.internaldafny.types.DecryptResponse.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> _out227;
      _out227 = KMSKeystoreOperations_Compile.__default.DecryptKey(_1279_encryptionContext, _1277_branchKeyItem, kmsConfiguration, grantTokens, kmsClient);
      _1282_valueOrError2 = _out227;
      if ((_1282_valueOrError2).IsFailure()) {
        output = (_1282_valueOrError2).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput>();
        return output;
      }
      _1281_branchKey = (_1282_valueOrError2).Extract();
      software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials _1283_branchKeyMaterials;
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials, software.amazon.cryptography.keystore.internaldafny.types._IError> _1284_valueOrError3 = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IBranchKeyMaterials, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.BranchKeyMaterials.Default());
      _1284_valueOrError3 = Structure_Compile.__default.ToBranchKeyMaterials(_1279_encryptionContext, ((_1281_branchKey).dtor_Plaintext).dtor_value);
      if ((_1284_valueOrError3).IsFailure()) {
        output = (_1284_valueOrError3).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput>();
        return output;
      }
      _1283_branchKeyMaterials = (_1284_valueOrError3).Extract();
      output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.create_Success(software.amazon.cryptography.keystore.internaldafny.types.GetBranchKeyVersionOutput.create(_1283_branchKeyMaterials));
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> GetBeaconKeyAndUnwrap(software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyInput input, Dafny.ISequence<char> tableName, Dafny.ISequence<char> logicalKeyStoreName, software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration kmsConfiguration, Dafny.ISequence<Dafny.ISequence<char>> grantTokens, software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient kmsClient, software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient ddbClient)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.GetBeaconKeyOutput.Default());
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _1285_branchKeyItem;
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError> _1286_valueOrError0 = default(Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError>);
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.keystore.internaldafny.types._IError> _out228;
      _out228 = DDBKeystoreOperations_Compile.__default.GetBeaconKeyItem((input).dtor_branchKeyIdentifier, tableName, ddbClient);
      _1286_valueOrError0 = _out228;
      if ((_1286_valueOrError0).IsFailure()) {
        output = (_1286_valueOrError0).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput>();
        return output;
      }
      _1285_branchKeyItem = (_1286_valueOrError0).Extract();
      Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _1287_encryptionContext;
      _1287_encryptionContext = Structure_Compile.__default.ToBranchKeyContext(_1285_branchKeyItem, logicalKeyStoreName);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1288_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
      _1288_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>(KMSKeystoreOperations_Compile.__default.AttemptKmsOperation_q(kmsConfiguration, _1287_encryptionContext), software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("AWS KMS Key ARN does not match configured value")));
      if ((_1288_valueOrError1).IsFailure()) {
        output = (_1288_valueOrError1).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput>();
        return output;
      }
      software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse _1289_branchKey;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> _1290_valueOrError2 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.services.kms.internaldafny.types.DecryptResponse.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types._IDecryptResponse, software.amazon.cryptography.keystore.internaldafny.types._IError> _out229;
      _out229 = KMSKeystoreOperations_Compile.__default.DecryptKey(_1287_encryptionContext, _1285_branchKeyItem, kmsConfiguration, grantTokens, kmsClient);
      _1290_valueOrError2 = _out229;
      if ((_1290_valueOrError2).IsFailure()) {
        output = (_1290_valueOrError2).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput>();
        return output;
      }
      _1289_branchKey = (_1290_valueOrError2).Extract();
      software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials _1291_branchKeyMaterials;
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials, software.amazon.cryptography.keystore.internaldafny.types._IError> _1292_valueOrError3 = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.BeaconKeyMaterials.Default());
      _1292_valueOrError3 = Structure_Compile.__default.ToBeaconKeyMaterials(_1287_encryptionContext, ((_1289_branchKey).dtor_Plaintext).dtor_value);
      if ((_1292_valueOrError3).IsFailure()) {
        output = (_1292_valueOrError3).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput>();
        return output;
      }
      _1291_branchKeyMaterials = (_1292_valueOrError3).Extract();
      output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.create_Success(software.amazon.cryptography.keystore.internaldafny.types.GetBeaconKeyOutput.create(_1291_branchKeyMaterials));
      return output;
      return output;
    }
  }
} // end of namespace GetKeys_Compile
namespace AwsCryptographyKeyStoreOperations_Compile {

  public interface _IConfig {
    bool is_Config { get; }
    Dafny.ISequence<char> dtor_id { get; }
    Dafny.ISequence<char> dtor_ddbTableName { get; }
    Dafny.ISequence<char> dtor_logicalKeyStoreName { get; }
    software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration dtor_kmsConfiguration { get; }
    Dafny.ISequence<Dafny.ISequence<char>> dtor_grantTokens { get; }
    software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient dtor_kmsClient { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient dtor_ddbClient { get; }
    _IConfig DowncastClone();
  }
  public class Config : _IConfig {
    public readonly Dafny.ISequence<char> _id;
    public readonly Dafny.ISequence<char> _ddbTableName;
    public readonly Dafny.ISequence<char> _logicalKeyStoreName;
    public readonly software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration _kmsConfiguration;
    public readonly Dafny.ISequence<Dafny.ISequence<char>> _grantTokens;
    public readonly software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _kmsClient;
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient _ddbClient;
    public Config(Dafny.ISequence<char> id, Dafny.ISequence<char> ddbTableName, Dafny.ISequence<char> logicalKeyStoreName, software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration kmsConfiguration, Dafny.ISequence<Dafny.ISequence<char>> grantTokens, software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient kmsClient, software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient ddbClient) {
      this._id = id;
      this._ddbTableName = ddbTableName;
      this._logicalKeyStoreName = logicalKeyStoreName;
      this._kmsConfiguration = kmsConfiguration;
      this._grantTokens = grantTokens;
      this._kmsClient = kmsClient;
      this._ddbClient = ddbClient;
    }
    public _IConfig DowncastClone() {
      if (this is _IConfig dt) { return dt; }
      return new Config(_id, _ddbTableName, _logicalKeyStoreName, _kmsConfiguration, _grantTokens, _kmsClient, _ddbClient);
    }
    public override bool Equals(object other) {
      var oth = other as AwsCryptographyKeyStoreOperations_Compile.Config;
      return oth != null && object.Equals(this._id, oth._id) && object.Equals(this._ddbTableName, oth._ddbTableName) && object.Equals(this._logicalKeyStoreName, oth._logicalKeyStoreName) && object.Equals(this._kmsConfiguration, oth._kmsConfiguration) && object.Equals(this._grantTokens, oth._grantTokens) && this._kmsClient == oth._kmsClient && this._ddbClient == oth._ddbClient;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._id));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._ddbTableName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._logicalKeyStoreName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._kmsConfiguration));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._grantTokens));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._kmsClient));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._ddbClient));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyKeyStoreOperations_Compile.Config.Config";
      s += "(";
      s += Dafny.Helpers.ToString(this._id);
      s += ", ";
      s += Dafny.Helpers.ToString(this._ddbTableName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._logicalKeyStoreName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._kmsConfiguration);
      s += ", ";
      s += Dafny.Helpers.ToString(this._grantTokens);
      s += ", ";
      s += Dafny.Helpers.ToString(this._kmsClient);
      s += ", ";
      s += Dafny.Helpers.ToString(this._ddbClient);
      s += ")";
      return s;
    }
    private static readonly AwsCryptographyKeyStoreOperations_Compile._IConfig theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, software.amazon.cryptography.keystore.internaldafny.types.KMSConfiguration.Default(), Dafny.Sequence<Dafny.ISequence<char>>.Empty, default(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient), default(software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient));
    public static AwsCryptographyKeyStoreOperations_Compile._IConfig Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AwsCryptographyKeyStoreOperations_Compile._IConfig> _TYPE = new Dafny.TypeDescriptor<AwsCryptographyKeyStoreOperations_Compile._IConfig>(AwsCryptographyKeyStoreOperations_Compile.Config.Default());
    public static Dafny.TypeDescriptor<AwsCryptographyKeyStoreOperations_Compile._IConfig> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IConfig create(Dafny.ISequence<char> id, Dafny.ISequence<char> ddbTableName, Dafny.ISequence<char> logicalKeyStoreName, software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration kmsConfiguration, Dafny.ISequence<Dafny.ISequence<char>> grantTokens, software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient kmsClient, software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient ddbClient) {
      return new Config(id, ddbTableName, logicalKeyStoreName, kmsConfiguration, grantTokens, kmsClient, ddbClient);
    }
    public static _IConfig create_Config(Dafny.ISequence<char> id, Dafny.ISequence<char> ddbTableName, Dafny.ISequence<char> logicalKeyStoreName, software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration kmsConfiguration, Dafny.ISequence<Dafny.ISequence<char>> grantTokens, software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient kmsClient, software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient ddbClient) {
      return create(id, ddbTableName, logicalKeyStoreName, kmsConfiguration, grantTokens, kmsClient, ddbClient);
    }
    public bool is_Config { get { return true; } }
    public Dafny.ISequence<char> dtor_id {
      get {
        return this._id;
      }
    }
    public Dafny.ISequence<char> dtor_ddbTableName {
      get {
        return this._ddbTableName;
      }
    }
    public Dafny.ISequence<char> dtor_logicalKeyStoreName {
      get {
        return this._logicalKeyStoreName;
      }
    }
    public software.amazon.cryptography.keystore.internaldafny.types._IKMSConfiguration dtor_kmsConfiguration {
      get {
        return this._kmsConfiguration;
      }
    }
    public Dafny.ISequence<Dafny.ISequence<char>> dtor_grantTokens {
      get {
        return this._grantTokens;
      }
    }
    public software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient dtor_kmsClient {
      get {
        return this._kmsClient;
      }
    }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient dtor_ddbClient {
      get {
        return this._ddbClient;
      }
    }
  }

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetKeyStoreInfoOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> GetKeyStoreInfo(AwsCryptographyKeyStoreOperations_Compile._IConfig config)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetKeyStoreInfoOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetKeyStoreInfoOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>);
      output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IGetKeyStoreInfoOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.create_Success(software.amazon.cryptography.keystore.internaldafny.types.GetKeyStoreInfoOutput.create((config).dtor_id, (config).dtor_ddbTableName, (config).dtor_logicalKeyStoreName, (config).dtor_grantTokens, (config).dtor_kmsConfiguration));
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> CreateKeyStore(AwsCryptographyKeyStoreOperations_Compile._IConfig config, software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.CreateKeyStoreOutput.Default());
      Dafny.ISequence<char> _1293_ddbTableArn;
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError> _1294_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(Dafny.Sequence<char>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError> _out230;
      _out230 = CreateKeyStoreTable_Compile.__default.CreateKeyStoreTable((config).dtor_ddbTableName, (config).dtor_ddbClient);
      _1294_valueOrError0 = _out230;
      if ((_1294_valueOrError0).IsFailure()) {
        output = (_1294_valueOrError0).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreOutput>();
        return output;
      }
      _1293_ddbTableArn = (_1294_valueOrError0).Extract();
      Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _1295_tableName;
      _1295_tableName = AwsArnParsing_Compile.__default.ParseAmazonDynamodbTableName(_1293_ddbTableArn);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1296_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
      _1296_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>(((_1295_tableName).is_Success) && (((_1295_tableName).dtor_value).Equals((config).dtor_ddbTableName)), software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("Configured DDB Table Name does not match parsed Table Name from DDB Table Arn.")));
      if ((_1296_valueOrError1).IsFailure()) {
        output = (_1296_valueOrError1).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreOutput>();
        return output;
      }
      output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.create_Success(software.amazon.cryptography.keystore.internaldafny.types.CreateKeyStoreOutput.create(_1293_ddbTableArn));
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> CreateKey(AwsCryptographyKeyStoreOperations_Compile._IConfig config, software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.CreateKeyOutput.Default());
      Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1297_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
      _1297_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>(!(((input).dtor_branchKeyIdentifier).is_Some) || ((((input).dtor_encryptionContext).is_Some) && ((new BigInteger((((input).dtor_encryptionContext).dtor_value).Count)).Sign == 1)), software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("Custom branch key id requires custom encryption context.")));
      if ((_1297_valueOrError0).IsFailure()) {
        output = (_1297_valueOrError0).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput>();
        return output;
      }
      Dafny.ISequence<char> _1298_branchKeyIdentifier = Dafny.Sequence<char>.Empty;
      if (((input).dtor_branchKeyIdentifier).is_None) {
        Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _1299_maybeBranchKeyId;
        Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _out231;
        _out231 = UUID.__default.GenerateUUID();
        _1299_maybeBranchKeyId = _out231;
        Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError> _1300_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(Dafny.Sequence<char>.Empty);
        _1300_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.keystore.internaldafny.types._IError>(_1299_maybeBranchKeyId, ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError>)((_1301_e) => {
          return software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(_1301_e);
        })));
        if ((_1300_valueOrError1).IsFailure()) {
          output = (_1300_valueOrError1).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput>();
          return output;
        }
        _1298_branchKeyIdentifier = (_1300_valueOrError1).Extract();
      } else {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1302_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
        _1302_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>((new BigInteger((((input).dtor_branchKeyIdentifier).dtor_value).Count)).Sign == 1, software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("Custom branch key id can not be an empty string.")));
        if ((_1302_valueOrError2).IsFailure()) {
          output = (_1302_valueOrError2).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput>();
          return output;
        }
        _1298_branchKeyIdentifier = ((input).dtor_branchKeyIdentifier).dtor_value;
      }
      Dafny.ISequence<char> _1303_timestamp;
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError> _1304_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(Dafny.Sequence<char>.Empty);
      _1304_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.keystore.internaldafny.types._IError>(Time.__default.GetCurrentTimeStamp(), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError>)((_1305_e) => {
        return software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(_1305_e);
      })));
      if ((_1304_valueOrError3).IsFailure()) {
        output = (_1304_valueOrError3).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput>();
        return output;
      }
      _1303_timestamp = (_1304_valueOrError3).Extract();
      Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _1306_maybeBranchKeyVersion;
      Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _out232;
      _out232 = UUID.__default.GenerateUUID();
      _1306_maybeBranchKeyVersion = _out232;
      Dafny.ISequence<char> _1307_branchKeyVersion;
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError> _1308_valueOrError4 = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(Dafny.Sequence<char>.Empty);
      _1308_valueOrError4 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.keystore.internaldafny.types._IError>(_1306_maybeBranchKeyVersion, ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError>)((_1309_e) => {
        return software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(_1309_e);
      })));
      if ((_1308_valueOrError4).IsFailure()) {
        output = (_1308_valueOrError4).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput>();
        return output;
      }
      _1307_branchKeyVersion = (_1308_valueOrError4).Extract();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _1310_unwrapEncryptionContext;
      _1310_unwrapEncryptionContext = Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>.UnwrapOr((input).dtor_encryptionContext, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements());
      Dafny.ISet<_System._ITuple3<Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Dafny.ISequence<byte>>> _1311_encodedEncryptionContext;
      _1311_encodedEncryptionContext = Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, Dafny.ISet<_System._ITuple3<Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Dafny.ISequence<byte>>>>>((_1312_unwrapEncryptionContext) => ((System.Func<Dafny.ISet<_System._ITuple3<Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Dafny.ISequence<byte>>>>)(() => {
        var _coll9 = new System.Collections.Generic.List<_System._ITuple3<Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Dafny.ISequence<byte>>>();
        foreach (Dafny.ISequence<byte> _compr_9 in (_1312_unwrapEncryptionContext).Keys.Elements) {
          Dafny.ISequence<byte> _1313_k = (Dafny.ISequence<byte>)_compr_9;
          if ((_1312_unwrapEncryptionContext).Contains(_1313_k)) {
            _coll9.Add(_System.Tuple3<Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Dafny.ISequence<byte>>.create(UTF8.__default.Decode(_1313_k), UTF8.__default.Decode(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(_1312_unwrapEncryptionContext,_1313_k)), _1313_k));
          }
        }
        return Dafny.Set<_System._ITuple3<Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Dafny.ISequence<byte>>>.FromCollection(_coll9);
      }))())(_1310_unwrapEncryptionContext);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1314_valueOrError5 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
      _1314_valueOrError5 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>(Dafny.Helpers.Id<Func<Dafny.ISet<_System._ITuple3<Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Dafny.ISequence<byte>>>, bool>>((_1315_encodedEncryptionContext) => Dafny.Helpers.Quantifier<_System._ITuple3<Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Dafny.ISequence<byte>>>((_1315_encodedEncryptionContext).Elements, true, (((_forall_var_18) => {
        _System._ITuple3<Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Dafny.ISequence<byte>> _1316_i = (_System._ITuple3<Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Dafny.ISequence<byte>>)_forall_var_18;
        return !((_1315_encodedEncryptionContext).Contains(_1316_i)) || ((((((_1316_i).dtor__0).is_Success) && (((_1316_i).dtor__1).is_Success)) && (software.amazon.cryptography.services.dynamodb.internaldafny.types.__default.IsValid__AttributeName(Dafny.Sequence<char>.Concat(Structure_Compile.__default.ENCRYPTION__CONTEXT__PREFIX, ((_1316_i).dtor__0).dtor_value)))) && (Dafny.Helpers.Let<Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>, bool>(UTF8.__default.Encode(((_1316_i).dtor__0).dtor_value), _pat_let24_0 => Dafny.Helpers.Let<Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>, bool>(_pat_let24_0, _1317_encoded => ((_1317_encoded).is_Success) && (((_1316_i).dtor__2).Equals((_1317_encoded).dtor_value))))));
      }))))(_1311_encodedEncryptionContext), software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("Unable to encode string")));
      if ((_1314_valueOrError5).IsFailure()) {
        output = (_1314_valueOrError5).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput>();
        return output;
      }
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _out233;
      _out233 = CreateKeys_Compile.__default.CreateBranchAndBeaconKeys(_1298_branchKeyIdentifier, Dafny.Helpers.Id<Func<Dafny.ISet<_System._ITuple3<Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Dafny.ISequence<byte>>>, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>>((_1318_encodedEncryptionContext) => ((System.Func<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>)(() => {
        var _coll10 = new System.Collections.Generic.List<Dafny.Pair<Dafny.ISequence<char>,Dafny.ISequence<char>>>();
        foreach (_System._ITuple3<Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Dafny.ISequence<byte>> _compr_10 in (_1318_encodedEncryptionContext).Elements) {
          _System._ITuple3<Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Dafny.ISequence<byte>> _1319_i = (_System._ITuple3<Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>, Dafny.ISequence<byte>>)_compr_10;
          if ((_1318_encodedEncryptionContext).Contains(_1319_i)) {
            _coll10.Add(new Dafny.Pair<Dafny.ISequence<char>,Dafny.ISequence<char>>(((_1319_i).dtor__0).dtor_value, ((_1319_i).dtor__1).dtor_value));
          }
        }
        return Dafny.Map<Dafny.ISequence<char>,Dafny.ISequence<char>>.FromCollection(_coll10);
      }))())(_1311_encodedEncryptionContext), _1303_timestamp, _1307_branchKeyVersion, (config).dtor_ddbTableName, (config).dtor_logicalKeyStoreName, (config).dtor_kmsConfiguration, (config).dtor_grantTokens, (config).dtor_kmsClient, (config).dtor_ddbClient);
      output = _out233;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> VersionKey(AwsCryptographyKeyStoreOperations_Compile._IConfig config, software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.VersionKeyOutput.Default());
      Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1320_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
      _1320_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>((new BigInteger(((input).dtor_branchKeyIdentifier).Count)).Sign == 1, software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("Empty string not supported for identifier.")));
      if ((_1320_valueOrError0).IsFailure()) {
        output = (_1320_valueOrError0).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput>();
        return output;
      }
      Dafny.ISequence<char> _1321_timestamp;
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError> _1322_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(Dafny.Sequence<char>.Empty);
      _1322_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.keystore.internaldafny.types._IError>(Time.__default.GetCurrentTimeStamp(), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError>)((_1323_e) => {
        return software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(_1323_e);
      })));
      if ((_1322_valueOrError1).IsFailure()) {
        output = (_1322_valueOrError1).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput>();
        return output;
      }
      _1321_timestamp = (_1322_valueOrError1).Extract();
      Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _1324_maybeBranchKeyVersion;
      Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _out234;
      _out234 = UUID.__default.GenerateUUID();
      _1324_maybeBranchKeyVersion = _out234;
      Dafny.ISequence<char> _1325_branchKeyVersion;
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError> _1326_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(Dafny.Sequence<char>.Empty);
      _1326_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.keystore.internaldafny.types._IError>(_1324_maybeBranchKeyVersion, ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError>)((_1327_e) => {
        return software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(_1327_e);
      })));
      if ((_1326_valueOrError2).IsFailure()) {
        output = (_1326_valueOrError2).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput>();
        return output;
      }
      _1325_branchKeyVersion = (_1326_valueOrError2).Extract();
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _out235;
      _out235 = CreateKeys_Compile.__default.VersionActiveBranchKey(input, _1321_timestamp, _1325_branchKeyVersion, (config).dtor_ddbTableName, (config).dtor_logicalKeyStoreName, (config).dtor_kmsConfiguration, (config).dtor_grantTokens, (config).dtor_kmsClient, (config).dtor_ddbClient);
      output = _out235;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> GetActiveBranchKey(AwsCryptographyKeyStoreOperations_Compile._IConfig config, software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.GetActiveBranchKeyOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _out236;
      _out236 = GetKeys_Compile.__default.GetActiveKeyAndUnwrap(input, (config).dtor_ddbTableName, (config).dtor_logicalKeyStoreName, (config).dtor_kmsConfiguration, (config).dtor_grantTokens, (config).dtor_kmsClient, (config).dtor_ddbClient);
      output = _out236;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> GetBranchKeyVersion(AwsCryptographyKeyStoreOperations_Compile._IConfig config, software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.GetBranchKeyVersionOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _out237;
      _out237 = GetKeys_Compile.__default.GetBranchKeyVersion(input, (config).dtor_ddbTableName, (config).dtor_logicalKeyStoreName, (config).dtor_kmsConfiguration, (config).dtor_grantTokens, (config).dtor_kmsClient, (config).dtor_ddbClient);
      output = _out237;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> GetBeaconKey(AwsCryptographyKeyStoreOperations_Compile._IConfig config, software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.GetBeaconKeyOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _out238;
      _out238 = GetKeys_Compile.__default.GetBeaconKeyAndUnwrap(input, (config).dtor_ddbTableName, (config).dtor_logicalKeyStoreName, (config).dtor_kmsConfiguration, (config).dtor_grantTokens, (config).dtor_kmsClient, (config).dtor_ddbClient);
      output = _out238;
      return output;
    }
  }
} // end of namespace AwsCryptographyKeyStoreOperations_Compile
namespace software.amazon.cryptography.keystore.internaldafny {

  public partial class KeyStoreClient : software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient {
    public KeyStoreClient() {
      this._config = default(AwsCryptographyKeyStoreOperations_Compile._IConfig);
    }
    public void __ctor(AwsCryptographyKeyStoreOperations_Compile._IConfig config)
    {
      (this)._config = config;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetKeyStoreInfoOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> GetKeyStoreInfo()
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetKeyStoreInfoOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetKeyStoreInfoOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetKeyStoreInfoOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _out239;
      _out239 = AwsCryptographyKeyStoreOperations_Compile.__default.GetKeyStoreInfo((this).config);
      output = _out239;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> CreateKeyStore(software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.CreateKeyStoreOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyStoreOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _out240;
      _out240 = AwsCryptographyKeyStoreOperations_Compile.__default.CreateKeyStore((this).config, input);
      output = _out240;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> CreateKey(software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.CreateKeyOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._ICreateKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _out241;
      _out241 = AwsCryptographyKeyStoreOperations_Compile.__default.CreateKey((this).config, input);
      output = _out241;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> VersionKey(software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.VersionKeyOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IVersionKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _out242;
      _out242 = AwsCryptographyKeyStoreOperations_Compile.__default.VersionKey((this).config, input);
      output = _out242;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> GetActiveBranchKey(software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.GetActiveBranchKeyOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetActiveBranchKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _out243;
      _out243 = AwsCryptographyKeyStoreOperations_Compile.__default.GetActiveBranchKey((this).config, input);
      output = _out243;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> GetBranchKeyVersion(software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.GetBranchKeyVersionOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBranchKeyVersionOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _out244;
      _out244 = AwsCryptographyKeyStoreOperations_Compile.__default.GetBranchKeyVersion((this).config, input);
      output = _out244;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> GetBeaconKey(software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.GetBeaconKeyOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _out245;
      _out245 = AwsCryptographyKeyStoreOperations_Compile.__default.GetBeaconKey((this).config, input);
      output = _out245;
      return output;
    }
    public AwsCryptographyKeyStoreOperations_Compile._IConfig _config {get; set;}
    public AwsCryptographyKeyStoreOperations_Compile._IConfig config { get {
      return this._config;
    } }
  }

  public partial class __default {
    public static software.amazon.cryptography.keystore.internaldafny.types._IKeyStoreConfig DefaultKeyStoreConfig() {
      return software.amazon.cryptography.keystore.internaldafny.types.KeyStoreConfig.create(Dafny.Sequence<char>.FromString("None"), software.amazon.cryptography.keystore.internaldafny.types.KMSConfiguration.create(Dafny.Sequence<char>.FromString("1234abcd-12ab-34cd-56ef-1234567890ab")), Dafny.Sequence<char>.FromString("None"), Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None(), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.create_None(), Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient>.create_None(), Wrappers_Compile.Option<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient>.create_None());
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.KeyStoreClient, software.amazon.cryptography.keystore.internaldafny.types._IError> KeyStore(software.amazon.cryptography.keystore.internaldafny.types._IKeyStoreConfig config)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.KeyStoreClient, software.amazon.cryptography.keystore.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.KeyStoreClient, software.amazon.cryptography.keystore.internaldafny.types._IError>);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1328_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
      _1328_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>((software.amazon.cryptography.services.kms.internaldafny.types.__default.IsValid__KeyIdType(((config).dtor_kmsConfiguration).dtor_kmsKeyArn)) && ((AwsArnParsing_Compile.__default.ParseAwsKmsArn(((config).dtor_kmsConfiguration).dtor_kmsKeyArn)).is_Success), software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("Invalid AWS KMS Key Arn")));
      if ((_1328_valueOrError0).IsFailure()) {
        res = (_1328_valueOrError0).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.KeyStoreClient>();
        return res;
      }
      Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1329_grantTokens;
      _1329_grantTokens = AwsKmsUtils_Compile.__default.GetValidGrantTokens((config).dtor_grantTokens);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1330_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
      _1330_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>((true) && ((_1329_grantTokens).is_Success), software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("CreateKey received invalid grant tokens")));
      if ((_1330_valueOrError1).IsFailure()) {
        res = (_1330_valueOrError1).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.KeyStoreClient>();
        return res;
      }
      Dafny.ISequence<char> _1331_keyStoreId = Dafny.Sequence<char>.Empty;
      if (((config).dtor_id).is_Some) {
        _1331_keyStoreId = ((config).dtor_id).dtor_value;
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _1332_maybeUuid;
        Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _out246;
        _out246 = UUID.__default.GenerateUUID();
        _1332_maybeUuid = _out246;
        Dafny.ISequence<char> _1333_uuid;
        Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError> _1334_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError>.Default(Dafny.Sequence<char>.Empty);
        _1334_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.keystore.internaldafny.types._IError>(_1332_maybeUuid, ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.keystore.internaldafny.types._IError>)((_1335_e) => {
          return software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(_1335_e);
        })));
        if ((_1334_valueOrError2).IsFailure()) {
          res = (_1334_valueOrError2).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.KeyStoreClient>();
          return res;
        }
        _1333_uuid = (_1334_valueOrError2).Extract();
        _1331_keyStoreId = _1333_uuid;
      }
      software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient _1336_kmsClient = default(software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient);
      software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient _1337_ddbClient = default(software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient);
      Wrappers_Compile._IResult<AwsArnParsing_Compile._IAwsKmsIdentifier, Dafny.ISequence<char>> _1338_keyArn;
      _1338_keyArn = AwsArnParsing_Compile.__default.ParseAwsKmsIdentifier(((config).dtor_kmsConfiguration).dtor_kmsKeyArn);
      Wrappers_Compile._IOption<Dafny.ISequence<char>> _1339_kmsRegion;
      _1339_kmsRegion = AwsArnParsing_Compile.__default.GetRegion((_1338_keyArn).dtor_value);
      if (((config).dtor_kmsClient).is_None) {
        Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.services.kms.internaldafny.types._IError> _1340_maybeKmsClient;
        Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.services.kms.internaldafny.types._IError> _out247;
        _out247 = software.amazon.cryptography.services.kms.internaldafny.__default.KMSClientForRegion((_1339_kmsRegion).dtor_value);
        _1340_maybeKmsClient = _out247;
        Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.keystore.internaldafny.types._IError> _1341_valueOrError3 = default(Wrappers_Compile._IResult<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.keystore.internaldafny.types._IError>);
        _1341_valueOrError3 = Wrappers_Compile.Result<software.amazon.cryptography.services.kms.internaldafny.types.IKMSClient, software.amazon.cryptography.services.kms.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.keystore.internaldafny.types._IError>(_1340_maybeKmsClient, ((System.Func<software.amazon.cryptography.services.kms.internaldafny.types._IError, software.amazon.cryptography.keystore.internaldafny.types._IError>)((_1342_e) => {
          return software.amazon.cryptography.keystore.internaldafny.types.Error.create_ComAmazonawsKms(_1342_e);
        })));
        if ((_1341_valueOrError3).IsFailure()) {
          res = (_1341_valueOrError3).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.KeyStoreClient>();
          return res;
        }
        _1336_kmsClient = (_1341_valueOrError3).Extract();
      } else {
        _1336_kmsClient = ((config).dtor_kmsClient).dtor_value;
      }
      if (((config).dtor_ddbClient).is_None) {
        Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient, software.amazon.cryptography.services.dynamodb.internaldafny.types._IError> _1343_maybeDdbClient;
        Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient, software.amazon.cryptography.services.dynamodb.internaldafny.types._IError> _out248;
        _out248 = software.amazon.cryptography.services.dynamodb.internaldafny.__default.DDBClientForRegion((_1339_kmsRegion).dtor_value);
        _1343_maybeDdbClient = _out248;
        Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient, software.amazon.cryptography.keystore.internaldafny.types._IError> _1344_valueOrError4 = default(Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient, software.amazon.cryptography.keystore.internaldafny.types._IError>);
        _1344_valueOrError4 = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types.IDynamoDBClient, software.amazon.cryptography.services.dynamodb.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.keystore.internaldafny.types._IError>(_1343_maybeDdbClient, ((System.Func<software.amazon.cryptography.services.dynamodb.internaldafny.types._IError, software.amazon.cryptography.keystore.internaldafny.types._IError>)((_1345_e) => {
          return software.amazon.cryptography.keystore.internaldafny.types.Error.create_ComAmazonawsDynamodb(_1345_e);
        })));
        if ((_1344_valueOrError4).IsFailure()) {
          res = (_1344_valueOrError4).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.KeyStoreClient>();
          return res;
        }
        _1337_ddbClient = (_1344_valueOrError4).Extract();
      } else {
        _1337_ddbClient = ((config).dtor_ddbClient).dtor_value;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.keystore.internaldafny.types._IError> _1346_valueOrError5 = Wrappers_Compile.Outcome<software.amazon.cryptography.keystore.internaldafny.types._IError>.Default();
      _1346_valueOrError5 = Wrappers_Compile.__default.Need<software.amazon.cryptography.keystore.internaldafny.types._IError>(software.amazon.cryptography.services.dynamodb.internaldafny.types.__default.IsValid__TableName((config).dtor_ddbTableName), software.amazon.cryptography.keystore.internaldafny.types.Error.create_KeyStoreException(Dafny.Sequence<char>.FromString("Invalid Amazon DynamoDB Table Name")));
      if ((_1346_valueOrError5).IsFailure()) {
        res = (_1346_valueOrError5).PropagateFailure<software.amazon.cryptography.keystore.internaldafny.KeyStoreClient>();
        return res;
      }
      software.amazon.cryptography.keystore.internaldafny.KeyStoreClient _1347_client;
      software.amazon.cryptography.keystore.internaldafny.KeyStoreClient _nw72 = new software.amazon.cryptography.keystore.internaldafny.KeyStoreClient();
      _nw72.__ctor(AwsCryptographyKeyStoreOperations_Compile.Config.create(_1331_keyStoreId, (config).dtor_ddbTableName, (config).dtor_logicalKeyStoreName, (config).dtor_kmsConfiguration, (_1329_grantTokens).dtor_value, _1336_kmsClient, _1337_ddbClient));
      _1347_client = _nw72;
      res = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.KeyStoreClient, software.amazon.cryptography.keystore.internaldafny.types._IError>.create_Success(_1347_client);
      return res;
      return res;
    }
  }
} // end of namespace software.amazon.cryptography.keystore.internaldafny
namespace JSON_mUtils_mViews_Compile {

} // end of namespace JSON_mUtils_mViews_Compile
namespace JSON_mUtils_Compile {

} // end of namespace JSON_mUtils_Compile
namespace JSON_mConcreteSyntax_Compile {

} // end of namespace JSON_mConcreteSyntax_Compile
namespace JSON_mZeroCopy_Compile {

} // end of namespace JSON_mZeroCopy_Compile
namespace JSON_Compile {

} // end of namespace JSON_Compile
namespace _module {

} // end of namespace _module
